(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/common'), require('@angular/core'), require('@angular/forms'), require('@angular/platform-browser')) :
	typeof define === 'function' && define.amd ? define(['exports', '@angular/common', '@angular/core', '@angular/forms', '@angular/platform-browser'], factory) :
	(factory((global['amexio-ng-extensions'] = {}),global.ng.common,global.ng.core,global.ng.forms,global.ng['platform-browser']));
}(this, (function (exports,common,i0,forms,platformBrowser) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return extendStatics(d, b);
};

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isFunction(x) {
    return typeof x === 'function';
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var _enable_super_gross_mode_that_will_cause_bad_things = false;
/**
 * The global configuration object for RxJS, used to configure things
 * like what Promise contructor should used to create Promises
 */
var config = {
    /**
     * The promise constructor used by default for methods such as
     * {@link toPromise} and {@link forEach}
     */
    Promise: undefined,
    /**
     * If true, turns on synchronous error rethrowing, which is a deprecated behavior
     * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe
     * call in a try/catch block. It also enables producer interference, a nasty bug
     * where a multicast can be broken for all observers by a downstream consumer with
     * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME
     * FOR MIGRATION REASONS.
     */
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = /*@__PURE__*/ new Error();
            /*@__PURE__*/ console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            /*@__PURE__*/ console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

/**
 * Throws an error on another job so that it's picked up by the runtime's
 * uncaught error handling mechanism.
 * @param err the error to throw
 */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function hostReportError(err) {
    setTimeout(function () { throw err; });
}

/** PURE_IMPORTS_START _config,_util_hostReportError PURE_IMPORTS_END */
var empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError(err);
        }
    },
    complete: function () { }
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isObject(x) {
    return x != null && typeof x === 'object';
}

// typeof any so that it we don't have to cast when comparing a result to the error object
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var errorObject = { e: {} };

/** PURE_IMPORTS_START _errorObject PURE_IMPORTS_END */
var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject.e = e;
        return errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}

/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = /*@__PURE__*/ (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        var _this = _super.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '') || this;
        _this.errors = errors;
        _this.name = 'UnsubscriptionError';
        Object.setPrototypeOf(_this, UnsubscriptionError.prototype);
        return _this;
    }
    return UnsubscriptionError;
}(Error));

/** PURE_IMPORTS_START _util_isArray,_util_isObject,_util_isFunction,_util_tryCatch,_util_errorObject,_util_UnsubscriptionError PURE_IMPORTS_END */
/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = /*@__PURE__*/ (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        /** @internal */
        this._parent = null;
        /** @internal */
        this._parents = null;
        /** @internal */
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction(_unsubscribe)) {
            var trial = tryCatch(_unsubscribe).call(this);
            if (trial === errorObject) {
                hasErrors = true;
                errors = errors || (errorObject.e instanceof UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject.e.errors) : [errorObject.e]);
            }
        }
        if (isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject(sub)) {
                    var trial = tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject.e;
                        if (err instanceof UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    /** @internal */
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    /** @nocollapse */
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError) ? err.errors : err); }, []);
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? /*@__PURE__*/ Symbol.for('rxSubscriber')
    : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */

/** PURE_IMPORTS_START tslib,_util_isFunction,_Observer,_Subscription,_internal_symbol_rxSubscriber,_config,_util_hostReportError PURE_IMPORTS_END */
/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = /*@__PURE__*/ (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        /** @internal */ _this.syncErrorValue = null;
        /** @internal */ _this.syncErrorThrown = false;
        /** @internal */ _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    // HACK(benlesh): For situations where Node has multiple copies of rxjs in
                    // node_modules, we cannot rely on `instanceof` checks
                    if (isTrustedSubscriber(destinationOrNext)) {
                        var trustedSubscriber = destinationOrNext[rxSubscriber]();
                        _this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
                        _this.destination = trustedSubscriber;
                        trustedSubscriber.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     * @nocollapse
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== empty) {
                context = Object.create(observerOrNext);
                if (isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError(err);
                return true;
            }
        }
        return false;
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
function isTrustedSubscriber(obj) {
    return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriber]);
}

/** PURE_IMPORTS_START _Subscriber,_symbol_rxSubscriber,_Observer PURE_IMPORTS_END */
function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber]) {
            return nextOrObserver[rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber(empty);
    }
    return new Subscriber(nextOrObserver, error, complete);
}

/** Symbol.observable or a string "@@observable". Used for interop */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

/* tslint:disable:no-empty */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function noop() { }

/** PURE_IMPORTS_START _noop PURE_IMPORTS_END */
/* tslint:enable:max-line-length */

/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}

/** PURE_IMPORTS_START _util_toSubscriber,_internal_symbol_observable,_util_pipe,_config PURE_IMPORTS_END */
/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = /*@__PURE__*/ (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        /** Internal implementation detail, do not use directly. */
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable$$1 = new Observable();
        observable$$1.source = this;
        observable$$1.operator = operator;
        return observable$$1;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     * @nocollapse
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
/**
 * Decides between a passed promise constructor from consuming code,
 * A default configured promise constructor, and the native promise
 * constructor and returns it. If nothing can be found, it will throw
 * an error.
 * @param promiseCtor The optional promise constructor to passed by consuming code
 */
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = /*@__PURE__*/ (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var _this = _super.call(this, 'object unsubscribed') || this;
        _this.name = 'ObjectUnsubscribedError';
        Object.setPrototypeOf(_this, ObjectUnsubscribedError.prototype);
        return _this;
    }
    return ObjectUnsubscribedError;
}(Error));

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Observable,_Subscriber,_Subscription,_util_ObjectUnsubscribedError,_SubjectSubscription,_internal_symbol_rxSubscriber PURE_IMPORTS_END */
/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber));
/**
 * @class Subject<T>
 */
var Subject = /*@__PURE__*/ (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable();
        observable.source = this;
        return observable;
    };
    /**@nocollapse */
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable));
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = /*@__PURE__*/ (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator$1(source));
    };
}
var RefCountOperator$1 = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber$1(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_Observable,_Subscriber,_Subscription,_operators_refCount PURE_IMPORTS_END */
/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        /** @internal */
        _this._isComplete = false;
        return _this;
    }
    /** @deprecated This is an internal implementation detail, do not use. */
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount()(this);
    };
    return ConnectableObservable;
}(Observable));

var ConnectableSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(SubjectSubscriber));
var RefCountOperator = /*@__PURE__*/ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount$$1 = connectable._refCount;
        if (refCount$$1 <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount$$1 - 1;
        if (refCount$$1 > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription,_Observable,_Subject PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Groups the items emitted by an Observable according to a specified criterion,
 * and emits these grouped items as `GroupedObservables`, one
 * {@link GroupedObservable} per group.
 *
 * <img src="./img/groupBy.png" width="100%">
 *
 * @example <caption>Group objects by id and return as array</caption>
 * Observable.of<Obj>({id: 1, name: 'aze1'},
 *                    {id: 2, name: 'sf2'},
 *                    {id: 2, name: 'dg2'},
 *                    {id: 1, name: 'erg1'},
 *                    {id: 1, name: 'df1'},
 *                    {id: 2, name: 'sfqfb2'},
 *                    {id: 3, name: 'qfs3'},
 *                    {id: 2, name: 'qsgqsfg2'}
 *     )
 *     .groupBy(p => p.id)
 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
 *     .subscribe(p => console.log(p));
 *
 * // displays:
 * // [ { id: 1, name: 'aze1' },
 * //   { id: 1, name: 'erg1' },
 * //   { id: 1, name: 'df1' } ]
 * //
 * // [ { id: 2, name: 'sf2' },
 * //   { id: 2, name: 'dg2' },
 * //   { id: 2, name: 'sfqfb2' },
 * //   { id: 2, name: 'qsgqsfg2' } ]
 * //
 * // [ { id: 3, name: 'qfs3' } ]
 *
 * @example <caption>Pivot data on the id field</caption>
 * Observable.of<Obj>({id: 1, name: 'aze1'},
 *                    {id: 2, name: 'sf2'},
 *                    {id: 2, name: 'dg2'},
 *                    {id: 1, name: 'erg1'},
 *                    {id: 1, name: 'df1'},
 *                    {id: 2, name: 'sfqfb2'},
 *                    {id: 3, name: 'qfs1'},
 *                    {id: 2, name: 'qsgqsfg2'}
 *                   )
 *     .groupBy(p => p.id, p => p.name)
 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
 *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
 *     .subscribe(p => console.log(p));
 *
 * // displays:
 * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
 * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
 * // { id: 3, values: [ 'qfs1' ] }
 *
 * @param {function(value: T): K} keySelector A function that extracts the key
 * for each item.
 * @param {function(value: T): R} [elementSelector] A function that extracts the
 * return element for each item.
 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
 * A function that returns an Observable to determine how long each group should
 * exist.
 * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
 * GroupedObservables, each of which corresponds to a unique key value and each
 * of which emits those items from the source Observable that share that key
 * value.
 * @method groupBy
 * @owner Observable
 */

var GroupByOperator = /*@__PURE__*/ (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupBySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupDurationSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber));
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
var GroupedObservable = /*@__PURE__*/ (function (_super) {
    __extends(GroupedObservable, _super);
    /** @deprecated Do not construct this type. Internal use only */
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    /** @deprecated This is an internal implementation detail, do not use. */
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerRefCountSubscription = /*@__PURE__*/ (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Subject,_util_ObjectUnsubscribedError PURE_IMPORTS_END */
/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = /*@__PURE__*/ (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    /** @deprecated This is an internal implementation detail, do not use. */
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject));

/** PURE_IMPORTS_START tslib,_Subscription PURE_IMPORTS_END */
/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = /*@__PURE__*/ (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return this;
    };
    return Action;
}(Subscription));

/** PURE_IMPORTS_START tslib,_Action PURE_IMPORTS_END */
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = /*@__PURE__*/ (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action));

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = /*@__PURE__*/ (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction));

/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 * @deprecated Scheduler is an internal implementation detail of RxJS, and
 * should not be used directly. Rather, create your own class and implement
 * {@link SchedulerLike}
 */
var Scheduler = /*@__PURE__*/ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    /** @nocollapse */
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());

/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */
var AsyncScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) {
            now = Scheduler.now;
        }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         * @deprecated internal use only
         */
        _this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         * @deprecated internal use only
         */
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) {
            delay = 0;
        }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var QueueScheduler = /*@__PURE__*/ (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _QueueAction,_QueueScheduler PURE_IMPORTS_END */
/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
var queue = /*@__PURE__*/ new QueueScheduler(QueueAction);

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
/**
 * The same Observable instance returned by any call to {@link empty} without a
 * {@link Scheduler}. It is preferrable to use this over `empty()`.
 */
var EMPTY = /*@__PURE__*/ new Observable(function (subscriber) { return subscriber.complete(); });
/**
 * Creates an Observable that emits no items to the Observer and immediately
 * emits a complete notification.
 *
 * <span class="informal">Just emits 'complete', and nothing else.
 * </span>
 *
 * <img src="./img/empty.png" width="100%">
 *
 * This static operator is useful for creating a simple Observable that only
 * emits the complete notification. It can be used for composing with other
 * Observables, such as in a {@link mergeMap}.
 *
 * @example <caption>Emit the number 7, then complete.</caption>
 * var result = Rx.Observable.empty().startWith(7);
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
 * var interval = Rx.Observable.interval(1000);
 * var result = interval.mergeMap(x =>
 *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following to the console:
 * // x is equal to the count on the interval eg(0,1,2,3,...)
 * // x will occur every 1000ms
 * // if x % 2 is equal to 1 print abc
 * // if x % 2 is not equal to 1 nothing will be output
 *
 * @see {@link create}
 * @see {@link never}
 * @see {@link of}
 * @see {@link throw}
 *
 * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
 * the emission of the complete notification.
 * @return {Observable} An "empty" Observable: emits only the complete
 * notification.
 * @static true
 * @name empty
 * @owner Observable
 * @deprecated Deprecated in favor of using EMPTY constant.
 */
function empty$1(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : EMPTY;
}
function emptyScheduled(scheduler) {
    return new Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}

/**
 * Subscribes to an ArrayLike with a subscriber
 * @param array The array or array-like to subscribe to
 */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var subscribeToArray = function (array) {
    return function (subscriber) {
        for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
            subscriber.next(array[i]);
        }
        if (!subscriber.closed) {
            subscriber.complete();
        }
    };
};

/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToArray PURE_IMPORTS_END */
function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToArray(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
function scalar(value) {
    var result = new Observable(function (subscriber) {
        subscriber.next(value);
        subscriber.complete();
    });
    result._isScalar = true;
    result.value = value;
    return result;
}

/** PURE_IMPORTS_START _util_isScheduler,_fromArray,_empty,_scalar PURE_IMPORTS_END */
function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler(scheduler)) {
        args.pop();
    }
    else {
        scheduler = undefined;
    }
    switch (args.length) {
        case 0:
            return empty$1(scheduler);
        case 1:
            return scheduler ? fromArray(args, scheduler) : scalar(args[0]);
        default:
            return fromArray(args, scheduler);
    }
}

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
/**
 * Creates an Observable that emits no items to the Observer and immediately
 * emits an error notification.
 *
 * <span class="informal">Just emits 'error', and nothing else.
 * </span>
 *
 * <img src="./img/throw.png" width="100%">
 *
 * This static operator is useful for creating a simple Observable that only
 * emits the error notification. It can be used for composing with other
 * Observables, such as in a {@link mergeMap}.
 *
 * @example <caption>Emit the number 7, then emit an error.</caption>
 * import { throwError, concat, of } from 'rxjs/create';
 *
 * const result = concat(of(7), throwError(new Error('oops!')));
 * result.subscribe(x => console.log(x), e => console.error(e));
 *
 * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
 * import { throwError, interval, of } from 'rxjs/create';
 * import { mergeMap } from 'rxjs/operators';
 *
 * interval(1000).pipe(
 *   mergeMap(x => x === 13 ?
 *     throwError('Thirteens are bad') :
 *     of('a', 'b', 'c')
 *   )
 * ).subscribe(x => console.log(x), e => console.error(e));
 *
 * @see {@link create}
 * @see {@link empty}
 * @see {@link never}
 * @see {@link of}
 *
 * @param {any} error The particular Error to pass to the error notification.
 * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
 * the emission of the error notification.
 * @return {Observable} An error Observable: emits only the error notification
 * using the given error argument.
 * @static true
 * @name throw
 * @owner Observable
 */
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

/** PURE_IMPORTS_START _observable_empty,_observable_of,_observable_throwError PURE_IMPORTS_END */
/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = /*@__PURE__*/ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of(this.value);
            case 'E':
                return throwError(this.error);
            case 'C':
                return empty$1();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     * @nocollapse
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     * @nocollapse
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     * @nocollapse
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */

var ObserveOnOperator = /*@__PURE__*/ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    /** @nocollapse */
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber));
var ObserveOnMessage = /*@__PURE__*/ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_queue,_Subscription,_operators_observeOn,_util_ObjectUnsubscribedError,_SubjectSubscription PURE_IMPORTS_END */
/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = /*@__PURE__*/ (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) {
            bufferSize = Number.POSITIVE_INFINITY;
        }
        if (windowTime === void 0) {
            windowTime = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        // Since this method is invoked in every next() call than the buffer
        // can overgrow the max size only by one item
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    ReplaySubject.prototype._subscribe = function (subscriber) {
        // When `_infiniteTimeWindow === true` then the buffer is already trimmed
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject));
var ReplayEvent = /*@__PURE__*/ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

/** PURE_IMPORTS_START tslib,_Subject,_Subscription PURE_IMPORTS_END */
/**
 * @class AsyncSubject<T>
 */
var AsyncSubject = /*@__PURE__*/ (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    /** @deprecated This is an internal implementation detail, do not use. */
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
var Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};

/** PURE_IMPORTS_START tslib,_util_Immediate,_AsyncAction PURE_IMPORTS_END */
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsapAction = /*@__PURE__*/ (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If a microtask has already been scheduled, don't schedule another
        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
        // the current scheduled microtask id.
        return scheduler.scheduled || (scheduler.scheduled = Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested microtask and
        // set the scheduled flag to undefined so the next AsapAction will schedule
        // its own.
        if (scheduler.actions.length === 0) {
            Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AsapAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AsapScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AsapAction,_AsapScheduler PURE_IMPORTS_END */
/**
 *
 * Asap Scheduler
 *
 * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
 *
 * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
 * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
 * code to end and then it will try to execute given task as fast as possible.
 *
 * `asap` scheduler will do its best to minimize time between end of currently executing code
 * and start of scheduled task. This makes it best candidate for performing so called "deferring".
 * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
 * some (although minimal) unwanted delay.
 *
 * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
 * after currently executing code. In particular, if some task was also scheduled with `asap` before,
 * that task will execute first. That being said, if you need to schedule task asynchronously, but
 * as soon as possible, `asap` scheduler is your best bet.
 *
 * @example <caption>Compare async and asap scheduler</caption>
 *
 * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
 * Rx.Scheduler.asap.schedule(() => console.log('asap'));
 *
 * // Logs:
 * // "asap"
 * // "async"
 * // ... but 'asap' goes first!
 *
 * @static true
 * @name asap
 * @owner Scheduler
 */
var asap = /*@__PURE__*/ new AsapScheduler(AsapAction);

/** PURE_IMPORTS_START _AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
var async = /*@__PURE__*/ new AsyncScheduler(AsyncAction);

/** PURE_IMPORTS_START tslib,_AsyncAction PURE_IMPORTS_END */
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AnimationFrameAction = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If an animation frame has already been requested, don't request another
        // one. If an animation frame hasn't been requested yet, request one. Return
        // the current animation frame request id.
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested animation frame and
        // set the scheduled flag to undefined so the next AnimationFrameAction will
        // request its own.
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction));

/** PURE_IMPORTS_START tslib,_AsyncScheduler PURE_IMPORTS_END */
var AnimationFrameScheduler = /*@__PURE__*/ (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler));

/** PURE_IMPORTS_START _AnimationFrameAction,_AnimationFrameScheduler PURE_IMPORTS_END */
/**
 *
 * Animation Frame Scheduler
 *
 * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
 *
 * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
 * behaviour.
 *
 * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
 * It makes sure scheduled task will happen just before next browser content repaint,
 * thus performing animations as efficiently as possible.
 *
 * @example <caption>Schedule div height animation</caption>
 * const div = document.querySelector('.some-div');
 *
 * Rx.Scheduler.animationFrame.schedule(function(height) {
 *   div.style.height = height + "px";
 *
 *   this.schedule(height + 1);  // `this` references currently executing Action,
 *                               // which we reschedule with new state
 * }, 0, 0);
 *
 * // You will see .some-div element growing in height
 *
 *
 * @static true
 * @name animationFrame
 * @owner Scheduler
 */
var animationFrame = /*@__PURE__*/ new AnimationFrameScheduler(AnimationFrameAction);

/** PURE_IMPORTS_START tslib,_AsyncAction,_AsyncScheduler PURE_IMPORTS_END */
var VirtualTimeScheduler = /*@__PURE__*/ (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) {
            SchedulerAction = VirtualAction;
        }
        if (maxFrames === void 0) {
            maxFrames = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    /**
     * Prompt the Scheduler to execute all of its queued actions, therefore
     * clearing its queue.
     * @return {void}
     */
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var VirtualAction = /*@__PURE__*/ (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) {
            index = scheduler.index += 1;
        }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        // If an action is rescheduled, we save allocations by mutating its state,
        // pushing it to the end of the scheduler queue, and recycling the action.
        // But since the VirtualTimeScheduler is used for testing, VirtualActions
        // must be immutable so they can be inspected later.
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) {
            delay = 0;
        }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
/**
 * Tests to see if the object is an RxJS {@link Observable}
 * @param obj the object to test
 */

/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = /*@__PURE__*/ (function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var _this = _super.call(this, 'argument out of range') || this;
        _this.name = 'ArgumentOutOfRangeError';
        Object.setPrototypeOf(_this, ArgumentOutOfRangeError.prototype);
        return _this;
    }
    return ArgumentOutOfRangeError;
}(Error));

/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
var EmptyError = /*@__PURE__*/ (function (_super) {
    __extends(EmptyError, _super);
    function EmptyError() {
        var _this = _super.call(this, 'no elements in sequence') || this;
        _this.name = 'EmptyError';
        Object.setPrototypeOf(_this, EmptyError.prototype);
        return _this;
    }
    return EmptyError;
}(Error));

/** PURE_IMPORTS_START tslib PURE_IMPORTS_END */
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = /*@__PURE__*/ (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError() {
        var _this = _super.call(this, 'Timeout has occurred') || this;
        _this.name = 'TimeoutError';
        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
    }
    return TimeoutError;
}(Error));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
var MapOperator = /*@__PURE__*/ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isArray,_util_isScheduler PURE_IMPORTS_END */
// tslint:enable:max-line-length
/**
 * Converts a callback API to a function that returns an Observable.
 *
 * <span class="informal">Give it a function `f` of type `f(x, callback)` and
 * it will return a function `g` that when called as `g(x)` will output an
 * Observable.</span>
 *
 * `bindCallback` is not an operator because its input and output are not
 * Observables. The input is a function `func` with some parameters, the
 * last parameter must be a callback function that `func` calls when it is
 * done.
 *
 * The output of `bindCallback` is a function that takes the same parameters
 * as `func`, except the last one (the callback). When the output function
 * is called with arguments it will return an Observable. If function `func`
 * calls its callback with one argument the Observable will emit that value.
 * If on the other hand the callback is called with multiple values the resulting
 * Observable will emit an array with said values as arguments.
 *
 * It is very important to remember that input function `func` is not called
 * when the output function is, but rather when the Observable returned by the output
 * function is subscribed. This means if `func` makes an AJAX request, that request
 * will be made every time someone subscribes to the resulting Observable, but not before.
 *
 * The last optional parameter - {@link Scheduler} - can be used to control when the call
 * to `func` happens after someone subscribes to Observable, as well as when results
 * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`
 * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,
 * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler
 * and call `subscribe` on the output Observable all function calls that are currently executing
 * will end before `func` is invoked.
 *
 * By default results passed to the callback are emitted immediately after `func` invokes the callback.
 * In particular, if the callback is called synchronously the subscription of the resulting Observable
 * will call the `next` function synchronously as well.  If you want to defer that call,
 * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can
 * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.
 *
 * Note that the Observable created by the output function will always emit a single value
 * and then complete immediately. If `func` calls the callback multiple times, values from subsequent
 * calls will not appear in the stream. If you need to listen for multiple calls,
 *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.
 *
 * If `func` depends on some context (`this` property) and is not already bound the context of `func`
 * will be the context that the output function has at call time. In particular, if `func`
 * is called as a method of some objec and if `func` is not already bound, in order to preserve the context
 * it is recommended that the context of the output function is set to that object as well.
 *
 * If the input function calls its callback in the "node style" (i.e. first argument to callback is
 * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}
 * provides convenient error handling and probably is a better choice.
 * `bindCallback` will treat such functions the same as any other and error parameters
 * (whether passed or not) will always be interpreted as regular callback argument.
 *
 *
 * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
 * // Suppose we have jQuery.getJSON('/my/url', callback)
 * var getJSONAsObservable = bindCallback(jQuery.getJSON);
 * var result = getJSONAsObservable('/my/url');
 * result.subscribe(x => console.log(x), e => console.error(e));
 *
 *
 * @example <caption>Receive an array of arguments passed to a callback</caption>
 * someFunction((a, b, c) => {
 *   console.log(a); // 5
 *   console.log(b); // 'some string'
 *   console.log(c); // {someProperty: 'someValue'}
 * });
 *
 * const boundSomeFunction = bindCallback(someFunction);
 * boundSomeFunction().subscribe(values => {
 *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]
 * });
 *
 *
 * @example <caption>Compare behaviour with and without async Scheduler</caption>
 * function iCallMyCallbackSynchronously(cb) {
 *   cb();
 * }
 *
 * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);
 * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);
 *
 * boundSyncFn().subscribe(() => console.log('I was sync!'));
 * boundAsyncFn().subscribe(() => console.log('I was async!'));
 * console.log('This happened...');
 *
 * // Logs:
 * // I was sync!
 * // This happened...
 * // I was async!
 *
 *
 * @example <caption>Use bindCallback on an object method</caption>
 * const boundMethod = bindCallback(someObject.methodWithCallback);
 * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject
 * .subscribe(subscriber);
 *
 *
 * @see {@link bindNodeCallback}
 * @see {@link from}
 * @see {@link fromPromise}
 *
 * @param {function} func A function with a callback as the last parameter.
 * @param {Scheduler} [scheduler] The scheduler on which to schedule the
 * callbacks.
 * @return {function(...params: *): Observable} A function which returns the
 * Observable that delivers the same values the callback would deliver.
 * @name bindCallback
 */

/** PURE_IMPORTS_START _Observable,_AsyncSubject,_operators_map,_util_isScheduler,_util_isArray PURE_IMPORTS_END */
/**
 * Converts a Node.js-style callback API to a function that returns an
 * Observable.
 *
 * <span class="informal">It's just like {@link bindCallback}, but the
 * callback is expected to be of type `callback(error, result)`.</span>
 *
 * `bindNodeCallback` is not an operator because its input and output are not
 * Observables. The input is a function `func` with some parameters, but the
 * last parameter must be a callback function that `func` calls when it is
 * done. The callback function is expected to follow Node.js conventions,
 * where the first argument to the callback is an error object, signaling
 * whether call was successful. If that object is passed to callback, it means
 * something went wrong.
 *
 * The output of `bindNodeCallback` is a function that takes the same
 * parameters as `func`, except the last one (the callback). When the output
 * function is called with arguments, it will return an Observable.
 * If `func` calls its callback with error parameter present, Observable will
 * error with that value as well. If error parameter is not passed, Observable will emit
 * second parameter. If there are more parameters (third and so on),
 * Observable will emit an array with all arguments, except first error argument.
 *
 * Note that `func` will not be called at the same time output function is,
 * but rather whenever resulting Observable is subscribed. By default call to
 * `func` will happen synchronously after subscription, but that can be changed
 * with proper {@link Scheduler} provided as optional third parameter. Scheduler
 * can also control when values from callback will be emitted by Observable.
 * To find out more, check out documentation for {@link bindCallback}, where
 * Scheduler works exactly the same.
 *
 * As in {@link bindCallback}, context (`this` property) of input function will be set to context
 * of returned function, when it is called.
 *
 * After Observable emits value, it will complete immediately. This means
 * even if `func` calls callback again, values from second and consecutive
 * calls will never appear on the stream. If you need to handle functions
 * that call callbacks multiple times, check out {@link fromEvent} or
 * {@link fromEventPattern} instead.
 *
 * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
 * "Node.js-style" callbacks are just a convention, so if you write for
 * browsers or any other environment and API you use implements that callback style,
 * `bindNodeCallback` can be safely used on that API functions as well.
 *
 * Remember that Error object passed to callback does not have to be an instance
 * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
 * Error parameter of callback function is interpreted as "present", when value
 * of that parameter is truthy. It could be, for example, non-zero number, non-empty
 * string or boolean `true`. In all of these cases resulting Observable would error
 * with that value. This means usually regular style callbacks will fail very often when
 * `bindNodeCallback` is used. If your Observable errors much more often then you
 * would expect, check if callback really is called in Node.js-style and, if not,
 * switch to {@link bindCallback} instead.
 *
 * Note that even if error parameter is technically present in callback, but its value
 * is falsy, it still won't appear in array emitted by Observable.
 *
 *
 * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
 * import * as fs from 'fs';
 * var readFileAsObservable = bindNodeCallback(fs.readFile);
 * var result = readFileAsObservable('./roadNames.txt', 'utf8');
 * result.subscribe(x => console.log(x), e => console.error(e));
 *
 *
 * @example <caption>Use on function calling callback with multiple arguments</caption>
 * someFunction((err, a, b) => {
 *   console.log(err); // null
 *   console.log(a); // 5
 *   console.log(b); // "some string"
 * });
 * var boundSomeFunction = bindNodeCallback(someFunction);
 * boundSomeFunction()
 * .subscribe(value => {
 *   console.log(value); // [5, "some string"]
 * });
 *
 * @example <caption>Use on function calling callback in regular style</caption>
 * someFunction(a => {
 *   console.log(a); // 5
 * });
 * var boundSomeFunction = bindNodeCallback(someFunction);
 * boundSomeFunction()
 * .subscribe(
 *   value => {}             // never gets called
 *   err => console.log(err) // 5
 * );
 *
 *
 * @see {@link bindCallback}
 * @see {@link from}
 * @see {@link fromPromise}
 *
 * @param {function} func Function with a Node.js-style callback as the last parameter.
 * @param {Scheduler} [scheduler] The scheduler on which to schedule the
 * callbacks.
 * @return {function(...params: *): Observable} A function which returns the
 * Observable that delivers the same values the Node.js callback would
 * deliver.
 * @name bindNodeCallback
 */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _hostReportError PURE_IMPORTS_END */
var subscribeToPromise = function (promise) {
    return function (subscriber) {
        promise.then(function (value) {
            if (!subscriber.closed) {
                subscriber.next(value);
                subscriber.complete();
            }
        }, function (err) { return subscriber.error(err); })
            .then(null, hostReportError);
        return subscriber;
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
var iterator = /*@__PURE__*/ getSymbolIterator();
/**
 * @deprecated use {@link iterator} instead
 */

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
var subscribeToIterable = function (iterable) {
    return function (subscriber) {
        var iterator$$1 = iterable[iterator]();
        do {
            var item = iterator$$1.next();
            if (item.done) {
                subscriber.complete();
                break;
            }
            subscriber.next(item.value);
            if (subscriber.closed) {
                break;
            }
        } while (true);
        // Finalize the iterator if it happens to be a Generator
        if (typeof iterator$$1.return === 'function') {
            subscriber.add(function () {
                if (iterator$$1.return) {
                    iterator$$1.return();
                }
            });
        }
        return subscriber;
    };
};

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
/**
 * Subscribes to an object that implements Symbol.observable with the given
 * Subscriber.
 * @param obj An object that implements Symbol.observable
 */
var subscribeToObservable = function (obj) {
    return function (subscriber) {
        var obs = obj[observable]();
        if (typeof obs.subscribe !== 'function') {
            // Should be caught by observable subscribe function error handling.
            throw new TypeError('Provided object does not correctly implement Symbol.observable');
        }
        else {
            return obs.subscribe(subscriber);
        }
    };
};

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
var isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

/** PURE_IMPORTS_START  PURE_IMPORTS_END */
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}

/** PURE_IMPORTS_START _Observable,_subscribeToArray,_subscribeToPromise,_subscribeToIterable,_subscribeToObservable,_isArrayLike,_isPromise,_isObject,_symbol_iterator,_symbol_observable PURE_IMPORTS_END */
var subscribeTo = function (result) {
    if (result instanceof Observable) {
        return function (subscriber) {
            if (result._isScalar) {
                subscriber.next(result.value);
                subscriber.complete();
                return undefined;
            }
            else {
                return result.subscribe(subscriber);
            }
        };
    }
    else if (isArrayLike(result)) {
        return subscribeToArray(result);
    }
    else if (isPromise(result)) {
        return subscribeToPromise(result);
    }
    else if (result && typeof result[iterator] === 'function') {
        return subscribeToIterable(result);
    }
    else if (result && typeof result[observable] === 'function') {
        return subscribeToObservable(result);
    }
    else {
        var value = isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

/** PURE_IMPORTS_START _InnerSubscriber,_subscribeTo PURE_IMPORTS_END */
function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    return subscribeTo(result)(destination);
}

/** PURE_IMPORTS_START tslib,_util_isScheduler,_util_isArray,_OuterSubscriber,_util_subscribeToResult,_fromArray PURE_IMPORTS_END */
var NONE = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from all the Observables passed as
 * arguments. This is done by subscribing to each Observable in order and,
 * whenever any Observable emits, collecting an array of the most recent
 * values from each Observable. So if you pass `n` Observables to operator,
 * returned Observable will always emit an array of `n` values, in order
 * corresponding to order of passed Observables (value from the first Observable
 * on the first place and so on).
 *
 * Static version of `combineLatest` accepts either an array of Observables
 * or each Observable can be put directly as an argument. Note that array of
 * Observables is good choice, if you don't know beforehand how many Observables
 * you will combine. Passing empty array will result in Observable that
 * completes immediately.
 *
 * To ensure output array has always the same length, `combineLatest` will
 * actually wait for all input Observables to emit at least once,
 * before it starts emitting results. This means if some Observable emits
 * values before other Observables started emitting, all that values but last
 * will be lost. On the other hand, is some Observable does not emit value but
 * completes, resulting Observable will complete at the same moment without
 * emitting anything, since it will be now impossible to include value from
 * completed Observable in resulting array. Also, if some input Observable does
 * not emit any value and never completes, `combineLatest` will also never emit
 * and never complete, since, again, it will wait for all streams to emit some
 * value.
 *
 * If at least one Observable was passed to `combineLatest` and all passed Observables
 * emitted something, resulting Observable will complete when all combined
 * streams complete. So even if some Observable completes, result of
 * `combineLatest` will still emit values when other Observables do. In case
 * of completed Observable, its value from now on will always be the last
 * emitted value. On the other hand, if any Observable errors, `combineLatest`
 * will error immediately as well, and all other Observables will be unsubscribed.
 *
 * `combineLatest` accepts as optional parameter `project` function, which takes
 * as arguments all values that would normally be emitted by resulting Observable.
 * `project` can return any kind of value, which will be then emitted by Observable
 * instead of default array. Note that `project` does not take as argument that array
 * of values, but values themselves. That means default `project` can be imagined
 * as function that takes all its arguments and puts them into an array.
 *
 *
 * @example <caption>Combine two timer Observables</caption>
 * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
 * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
 * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
 * combinedTimers.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0] after 0.5s
 * // [1, 0] after 1s
 * // [1, 1] after 1.5s
 * // [2, 1] after 2s
 *
 *
 * @example <caption>Combine an array of Observables</caption>
 * const observables = [1, 5, 10].map(
 *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
 * );
 * const combined = Rx.Observable.combineLatest(observables);
 * combined.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0, 0] immediately
 * // [1, 0, 0] after 1s
 * // [1, 5, 0] after 5s
 * // [1, 5, 10] after 10s
 *
 *
 * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
 * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
 * More than one input Observables may be given as arguments
 * or an array of Observables may be given as the first argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each input Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 */

var CombineLatestOperator = /*@__PURE__*/ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _symbol_observable PURE_IMPORTS_END */
/** Identifies an input as being Observable (but not necessary an Rx Observable) */
function isInteropObservable(input) {
    return input && typeof input[observable] === 'function';
}

/** PURE_IMPORTS_START _symbol_iterator PURE_IMPORTS_END */
/** Identifies an input as being an Iterable */
function isIterable(input) {
    return input && typeof input[iterator] === 'function';
}

/** PURE_IMPORTS_START _Observable,_Subscription,_util_subscribeToPromise PURE_IMPORTS_END */
function fromPromise(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToPromise(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                return input.then(function (value) {
                    sub.add(scheduler.schedule(function () {
                        subscriber.next(value);
                        sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                    }));
                }, function (err) {
                    sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
                });
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_iterator,_util_subscribeToIterable PURE_IMPORTS_END */
function fromIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    if (!scheduler) {
        return new Observable(subscribeToIterable(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            var iterator$$1;
            sub.add(function () {
                // Finalize generators
                if (iterator$$1 && typeof iterator$$1.return === 'function') {
                    iterator$$1.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator$$1 = input[iterator]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator$$1.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_Subscription,_symbol_observable,_util_subscribeToObservable PURE_IMPORTS_END */
function fromObservable(input, scheduler) {
    if (!scheduler) {
        return new Observable(subscribeToObservable(input));
    }
    else {
        return new Observable(function (subscriber) {
            var sub = new Subscription();
            sub.add(scheduler.schedule(function () {
                var observable$$1 = input[observable]();
                sub.add(observable$$1.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }
}

/** PURE_IMPORTS_START _Observable,_util_isPromise,_util_isArrayLike,_util_isInteropObservable,_util_isIterable,_fromArray,_fromPromise,_fromIterable,_fromObservable,_util_subscribeTo PURE_IMPORTS_END */
function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable) {
            return input;
        }
        return new Observable(subscribeTo(input));
    }
    if (input != null) {
        if (isInteropObservable(input)) {
            return fromObservable(input, scheduler);
        }
        else if (isPromise(input)) {
            return fromPromise(input, scheduler);
        }
        else if (isArrayLike(input)) {
            return fromArray(input, scheduler);
        }
        else if (isIterable(input) || typeof input === 'string') {
            return fromIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}

/** PURE_IMPORTS_START tslib,_util_subscribeToResult,_OuterSubscriber,_map,_observable_from PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) {
        concurrent = Number.POSITIVE_INFINITY;
    }
    if (typeof resultSelector === 'function') {
        // DEPRECATED PATH
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from(project(a, i)).pipe(map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
var MergeMapOperator = /*@__PURE__*/ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) {
            concurrent = Number.POSITIVE_INFINITY;
        }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _mergeMap,_util_identity PURE_IMPORTS_END */
/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */

/** PURE_IMPORTS_START _mergeAll PURE_IMPORTS_END */
/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */

/** PURE_IMPORTS_START _util_isScheduler,_of,_from,_operators_concatAll PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
/**
 * Creates an Observable that, on subscribe, calls an Observable factory to
 * make an Observable for each new Observer.
 *
 * <span class="informal">Creates the Observable lazily, that is, only when it
 * is subscribed.
 * </span>
 *
 * <img src="./img/defer.png" width="100%">
 *
 * `defer` allows you to create the Observable only when the Observer
 * subscribes, and create a fresh Observable for each Observer. It waits until
 * an Observer subscribes to it, and then it generates an Observable,
 * typically with an Observable factory function. It does this afresh for each
 * subscriber, so although each subscriber may think it is subscribing to the
 * same Observable, in fact each subscriber gets its own individual
 * Observable.
 *
 * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
 * var clicksOrInterval = Rx.Observable.defer(function () {
 *   if (Math.random() > 0.5) {
 *     return Rx.Observable.fromEvent(document, 'click');
 *   } else {
 *     return Rx.Observable.interval(1000);
 *   }
 * });
 * clicksOrInterval.subscribe(x => console.log(x));
 *
 * // Results in the following behavior:
 * // If the result of Math.random() is greater than 0.5 it will listen
 * // for clicks anywhere on the "document"; when document is clicked it
 * // will log a MouseEvent object to the console. If the result is less
 * // than 0.5 it will emit ascending numbers, one every second(1000ms).
 *
 * @see {@link create}
 *
 * @param {function(): SubscribableOrPromise} observableFactory The Observable
 * factory function to invoke for each Observer that subscribes to the output
 * Observable. May also return a Promise, which will be converted on the fly
 * to an Observable.
 * @return {Observable} An Observable whose Observers' subscriptions trigger
 * an invocation of the given Observable factory function.
 * @static true
 * @name defer
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_Observable,_util_isArray,_empty,_util_subscribeToResult,_OuterSubscriber,_operators_map PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Joins last values emitted by passed Observables.
 *
 * <span class="informal">Wait for Observables to complete and then combine last values they emitted.</span>
 *
 * <img src="./img/forkJoin.png" width="100%">
 *
 * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array
 * or directly as arguments. If no input Observables are provided, resulting stream will complete
 * immediately.
 *
 * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last
 * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting
 * array will have `n` values, where first value is the last thing emitted by the first Observable,
 * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will
 * not emit more than once and it will complete after that. If you need to emit combined values not only
 * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}
 * or {@link zip} instead.
 *
 * In order for resulting array to have the same length as the number of input Observables, whenever any of
 * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well
 * and it will not emit anything either, even if it already has some last values from other Observables.
 * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,
 * unless at any point some other Observable completes without emitting value, which brings us back to
 * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments
 * have to emit something at least once and complete.
 *
 * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables
 * will be immediately unsubscribed.
 *
 * Optionally `forkJoin` accepts project function, that will be called with values which normally
 * would land in emitted array. Whatever is returned by project function, will appear in output
 * Observable instead. This means that default project can be thought of as a function that takes
 * all its arguments and puts them into an array. Note that project function will be called only
 * when output Observable is supposed to emit a result.
 *
 * @example <caption>Use forkJoin with operator emitting immediately</caption>
 * import { forkJoin, of } from 'rxjs';
 *
 * const observable = forkJoin(
 *   of(1, 2, 3, 4),
 *   of(5, 6, 7, 8)
 * );
 * observable.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('This is how it ends!')
 * );
 *
 * // Logs:
 * // [4, 8]
 * // "This is how it ends!"
 *
 *
 * @example <caption>Use forkJoin with operator emitting after some time</caption>
 * import { forkJoin, interval } from 'rxjs';
 * import { take } from 'rxjs/operators';
 *
 * const observable = forkJoin(
 *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete
 *   interval(500).pipe(take(4)) // emit 0, 1, 2, 3 every half a second and complete
 * );
 * observable.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('This is how it ends!')
 * );
 *
 * // Logs:
 * // [2, 3] after 3 seconds
 * // "This is how it ends!" immediately after
 *
 *
 * @example <caption>Use forkJoin with project function</caption>
 * import { jorkJoin, interval } from 'rxjs';
 * import { take } from 'rxjs/operators';
 *
 * const observable = forkJoin(
 *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete
 *   interval(500).pipe(take(4)), // emit 0, 1, 2, 3 every half a second and complete
 *   (n, m) => n + m
 * );
 * observable.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('This is how it ends!')
 * );
 *
 * // Logs:
 * // 5 after 3 seconds
 * // "This is how it ends!" immediately after
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 *
 * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments
 * passed directly to the operator.
 * @param {function} [project] Function that takes values emitted by input Observables and returns value
 * that will appear in resulting Observable instead of default array.
 * @return {Observable} Observable emitting either an array of last values emitted by passed Observables
 * or value from project function.
 */

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ForkJoinSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ForkJoinSubscriber, _super);
    function ForkJoinSubscriber(destination, sources) {
        var _this = _super.call(this, destination) || this;
        _this.sources = sources;
        _this.completed = 0;
        _this.haveValues = 0;
        var len = sources.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            var innerSubscription = subscribeToResult(_this, source, null, i);
            if (innerSubscription) {
                _this.add(innerSubscription);
            }
        }
        return _this;
    }
    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        if (!innerSub._hasValue) {
            innerSub._hasValue = true;
            this.haveValues++;
        }
    };
    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
        var len = values.length;
        if (!innerSub._hasValue) {
            destination.complete();
            return;
        }
        this.completed++;
        if (this.completed !== len) {
            return;
        }
        if (haveValues === len) {
            destination.next(values);
        }
        destination.complete();
    };
    return ForkJoinSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Creates an Observable that emits events of a specific type coming from the
 * given event target.
 *
 * <span class="informal">Creates an Observable from DOM events, or Node.js
 * EventEmitter events or others.</span>
 *
 * <img src="./img/fromEvent.png" width="100%">
 *
 * `fromEvent` accepts as a first argument event target, which is an object with methods
 * for registering event handler functions. As a second argument it takes string that indicates
 * type of event we want to listen for. `fromEvent` supports selected types of event targets,
 * which are described in detail below. If your event target does not match any of the ones listed,
 * you should use {@link fromEventPattern}, which can be used on arbitrary APIs.
 * When it comes to APIs supported by `fromEvent`, their methods for adding and removing event
 * handler functions have different names, but they all accept a string describing event type
 * and function itself, which will be called whenever said event happens.
 *
 * Every time resulting Observable is subscribed, event handler function will be registered
 * to event target on given event type. When that event fires, value
 * passed as a first argument to registered function will be emitted by output Observable.
 * When Observable is unsubscribed, function will be unregistered from event target.
 *
 * Note that if event target calls registered function with more than one argument, second
 * and following arguments will not appear in resulting stream. In order to get access to them,
 * you can pass to `fromEvent` optional project function, which will be called with all arguments
 * passed to event handler. Output Observable will then emit value returned by project function,
 * instead of the usual value.
 *
 * Remember that event targets listed below are checked via duck typing. It means that
 * no matter what kind of object you have and no matter what environment you work in,
 * you can safely use `fromEvent` on that object if it exposes described methods (provided
 * of course they behave as was described above). So for example if Node.js library exposes
 * event target which has the same method names as DOM EventTarget, `fromEvent` is still
 * a good choice.
 *
 * If the API you use is more callback then event handler oriented (subscribed
 * callback function fires only once and thus there is no need to manually
 * unregister it), you should use {@link bindCallback} or {@link bindNodeCallback}
 * instead.
 *
 * `fromEvent` supports following types of event targets:
 *
 * **DOM EventTarget**
 *
 * This is an object with `addEventListener` and `removeEventListener` methods.
 *
 * In the browser, `addEventListener` accepts - apart from event type string and event
 * handler function arguments - optional third parameter, which is either an object or boolean,
 * both used for additional configuration how and when passed function will be called. When
 * `fromEvent` is used with event target of that type, you can provide this values
 * as third parameter as well.
 *
 * **Node.js EventEmitter**
 *
 * An object with `addListener` and `removeListener` methods.
 *
 * **JQuery-style event target**
 *
 * An object with `on` and `off` methods
 *
 * **DOM NodeList**
 *
 * List of DOM Nodes, returned for example by `document.querySelectorAll` or `Node.childNodes`.
 *
 * Although this collection is not event target in itself, `fromEvent` will iterate over all Nodes
 * it contains and install event handler function in every of them. When returned Observable
 * is unsubscribed, function will be removed from all Nodes.
 *
 * **DOM HtmlCollection**
 *
 * Just as in case of NodeList it is a collection of DOM nodes. Here as well event handler function is
 * installed and removed in each of elements.
 *
 *
 * @example <caption>Emits clicks happening on the DOM document</caption>
 * var clicks = fromEvent(document, 'click');
 * clicks.subscribe(x => console.log(x));
 *
 * // Results in:
 * // MouseEvent object logged to console every time a click
 * // occurs on the document.
 *
 *
 * @example <caption>Use addEventListener with capture option</caption>
 * var clicksInDocument = fromEvent(document, 'click', true); // note optional configuration parameter
 *                                                                          // which will be passed to addEventListener
 * var clicksInDiv = fromEvent(someDivInDocument, 'click');
 *
 * clicksInDocument.subscribe(() => console.log('document'));
 * clicksInDiv.subscribe(() => console.log('div'));
 *
 * // By default events bubble UP in DOM tree, so normally
 * // when we would click on div in document
 * // "div" would be logged first and then "document".
 * // Since we specified optional `capture` option, document
 * // will catch event when it goes DOWN DOM tree, so console
 * // will log "document" and then "div".
 *
 * @see {@link bindCallback}
 * @see {@link bindNodeCallback}
 * @see {@link fromEventPattern}
 *
 * @param {FromEventTarget<T>} target The DOM EventTarget, Node.js
 * EventEmitter, JQuery-like event target, NodeList or HTMLCollection to attach the event handler to.
 * @param {string} eventName The event name of interest, being emitted by the
 * `target`.
 * @param {EventListenerOptions} [options] Options to pass through to addEventListener
 * @return {Observable<T>}
 * @name fromEvent
 */

/** PURE_IMPORTS_START _Observable,_util_isArray,_util_isFunction,_operators_map PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Creates an Observable from an API based on addHandler/removeHandler
 * functions.
 *
 * <span class="informal">Converts any addHandler/removeHandler API to an
 * Observable.</span>
 *
 * <img src="./img/fromEventPattern.png" width="100%">
 *
 * Creates an Observable by using the `addHandler` and `removeHandler`
 * functions to add and remove the handlers. The `addHandler` is
 * called when the output Observable is subscribed, and `removeHandler` is
 * called when the Subscription is unsubscribed.
 *
 * @example <caption>Emits clicks happening on the DOM document</caption>
 * function addClickHandler(handler) {
 *   document.addEventListener('click', handler);
 * }
 *
 * function removeClickHandler(handler) {
 *   document.removeEventListener('click', handler);
 * }
 *
 * var clicks = fromEventPattern(
 *   addClickHandler,
 *   removeClickHandler
 * );
 * clicks.subscribe(x => console.log(x));
 *
 * @see {@link from}
 * @see {@link fromEvent}
 *
 * @param {function(handler: Function): any} addHandler A function that takes
 * a `handler` function as argument and attaches it somehow to the actual
 * source of events.
 * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that
 * takes a `handler` function as argument and removes it in case it was
 * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,
 * removeHandler function will forward it.
 * @return {Observable<T>}
 * @name fromEventPattern
 */

/** PURE_IMPORTS_START _Observable,_util_identity,_util_isScheduler PURE_IMPORTS_END */

/** PURE_IMPORTS_START _defer,_empty PURE_IMPORTS_END */
/**
 * Decides at subscription time which Observable will actually be subscribed.
 *
 * <span class="informal">`If` statement for Observables.</span>
 *
 * `if` accepts a condition function and two Observables. When
 * an Observable returned by the operator is subscribed, condition function will be called.
 * Based on what boolean it returns at that moment, consumer will subscribe either to
 * the first Observable (if condition was true) or to the second (if condition was false). Condition
 * function may also not return anything - in that case condition will be evaluated as false and
 * second Observable will be subscribed.
 *
 * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that
 * was left undefined, resulting stream will simply complete immediately. That allows you to, rather
 * then controlling which Observable will be subscribed, decide at runtime if consumer should have access
 * to given Observable or not.
 *
 * If you have more complex logic that requires decision between more than two Observables, {@link defer}
 * will probably be a better choice. Actually `if` can be easily implemented with {@link defer}
 * and exists only for convenience and readability reasons.
 *
 *
 * @example <caption>Change at runtime which Observable will be subscribed</caption>
 * let subscribeToFirst;
 * const firstOrSecond = Rx.Observable.if(
 *   () => subscribeToFirst,
 *   Rx.Observable.of('first'),
 *   Rx.Observable.of('second')
 * );
 *
 * subscribeToFirst = true;
 * firstOrSecond.subscribe(value => console.log(value));
 *
 * // Logs:
 * // "first"
 *
 * subscribeToFirst = false;
 * firstOrSecond.subscribe(value => console.log(value));
 *
 * // Logs:
 * // "second"
 *
 *
 * @example <caption>Control an access to an Observable</caption>
 * let accessGranted;
 * const observableIfYouHaveAccess = Rx.Observable.if(
 *   () => accessGranted,
 *   Rx.Observable.of('It seems you have an access...') // Note that only one Observable is passed to the operator.
 * );
 *
 * accessGranted = true;
 * observableIfYouHaveAccess.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('The end')
 * );
 *
 * // Logs:
 * // "It seems you have an access..."
 * // "The end"
 *
 * accessGranted = false;
 * observableIfYouHaveAccess.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('The end')
 * );
 *
 * // Logs:
 * // "The end"
 *
 * @see {@link defer}
 *
 * @param {function(): boolean} condition Condition which Observable should be chosen.
 * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.
 * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.
 * @return {Observable} Either first or second Observable, depending on condition.
 * @static true
 * @name iif
 * @owner Observable
 */

/** PURE_IMPORTS_START _isArray PURE_IMPORTS_END */
function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray(val) && (val - parseFloat(val) + 1) >= 0;
}

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric PURE_IMPORTS_END */
/**
 * Creates an Observable that emits sequential numbers every specified
 * interval of time, on a specified IScheduler.
 *
 * <span class="informal">Emits incremental numbers periodically in time.
 * </span>
 *
 * <img src="./img/interval.png" width="100%">
 *
 * `interval` returns an Observable that emits an infinite sequence of
 * ascending integers, with a constant interval of time of your choosing
 * between those emissions. The first emission is not sent immediately, but
 * only after the first period has passed. By default, this operator uses the
 * `async` IScheduler to provide a notion of time, but you may pass any
 * IScheduler to it.
 *
 * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
 * var numbers = Rx.Observable.interval(1000);
 * numbers.subscribe(x => console.log(x));
 *
 * @see {@link timer}
 * @see {@link delay}
 *
 * @param {number} [period=0] The interval size in milliseconds (by default)
 * or the time unit determined by the scheduler's clock.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
 * the emission of values, and providing a notion of "time".
 * @return {Observable} An Observable that emits a sequential number each time
 * interval.
 * @static true
 * @name interval
 * @owner Observable
 */

/** PURE_IMPORTS_START _Observable,_util_isScheduler,_operators_mergeAll,_fromArray PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */

/** PURE_IMPORTS_START _Observable,_util_noop PURE_IMPORTS_END */
/**
 * An Observable that emits no items to the Observer and never completes.
 *
 * <img src="./img/never.png" width="100%">
 *
 * A simple Observable that emits neither values nor errors nor the completion
 * notification. It can be used for testing purposes or for composing with other
 * Observables. Please note that by never emitting a complete notification, this
 * Observable keeps the subscription from being disposed automatically.
 * Subscriptions need to be manually disposed.
 *
 * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
 * function info() {
 *   console.log('Will not be called');
 * }
 * var result = NEVER.startWith(7);
 * result.subscribe(x => console.log(x), info, info);
 *
 * @see {@link create}
 * @see {@link EMPTY}
 * @see {@link of}
 * @see {@link throwError}
 */
var NEVER = /*@__PURE__*/ new Observable(noop);
/**
 * @deprecated Deprecated in favor of using NEVER constant.
 */

/** PURE_IMPORTS_START _Observable,_from,_util_isArray,_empty PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
 * that was passed.
 *
 * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
 *
 * <img src="./img/onErrorResumeNext.png" width="100%">
 *
 * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.
 * If the source it's subscribed to emits an error or completes, it will move to the next source
 * without error.
 *
 * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.
 *
 * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its
 * sources emits an error.
 *
 * Note that there is no way to handle any errors thrown by sources via the resuult of
 * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can
 * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.
 *
 * @example <caption>Subscribe to the next Observable after map fails</caption>
 * import { onErrorResumeNext, of } from 'rxjs/create';
 * import { map } from 'rxjs/operators';
 *
 * onErrorResumeNext(
 *  of(1, 2, 3, 0).pipe(
 *    map(x => {
 *      if (x === 0) throw Error();
 *      return 10 / x;
 *    })
 *  ),
 *  of(1, 2, 3),
 * )
 * .subscribe(
 *   val => console.log(val),
 *   err => console.log(err),          // Will never be called.
 *   () => console.log('done')
 * );
 *
 * // Logs:
 * // 10
 * // 5
 * // 3.3333333333333335
 * // 1
 * // 2
 * // 3
 * // "done"
 *
 * @see {@link concat}
 * @see {@link catch}
 *
 * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.
 * @return {Observable} An Observable that concatenates all sources, one after the other,
 * ignoring all errors, such that any error causes it to move on to the next source.
 */

/** PURE_IMPORTS_START _Observable,_Subscription PURE_IMPORTS_END */
/**
 * Convert an object into an observable sequence of [key, value] pairs
 * using an optional IScheduler to enumerate the object.
 *
 * @example <caption>Converts a javascript object to an Observable</caption>
 * var obj = {
 *   foo: 42,
 *   bar: 56,
 *   baz: 78
 * };
 *
 * var source = Rx.Observable.pairs(obj);
 *
 * var subscription = source.subscribe(
 *   function (x) {
 *     console.log('Next: %s', x);
 *   },
 *   function (err) {
 *     console.log('Error: %s', err);
 *   },
 *   function () {
 *     console.log('Completed');
 *   });
 *
 * @param {Object} obj The object to inspect and turn into an
 * Observable sequence.
 * @param {Scheduler} [scheduler] An optional IScheduler to run the
 * enumeration of the input sequence on.
 * @returns {(Observable<[string, T]>)} An observable sequence of
 * [key, value] pairs from the object.
 */

/** @internal */

/** PURE_IMPORTS_START tslib,_util_isArray,_fromArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var RaceOperator = /*@__PURE__*/ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RaceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _Observable PURE_IMPORTS_END */
/**
 * Creates an Observable that emits a sequence of numbers within a specified
 * range.
 *
 * <span class="informal">Emits a sequence of numbers in a range.</span>
 *
 * <img src="./img/range.png" width="100%">
 *
 * `range` operator emits a range of sequential integers, in order, where you
 * select the `start` of the range and its `length`. By default, uses no
 * IScheduler and just delivers the notifications synchronously, but may use
 * an optional IScheduler to regulate those deliveries.
 *
 * @example <caption>Emits the numbers 1 to 10</caption>
 * var numbers = Rx.Observable.range(1, 10);
 * numbers.subscribe(x => console.log(x));
 *
 * @see {@link timer}
 * @see {@link interval}
 *
 * @param {number} [start=0] The value of the first integer in the sequence.
 * @param {number} [count=0] The number of sequential integers to generate.
 * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
 * the emissions of the notifications.
 * @return {Observable} An Observable of numbers that emits a finite range of
 * sequential integers.
 * @static true
 * @name range
 * @owner Observable
 */

/** @internal */

/** PURE_IMPORTS_START _Observable,_scheduler_async,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */
/**
 * Creates an Observable that starts emitting after an `initialDelay` and
 * emits ever increasing numbers after each `period` of time thereafter.
 *
 * <span class="informal">Its like {@link interval}, but you can specify when
 * should the emissions start.</span>
 *
 * <img src="./img/timer.png" width="100%">
 *
 * `timer` returns an Observable that emits an infinite sequence of ascending
 * integers, with a constant interval of time, `period` of your choosing
 * between those emissions. The first emission happens after the specified
 * `initialDelay`. The initial delay may be a {@link Date}. By default, this
 * operator uses the `async` IScheduler to provide a notion of time, but you
 * may pass any IScheduler to it. If `period` is not specified, the output
 * Observable emits only one value, `0`. Otherwise, it emits an infinite
 * sequence.
 *
 * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
 * var numbers = Rx.Observable.timer(3000, 1000);
 * numbers.subscribe(x => console.log(x));
 *
 * @example <caption>Emits one number after five seconds</caption>
 * var numbers = Rx.Observable.timer(5000);
 * numbers.subscribe(x => console.log(x));
 *
 * @see {@link interval}
 * @see {@link delay}
 *
 * @param {number|Date} [dueTime] The initial delay time to wait before
 * emitting the first value of `0`.
 * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the
 * subsequent numbers.
 * @param {SchedulerLike} [scheduler=async] The IScheduler to use for scheduling
 * the emission of values, and providing a notion of "time".
 * @return {Observable} An Observable that emits a `0` after the
 * `initialDelay` and ever increasing numbers after each `period` of time
 * thereafter.
 * @static true
 * @name timer
 * @owner Observable
 */

/** PURE_IMPORTS_START _Observable,_from,_empty PURE_IMPORTS_END */
/**
 * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.
 *
 * <span class="informal">Use it when you catch yourself cleaning up after an Observable.</span>
 *
 * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.
 * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with
 * that object and should return an Observable. That Observable can use resource object during its execution.
 * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor
 * resource object will be shared in any way between subscriptions.
 *
 * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed
 * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output
 * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,
 * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which
 * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone
 * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make
 * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.
 *
 * @see {@link defer}
 *
 * @param {function(): ISubscription} resourceFactory A function which creates any resource object
 * that implements `unsubscribe` method.
 * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which
 * creates an Observable, that can use injected resource object.
 * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but
 * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.
 */

/** PURE_IMPORTS_START tslib,_fromArray,_util_isArray,_Subscriber,_OuterSubscriber,_util_subscribeToResult,_.._internal_symbol_iterator PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */

var ZipOperator = /*@__PURE__*/ (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) {
            values = Object.create(null);
        }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (iterator$$1.stillUnsubscribed) {
                this.add(iterator$$1.subscribe(iterator$$1, i));
            }
            else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            if (typeof iterator$$1.hasValue === 'function' && !iterator$$1.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator$$1 = iterators[i];
            var result = iterator$$1.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator$$1.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber));
var StaticIterator = /*@__PURE__*/ (function () {
    function StaticIterator(iterator$$1) {
        this.iterator = iterator$$1;
        this.nextResult = iterator$$1.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = /*@__PURE__*/ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = /*@__PURE__*/ (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber));

/* Observable */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Ignores source values for a duration determined by another Observable, then
 * emits the most recent value from the source Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link auditTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/audit.png" width="100%">
 *
 * `audit` is similar to `throttle`, but emits the last value from the silenced
 * time window, instead of the first value. `audit` emits the most recent value
 * from the source Observable on the output Observable as soon as its internal
 * timer becomes disabled, and ignores source values while the timer is enabled.
 * Initially, the timer is disabled. As soon as the first source value arrives,
 * the timer is enabled by calling the `durationSelector` function with the
 * source value, which returns the "duration" Observable. When the duration
 * Observable emits a value or completes, the timer is disabled, then the most
 * recent source value is emitted on the output Observable, and this process
 * repeats for the next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.audit(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttle}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration, returned as an Observable or a Promise.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method audit
 * @owner Observable
 */

var AuditOperator = /*@__PURE__*/ (function () {
    function AuditOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    AuditOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new AuditSubscriber(subscriber, this.durationSelector));
    };
    return AuditOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AuditSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(AuditSubscriber, _super);
    function AuditSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        return _this;
    }
    AuditSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
        if (!this.throttled) {
            var duration = tryCatch(this.durationSelector)(value);
            if (duration === errorObject) {
                this.destination.error(errorObject.e);
            }
            else {
                var innerSubscription = subscribeToResult(this, duration);
                if (!innerSubscription || innerSubscription.closed) {
                    this.clearThrottle();
                }
                else {
                    this.add(this.throttled = innerSubscription);
                }
            }
        }
    };
    AuditSubscriber.prototype.clearThrottle = function () {
        var _a = this, value = _a.value, hasValue = _a.hasValue, throttled = _a.throttled;
        if (throttled) {
            this.remove(throttled);
            this.throttled = null;
            throttled.unsubscribe();
        }
        if (hasValue) {
            this.value = null;
            this.hasValue = false;
            this.destination.next(value);
        }
    };
    AuditSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex) {
        this.clearThrottle();
    };
    AuditSubscriber.prototype.notifyComplete = function () {
        this.clearThrottle();
    };
    return AuditSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_audit,_observable_timer PURE_IMPORTS_END */
/**
 * Ignores source values for `duration` milliseconds, then emits the most recent
 * value from the source Observable, then repeats this process.
 *
 * <span class="informal">When it sees a source values, it ignores that plus
 * the next ones for `duration` milliseconds, and then it emits the most recent
 * value from the source.</span>
 *
 * <img src="./img/auditTime.png" width="100%">
 *
 * `auditTime` is similar to `throttleTime`, but emits the last value from the
 * silenced time window, instead of the first value. `auditTime` emits the most
 * recent value from the source Observable on the output Observable as soon as
 * its internal timer becomes disabled, and ignores source values while the
 * timer is enabled. Initially, the timer is disabled. As soon as the first
 * source value arrives, the timer is enabled. After `duration` milliseconds (or
 * the time unit determined internally by the optional `scheduler`) has passed,
 * the timer is disabled, then the most recent source value is emitted on the
 * output Observable, and this process repeats for the next source value.
 * Optionally takes a {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.auditTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} duration Time to wait before emitting the most recent source
 * value, measured in milliseconds or the time unit determined internally
 * by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the rate-limiting behavior.
 * @return {Observable<T>} An Observable that performs rate-limiting of
 * emissions from the source Observable.
 * @method auditTime
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Buffers the source Observable values until `closingNotifier` emits.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when another Observable emits.</span>
 *
 * <img src="./img/buffer.png" width="100%">
 *
 * Buffers the incoming Observable values until the given `closingNotifier`
 * Observable emits a value, at which point it emits the buffer on the output
 * Observable and starts a new buffer internally, awaiting the next time
 * `closingNotifier` emits.
 *
 * @example <caption>On every click, emit array of most recent interval events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var buffered = interval.buffer(clicks);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link window}
 *
 * @param {Observable<any>} closingNotifier An Observable that signals the
 * buffer to be emitted on the output Observable.
 * @return {Observable<T[]>} An Observable of buffers, which are arrays of
 * values.
 * @method buffer
 * @owner Observable
 */

var BufferOperator = /*@__PURE__*/ (function () {
    function BufferOperator(closingNotifier) {
        this.closingNotifier = closingNotifier;
    }
    BufferOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferSubscriber(subscriber, this.closingNotifier));
    };
    return BufferOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSubscriber, _super);
    function BufferSubscriber(destination, closingNotifier) {
        var _this = _super.call(this, destination) || this;
        _this.buffer = [];
        _this.add(subscribeToResult(_this, closingNotifier));
        return _this;
    }
    BufferSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var buffer = this.buffer;
        this.buffer = [];
        this.destination.next(buffer);
    };
    return BufferSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Buffers the source Observable values until the size hits the maximum
 * `bufferSize` given.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * that array only when its size reaches `bufferSize`.</span>
 *
 * <img src="./img/bufferCount.png" width="100%">
 *
 * Buffers a number of values from the source Observable by `bufferSize` then
 * emits the buffer and clears it, and starts a new buffer each
 * `startBufferEvery` values. If `startBufferEvery` is not provided or is
 * `null`, then new buffers are started immediately at the start of the source
 * and when each buffer closes and is emitted.
 *
 * @example <caption>Emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>On every click, emit the last two click events as an array</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferCount(2, 1);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link pairwise}
 * @see {@link windowCount}
 *
 * @param {number} bufferSize The maximum size of the buffer emitted.
 * @param {number} [startBufferEvery] Interval at which to start a new buffer.
 * For example if `startBufferEvery` is `2`, then a new buffer will be started
 * on every other value from the source. A new buffer is started at the
 * beginning of the source by default.
 * @return {Observable<T[]>} An Observable of arrays of buffered values.
 * @method bufferCount
 * @owner Observable
 */

var BufferCountOperator = /*@__PURE__*/ (function () {
    function BufferCountOperator(bufferSize, startBufferEvery) {
        this.bufferSize = bufferSize;
        this.startBufferEvery = startBufferEvery;
        if (!startBufferEvery || bufferSize === startBufferEvery) {
            this.subscriberClass = BufferCountSubscriber;
        }
        else {
            this.subscriberClass = BufferSkipCountSubscriber;
        }
    }
    BufferCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new this.subscriberClass(subscriber, this.bufferSize, this.startBufferEvery));
    };
    return BufferCountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferCountSubscriber, _super);
    function BufferCountSubscriber(destination, bufferSize) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.buffer = [];
        return _this;
    }
    BufferCountSubscriber.prototype._next = function (value) {
        var buffer = this.buffer;
        buffer.push(value);
        if (buffer.length == this.bufferSize) {
            this.destination.next(buffer);
            this.buffer = [];
        }
    };
    BufferCountSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer.length > 0) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    return BufferCountSubscriber;
}(Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferSkipCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferSkipCountSubscriber, _super);
    function BufferSkipCountSubscriber(destination, bufferSize, startBufferEvery) {
        var _this = _super.call(this, destination) || this;
        _this.bufferSize = bufferSize;
        _this.startBufferEvery = startBufferEvery;
        _this.buffers = [];
        _this.count = 0;
        return _this;
    }
    BufferSkipCountSubscriber.prototype._next = function (value) {
        var _a = this, bufferSize = _a.bufferSize, startBufferEvery = _a.startBufferEvery, buffers = _a.buffers, count = _a.count;
        this.count++;
        if (count % startBufferEvery === 0) {
            buffers.push([]);
        }
        for (var i = buffers.length; i--;) {
            var buffer = buffers[i];
            buffer.push(value);
            if (buffer.length === bufferSize) {
                buffers.splice(i, 1);
                this.destination.next(buffer);
            }
        }
    };
    BufferSkipCountSubscriber.prototype._complete = function () {
        var _a = this, buffers = _a.buffers, destination = _a.destination;
        while (buffers.length > 0) {
            var buffer = buffers.shift();
            if (buffer.length > 0) {
                destination.next(buffer);
            }
        }
        _super.prototype._complete.call(this);
    };
    return BufferSkipCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_scheduler_async,_Subscriber,_util_isScheduler PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Buffers the source Observable values for a specific time period.
 *
 * <span class="informal">Collects values from the past as an array, and emits
 * those arrays periodically in time.</span>
 *
 * <img src="./img/bufferTime.png" width="100%">
 *
 * Buffers values from the source for a specific time duration `bufferTimeSpan`.
 * Unless the optional argument `bufferCreationInterval` is given, it emits and
 * resets the buffer every `bufferTimeSpan` milliseconds. If
 * `bufferCreationInterval` is given, this operator opens the buffer every
 * `bufferCreationInterval` milliseconds and closes (emits and resets) the
 * buffer every `bufferTimeSpan` milliseconds. When the optional argument
 * `maxBufferSize` is specified, the buffer will be closed either after
 * `bufferTimeSpan` milliseconds or when it contains `maxBufferSize` elements.
 *
 * @example <caption>Every second, emit an array of the recent click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(1000);
 * buffered.subscribe(x => console.log(x));
 *
 * @example <caption>Every 5 seconds, emit the click events from the next 2 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferTime(2000, 5000);
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferToggle}
 * @see {@link bufferWhen}
 * @see {@link windowTime}
 *
 * @param {number} bufferTimeSpan The amount of time to fill each buffer array.
 * @param {number} [bufferCreationInterval] The interval at which to start new
 * buffers.
 * @param {number} [maxBufferSize] The maximum buffer size.
 * @param {Scheduler} [scheduler=async] The scheduler on which to schedule the
 * intervals that determine buffer boundaries.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferTime
 * @owner Observable
 */

var BufferTimeOperator = /*@__PURE__*/ (function () {
    function BufferTimeOperator(bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        this.bufferTimeSpan = bufferTimeSpan;
        this.bufferCreationInterval = bufferCreationInterval;
        this.maxBufferSize = maxBufferSize;
        this.scheduler = scheduler;
    }
    BufferTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferTimeSubscriber(subscriber, this.bufferTimeSpan, this.bufferCreationInterval, this.maxBufferSize, this.scheduler));
    };
    return BufferTimeOperator;
}());
var Context = /*@__PURE__*/ (function () {
    function Context() {
        this.buffer = [];
    }
    return Context;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferTimeSubscriber, _super);
    function BufferTimeSubscriber(destination, bufferTimeSpan, bufferCreationInterval, maxBufferSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.bufferTimeSpan = bufferTimeSpan;
        _this.bufferCreationInterval = bufferCreationInterval;
        _this.maxBufferSize = maxBufferSize;
        _this.scheduler = scheduler;
        _this.contexts = [];
        var context = _this.openContext();
        _this.timespanOnly = bufferCreationInterval == null || bufferCreationInterval < 0;
        if (_this.timespanOnly) {
            var timeSpanOnlyState = { subscriber: _this, context: context, bufferTimeSpan: bufferTimeSpan };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
        else {
            var closeState = { subscriber: _this, context: context };
            var creationState = { bufferTimeSpan: bufferTimeSpan, bufferCreationInterval: bufferCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchBufferCreation, bufferCreationInterval, creationState));
        }
        return _this;
    }
    BufferTimeSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        var filledBufferContext;
        for (var i = 0; i < len; i++) {
            var context_1 = contexts[i];
            var buffer = context_1.buffer;
            buffer.push(value);
            if (buffer.length == this.maxBufferSize) {
                filledBufferContext = context_1;
            }
        }
        if (filledBufferContext) {
            this.onBufferFull(filledBufferContext);
        }
    };
    BufferTimeSubscriber.prototype._error = function (err) {
        this.contexts.length = 0;
        _super.prototype._error.call(this, err);
    };
    BufferTimeSubscriber.prototype._complete = function () {
        var _a = this, contexts = _a.contexts, destination = _a.destination;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            destination.next(context_2.buffer);
        }
        _super.prototype._complete.call(this);
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    BufferTimeSubscriber.prototype._unsubscribe = function () {
        this.contexts = null;
    };
    BufferTimeSubscriber.prototype.onBufferFull = function (context) {
        this.closeContext(context);
        var closeAction = context.closeAction;
        closeAction.unsubscribe();
        this.remove(closeAction);
        if (!this.closed && this.timespanOnly) {
            context = this.openContext();
            var bufferTimeSpan = this.bufferTimeSpan;
            var timeSpanOnlyState = { subscriber: this, context: context, bufferTimeSpan: bufferTimeSpan };
            this.add(context.closeAction = this.scheduler.schedule(dispatchBufferTimeSpanOnly, bufferTimeSpan, timeSpanOnlyState));
        }
    };
    BufferTimeSubscriber.prototype.openContext = function () {
        var context = new Context();
        this.contexts.push(context);
        return context;
    };
    BufferTimeSubscriber.prototype.closeContext = function (context) {
        this.destination.next(context.buffer);
        var contexts = this.contexts;
        var spliceIndex = contexts ? contexts.indexOf(context) : -1;
        if (spliceIndex >= 0) {
            contexts.splice(contexts.indexOf(context), 1);
        }
    };
    return BufferTimeSubscriber;
}(Subscriber));
function dispatchBufferTimeSpanOnly(state) {
    var subscriber = state.subscriber;
    var prevContext = state.context;
    if (prevContext) {
        subscriber.closeContext(prevContext);
    }
    if (!subscriber.closed) {
        state.context = subscriber.openContext();
        state.context.closeAction = this.schedule(state, state.bufferTimeSpan);
    }
}
function dispatchBufferCreation(state) {
    var bufferCreationInterval = state.bufferCreationInterval, bufferTimeSpan = state.bufferTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler;
    var context = subscriber.openContext();
    var action = this;
    if (!subscriber.closed) {
        subscriber.add(context.closeAction = scheduler.schedule(dispatchBufferClose, bufferTimeSpan, { subscriber: subscriber, context: context }));
        action.schedule(state, bufferCreationInterval);
    }
}
function dispatchBufferClose(arg) {
    var subscriber = arg.subscriber, context = arg.context;
    subscriber.closeContext(context);
}

/** PURE_IMPORTS_START tslib,_Subscription,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */
/**
 * Buffers the source Observable values starting from an emission from
 * `openings` and ending when the output of `closingSelector` emits.
 *
 * <span class="informal">Collects values from the past as an array. Starts
 * collecting only when `opening` emits, and calls the `closingSelector`
 * function to get an Observable that tells when to close the buffer.</span>
 *
 * <img src="./img/bufferToggle.png" width="100%">
 *
 * Buffers values from the source by opening the buffer via signals from an
 * Observable provided to `openings`, and closing and sending the buffers when
 * a Subscribable or Promise returned by the `closingSelector` function emits.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var buffered = clicks.bufferToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferWhen}
 * @see {@link windowToggle}
 *
 * @param {SubscribableOrPromise<O>} openings A Subscribable or Promise of notifications to start new
 * buffers.
 * @param {function(value: O): SubscribableOrPromise} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns a Subscribable or Promise,
 * which, when it emits, signals that the associated buffer should be emitted
 * and cleared.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferToggle
 * @owner Observable
 */

var BufferToggleOperator = /*@__PURE__*/ (function () {
    function BufferToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    BufferToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return BufferToggleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferToggleSubscriber, _super);
    function BufferToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(subscribeToResult(_this, openings));
        return _this;
    }
    BufferToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        var len = contexts.length;
        for (var i = 0; i < len; i++) {
            contexts[i].buffer.push(value);
        }
    };
    BufferToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_1 = contexts.shift();
            context_1.subscription.unsubscribe();
            context_1.buffer = null;
            context_1.subscription = null;
        }
        this.contexts = null;
        _super.prototype._error.call(this, err);
    };
    BufferToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        while (contexts.length > 0) {
            var context_2 = contexts.shift();
            this.destination.next(context_2.buffer);
            context_2.subscription.unsubscribe();
            context_2.buffer = null;
            context_2.subscription = null;
        }
        this.contexts = null;
        _super.prototype._complete.call(this);
    };
    BufferToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        outerValue ? this.closeBuffer(outerValue) : this.openBuffer(innerValue);
    };
    BufferToggleSubscriber.prototype.notifyComplete = function (innerSub) {
        this.closeBuffer(innerSub.context);
    };
    BufferToggleSubscriber.prototype.openBuffer = function (value) {
        try {
            var closingSelector = this.closingSelector;
            var closingNotifier = closingSelector.call(this, value);
            if (closingNotifier) {
                this.trySubscribe(closingNotifier);
            }
        }
        catch (err) {
            this._error(err);
        }
    };
    BufferToggleSubscriber.prototype.closeBuffer = function (context) {
        var contexts = this.contexts;
        if (contexts && context) {
            var buffer = context.buffer, subscription = context.subscription;
            this.destination.next(buffer);
            contexts.splice(contexts.indexOf(context), 1);
            this.remove(subscription);
            subscription.unsubscribe();
        }
    };
    BufferToggleSubscriber.prototype.trySubscribe = function (closingNotifier) {
        var contexts = this.contexts;
        var buffer = [];
        var subscription = new Subscription();
        var context = { buffer: buffer, subscription: subscription };
        contexts.push(context);
        var innerSubscription = subscribeToResult(this, closingNotifier, context);
        if (!innerSubscription || innerSubscription.closed) {
            this.closeBuffer(context);
        }
        else {
            innerSubscription.context = context;
            this.add(innerSubscription);
            subscription.add(innerSubscription);
        }
    };
    return BufferToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Buffers the source Observable values, using a factory function of closing
 * Observables to determine when to close, emit, and reset the buffer.
 *
 * <span class="informal">Collects values from the past as an array. When it
 * starts collecting values, it calls a function that returns an Observable that
 * tells when to close the buffer and restart collecting.</span>
 *
 * <img src="./img/bufferWhen.png" width="100%">
 *
 * Opens a buffer immediately, then closes the buffer when the observable
 * returned by calling `closingSelector` function emits a value. When it closes
 * the buffer, it immediately opens a new buffer and repeats the process.
 *
 * @example <caption>Emit an array of the last clicks every [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var buffered = clicks.bufferWhen(() =>
 *   Rx.Observable.interval(1000 + Math.random() * 4000)
 * );
 * buffered.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 * @see {@link bufferTime}
 * @see {@link bufferToggle}
 * @see {@link windowWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals buffer closure.
 * @return {Observable<T[]>} An observable of arrays of buffered values.
 * @method bufferWhen
 * @owner Observable
 */

var BufferWhenOperator = /*@__PURE__*/ (function () {
    function BufferWhenOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    BufferWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new BufferWhenSubscriber(subscriber, this.closingSelector));
    };
    return BufferWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var BufferWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(BufferWhenSubscriber, _super);
    function BufferWhenSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.closingSelector = closingSelector;
        _this.subscribing = false;
        _this.openBuffer();
        return _this;
    }
    BufferWhenSubscriber.prototype._next = function (value) {
        this.buffer.push(value);
    };
    BufferWhenSubscriber.prototype._complete = function () {
        var buffer = this.buffer;
        if (buffer) {
            this.destination.next(buffer);
        }
        _super.prototype._complete.call(this);
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    BufferWhenSubscriber.prototype._unsubscribe = function () {
        this.buffer = null;
        this.subscribing = false;
    };
    BufferWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openBuffer();
    };
    BufferWhenSubscriber.prototype.notifyComplete = function () {
        if (this.subscribing) {
            this.complete();
        }
        else {
            this.openBuffer();
        }
    };
    BufferWhenSubscriber.prototype.openBuffer = function () {
        var closingSubscription = this.closingSubscription;
        if (closingSubscription) {
            this.remove(closingSubscription);
            closingSubscription.unsubscribe();
        }
        var buffer = this.buffer;
        if (this.buffer) {
            this.destination.next(buffer);
        }
        this.buffer = [];
        var closingNotifier = tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject) {
            this.error(errorObject.e);
        }
        else {
            closingSubscription = new Subscription();
            this.closingSubscription = closingSubscription;
            this.add(closingSubscription);
            this.subscribing = true;
            closingSubscription.add(subscribeToResult(this, closingNotifier));
            this.subscribing = false;
        }
    };
    return BufferWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

var CatchOperator = /*@__PURE__*/ (function () {
    function CatchOperator(selector) {
        this.selector = selector;
    }
    CatchOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CatchSubscriber(subscriber, this.selector, this.caught));
    };
    return CatchOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CatchSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CatchSubscriber, _super);
    function CatchSubscriber(destination, selector, caught) {
        var _this = _super.call(this, destination) || this;
        _this.selector = selector;
        _this.caught = caught;
        return _this;
    }
    // NOTE: overriding `error` instead of `_error` because we don't want
    // to have this flag this subscriber as `isStopped`. We can mimic the
    // behavior of the RetrySubscriber (from the `retry` operator), where
    // we unsubscribe from our source chain, reset our Subscriber flags,
    // then subscribe to the selector result.
    CatchSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var result = void 0;
            try {
                result = this.selector(err, this.caught);
            }
            catch (err2) {
                _super.prototype.error.call(this, err2);
                return;
            }
            this._unsubscribeAndRecycle();
            this.add(subscribeToResult(this, result));
        }
    };
    return CatchSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_combineLatest PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_isArray,_observable_combineLatest,_observable_from PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * @deprecated Deprecated in favor of static combineLatest.
 */

/** PURE_IMPORTS_START _observable_concat PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * @deprecated Deprecated in favor of static concat.
 */

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, in a serialized fashion waiting for each one to complete before
 * merging the next.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link concatAll}.</span>
 *
 * <img src="./img/concatMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each new inner Observable is
 * concatenated with the previous inner Observable.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMap` is equivalent to `mergeMap` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMap(ev => Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMapTo}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking values from each projected inner
 * Observable sequentially.
 * @method concatMap
 * @owner Observable
 */
function concatMap(project, resultSelector) {
    return mergeMap(project, resultSelector, 1);
}

/** PURE_IMPORTS_START _concatMap PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in a serialized fashion on the output Observable.
 *
 * <span class="informal">It's like {@link concatMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/concatMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. Each new `innerObservable`
 * instance emitted on the output Observable is concatenated with the previous
 * `innerObservable` instance.
 *
 * __Warning:__ if source values arrive endlessly and faster than their
 * corresponding inner Observables can complete, it will result in memory issues
 * as inner Observables amass in an unbounded buffer waiting for their turn to
 * be subscribed to.
 *
 * Note: `concatMapTo` is equivalent to `mergeMapTo` with concurrency parameter
 * set to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.concatMapTo(Rx.Observable.interval(1000).take(4));
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link concat}
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link mergeMapTo}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @return {Observable} An observable of values merged together by joining the
 * passed observable with itself, one after the other, for each value emitted
 * from the source.
 * @method concatMapTo
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Counts the number of emissions on the source and emits that number when the
 * source completes.
 *
 * <span class="informal">Tells how many values were emitted, when the source
 * completes.</span>
 *
 * <img src="./img/count.png" width="100%">
 *
 * `count` transforms an Observable that emits values into an Observable that
 * emits a single value that represents the number of values emitted by the
 * source Observable. If the source Observable terminates with an error, `count`
 * will pass this error notification along without emitting a value first. If
 * the source Observable does not terminate at all, `count` will neither emit
 * a value nor terminate. This operator takes an optional `predicate` function
 * as argument, in which case the output emission will represent the number of
 * source values that matched `true` with the `predicate`.
 *
 * @example <caption>Counts how many seconds have passed before the first click happened</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var secondsBeforeClick = seconds.takeUntil(clicks);
 * var result = secondsBeforeClick.count();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Counts how many odd numbers are there between 1 and 7</caption>
 * var numbers = Rx.Observable.range(1, 7);
 * var result = numbers.count(i => i % 2 === 1);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 4
 *
 * @see {@link max}
 * @see {@link min}
 * @see {@link reduce}
 *
 * @param {function(value: T, i: number, source: Observable<T>): boolean} [predicate] A
 * boolean function to select what values are to be counted. It is provided with
 * arguments of:
 * - `value`: the value from the source Observable.
 * - `index`: the (zero-based) "index" of the value from the source Observable.
 * - `source`: the source Observable instance itself.
 * @return {Observable} An Observable of one number that represents the count as
 * described above.
 * @method count
 * @owner Observable
 */

var CountOperator = /*@__PURE__*/ (function () {
    function CountOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    CountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CountSubscriber(subscriber, this.predicate, this.source));
    };
    return CountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(CountSubscriber, _super);
    function CountSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.count = 0;
        _this.index = 0;
        return _this;
    }
    CountSubscriber.prototype._next = function (value) {
        if (this.predicate) {
            this._tryPredicate(value);
        }
        else {
            this.count++;
        }
    };
    CountSubscriber.prototype._tryPredicate = function (value) {
        var result;
        try {
            result = this.predicate(value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.count++;
        }
    };
    CountSubscriber.prototype._complete = function () {
        this.destination.next(this.count);
        this.destination.complete();
    };
    return CountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Emits a value from the source Observable only after a particular time span
 * determined by another Observable has passed without another source emission.
 *
 * <span class="informal">It's like {@link debounceTime}, but the time span of
 * emission silence is determined by a second Observable.</span>
 *
 * <img src="./img/debounce.png" width="100%">
 *
 * `debounce` delays values emitted by the source Observable, but drops previous
 * pending delayed emissions if a new value arrives on the source Observable.
 * This operator keeps track of the most recent value from the source
 * Observable, and spawns a duration Observable by calling the
 * `durationSelector` function. The value is emitted only when the duration
 * Observable emits a value or completes, and if no other value was emitted on
 * the source Observable since the duration Observable was spawned. If a new
 * value appears before the duration Observable emits, the previous value will
 * be dropped and will not be emitted on the output Observable.
 *
 * Like {@link debounceTime}, this is a rate-limiting operator, and also a
 * delay-like operator since output emissions do not necessarily occur at the
 * same time as they did on the source Observable.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounce(() => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 * @see {@link throttle}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the timeout
 * duration for each source value, returned as an Observable or a Promise.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified duration Observable returned by
 * `durationSelector`, and may drop some values if they occur too frequently.
 * @method debounce
 * @owner Observable
 */

var DebounceOperator = /*@__PURE__*/ (function () {
    function DebounceOperator(durationSelector) {
        this.durationSelector = durationSelector;
    }
    DebounceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceSubscriber(subscriber, this.durationSelector));
    };
    return DebounceOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceSubscriber, _super);
    function DebounceSubscriber(destination, durationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.durationSelector = durationSelector;
        _this.hasValue = false;
        _this.durationSubscription = null;
        return _this;
    }
    DebounceSubscriber.prototype._next = function (value) {
        try {
            var result = this.durationSelector.call(this, value);
            if (result) {
                this._tryNext(value, result);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DebounceSubscriber.prototype._complete = function () {
        this.emitValue();
        this.destination.complete();
    };
    DebounceSubscriber.prototype._tryNext = function (value, duration) {
        var subscription = this.durationSubscription;
        this.value = value;
        this.hasValue = true;
        if (subscription) {
            subscription.unsubscribe();
            this.remove(subscription);
        }
        subscription = subscribeToResult(this, duration);
        if (subscription && !subscription.closed) {
            this.add(this.durationSubscription = subscription);
        }
    };
    DebounceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    DebounceSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    DebounceSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            var value = this.value;
            var subscription = this.durationSubscription;
            if (subscription) {
                this.durationSubscription = null;
                subscription.unsubscribe();
                this.remove(subscription);
            }
            // This must be done *before* passing the value
            // along to the destination because it's possible for
            // the value to synchronously re-enter this operator
            // recursively if the duration selector Observable
            // emits synchronously
            this.value = null;
            this.hasValue = false;
            _super.prototype._next.call(this, value);
        }
    };
    return DebounceSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
/**
 * Emits a value from the source Observable only after a particular time span
 * has passed without another source emission.
 *
 * <span class="informal">It's like {@link delay}, but passes only the most
 * recent value from each burst of emissions.</span>
 *
 * <img src="./img/debounceTime.png" width="100%">
 *
 * `debounceTime` delays values emitted by the source Observable, but drops
 * previous pending delayed emissions if a new value arrives on the source
 * Observable. This operator keeps track of the most recent value from the
 * source Observable, and emits that only when `dueTime` enough time has passed
 * without any other value appearing on the source Observable. If a new value
 * appears before `dueTime` silence occurs, the previous value will be dropped
 * and will not be emitted on the output Observable.
 *
 * This is a rate-limiting operator, because it is impossible for more than one
 * value to be emitted in any time window of duration `dueTime`, but it is also
 * a delay-like operator since output emissions do not occur at the same time as
 * they did on the source Observable. Optionally takes a {@link IScheduler} for
 * managing timers.
 *
 * @example <caption>Emit the most recent click after a burst of clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.debounceTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounce}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttleTime}
 *
 * @param {number} dueTime The timeout duration in milliseconds (or the time
 * unit determined internally by the optional `scheduler`) for the window of
 * time required to wait for emission silence before emitting the most recent
 * source value.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the timeout for each value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified `dueTime`, and may drop some values if they occur
 * too frequently.
 * @method debounceTime
 * @owner Observable
 */

var DebounceTimeOperator = /*@__PURE__*/ (function () {
    function DebounceTimeOperator(dueTime, scheduler) {
        this.dueTime = dueTime;
        this.scheduler = scheduler;
    }
    DebounceTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DebounceTimeSubscriber(subscriber, this.dueTime, this.scheduler));
    };
    return DebounceTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DebounceTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DebounceTimeSubscriber, _super);
    function DebounceTimeSubscriber(destination, dueTime, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.dueTime = dueTime;
        _this.scheduler = scheduler;
        _this.debouncedSubscription = null;
        _this.lastValue = null;
        _this.hasValue = false;
        return _this;
    }
    DebounceTimeSubscriber.prototype._next = function (value) {
        this.clearDebounce();
        this.lastValue = value;
        this.hasValue = true;
        this.add(this.debouncedSubscription = this.scheduler.schedule(dispatchNext$2, this.dueTime, this));
    };
    DebounceTimeSubscriber.prototype._complete = function () {
        this.debouncedNext();
        this.destination.complete();
    };
    DebounceTimeSubscriber.prototype.debouncedNext = function () {
        this.clearDebounce();
        if (this.hasValue) {
            var lastValue = this.lastValue;
            // This must be done *before* passing the value
            // along to the destination because it's possible for
            // the value to synchronously re-enter this operator
            // recursively when scheduled with things like
            // VirtualScheduler/TestScheduler.
            this.lastValue = null;
            this.hasValue = false;
            this.destination.next(lastValue);
        }
    };
    DebounceTimeSubscriber.prototype.clearDebounce = function () {
        var debouncedSubscription = this.debouncedSubscription;
        if (debouncedSubscription !== null) {
            this.remove(debouncedSubscription);
            debouncedSubscription.unsubscribe();
            this.debouncedSubscription = null;
        }
    };
    return DebounceTimeSubscriber;
}(Subscriber));
function dispatchNext$2(subscriber) {
    subscriber.debouncedNext();
}

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Emits a given value if the source Observable completes without emitting any
 * `next` value, otherwise mirrors the source Observable.
 *
 * <span class="informal">If the source Observable turns out to be empty, then
 * this operator will emit a default value.</span>
 *
 * <img src="./img/defaultIfEmpty.png" width="100%">
 *
 * `defaultIfEmpty` emits the values emitted by the source Observable or a
 * specified default value if the source Observable is empty (completes without
 * having emitted any `next` value).
 *
 * @example <caption>If no clicks happen in 5 seconds, then emit "no clicks"</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksBeforeFive = clicks.takeUntil(Rx.Observable.interval(5000));
 * var result = clicksBeforeFive.defaultIfEmpty('no clicks');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link empty}
 * @see {@link last}
 *
 * @param {any} [defaultValue=null] The default value used if the source
 * Observable is empty.
 * @return {Observable} An Observable that emits either the specified
 * `defaultValue` if the source Observable emits no items, or the values emitted
 * by the source Observable.
 * @method defaultIfEmpty
 * @owner Observable
 */

var DefaultIfEmptyOperator = /*@__PURE__*/ (function () {
    function DefaultIfEmptyOperator(defaultValue) {
        this.defaultValue = defaultValue;
    }
    DefaultIfEmptyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DefaultIfEmptySubscriber(subscriber, this.defaultValue));
    };
    return DefaultIfEmptyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DefaultIfEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DefaultIfEmptySubscriber, _super);
    function DefaultIfEmptySubscriber(destination, defaultValue) {
        var _this = _super.call(this, destination) || this;
        _this.defaultValue = defaultValue;
        _this.isEmpty = true;
        return _this;
    }
    DefaultIfEmptySubscriber.prototype._next = function (value) {
        this.isEmpty = false;
        this.destination.next(value);
    };
    DefaultIfEmptySubscriber.prototype._complete = function () {
        if (this.isEmpty) {
            this.destination.next(this.defaultValue);
        }
        this.destination.complete();
    };
    return DefaultIfEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_Subscriber,_Notification PURE_IMPORTS_END */
/**
 * Delays the emission of items from the source Observable by a given timeout or
 * until a given Date.
 *
 * <span class="informal">Time shifts each item by some specified amount of
 * milliseconds.</span>
 *
 * <img src="./img/delay.png" width="100%">
 *
 * If the delay argument is a Number, this operator time shifts the source
 * Observable by that amount of time expressed in milliseconds. The relative
 * time intervals between the values are preserved.
 *
 * If the delay argument is a Date, this operator time shifts the start of the
 * Observable execution until the given date occurs.
 *
 * @example <caption>Delay each click by one second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delay(1000); // each click emitted after 1 second
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @example <caption>Delay all clicks until a future date happens</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var date = new Date('March 15, 2050 12:00:00'); // in the future
 * var delayedClicks = clicks.delay(date); // click emitted only after that date
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounceTime}
 * @see {@link delayWhen}
 *
 * @param {number|Date} delay The delay duration in milliseconds (a `number`) or
 * a `Date` until which the emission of the source items is delayed.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for
 * managing the timers that handle the time-shift for each item.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by the specified timeout or Date.
 * @method delay
 * @owner Observable
 */

var DelayOperator = /*@__PURE__*/ (function () {
    function DelayOperator(delay, scheduler) {
        this.delay = delay;
        this.scheduler = scheduler;
    }
    DelayOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelaySubscriber(subscriber, this.delay, this.scheduler));
    };
    return DelayOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelaySubscriber, _super);
    function DelaySubscriber(destination, delay, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.delay = delay;
        _this.scheduler = scheduler;
        _this.queue = [];
        _this.active = false;
        _this.errored = false;
        return _this;
    }
    DelaySubscriber.dispatch = function (state) {
        var source = state.source;
        var queue = source.queue;
        var scheduler = state.scheduler;
        var destination = state.destination;
        while (queue.length > 0 && (queue[0].time - scheduler.now()) <= 0) {
            queue.shift().notification.observe(destination);
        }
        if (queue.length > 0) {
            var delay_1 = Math.max(0, queue[0].time - scheduler.now());
            this.schedule(state, delay_1);
        }
        else {
            this.unsubscribe();
            source.active = false;
        }
    };
    DelaySubscriber.prototype._schedule = function (scheduler) {
        this.active = true;
        this.add(scheduler.schedule(DelaySubscriber.dispatch, this.delay, {
            source: this, destination: this.destination, scheduler: scheduler
        }));
    };
    DelaySubscriber.prototype.scheduleNotification = function (notification) {
        if (this.errored === true) {
            return;
        }
        var scheduler = this.scheduler;
        var message = new DelayMessage(scheduler.now() + this.delay, notification);
        this.queue.push(message);
        if (this.active === false) {
            this._schedule(scheduler);
        }
    };
    DelaySubscriber.prototype._next = function (value) {
        this.scheduleNotification(Notification.createNext(value));
    };
    DelaySubscriber.prototype._error = function (err) {
        this.errored = true;
        this.queue = [];
        this.destination.error(err);
    };
    DelaySubscriber.prototype._complete = function () {
        this.scheduleNotification(Notification.createComplete());
    };
    return DelaySubscriber;
}(Subscriber));
var DelayMessage = /*@__PURE__*/ (function () {
    function DelayMessage(time, notification) {
        this.time = time;
        this.notification = notification;
    }
    return DelayMessage;
}());

/** PURE_IMPORTS_START tslib,_Subscriber,_Observable,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Delays the emission of items from the source Observable by a given time span
 * determined by the emissions of another Observable.
 *
 * <span class="informal">It's like {@link delay}, but the time span of the
 * delay duration is determined by a second Observable.</span>
 *
 * <img src="./img/delayWhen.png" width="100%">
 *
 * `delayWhen` time shifts each emitted value from the source Observable by a
 * time span determined by another Observable. When the source emits a value,
 * the `delayDurationSelector` function is called with the source value as
 * argument, and should return an Observable, called the "duration" Observable.
 * The source value is emitted on the output Observable only when the duration
 * Observable emits a value or completes.
 *
 * Optionally, `delayWhen` takes a second argument, `subscriptionDelay`, which
 * is an Observable. When `subscriptionDelay` emits its first value or
 * completes, the source Observable is subscribed to and starts behaving like
 * described in the previous paragraph. If `subscriptionDelay` is not provided,
 * `delayWhen` will subscribe to the source Observable as soon as the output
 * Observable is subscribed.
 *
 * @example <caption>Delay each click by a random amount of time, between 0 and 5 seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var delayedClicks = clicks.delayWhen(event =>
 *   Rx.Observable.interval(Math.random() * 5000)
 * );
 * delayedClicks.subscribe(x => console.log(x));
 *
 * @see {@link debounce}
 * @see {@link delay}
 *
 * @param {function(value: T): Observable} delayDurationSelector A function that
 * returns an Observable for each value emitted by the source Observable, which
 * is then used to delay the emission of that item on the output Observable
 * until the Observable returned from this function emits a value.
 * @param {Observable} subscriptionDelay An Observable that triggers the
 * subscription to the source Observable once it emits any value.
 * @return {Observable} An Observable that delays the emissions of the source
 * Observable by an amount of time specified by the Observable returned by
 * `delayDurationSelector`.
 * @method delayWhen
 * @owner Observable
 */

var DelayWhenOperator = /*@__PURE__*/ (function () {
    function DelayWhenOperator(delayDurationSelector) {
        this.delayDurationSelector = delayDurationSelector;
    }
    DelayWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DelayWhenSubscriber(subscriber, this.delayDurationSelector));
    };
    return DelayWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DelayWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DelayWhenSubscriber, _super);
    function DelayWhenSubscriber(destination, delayDurationSelector) {
        var _this = _super.call(this, destination) || this;
        _this.delayDurationSelector = delayDurationSelector;
        _this.completed = false;
        _this.delayNotifierSubscriptions = [];
        _this.values = [];
        return _this;
    }
    DelayWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(outerValue);
        this.removeSubscription(innerSub);
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DelayWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        var value = this.removeSubscription(innerSub);
        if (value) {
            this.destination.next(value);
        }
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype._next = function (value) {
        try {
            var delayNotifier = this.delayDurationSelector(value);
            if (delayNotifier) {
                this.tryDelay(delayNotifier, value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    DelayWhenSubscriber.prototype._complete = function () {
        this.completed = true;
        this.tryComplete();
    };
    DelayWhenSubscriber.prototype.removeSubscription = function (subscription) {
        subscription.unsubscribe();
        var subscriptionIdx = this.delayNotifierSubscriptions.indexOf(subscription);
        var value = null;
        if (subscriptionIdx !== -1) {
            value = this.values[subscriptionIdx];
            this.delayNotifierSubscriptions.splice(subscriptionIdx, 1);
            this.values.splice(subscriptionIdx, 1);
        }
        return value;
    };
    DelayWhenSubscriber.prototype.tryDelay = function (delayNotifier, value) {
        var notifierSubscription = subscribeToResult(this, delayNotifier, value);
        if (notifierSubscription && !notifierSubscription.closed) {
            this.add(notifierSubscription);
            this.delayNotifierSubscriptions.push(notifierSubscription);
        }
        this.values.push(value);
    };
    DelayWhenSubscriber.prototype.tryComplete = function () {
        if (this.completed && this.delayNotifierSubscriptions.length === 0) {
            this.destination.complete();
        }
    };
    return DelayWhenSubscriber;
}(OuterSubscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelayObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelayObservable, _super);
    function SubscriptionDelayObservable(source, subscriptionDelay) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subscriptionDelay = subscriptionDelay;
        return _this;
    }
    /** @deprecated This is an internal implementation detail, do not use. */
    SubscriptionDelayObservable.prototype._subscribe = function (subscriber) {
        this.subscriptionDelay.subscribe(new SubscriptionDelaySubscriber(subscriber, this.source));
    };
    return SubscriptionDelayObservable;
}(Observable));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubscriptionDelaySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SubscriptionDelaySubscriber, _super);
    function SubscriptionDelaySubscriber(parent, source) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.source = source;
        _this.sourceSubscribed = false;
        return _this;
    }
    SubscriptionDelaySubscriber.prototype._next = function (unused) {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype._error = function (err) {
        this.unsubscribe();
        this.parent.error(err);
    };
    SubscriptionDelaySubscriber.prototype._complete = function () {
        this.subscribeToSource();
    };
    SubscriptionDelaySubscriber.prototype.subscribeToSource = function () {
        if (!this.sourceSubscribed) {
            this.sourceSubscribed = true;
            this.unsubscribe();
            this.source.subscribe(this.parent);
        }
    };
    return SubscriptionDelaySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Converts an Observable of {@link Notification} objects into the emissions
 * that they represent.
 *
 * <span class="informal">Unwraps {@link Notification} objects as actual `next`,
 * `error` and `complete` emissions. The opposite of {@link materialize}.</span>
 *
 * <img src="./img/dematerialize.png" width="100%">
 *
 * `dematerialize` is assumed to operate an Observable that only emits
 * {@link Notification} objects as `next` emissions, and does not emit any
 * `error`. Such Observable is the output of a `materialize` operation. Those
 * notifications are then unwrapped using the metadata they contain, and emitted
 * as `next`, `error`, and `complete` on the output Observable.
 *
 * Use this operator in conjunction with {@link materialize}.
 *
 * @example <caption>Convert an Observable of Notifications to an actual Observable</caption>
 * var notifA = new Rx.Notification('N', 'A');
 * var notifB = new Rx.Notification('N', 'B');
 * var notifE = new Rx.Notification('E', void 0,
 *   new TypeError('x.toUpperCase is not a function')
 * );
 * var materialized = Rx.Observable.of(notifA, notifB, notifE);
 * var upperCase = materialized.dematerialize();
 * upperCase.subscribe(x => console.log(x), e => console.error(e));
 *
 * // Results in:
 * // A
 * // B
 * // TypeError: x.toUpperCase is not a function
 *
 * @see {@link Notification}
 * @see {@link materialize}
 *
 * @return {Observable} An Observable that emits items and notifications
 * embedded in Notification objects emitted by the source Observable.
 * @method dematerialize
 * @owner Observable
 */

var DeMaterializeOperator = /*@__PURE__*/ (function () {
    function DeMaterializeOperator() {
    }
    DeMaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DeMaterializeSubscriber(subscriber));
    };
    return DeMaterializeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DeMaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DeMaterializeSubscriber, _super);
    function DeMaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    DeMaterializeSubscriber.prototype._next = function (value) {
        value.observe(this.destination);
    };
    return DeMaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from previous items.
 *
 * If a keySelector function is provided, then it will project each value from the source observable into a new value that it will
 * check for equality with previously projected values. If a keySelector function is not provided, it will use each value from the
 * source observable directly with an equality check against previous values.
 *
 * In JavaScript runtimes that support `Set`, this operator will use a `Set` to improve performance of the distinct value checking.
 *
 * In other runtimes, this operator will use a minimal implementation of `Set` that relies on an `Array` and `indexOf` under the
 * hood, so performance will degrade as more values are checked for distinction. Even in newer browsers, a long-running `distinct`
 * use might result in memory leaks. To help alleviate this in some scenarios, an optional `flushes` parameter is also provided so
 * that the internal `Set` can be "flushed", basically clearing it of values.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 2, 3, 4, 3, 2, 1)
 *   .distinct()
 *   .subscribe(x => console.log(x)); // 1, 2, 3, 4
 *
 * @example <caption>An example using a keySelector function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     .distinct((p: Person) => p.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 *
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [keySelector] Optional function to select which value you want to check as distinct.
 * @param {Observable} [flushes] Optional Observable for flushing the internal HashSet of the operator.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinct
 * @owner Observable
 */

var DistinctOperator = /*@__PURE__*/ (function () {
    function DistinctOperator(keySelector, flushes) {
        this.keySelector = keySelector;
        this.flushes = flushes;
    }
    DistinctOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctSubscriber(subscriber, this.keySelector, this.flushes));
    };
    return DistinctOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctSubscriber, _super);
    function DistinctSubscriber(destination, keySelector, flushes) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.values = new Set();
        if (flushes) {
            _this.add(subscribeToResult(_this, flushes));
        }
        return _this;
    }
    DistinctSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values.clear();
    };
    DistinctSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    DistinctSubscriber.prototype._next = function (value) {
        if (this.keySelector) {
            this._useKeySelector(value);
        }
        else {
            this._finalizeNext(value, value);
        }
    };
    DistinctSubscriber.prototype._useKeySelector = function (value) {
        var key;
        var destination = this.destination;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this._finalizeNext(key, value);
    };
    DistinctSubscriber.prototype._finalizeNext = function (key, value) {
        var values = this.values;
        if (!values.has(key)) {
            values.add(key);
            this.destination.next(value);
        }
    };
    return DistinctSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>A simple example with numbers</caption>
 * Observable.of(1, 1, 2, 2, 2, 1, 1, 2, 3, 3, 4)
 *   .distinctUntilChanged()
 *   .subscribe(x => console.log(x)); // 1, 2, 1, 2, 3, 4
 *
 * @example <caption>An example using a compare function</caption>
 * interface Person {
 *    age: number,
 *    name: string
 * }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'})
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilChanged((p: Person, q: Person) => p.name === q.name)
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilKeyChanged}
 *
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values.
 * @method distinctUntilChanged
 * @owner Observable
 */

var DistinctUntilChangedOperator = /*@__PURE__*/ (function () {
    function DistinctUntilChangedOperator(compare, keySelector) {
        this.compare = compare;
        this.keySelector = keySelector;
    }
    DistinctUntilChangedOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new DistinctUntilChangedSubscriber(subscriber, this.compare, this.keySelector));
    };
    return DistinctUntilChangedOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var DistinctUntilChangedSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(DistinctUntilChangedSubscriber, _super);
    function DistinctUntilChangedSubscriber(destination, compare, keySelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.hasKey = false;
        if (typeof compare === 'function') {
            _this.compare = compare;
        }
        return _this;
    }
    DistinctUntilChangedSubscriber.prototype.compare = function (x, y) {
        return x === y;
    };
    DistinctUntilChangedSubscriber.prototype._next = function (value) {
        var keySelector = this.keySelector;
        var key = value;
        if (keySelector) {
            key = tryCatch(this.keySelector)(value);
            if (key === errorObject) {
                return this.destination.error(errorObject.e);
            }
        }
        var result = false;
        if (this.hasKey) {
            result = tryCatch(this.compare)(this.key, key);
            if (result === errorObject) {
                return this.destination.error(errorObject.e);
            }
        }
        else {
            this.hasKey = true;
        }
        if (Boolean(result) === false) {
            this.key = key;
            this.destination.next(value);
        }
    };
    return DistinctUntilChangedSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _distinctUntilChanged PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits all items emitted by the source Observable that are distinct by comparison from the previous item,
 * using a property accessed by using the key provided to check if the two items are distinct.
 *
 * If a comparator function is provided, then it will be called for each item to test for whether or not that value should be emitted.
 *
 * If a comparator function is not provided, an equality check is used by default.
 *
 * @example <caption>An example comparing the name of persons</caption>
 *
 *  interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo'},
 *     { age: 6, name: 'Foo'})
 *     .distinctUntilKeyChanged('name')
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo' }
 *
 * @example <caption>An example comparing the first letters of the name</caption>
 *
 * interface Person {
 *     age: number,
 *     name: string
 *  }
 *
 * Observable.of<Person>(
 *     { age: 4, name: 'Foo1'},
 *     { age: 7, name: 'Bar'},
 *     { age: 5, name: 'Foo2'},
 *     { age: 6, name: 'Foo3'})
 *     .distinctUntilKeyChanged('name', (x: string, y: string) => x.substring(0, 3) === y.substring(0, 3))
 *     .subscribe(x => console.log(x));
 *
 * // displays:
 * // { age: 4, name: 'Foo1' }
 * // { age: 7, name: 'Bar' }
 * // { age: 5, name: 'Foo2' }
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 *
 * @param {string} key String key for object property lookup on each item.
 * @param {function} [compare] Optional comparison function called to test if an item is distinct from the previous item in the source.
 * @return {Observable} An Observable that emits items from the source Observable with distinct values based on the key specified.
 * @method distinctUntilKeyChanged
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Filter items emitted by the source Observable by only emitting those that
 * satisfy a specified predicate.
 *
 * <span class="informal">Like
 * [Array.prototype.filter()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter),
 * it only emits a value from the source if it passes a criterion function.</span>
 *
 * <img src="./img/filter.png" width="100%">
 *
 * Similar to the well-known `Array.prototype.filter` method, this operator
 * takes values from the source Observable, passes them through a `predicate`
 * function and only emits those values that yielded `true`.
 *
 * @example <caption>Emit only click events whose target was a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var clicksOnDivs = clicks.filter(ev => ev.target.tagName === 'DIV');
 * clicksOnDivs.subscribe(x => console.log(x));
 *
 * @see {@link distinct}
 * @see {@link distinctUntilChanged}
 * @see {@link distinctUntilKeyChanged}
 * @see {@link ignoreElements}
 * @see {@link partition}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted, if `false` the value is not passed to the output
 * Observable. The `index` parameter is the number `i` for the i-th source
 * emission that has happened since the subscription, starting from the number
 * `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of values from the source that were
 * allowed by the `predicate` function.
 * @method filter
 * @owner Observable
 */
function filter(predicate, thisArg) {
    return function filterOperatorFunction(source) {
        return source.lift(new FilterOperator(predicate, thisArg));
    };
}
var FilterOperator = /*@__PURE__*/ (function () {
    function FilterOperator(predicate, thisArg) {
        this.predicate = predicate;
        this.thisArg = thisArg;
    }
    FilterOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FilterSubscriber(subscriber, this.predicate, this.thisArg));
    };
    return FilterOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FilterSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FilterSubscriber, _super);
    function FilterSubscriber(destination, predicate, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.count = 0;
        return _this;
    }
    // the try catch block below is left specifically for
    // optimization and perf reasons. a tryCatcher is not necessary here.
    FilterSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.predicate.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (result) {
            this.destination.next(value);
        }
    };
    return FilterSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_noop,_util_isFunction PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Perform a side effect for every emission on the source Observable, but return
 * an Observable that is identical to the source.
 *
 * <span class="informal">Intercepts each emission on the source and runs a
 * function, but returns an output which is identical to the source as long as errors don't occur.</span>
 *
 * <img src="./img/do.png" width="100%">
 *
 * Returns a mirrored Observable of the source Observable, but modified so that
 * the provided Observer is called to perform a side effect for every value,
 * error, and completion emitted by the source. Any errors that are thrown in
 * the aforementioned Observer or handlers are safely sent down the error path
 * of the output Observable.
 *
 * This operator is useful for debugging your Observables for the correct values
 * or performing other side effects.
 *
 * Note: this is different to a `subscribe` on the Observable. If the Observable
 * returned by `do` is not subscribed, the side effects specified by the
 * Observer will never happen. `do` therefore simply spies on existing
 * execution, it does not trigger an execution to happen like `subscribe` does.
 *
 * @example <caption>Map every click to the clientX position of that click, while also logging the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks
 *   .do(ev => console.log(ev))
 *   .map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link map}
 * @see {@link subscribe}
 *
 * @param {Observer|function} [nextOrObserver] A normal Observer object or a
 * callback for `next`.
 * @param {function} [error] Callback for errors in the source.
 * @param {function} [complete] Callback for the completion of the source.
 * @return {Observable} An Observable identical to the source, but runs the
 * specified Observer or callback(s) for each item.
 * @name tap
 */

var DoOperator = /*@__PURE__*/ (function () {
    function DoOperator(nextOrObserver, error, complete) {
        this.nextOrObserver = nextOrObserver;
        this.error = error;
        this.complete = complete;
    }
    DoOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TapSubscriber(subscriber, this.nextOrObserver, this.error, this.complete));
    };
    return DoOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TapSubscriber, _super);
    function TapSubscriber(destination, observerOrNext, error, complete) {
        var _this = _super.call(this, destination) || this;
        _this._tapNext = noop;
        _this._tapError = noop;
        _this._tapComplete = noop;
        _this._tapError = error || noop;
        _this._tapComplete = complete || noop;
        if (isFunction(observerOrNext)) {
            _this._context = _this;
            _this._tapNext = observerOrNext;
        }
        else if (observerOrNext) {
            _this._context = observerOrNext;
            _this._tapNext = observerOrNext.next || noop;
            _this._tapError = observerOrNext.error || noop;
            _this._tapComplete = observerOrNext.complete || noop;
        }
        return _this;
    }
    TapSubscriber.prototype._next = function (value) {
        try {
            this._tapNext.call(this._context, value);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(value);
    };
    TapSubscriber.prototype._error = function (err) {
        try {
            this._tapError.call(this._context, err);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.error(err);
    };
    TapSubscriber.prototype._complete = function () {
        try {
            this._tapComplete.call(this._context);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        return this.destination.complete();
    };
    return TapSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _tap,_util_EmptyError PURE_IMPORTS_END */
/**
 * If the source observable completes without emitting a value, it will emit
 * an error. The error will be created at that time by the optional
 * `errorFactory` argument, otherwise, the error will be {@link ErrorEmpty}.
 *
 * @example
 *
 * const click$ = fromEvent(button, 'click');
 *
 * clicks$.pipe(
 *   takeUntil(timer(1000)),
 *   throwIfEmpty(
 *     () => new Error('the button was not clicked within 1 second')
 *   ),
 * )
 * .subscribe({
 *   next() { console.log('The button was clicked'); },
 *   error(err) { console.error(err); },
 * });
 * @param {Function} [errorFactory] A factory function called to produce the
 * error to be thrown when the source observable completes without emitting a
 * value.
 */

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
/**
 * Emits only the first `count` values emitted by the source Observable.
 *
 * <span class="informal">Takes the first `count` values from the source, then
 * completes.</span>
 *
 * <img src="./img/take.png" width="100%">
 *
 * `take` returns an Observable that emits only the first `count` values emitted
 * by the source Observable. If the source emits fewer than `count` values then
 * all of its values are emitted. After that, it completes, regardless if the
 * source completes.
 *
 * @example <caption>Take the first 5 seconds of an infinite 1-second interval Observable</caption>
 * var interval = Rx.Observable.interval(1000);
 * var five = interval.take(5);
 * five.subscribe(x => console.log(x));
 *
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `take(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of `next` values to emit.
 * @return {Observable<T>} An Observable that emits only the first `count`
 * values emitted by the source Observable, or all of the values from the source
 * if the source emits fewer than `count` values.
 * @method take
 * @owner Observable
 */

var TakeOperator = /*@__PURE__*/ (function () {
    function TakeOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    TakeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeSubscriber(subscriber, this.total));
    };
    return TakeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeSubscriber, _super);
    function TakeSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    TakeSubscriber.prototype._next = function (value) {
        var total = this.total;
        var count = ++this.count;
        if (count <= total) {
            this.destination.next(value);
            if (count === total) {
                this.destination.complete();
                this.unsubscribe();
            }
        }
    };
    return TakeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_ArgumentOutOfRangeError,_filter,_throwIfEmpty,_defaultIfEmpty,_take PURE_IMPORTS_END */
/**
 * Emits the single value at the specified `index` in a sequence of emissions
 * from the source Observable.
 *
 * <span class="informal">Emits only the i-th value, then completes.</span>
 *
 * <img src="./img/elementAt.png" width="100%">
 *
 * `elementAt` returns an Observable that emits the item at the specified
 * `index` in the source Observable, or a default value if that `index` is out
 * of range and the `default` argument is provided. If the `default` argument is
 * not given and the `index` is out of range, the output Observable will emit an
 * `ArgumentOutOfRangeError` error.
 *
 * @example <caption>Emit only the third click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.elementAt(2);
 * result.subscribe(x => console.log(x));
 *
 * // Results in:
 * // click 1 = nothing
 * // click 2 = nothing
 * // click 3 = MouseEvent object logged to console
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link skip}
 * @see {@link single}
 * @see {@link take}
 *
 * @throws {ArgumentOutOfRangeError} When using `elementAt(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0` or the
 * Observable has completed before emitting the i-th `next` notification.
 *
 * @param {number} index Is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {T} [defaultValue] The default value returned for missing indices.
 * @return {Observable} An Observable that emits a single item, if it is found.
 * Otherwise, will emit the default value if given. If not, then emits an error.
 * @method elementAt
 * @owner Observable
 */

/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments after it finishes emitting
 * items emitted by the source Observable.
 *
 * @param {...T} values - Items you want the modified Observable to emit last.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items emitted by the source Observable
 *  and then emits the items in the specified Iterable.
 * @method endWith
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Returns an Observable that emits whether or not every item of the source satisfies the condition specified.
 *
 * @example <caption>A simple example emitting true if all elements are less than 5, false otherwise</caption>
 *  Observable.of(1, 2, 3, 4, 5, 6)
 *     .every(x => x < 5)
 *     .subscribe(x => console.log(x)); // -> false
 *
 * @param {function} predicate A function for determining if an item meets a specified condition.
 * @param {any} [thisArg] Optional object to use for `this` in the callback.
 * @return {Observable} An Observable of booleans that determines if all items of the source Observable meet the condition specified.
 * @method every
 * @owner Observable
 */

var EveryOperator = /*@__PURE__*/ (function () {
    function EveryOperator(predicate, thisArg, source) {
        this.predicate = predicate;
        this.thisArg = thisArg;
        this.source = source;
    }
    EveryOperator.prototype.call = function (observer, source) {
        return source.subscribe(new EverySubscriber(observer, this.predicate, this.thisArg, this.source));
    };
    return EveryOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var EverySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(EverySubscriber, _super);
    function EverySubscriber(destination, predicate, thisArg, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.thisArg = thisArg;
        _this.source = source;
        _this.index = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    EverySubscriber.prototype.notifyComplete = function (everyValueMatch) {
        this.destination.next(everyValueMatch);
        this.destination.complete();
    };
    EverySubscriber.prototype._next = function (value) {
        var result = false;
        try {
            result = this.predicate.call(this.thisArg, value, this.index++, this.source);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        if (!result) {
            this.notifyComplete(false);
        }
    };
    EverySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return EverySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Converts a higher-order Observable into a first-order Observable by dropping
 * inner Observables while the previous inner Observable has not yet completed.
 *
 * <span class="informal">Flattens an Observable-of-Observables by dropping the
 * next inner Observables while the current inner is still executing.</span>
 *
 * <img src="./img/exhaust.png" width="100%">
 *
 * `exhaust` subscribes to an Observable that emits Observables, also known as a
 * higher-order Observable. Each time it observes one of these emitted inner
 * Observables, the output Observable begins emitting the items emitted by that
 * inner Observable. So far, it behaves like {@link mergeAll}. However,
 * `exhaust` ignores every new inner Observable if the previous Observable has
 * not yet completed. Once that one completes, it will accept and flatten the
 * next inner Observable and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(5));
 * var result = higherOrder.exhaust();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link switch}
 * @see {@link mergeAll}
 * @see {@link exhaustMap}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable that takes a source of Observables and propagates the first observable
 * exclusively until it completes before subscribing to the next.
 * @method exhaust
 * @owner Observable
 */

var SwitchFirstOperator = /*@__PURE__*/ (function () {
    function SwitchFirstOperator() {
    }
    SwitchFirstOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchFirstSubscriber(subscriber));
    };
    return SwitchFirstOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchFirstSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchFirstSubscriber, _super);
    function SwitchFirstSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasCompleted = false;
        _this.hasSubscription = false;
        return _this;
    }
    SwitchFirstSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.hasSubscription = true;
            this.add(subscribeToResult(this, value));
        }
    };
    SwitchFirstSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    SwitchFirstSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return SwitchFirstSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable only if the previous projected Observable has completed.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link exhaust}.</span>
 *
 * <img src="./img/exhaustMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. When it projects a source value to
 * an Observable, the output Observable begins emitting the items emitted by
 * that projected Observable. However, `exhaustMap` ignores every new projected
 * Observable if the previous projected Observable has not yet completed. Once
 * that one completes, it will accept and flatten the next projected Observable
 * and repeat this process.
 *
 * @example <caption>Run a finite timer for each click, only if there is no currently active timer</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.exhaustMap((ev) => Rx.Observable.interval(1000).take(5));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaust}
 * @see {@link mergeMap}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @return {Observable} An Observable containing projected Observables
 * of each item of the source, ignoring projected Observables that start before
 * their preceding Observable has completed.
 * @method exhaustMap
 * @owner Observable
 */

var ExhauseMapOperator = /*@__PURE__*/ (function () {
    function ExhauseMapOperator(project) {
        this.project = project;
    }
    ExhauseMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExhaustMapSubscriber(subscriber, this.project));
    };
    return ExhauseMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ExhaustMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExhaustMapSubscriber, _super);
    function ExhaustMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.hasSubscription = false;
        _this.hasCompleted = false;
        _this.index = 0;
        return _this;
    }
    ExhaustMapSubscriber.prototype._next = function (value) {
        if (!this.hasSubscription) {
            this.tryNext(value);
        }
    };
    ExhaustMapSubscriber.prototype.tryNext = function (value) {
        var index = this.index++;
        var destination = this.destination;
        try {
            var result = this.project(value, index);
            this.hasSubscription = true;
            this.add(subscribeToResult(this, result, value, index));
        }
        catch (err) {
            destination.error(err);
        }
    };
    ExhaustMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (!this.hasSubscription) {
            this.destination.complete();
        }
    };
    ExhaustMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    ExhaustMapSubscriber.prototype.notifyError = function (err) {
        this.destination.error(err);
    };
    ExhaustMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.hasSubscription = false;
        if (this.hasCompleted) {
            this.destination.complete();
        }
    };
    return ExhaustMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Recursively projects each source value to an Observable which is merged in
 * the output Observable.
 *
 * <span class="informal">It's similar to {@link mergeMap}, but applies the
 * projection function to every source value as well as every output value.
 * It's recursive.</span>
 *
 * <img src="./img/expand.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger. *Expand* will re-emit on the output
 * Observable every source value. Then, each output value is given to the
 * `project` function which returns an inner Observable to be merged on the
 * output Observable. Those output values resulting from the projection are also
 * given to the `project` function to produce new output values. This is how
 * *expand* behaves recursively.
 *
 * @example <caption>Start emitting the powers of two on every click, at most 10 of them</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var powersOfTwo = clicks
 *   .mapTo(1)
 *   .expand(x => Rx.Observable.of(2 * x).delay(1000))
 *   .take(10);
 * powersOfTwo.subscribe(x => console.log(x));
 *
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 *
 * @param {function(value: T, index: number) => Observable} project A function
 * that, when applied to an item emitted by the source or the output Observable,
 * returns an Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each projected inner Observable.
 * @return {Observable} An Observable that emits the source values and also
 * result of applying the projection function to each value emitted on the
 * output Observable and and merging the results of the Observables obtained
 * from this transformation.
 * @method expand
 * @owner Observable
 */

var ExpandOperator = /*@__PURE__*/ (function () {
    function ExpandOperator(project, concurrent, scheduler) {
        this.project = project;
        this.concurrent = concurrent;
        this.scheduler = scheduler;
    }
    ExpandOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ExpandSubscriber(subscriber, this.project, this.concurrent, this.scheduler));
    };
    return ExpandOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ExpandSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ExpandSubscriber, _super);
    function ExpandSubscriber(destination, project, concurrent, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.scheduler = scheduler;
        _this.index = 0;
        _this.active = 0;
        _this.hasCompleted = false;
        if (concurrent < Number.POSITIVE_INFINITY) {
            _this.buffer = [];
        }
        return _this;
    }
    ExpandSubscriber.dispatch = function (arg) {
        var subscriber = arg.subscriber, result = arg.result, value = arg.value, index = arg.index;
        subscriber.subscribeToProjection(result, value, index);
    };
    ExpandSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (destination.closed) {
            this._complete();
            return;
        }
        var index = this.index++;
        if (this.active < this.concurrent) {
            destination.next(value);
            var result = tryCatch(this.project)(value, index);
            if (result === errorObject) {
                destination.error(errorObject.e);
            }
            else if (!this.scheduler) {
                this.subscribeToProjection(result, value, index);
            }
            else {
                var state = { subscriber: this, result: result, value: value, index: index };
                this.add(this.scheduler.schedule(ExpandSubscriber.dispatch, 0, state));
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    ExpandSubscriber.prototype.subscribeToProjection = function (result, value, index) {
        this.active++;
        this.add(subscribeToResult(this, result, value, index));
    };
    ExpandSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    ExpandSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this._next(innerValue);
    };
    ExpandSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer && buffer.length > 0) {
            this._next(buffer.shift());
        }
        if (this.hasCompleted && this.active === 0) {
            this.destination.complete();
        }
    };
    return ExpandSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subscription PURE_IMPORTS_END */
/**
 * Returns an Observable that mirrors the source Observable, but will call a specified function when
 * the source terminates on complete or error.
 * @param {function} callback Function to be called when source terminates.
 * @return {Observable} An Observable that mirrors the source, but will call the specified function on termination.
 * @method finally
 * @owner Observable
 */

var FinallyOperator = /*@__PURE__*/ (function () {
    function FinallyOperator(callback) {
        this.callback = callback;
    }
    FinallyOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new FinallySubscriber(subscriber, this.callback));
    };
    return FinallyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FinallySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FinallySubscriber, _super);
    function FinallySubscriber(destination, callback) {
        var _this = _super.call(this, destination) || this;
        _this.add(new Subscription(callback));
        return _this;
    }
    return FinallySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Emits only the first value emitted by the source Observable that meets some
 * condition.
 *
 * <span class="informal">Finds the first value that passes some test and emits
 * that.</span>
 *
 * <img src="./img/find.png" width="100%">
 *
 * `find` searches for the first item in the source Observable that matches the
 * specified condition embodied by the `predicate`, and returns the first
 * occurrence in the source. Unlike {@link first}, the `predicate` is required
 * in `find`, and does not emit an error if a valid value is not found.
 *
 * @example <caption>Find and emit the first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.find(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link first}
 * @see {@link findIndex}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable<T>} An Observable of the first item that matches the
 * condition.
 * @method find
 * @owner Observable
 */

var FindValueOperator = /*@__PURE__*/ (function () {
    function FindValueOperator(predicate, source, yieldIndex, thisArg) {
        this.predicate = predicate;
        this.source = source;
        this.yieldIndex = yieldIndex;
        this.thisArg = thisArg;
    }
    FindValueOperator.prototype.call = function (observer, source) {
        return source.subscribe(new FindValueSubscriber(observer, this.predicate, this.source, this.yieldIndex, this.thisArg));
    };
    return FindValueOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var FindValueSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(FindValueSubscriber, _super);
    function FindValueSubscriber(destination, predicate, source, yieldIndex, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.yieldIndex = yieldIndex;
        _this.thisArg = thisArg;
        _this.index = 0;
        return _this;
    }
    FindValueSubscriber.prototype.notifyComplete = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    FindValueSubscriber.prototype._next = function (value) {
        var _a = this, predicate = _a.predicate, thisArg = _a.thisArg;
        var index = this.index++;
        try {
            var result = predicate.call(thisArg || this, value, index, this.source);
            if (result) {
                this.notifyComplete(this.yieldIndex ? index : value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    FindValueSubscriber.prototype._complete = function () {
        this.notifyComplete(this.yieldIndex ? -1 : undefined);
    };
    return FindValueSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _operators_find PURE_IMPORTS_END */
/**
 * Emits only the index of the first value emitted by the source Observable that
 * meets some condition.
 *
 * <span class="informal">It's like {@link find}, but emits the index of the
 * found value, not the value itself.</span>
 *
 * <img src="./img/findIndex.png" width="100%">
 *
 * `findIndex` searches for the first item in the source Observable that matches
 * the specified condition embodied by the `predicate`, and returns the
 * (zero-based) index of the first occurrence in the source. Unlike
 * {@link first}, the `predicate` is required in `findIndex`, and does not emit
 * an error if a valid value is not found.
 *
 * @example <caption>Emit the index of first click that happens on a DIV element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.findIndex(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link first}
 * @see {@link take}
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} predicate
 * A function called with each item to test for condition matching.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {Observable} An Observable of the index of the first item that
 * matches the condition.
 * @method find
 * @owner Observable
 */

/** PURE_IMPORTS_START _util_EmptyError,_filter,_take,_defaultIfEmpty,_throwIfEmpty,_util_identity PURE_IMPORTS_END */
/**
 * Emits only the first value (or the first value that meets some condition)
 * emitted by the source Observable.
 *
 * <span class="informal">Emits only the first value. Or emits only the first
 * value that passes some test.</span>
 *
 * <img src="./img/first.png" width="100%">
 *
 * If called with no arguments, `first` emits the first value of the source
 * Observable, then completes. If called with a `predicate` function, `first`
 * emits the first value of the source that matches the specified condition. It
 * may also take a `resultSelector` function to produce the output value from
 * the input value, and a `defaultValue` to emit in case the source completes
 * before it is able to emit a valid value. Throws an error if `defaultValue`
 * was not provided and a matching element is not found.
 *
 * @example <caption>Emit only the first click that happens on the DOM</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first();
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Emits the first click that happens on a DIV</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.first(ev => ev.target.tagName === 'DIV');
 * result.subscribe(x => console.log(x));
 *
 * @see {@link filter}
 * @see {@link find}
 * @see {@link take}
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 *
 * @param {function(value: T, index: number, source: Observable<T>): boolean} [predicate]
 * An optional function called with each item to test for condition matching.
 * @param {R} [defaultValue] The default value emitted in case no valid value
 * was found on the source.
 * @return {Observable<T|R>} An Observable of the first item that matches the
 * condition.
 * @method first
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Ignores all items emitted by the source Observable and only passes calls of `complete` or `error`.
 *
 * <img src="./img/ignoreElements.png" width="100%">
 *
 * @return {Observable} An empty Observable that only calls `complete`
 * or `error`, based on which one is called by the source Observable.
 * @method ignoreElements
 * @owner Observable
 */

var IgnoreElementsOperator = /*@__PURE__*/ (function () {
    function IgnoreElementsOperator() {
    }
    IgnoreElementsOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new IgnoreElementsSubscriber(subscriber));
    };
    return IgnoreElementsOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IgnoreElementsSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IgnoreElementsSubscriber, _super);
    function IgnoreElementsSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    IgnoreElementsSubscriber.prototype._next = function (unused) {
        // Do nothing
    };
    return IgnoreElementsSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */

var IsEmptyOperator = /*@__PURE__*/ (function () {
    function IsEmptyOperator() {
    }
    IsEmptyOperator.prototype.call = function (observer, source) {
        return source.subscribe(new IsEmptySubscriber(observer));
    };
    return IsEmptyOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var IsEmptySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(IsEmptySubscriber, _super);
    function IsEmptySubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    IsEmptySubscriber.prototype.notifyComplete = function (isEmpty) {
        var destination = this.destination;
        destination.next(isEmpty);
        destination.complete();
    };
    IsEmptySubscriber.prototype._next = function (value) {
        this.notifyComplete(false);
    };
    IsEmptySubscriber.prototype._complete = function () {
        this.notifyComplete(true);
    };
    return IsEmptySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError,_observable_empty PURE_IMPORTS_END */
/**
 * Emits only the last `count` values emitted by the source Observable.
 *
 * <span class="informal">Remembers the latest `count` values, then emits those
 * only when the source completes.</span>
 *
 * <img src="./img/takeLast.png" width="100%">
 *
 * `takeLast` returns an Observable that emits at most the last `count` values
 * emitted by the source Observable. If the source emits fewer than `count`
 * values then all of its values are emitted. This operator must wait until the
 * `complete` notification emission from the source in order to emit the `next`
 * values on the output Observable, because otherwise it is impossible to know
 * whether or not more values will be emitted on the source. For this reason,
 * all values are emitted synchronously, followed by the complete notification.
 *
 * @example <caption>Take the last 3 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 100);
 * var lastThree = many.pipe(takeLast(3));
 * lastThree.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeUntil}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @throws {ArgumentOutOfRangeError} When using `takeLast(i)`, it delivers an
 * ArgumentOutOrRangeError to the Observer's `error` callback if `i < 0`.
 *
 * @param {number} count The maximum number of values to emit from the end of
 * the sequence of values emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits at most the last count
 * values emitted by the source Observable.
 * @method takeLast
 * @owner Observable
 */

var TakeLastOperator = /*@__PURE__*/ (function () {
    function TakeLastOperator(total) {
        this.total = total;
        if (this.total < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    TakeLastOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeLastSubscriber(subscriber, this.total));
    };
    return TakeLastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeLastSubscriber, _super);
    function TakeLastSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.ring = new Array();
        _this.count = 0;
        return _this;
    }
    TakeLastSubscriber.prototype._next = function (value) {
        var ring = this.ring;
        var total = this.total;
        var count = this.count++;
        if (ring.length < total) {
            ring.push(value);
        }
        else {
            var index = count % total;
            ring[index] = value;
        }
    };
    TakeLastSubscriber.prototype._complete = function () {
        var destination = this.destination;
        var count = this.count;
        if (count > 0) {
            var total = this.count >= this.total ? this.total : this.count;
            var ring = this.ring;
            for (var i = 0; i < total; i++) {
                var idx = (count++) % total;
                destination.next(ring[idx]);
            }
        }
        destination.complete();
    };
    return TakeLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _util_EmptyError,_filter,_takeLast,_throwIfEmpty,_defaultIfEmpty,_util_identity PURE_IMPORTS_END */
/**
 * Returns an Observable that emits only the last item emitted by the source Observable.
 * It optionally takes a predicate function as a parameter, in which case, rather than emitting
 * the last item from the source Observable, the resulting Observable will emit the last item
 * from the source Observable that satisfies the predicate.
 *
 * <img src="./img/last.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {function} [predicate] - The condition any source emitted item has to satisfy.
 * @param {any} [defaultValue] - An optional default value to provide if last
 * predicate isn't met or no values were emitted.
 * @return {Observable} An Observable that emits only the last item satisfying the given condition
 * from the source, or an NoSuchElementException if no such items are emitted.
 * @throws - Throws if no items that match the predicate are emitted by the source Observable.
 */

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Emits the given constant value on the output Observable every time the source
 * Observable emits a value.
 *
 * <span class="informal">Like {@link map}, but it maps every source value to
 * the same output value every time.</span>
 *
 * <img src="./img/mapTo.png" width="100%">
 *
 * Takes a constant `value` as argument, and emits that whenever the source
 * Observable emits a value. In other words, ignores the actual source value,
 * and simply uses the emission moment to know when to emit the given `value`.
 *
 * @example <caption>Map every click to the string 'Hi'</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var greetings = clicks.mapTo('Hi');
 * greetings.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {any} value The value to map each source value to.
 * @return {Observable} An Observable that emits the given `value` every time
 * the source Observable emits something.
 * @method mapTo
 * @owner Observable
 */

var MapToOperator = /*@__PURE__*/ (function () {
    function MapToOperator(value) {
        this.value = value;
    }
    MapToOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapToSubscriber(subscriber, this.value));
    };
    return MapToOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MapToSubscriber, _super);
    function MapToSubscriber(destination, value) {
        var _this = _super.call(this, destination) || this;
        _this.value = value;
        return _this;
    }
    MapToSubscriber.prototype._next = function (x) {
        this.destination.next(this.value);
    };
    return MapToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Notification PURE_IMPORTS_END */
/**
 * Represents all of the notifications from the source Observable as `next`
 * emissions marked with their original types within {@link Notification}
 * objects.
 *
 * <span class="informal">Wraps `next`, `error` and `complete` emissions in
 * {@link Notification} objects, emitted as `next` on the output Observable.
 * </span>
 *
 * <img src="./img/materialize.png" width="100%">
 *
 * `materialize` returns an Observable that emits a `next` notification for each
 * `next`, `error`, or `complete` emission of the source Observable. When the
 * source Observable emits `complete`, the output Observable will emit `next` as
 * a Notification of type "complete", and then it will emit `complete` as well.
 * When the source Observable emits `error`, the output will emit `next` as a
 * Notification of type "error", and then `complete`.
 *
 * This operator is useful for producing metadata of the source Observable, to
 * be consumed as `next` emissions. Use it in conjunction with
 * {@link dematerialize}.
 *
 * @example <caption>Convert a faulty Observable to an Observable of Notifications</caption>
 * var letters = Rx.Observable.of('a', 'b', 13, 'd');
 * var upperCase = letters.map(x => x.toUpperCase());
 * var materialized = upperCase.materialize();
 * materialized.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - Notification {kind: "N", value: "A", error: undefined, hasValue: true}
 * // - Notification {kind: "N", value: "B", error: undefined, hasValue: true}
 * // - Notification {kind: "E", value: undefined, error: TypeError:
 * //   x.toUpperCase is not a function at MapSubscriber.letters.map.x
 * //   [as project] (http://1, hasValue: false}
 *
 * @see {@link Notification}
 * @see {@link dematerialize}
 *
 * @return {Observable<Notification<T>>} An Observable that emits
 * {@link Notification} objects that wrap the original emissions from the source
 * Observable with metadata.
 * @method materialize
 * @owner Observable
 */

var MaterializeOperator = /*@__PURE__*/ (function () {
    function MaterializeOperator() {
    }
    MaterializeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MaterializeSubscriber(subscriber));
    };
    return MaterializeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MaterializeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MaterializeSubscriber, _super);
    function MaterializeSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    MaterializeSubscriber.prototype._next = function (value) {
        this.destination.next(Notification.createNext(value));
    };
    MaterializeSubscriber.prototype._error = function (err) {
        var destination = this.destination;
        destination.next(Notification.createError(err));
        destination.complete();
    };
    MaterializeSubscriber.prototype._complete = function () {
        var destination = this.destination;
        destination.next(Notification.createComplete());
        destination.complete();
    };
    return MaterializeSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns each
 * intermediate result, with an optional seed value.
 *
 * <span class="informal">It's like {@link reduce}, but emits the current
 * accumulation whenever the source emits a value.</span>
 *
 * <img src="./img/scan.png" width="100%">
 *
 * Combines together all values emitted on the source, using an accumulator
 * function that knows how to join a new source value into the accumulation from
 * the past. Is similar to {@link reduce}, but emits the intermediate
 * accumulations.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var ones = clicks.mapTo(1);
 * var seed = 0;
 * var count = ones.scan((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link reduce}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator
 * The accumulator function called on each source value.
 * @param {T|R} [seed] The initial accumulation value.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method scan
 * @owner Observable
 */

var ScanOperator = /*@__PURE__*/ (function () {
    function ScanOperator(accumulator, seed, hasSeed) {
        if (hasSeed === void 0) {
            hasSeed = false;
        }
        this.accumulator = accumulator;
        this.seed = seed;
        this.hasSeed = hasSeed;
    }
    ScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ScanSubscriber(subscriber, this.accumulator, this.seed, this.hasSeed));
    };
    return ScanOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ScanSubscriber, _super);
    function ScanSubscriber(destination, accumulator, _seed, hasSeed) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this._seed = _seed;
        _this.hasSeed = hasSeed;
        _this.index = 0;
        return _this;
    }
    Object.defineProperty(ScanSubscriber.prototype, "seed", {
        get: function () {
            return this._seed;
        },
        set: function (value) {
            this.hasSeed = true;
            this._seed = value;
        },
        enumerable: true,
        configurable: true
    });
    ScanSubscriber.prototype._next = function (value) {
        if (!this.hasSeed) {
            this.seed = value;
            this.destination.next(value);
        }
        else {
            return this._tryNext(value);
        }
    };
    ScanSubscriber.prototype._tryNext = function (value) {
        var index = this.index++;
        var result;
        try {
            result = this.accumulator(this.seed, value, index);
        }
        catch (err) {
            this.destination.error(err);
        }
        this.seed = result;
        this.destination.next(result);
    };
    return ScanSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _scan,_takeLast,_defaultIfEmpty,_util_pipe PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Applies an accumulator function over the source Observable, and returns the
 * accumulated result when the source completes, given an optional seed value.
 *
 * <span class="informal">Combines together all values emitted on the source,
 * using an accumulator function that knows how to join a new source value into
 * the accumulation from the past.</span>
 *
 * <img src="./img/reduce.png" width="100%">
 *
 * Like
 * [Array.prototype.reduce()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce),
 * `reduce` applies an `accumulator` function against an accumulation and each
 * value of the source Observable (from the past) to reduce it to a single
 * value, emitted on the output Observable. Note that `reduce` will only emit
 * one value, only when the source Observable completes. It is equivalent to
 * applying operator {@link scan} followed by operator {@link last}.
 *
 * Returns an Observable that applies a specified `accumulator` function to each
 * item emitted by the source Observable. If a `seed` value is specified, then
 * that value will be used as the initial value for the accumulator. If no seed
 * value is specified, the first item of the source is used as the seed.
 *
 * @example <caption>Count the number of click events that happened in 5 seconds</caption>
 * var clicksInFiveSeconds = Rx.Observable.fromEvent(document, 'click')
 *   .takeUntil(Rx.Observable.interval(5000));
 * var ones = clicksInFiveSeconds.mapTo(1);
 * var seed = 0;
 * var count = ones.reduce((acc, one) => acc + one, seed);
 * count.subscribe(x => console.log(x));
 *
 * @see {@link count}
 * @see {@link expand}
 * @see {@link mergeScan}
 * @see {@link scan}
 *
 * @param {function(acc: R, value: T, index: number): R} accumulator The accumulator function
 * called on each source value.
 * @param {R} [seed] The initial accumulation value.
 * @return {Observable<R>} An Observable that emits a single value that is the
 * result of accumulating the values emitted by the source Observable.
 * @method reduce
 * @owner Observable
 */

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
/**
 * The Max operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
 * and when source Observable completes it emits a single item: the item with the largest value.
 *
 * <img src="./img/max.png" width="100%">
 *
 * @example <caption>Get the maximal value of a series of numbers</caption>
 * Rx.Observable.of(5, 4, 7, 2, 8)
 *   .max()
 *   .subscribe(x => console.log(x)); // -> 8
 *
 * @example <caption>Use a comparer function to get the maximal item</caption>
 * interface Person {
 *   age: number,
 *   name: string
 * }
 * Observable.of<Person>({age: 7, name: 'Foo'},
 *                       {age: 5, name: 'Bar'},
 *                       {age: 9, name: 'Beer'})
 *           .max<Person>((a: Person, b: Person) => a.age < b.age ? -1 : 1)
 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Beer'
 * }
 *
 * @see {@link min}
 *
 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
 * value of two items.
 * @return {Observable} An Observable that emits item with the largest value.
 * @method max
 * @owner Observable
 */

/** PURE_IMPORTS_START _observable_merge PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * @deprecated Deprecated in favor of static merge.
 */

/** PURE_IMPORTS_START _mergeMap PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is merged multiple
 * times in the output Observable.
 *
 * <span class="informal">It's like {@link mergeMap}, but maps each value always
 * to the same inner Observable.</span>
 *
 * <img src="./img/mergeMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then merges those resulting Observables into one
 * single Observable, which is the output Observable.
 *
 * @example <caption>For each click event, start an interval Observable ticking every 1 second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.mergeMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeScan}
 * @see {@link switchMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable`
 * @method mergeMapTo
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_util_tryCatch,_util_errorObject,_util_subscribeToResult,_OuterSubscriber PURE_IMPORTS_END */
/**
 * Applies an accumulator function over the source Observable where the
 * accumulator function itself returns an Observable, then each intermediate
 * Observable returned is merged into the output Observable.
 *
 * <span class="informal">It's like {@link scan}, but the Observables returned
 * by the accumulator are merged into the outer Observable.</span>
 *
 * @example <caption>Count the number of click events</caption>
 * const click$ = Rx.Observable.fromEvent(document, 'click');
 * const one$ = click$.mapTo(1);
 * const seed = 0;
 * const count$ = one$.mergeScan((acc, one) => Rx.Observable.of(acc + one), seed);
 * count$.subscribe(x => console.log(x));
 *
 * // Results:
 * 1
 * 2
 * 3
 * 4
 * // ...and so on for each click
 *
 * @param {function(acc: R, value: T): Observable<R>} accumulator
 * The accumulator function called on each source value.
 * @param seed The initial accumulation value.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of
 * input Observables being subscribed to concurrently.
 * @return {Observable<R>} An observable of the accumulated values.
 * @method mergeScan
 * @owner Observable
 */

var MergeScanOperator = /*@__PURE__*/ (function () {
    function MergeScanOperator(accumulator, seed, concurrent) {
        this.accumulator = accumulator;
        this.seed = seed;
        this.concurrent = concurrent;
    }
    MergeScanOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MergeScanSubscriber(subscriber, this.accumulator, this.seed, this.concurrent));
    };
    return MergeScanOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeScanSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(MergeScanSubscriber, _super);
    function MergeScanSubscriber(destination, accumulator, acc, concurrent) {
        var _this = _super.call(this, destination) || this;
        _this.accumulator = accumulator;
        _this.acc = acc;
        _this.concurrent = concurrent;
        _this.hasValue = false;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeScanSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            var index = this.index++;
            var ish = tryCatch(this.accumulator)(this.acc, value);
            var destination = this.destination;
            if (ish === errorObject) {
                destination.error(errorObject.e);
            }
            else {
                this.active++;
                this._innerSub(ish, value, index);
            }
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeScanSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult(this, ish, value, index));
    };
    MergeScanSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    MergeScanSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var destination = this.destination;
        this.acc = innerValue;
        this.hasValue = true;
        destination.next(innerValue);
    };
    MergeScanSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            if (this.hasValue === false) {
                this.destination.next(this.acc);
            }
            this.destination.complete();
        }
    };
    return MergeScanSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */
/**
 * The Min operator operates on an Observable that emits numbers (or items that can be compared with a provided function),
 * and when source Observable completes it emits a single item: the item with the smallest value.
 *
 * <img src="./img/min.png" width="100%">
 *
 * @example <caption>Get the minimal value of a series of numbers</caption>
 * Rx.Observable.of(5, 4, 7, 2, 8)
 *   .min()
 *   .subscribe(x => console.log(x)); // -> 2
 *
 * @example <caption>Use a comparer function to get the minimal item</caption>
 * interface Person {
 *   age: number,
 *   name: string
 * }
 * Observable.of<Person>({age: 7, name: 'Foo'},
 *                       {age: 5, name: 'Bar'},
 *                       {age: 9, name: 'Beer'})
 *           .min<Person>( (a: Person, b: Person) => a.age < b.age ? -1 : 1)
 *           .subscribe((x: Person) => console.log(x.name)); // -> 'Bar'
 * }
 *
 * @see {@link max}
 *
 * @param {Function} [comparer] - Optional comparer function that it will use instead of its default to compare the
 * value of two items.
 * @return {Observable<R>} An Observable that emits item with the smallest value.
 * @method min
 * @owner Observable
 */

/** PURE_IMPORTS_START _observable_ConnectableObservable PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the results of invoking a specified selector on items
 * emitted by a ConnectableObservable that shares a single subscription to the underlying stream.
 *
 * <img src="./img/multicast.png" width="100%">
 *
 * @param {Function|Subject} subjectOrSubjectFactory - Factory function to create an intermediate subject through
 * which the source sequence's elements will be multicast to the selector function
 * or Subject to push source elements into.
 * @param {Function} [selector] - Optional selector function that can use the multicasted source stream
 * as many times as needed, without causing multiple subscriptions to the source stream.
 * Subscribers to the given source will receive all notifications of the source from the
 * time of the subscription forward.
 * @return {Observable} An Observable that emits the results of invoking the selector
 * on the items emitted by a `ConnectableObservable` that shares a single subscription to
 * the underlying stream.
 * @method multicast
 * @owner Observable
 */

var MulticastOperator = /*@__PURE__*/ (function () {
    function MulticastOperator(subjectFactory, selector) {
        this.subjectFactory = subjectFactory;
        this.selector = selector;
    }
    MulticastOperator.prototype.call = function (subscriber, source) {
        var selector = this.selector;
        var subject = this.subjectFactory();
        var subscription = selector(subject).subscribe(subscriber);
        subscription.add(source.subscribe(subject));
        return subscription;
    };
    return MulticastOperator;
}());

/** PURE_IMPORTS_START tslib,_observable_from,_util_isArray,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
 * that was passed.
 *
 * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
 *
 * <img src="./img/onErrorResumeNext.png" width="100%">
 *
 * `onErrorResumeNext` is an operator that accepts a series of Observables, provided either directly as
 * arguments or as an array. If no single Observable is provided, returned Observable will simply behave the same
 * as the source.
 *
 * `onErrorResumeNext` returns an Observable that starts by subscribing and re-emitting values from the source Observable.
 * When its stream of values ends - no matter if Observable completed or emitted an error - `onErrorResumeNext`
 * will subscribe to the first Observable that was passed as an argument to the method. It will start re-emitting
 * its values as well and - again - when that stream ends, `onErrorResumeNext` will proceed to subscribing yet another
 * Observable in provided series, no matter if previous Observable completed or ended with an error. This will
 * be happening until there is no more Observables left in the series, at which point returned Observable will
 * complete - even if the last subscribed stream ended with an error.
 *
 * `onErrorResumeNext` can be therefore thought of as version of {@link concat} operator, which is more permissive
 * when it comes to the errors emitted by its input Observables. While `concat` subscribes to the next Observable
 * in series only if previous one successfully completed, `onErrorResumeNext` subscribes even if it ended with
 * an error.
 *
 * Note that you do not get any access to errors emitted by the Observables. In particular do not
 * expect these errors to appear in error callback passed to {@link subscribe}. If you want to take
 * specific actions based on what error was emitted by an Observable, you should try out {@link catch} instead.
 *
 *
 * @example <caption>Subscribe to the next Observable after map fails</caption>
 * Rx.Observable.of(1, 2, 3, 0)
 *   .map(x => {
 *       if (x === 0) { throw Error(); }
         return 10 / x;
 *   })
 *   .onErrorResumeNext(Rx.Observable.of(1, 2, 3))
 *   .subscribe(
 *     val => console.log(val),
 *     err => console.log(err),          // Will never be called.
 *     () => console.log('that\'s it!')
 *   );
 *
 * // Logs:
 * // 10
 * // 5
 * // 3.3333333333333335
 * // 1
 * // 2
 * // 3
 * // "that's it!"
 *
 * @see {@link concat}
 * @see {@link catch}
 *
 * @param {...ObservableInput} observables Observables passed either directly or as an array.
 * @return {Observable} An Observable that emits values from source Observable, but - if it errors - subscribes
 * to the next passed Observable and so on, until it completes or runs out of Observables.
 * @method onErrorResumeNext
 * @owner Observable
 */

/* tslint:enable:max-line-length */

var OnErrorResumeNextOperator = /*@__PURE__*/ (function () {
    function OnErrorResumeNextOperator(nextSources) {
        this.nextSources = nextSources;
    }
    OnErrorResumeNextOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new OnErrorResumeNextSubscriber(subscriber, this.nextSources));
    };
    return OnErrorResumeNextOperator;
}());
var OnErrorResumeNextSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(OnErrorResumeNextSubscriber, _super);
    function OnErrorResumeNextSubscriber(destination, nextSources) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.nextSources = nextSources;
        return _this;
    }
    OnErrorResumeNextSubscriber.prototype.notifyError = function (error, innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.notifyComplete = function (innerSub) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._error = function (err) {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype._complete = function () {
        this.subscribeToNextSource();
    };
    OnErrorResumeNextSubscriber.prototype.subscribeToNextSource = function () {
        var next = this.nextSources.shift();
        if (next) {
            this.add(subscribeToResult(this, next));
        }
        else {
            this.destination.complete();
        }
    };
    return OnErrorResumeNextSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Groups pairs of consecutive emissions together and emits them as an array of
 * two values.
 *
 * <span class="informal">Puts the current value and previous value together as
 * an array, and emits that.</span>
 *
 * <img src="./img/pairwise.png" width="100%">
 *
 * The Nth emission from the source Observable will cause the output Observable
 * to emit an array [(N-1)th, Nth] of the previous and the current value, as a
 * pair. For this reason, `pairwise` emits on the second and subsequent
 * emissions from the source Observable, but not on the first emission, because
 * there is no previous value in that case.
 *
 * @example <caption>On every click (starting from the second), emit the relative distance to the previous click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var pairs = clicks.pairwise();
 * var distance = pairs.map(pair => {
 *   var x0 = pair[0].clientX;
 *   var y0 = pair[0].clientY;
 *   var x1 = pair[1].clientX;
 *   var y1 = pair[1].clientY;
 *   return Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));
 * });
 * distance.subscribe(x => console.log(x));
 *
 * @see {@link buffer}
 * @see {@link bufferCount}
 *
 * @return {Observable<Array<T>>} An Observable of pairs (as arrays) of
 * consecutive values from the source Observable.
 * @method pairwise
 * @owner Observable
 */

var PairwiseOperator = /*@__PURE__*/ (function () {
    function PairwiseOperator() {
    }
    PairwiseOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new PairwiseSubscriber(subscriber));
    };
    return PairwiseOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var PairwiseSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(PairwiseSubscriber, _super);
    function PairwiseSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasPrev = false;
        return _this;
    }
    PairwiseSubscriber.prototype._next = function (value) {
        if (this.hasPrev) {
            this.destination.next([this.prev, value]);
        }
        else {
            this.hasPrev = true;
        }
        this.prev = value;
    };
    return PairwiseSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/** PURE_IMPORTS_START _util_not,_filter PURE_IMPORTS_END */
/**
 * Splits the source Observable into two, one with values that satisfy a
 * predicate, and another with values that don't satisfy the predicate.
 *
 * <span class="informal">It's like {@link filter}, but returns two Observables:
 * one like the output of {@link filter}, and the other with values that did not
 * pass the condition.</span>
 *
 * <img src="./img/partition.png" width="100%">
 *
 * `partition` outputs an array with two Observables that partition the values
 * from the source Observable through the given `predicate` function. The first
 * Observable in that array emits source values for which the predicate argument
 * returns true. The second Observable emits source values for which the
 * predicate returns false. The first behaves like {@link filter} and the second
 * behaves like {@link filter} with the predicate negated.
 *
 * @example <caption>Partition click events into those on DIV elements and those elsewhere</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var parts = clicks.partition(ev => ev.target.tagName === 'DIV');
 * var clicksOnDivs = parts[0];
 * var clicksElsewhere = parts[1];
 * clicksOnDivs.subscribe(x => console.log('DIV clicked: ', x));
 * clicksElsewhere.subscribe(x => console.log('Other clicked: ', x));
 *
 * @see {@link filter}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates each value emitted by the source Observable. If it returns `true`,
 * the value is emitted on the first Observable in the returned array, if
 * `false` the value is emitted on the second Observable in the array. The
 * `index` parameter is the number `i` for the i-th source emission that has
 * happened since the subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to determine the value of `this`
 * in the `predicate` function.
 * @return {[Observable<T>, Observable<T>]} An array with two Observables: one
 * with values that passed the predicate, and another with values that did not
 * pass the predicate.
 * @method partition
 * @owner Observable
 */

/** PURE_IMPORTS_START _map PURE_IMPORTS_END */
/**
 * Maps each source value (an object) to its specified nested property.
 *
 * <span class="informal">Like {@link map}, but meant only for picking one of
 * the nested properties of every emitted object.</span>
 *
 * <img src="./img/pluck.png" width="100%">
 *
 * Given a list of strings describing a path to an object property, retrieves
 * the value of a specified nested property from all values in the source
 * Observable. If a property can't be resolved, it will return `undefined` for
 * that value.
 *
 * @example <caption>Map every click to the tagName of the clicked target element</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var tagNames = clicks.pluck('target', 'tagName');
 * tagNames.subscribe(x => console.log(x));
 *
 * @see {@link map}
 *
 * @param {...string} properties The nested properties to pluck from each source
 * value (an object).
 * @return {Observable} A new Observable of property values from the source values.
 * @method pluck
 * @owner Observable
 */

/** PURE_IMPORTS_START _Subject,_multicast PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Returns a ConnectableObservable, which is a variety of Observable that waits until its connect method is called
 * before it begins emitting items to those Observers that have subscribed to it.
 *
 * <img src="./img/publish.png" width="100%">
 *
 * @param {Function} [selector] - Optional selector function which can use the multicasted source sequence as many times
 * as needed, without causing multiple subscriptions to the source sequence.
 * Subscribers to the given source will receive all notifications of the source from the time of the subscription on.
 * @return A ConnectableObservable that upon connection causes the source Observable to emit items to its Observers.
 * @method publish
 * @owner Observable
 */

/** PURE_IMPORTS_START _BehaviorSubject,_multicast PURE_IMPORTS_END */
/**
 * @param value
 * @return {ConnectableObservable<T>}
 * @method publishBehavior
 * @owner Observable
 */

/** PURE_IMPORTS_START _AsyncSubject,_multicast PURE_IMPORTS_END */

/** PURE_IMPORTS_START _ReplaySubject,_multicast PURE_IMPORTS_END */
/* tslint:enable:max-line-length */

/** PURE_IMPORTS_START _util_isArray,_observable_race PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that mirrors the first source Observable to emit an item
 * from the combination of this Observable and supplied Observables.
 * @param {...Observables} ...observables Sources used to race for which Observable emits first.
 * @return {Observable} An Observable that mirrors the output of the first Observable to emit an item.
 * @method race
 * @owner Observable
 * @deprecated Deprecated in favor of static race.
 */

/** PURE_IMPORTS_START tslib,_Subscriber,_observable_empty PURE_IMPORTS_END */
/**
 * Returns an Observable that repeats the stream of items emitted by the source Observable at most count times.
 *
 * <img src="./img/repeat.png" width="100%">
 *
 * @param {number} [count] The number of times the source Observable items are repeated, a count of 0 will yield
 * an empty Observable.
 * @return {Observable} An Observable that repeats the stream of items emitted by the source Observable at most
 * count times.
 * @method repeat
 * @owner Observable
 */

var RepeatOperator = /*@__PURE__*/ (function () {
    function RepeatOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RepeatOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatSubscriber(subscriber, this.count, this.source));
    };
    return RepeatOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatSubscriber, _super);
    function RepeatSubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RepeatSubscriber.prototype.complete = function () {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.complete.call(this);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RepeatSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Returns an Observable that mirrors the source Observable with the exception of a `complete`. If the source
 * Observable calls `complete`, this method will emit to the Observable returned from `notifier`. If that Observable
 * calls `complete` or `error`, then this method will call `complete` or `error` on the child subscription. Otherwise
 * this method will resubscribe to the source Observable.
 *
 * <img src="./img/repeatWhen.png" width="100%">
 *
 * @param {function(notifications: Observable): Observable} notifier - Receives an Observable of notifications with
 * which a user can `complete` or `error`, aborting the repetition.
 * @return {Observable} The source Observable modified with repeat logic.
 * @method repeatWhen
 * @owner Observable
 */

var RepeatWhenOperator = /*@__PURE__*/ (function () {
    function RepeatWhenOperator(notifier) {
        this.notifier = notifier;
    }
    RepeatWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RepeatWhenSubscriber(subscriber, this.notifier, source));
    };
    return RepeatWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RepeatWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RepeatWhenSubscriber, _super);
    function RepeatWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        _this.sourceIsBeingSubscribedTo = true;
        return _this;
    }
    RepeatWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.sourceIsBeingSubscribedTo = true;
        this.source.subscribe(this);
    };
    RepeatWhenSubscriber.prototype.notifyComplete = function (innerSub) {
        if (this.sourceIsBeingSubscribedTo === false) {
            return _super.prototype.complete.call(this);
        }
    };
    RepeatWhenSubscriber.prototype.complete = function () {
        this.sourceIsBeingSubscribedTo = false;
        if (!this.isStopped) {
            if (!this.retries) {
                this.subscribeToRetries();
            }
            if (!this.retriesSubscription || this.retriesSubscription.closed) {
                return _super.prototype.complete.call(this);
            }
            this._unsubscribeAndRecycle();
            this.notifications.next();
        }
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    RepeatWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, notifications = _a.notifications, retriesSubscription = _a.retriesSubscription;
        if (notifications) {
            notifications.unsubscribe();
            this.notifications = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    RepeatWhenSubscriber.prototype._unsubscribeAndRecycle = function () {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        _super.prototype._unsubscribeAndRecycle.call(this);
        this._unsubscribe = _unsubscribe;
        return this;
    };
    RepeatWhenSubscriber.prototype.subscribeToRetries = function () {
        this.notifications = new Subject();
        var retries = tryCatch(this.notifier)(this.notifications);
        if (retries === errorObject) {
            return _super.prototype.complete.call(this);
        }
        this.retries = retries;
        this.retriesSubscription = subscribeToResult(this, retries);
    };
    return RepeatWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will resubscribe to the source Observable for a maximum of `count` resubscriptions (given
 * as a number parameter) rather than propagating the `error` call.
 *
 * <img src="./img/retry.png" width="100%">
 *
 * Any and all items emitted by the source Observable will be emitted by the resulting Observable, even those emitted
 * during failed subscriptions. For example, if an Observable fails at first but emits [1, 2] then succeeds the second
 * time and emits: [1, 2, 3, 4, 5] then the complete stream of emissions and notifications
 * would be: [1, 2, 1, 2, 3, 4, 5, `complete`].
 * @param {number} count - Number of retry attempts before failing.
 * @return {Observable} The source Observable modified with the retry logic.
 * @method retry
 * @owner Observable
 */

var RetryOperator = /*@__PURE__*/ (function () {
    function RetryOperator(count, source) {
        this.count = count;
        this.source = source;
    }
    RetryOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetrySubscriber(subscriber, this.count, this.source));
    };
    return RetryOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetrySubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetrySubscriber, _super);
    function RetrySubscriber(destination, count, source) {
        var _this = _super.call(this, destination) || this;
        _this.count = count;
        _this.source = source;
        return _this;
    }
    RetrySubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _a = this, source = _a.source, count = _a.count;
            if (count === 0) {
                return _super.prototype.error.call(this, err);
            }
            else if (count > -1) {
                this.count = count - 1;
            }
            source.subscribe(this._unsubscribeAndRecycle());
        }
    };
    return RetrySubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Returns an Observable that mirrors the source Observable with the exception of an `error`. If the source Observable
 * calls `error`, this method will emit the Throwable that caused the error to the Observable returned from `notifier`.
 * If that Observable calls `complete` or `error` then this method will call `complete` or `error` on the child
 * subscription. Otherwise this method will resubscribe to the source Observable.
 *
 * <img src="./img/retryWhen.png" width="100%">
 *
 * @param {function(errors: Observable): Observable} notifier - Receives an Observable of notifications with which a
 * user can `complete` or `error`, aborting the retry.
 * @return {Observable} The source Observable modified with retry logic.
 * @method retryWhen
 * @owner Observable
 */

var RetryWhenOperator = /*@__PURE__*/ (function () {
    function RetryWhenOperator(notifier, source) {
        this.notifier = notifier;
        this.source = source;
    }
    RetryWhenOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RetryWhenSubscriber(subscriber, this.notifier, this.source));
    };
    return RetryWhenOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RetryWhenSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(RetryWhenSubscriber, _super);
    function RetryWhenSubscriber(destination, notifier, source) {
        var _this = _super.call(this, destination) || this;
        _this.notifier = notifier;
        _this.source = source;
        return _this;
    }
    RetryWhenSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var errors = this.errors;
            var retries = this.retries;
            var retriesSubscription = this.retriesSubscription;
            if (!retries) {
                errors = new Subject();
                retries = tryCatch(this.notifier)(errors);
                if (retries === errorObject) {
                    return _super.prototype.error.call(this, errorObject.e);
                }
                retriesSubscription = subscribeToResult(this, retries);
            }
            else {
                this.errors = null;
                this.retriesSubscription = null;
            }
            this._unsubscribeAndRecycle();
            this.errors = errors;
            this.retries = retries;
            this.retriesSubscription = retriesSubscription;
            errors.next(err);
        }
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    RetryWhenSubscriber.prototype._unsubscribe = function () {
        var _a = this, errors = _a.errors, retriesSubscription = _a.retriesSubscription;
        if (errors) {
            errors.unsubscribe();
            this.errors = null;
        }
        if (retriesSubscription) {
            retriesSubscription.unsubscribe();
            this.retriesSubscription = null;
        }
        this.retries = null;
    };
    RetryWhenSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var _unsubscribe = this._unsubscribe;
        this._unsubscribe = null;
        this._unsubscribeAndRecycle();
        this._unsubscribe = _unsubscribe;
        this.source.subscribe(this);
    };
    return RetryWhenSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Emits the most recently emitted value from the source Observable whenever
 * another Observable, the `notifier`, emits.
 *
 * <span class="informal">It's like {@link sampleTime}, but samples whenever
 * the `notifier` Observable emits something.</span>
 *
 * <img src="./img/sample.png" width="100%">
 *
 * Whenever the `notifier` Observable emits a value or completes, `sample`
 * looks at the source Observable and emits whichever value it has most recently
 * emitted since the previous sampling, unless the source has not emitted
 * anything since the previous sampling. The `notifier` is subscribed to as soon
 * as the output Observable is subscribed.
 *
 * @example <caption>On every click, sample the most recent "seconds" timer</caption>
 * var seconds = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = seconds.sample(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {Observable<any>} notifier The Observable to use for sampling the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable whenever the notifier Observable
 * emits value or completes.
 * @method sample
 * @owner Observable
 */

var SampleOperator = /*@__PURE__*/ (function () {
    function SampleOperator(notifier) {
        this.notifier = notifier;
    }
    SampleOperator.prototype.call = function (subscriber, source) {
        var sampleSubscriber = new SampleSubscriber(subscriber);
        var subscription = source.subscribe(sampleSubscriber);
        subscription.add(subscribeToResult(sampleSubscriber, this.notifier));
        return subscription;
    };
    return SampleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleSubscriber, _super);
    function SampleSubscriber() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.hasValue = false;
        return _this;
    }
    SampleSubscriber.prototype._next = function (value) {
        this.value = value;
        this.hasValue = true;
    };
    SampleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.emitValue();
    };
    SampleSubscriber.prototype.notifyComplete = function () {
        this.emitValue();
    };
    SampleSubscriber.prototype.emitValue = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.value);
        }
    };
    return SampleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async PURE_IMPORTS_END */
/**
 * Emits the most recently emitted value from the source Observable within
 * periodic time intervals.
 *
 * <span class="informal">Samples the source Observable at periodic time
 * intervals, emitting what it samples.</span>
 *
 * <img src="./img/sampleTime.png" width="100%">
 *
 * `sampleTime` periodically looks at the source Observable and emits whichever
 * value it has most recently emitted since the previous sampling, unless the
 * source has not emitted anything since the previous sampling. The sampling
 * happens periodically in time every `period` milliseconds (or the time unit
 * defined by the optional `scheduler` argument). The sampling starts as soon as
 * the output Observable is subscribed.
 *
 * @example <caption>Every second, emit the most recent click at most once</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.sampleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {number} period The sampling period expressed in milliseconds or the
 * time unit determined internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the sampling.
 * @return {Observable<T>} An Observable that emits the results of sampling the
 * values emitted by the source Observable at the specified time interval.
 * @method sampleTime
 * @owner Observable
 */

var SampleTimeOperator = /*@__PURE__*/ (function () {
    function SampleTimeOperator(period, scheduler) {
        this.period = period;
        this.scheduler = scheduler;
    }
    SampleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SampleTimeSubscriber(subscriber, this.period, this.scheduler));
    };
    return SampleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SampleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SampleTimeSubscriber, _super);
    function SampleTimeSubscriber(destination, period, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.period = period;
        _this.scheduler = scheduler;
        _this.hasValue = false;
        _this.add(scheduler.schedule(dispatchNotification, period, { subscriber: _this, period: period }));
        return _this;
    }
    SampleTimeSubscriber.prototype._next = function (value) {
        this.lastValue = value;
        this.hasValue = true;
    };
    SampleTimeSubscriber.prototype.notifyNext = function () {
        if (this.hasValue) {
            this.hasValue = false;
            this.destination.next(this.lastValue);
        }
    };
    return SampleTimeSubscriber;
}(Subscriber));
function dispatchNotification(state) {
    var subscriber = state.subscriber, period = state.period;
    subscriber.notifyNext();
    this.schedule(state, period);
}

/** PURE_IMPORTS_START tslib,_Subscriber,_util_tryCatch,_util_errorObject PURE_IMPORTS_END */
/**
 * Compares all values of two observables in sequence using an optional comparor function
 * and returns an observable of a single boolean value representing whether or not the two sequences
 * are equal.
 *
 * <span class="informal">Checks to see of all values emitted by both observables are equal, in order.</span>
 *
 * <img src="./img/sequenceEqual.png" width="100%">
 *
 * `sequenceEqual` subscribes to two observables and buffers incoming values from each observable. Whenever either
 * observable emits a value, the value is buffered and the buffers are shifted and compared from the bottom
 * up; If any value pair doesn't match, the returned observable will emit `false` and complete. If one of the
 * observables completes, the operator will wait for the other observable to complete; If the other
 * observable emits before completing, the returned observable will emit `false` and complete. If one observable never
 * completes or emits after the other complets, the returned observable will never complete.
 *
 * @example <caption>figure out if the Konami code matches</caption>
 * var code = Rx.Observable.from([
 *  "ArrowUp",
 *  "ArrowUp",
 *  "ArrowDown",
 *  "ArrowDown",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "ArrowLeft",
 *  "ArrowRight",
 *  "KeyB",
 *  "KeyA",
 *  "Enter" // no start key, clearly.
 * ]);
 *
 * var keys = Rx.Observable.fromEvent(document, 'keyup')
 *  .map(e => e.code);
 * var matches = keys.bufferCount(11, 1)
 *  .mergeMap(
 *    last11 =>
 *      Rx.Observable.from(last11)
 *        .sequenceEqual(code)
 *   );
 * matches.subscribe(matched => console.log('Successful cheat at Contra? ', matched));
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 * @see {@link withLatestFrom}
 *
 * @param {Observable} compareTo The observable sequence to compare the source sequence to.
 * @param {function} [comparor] An optional function to compare each value pair
 * @return {Observable} An Observable of a single boolean value representing whether or not
 * the values emitted by both observables were equal in sequence.
 * @method sequenceEqual
 * @owner Observable
 */

var SequenceEqualOperator = /*@__PURE__*/ (function () {
    function SequenceEqualOperator(compareTo, comparor) {
        this.compareTo = compareTo;
        this.comparor = comparor;
    }
    SequenceEqualOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SequenceEqualSubscriber(subscriber, this.compareTo, this.comparor));
    };
    return SequenceEqualOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SequenceEqualSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualSubscriber, _super);
    function SequenceEqualSubscriber(destination, compareTo, comparor) {
        var _this = _super.call(this, destination) || this;
        _this.compareTo = compareTo;
        _this.comparor = comparor;
        _this._a = [];
        _this._b = [];
        _this._oneComplete = false;
        _this.add(compareTo.subscribe(new SequenceEqualCompareToSubscriber(destination, _this)));
        return _this;
    }
    SequenceEqualSubscriber.prototype._next = function (value) {
        if (this._oneComplete && this._b.length === 0) {
            this.emit(false);
        }
        else {
            this._a.push(value);
            this.checkValues();
        }
    };
    SequenceEqualSubscriber.prototype._complete = function () {
        if (this._oneComplete) {
            this.emit(this._a.length === 0 && this._b.length === 0);
        }
        else {
            this._oneComplete = true;
        }
    };
    SequenceEqualSubscriber.prototype.checkValues = function () {
        var _c = this, _a = _c._a, _b = _c._b, comparor = _c.comparor;
        while (_a.length > 0 && _b.length > 0) {
            var a = _a.shift();
            var b = _b.shift();
            var areEqual = false;
            if (comparor) {
                areEqual = tryCatch(comparor)(a, b);
                if (areEqual === errorObject) {
                    this.destination.error(errorObject.e);
                }
            }
            else {
                areEqual = a === b;
            }
            if (!areEqual) {
                this.emit(false);
            }
        }
    };
    SequenceEqualSubscriber.prototype.emit = function (value) {
        var destination = this.destination;
        destination.next(value);
        destination.complete();
    };
    SequenceEqualSubscriber.prototype.nextB = function (value) {
        if (this._oneComplete && this._a.length === 0) {
            this.emit(false);
        }
        else {
            this._b.push(value);
            this.checkValues();
        }
    };
    return SequenceEqualSubscriber;
}(Subscriber));
var SequenceEqualCompareToSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SequenceEqualCompareToSubscriber, _super);
    function SequenceEqualCompareToSubscriber(destination, parent) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        return _this;
    }
    SequenceEqualCompareToSubscriber.prototype._next = function (value) {
        this.parent.nextB(value);
    };
    SequenceEqualCompareToSubscriber.prototype._error = function (err) {
        this.parent.error(err);
    };
    SequenceEqualCompareToSubscriber.prototype._complete = function () {
        this.parent._complete();
    };
    return SequenceEqualCompareToSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _multicast,_refCount,_Subject PURE_IMPORTS_END */
/**
 * Returns a new Observable that multicasts (shares) the original Observable. As long as there is at least one
 * Subscriber this Observable will be subscribed and emitting data. When all subscribers have unsubscribed it will
 * unsubscribe from the source Observable. Because the Observable is multicasting it makes the stream `hot`.
 * This is an alias for .multicast(() => new Subject()).refCount().
 *
 * <img src="./img/share.png" width="100%">
 *
 * @return {Observable<T>} An Observable that upon connection causes the source Observable to emit items to its Observers.
 * @method share
 * @owner Observable
 */

/** PURE_IMPORTS_START _ReplaySubject PURE_IMPORTS_END */
/**
 * @method shareReplay
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_Subscriber,_util_EmptyError PURE_IMPORTS_END */
/**
 * Returns an Observable that emits the single item emitted by the source Observable that matches a specified
 * predicate, if that Observable emits one such item. If the source Observable emits more than one such item or no
 * items, notify of an IllegalArgumentException or NoSuchElementException respectively. If the source Observable
 * emits items but none match the specified predicate then `undefined` is emiited.
 *
 * <img src="./img/single.png" width="100%">
 *
 * @throws {EmptyError} Delivers an EmptyError to the Observer's `error`
 * callback if the Observable completes before any `next` notification was sent.
 * @param {Function} predicate - A predicate function to evaluate items emitted by the source Observable.
 * @return {Observable<T>} An Observable that emits the single item emitted by the source Observable that matches
 * the predicate or `undefined` when no items match.
 *
 * @method single
 * @owner Observable
 */

var SingleOperator = /*@__PURE__*/ (function () {
    function SingleOperator(predicate, source) {
        this.predicate = predicate;
        this.source = source;
    }
    SingleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SingleSubscriber(subscriber, this.predicate, this.source));
    };
    return SingleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SingleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SingleSubscriber, _super);
    function SingleSubscriber(destination, predicate, source) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.source = source;
        _this.seenValue = false;
        _this.index = 0;
        return _this;
    }
    SingleSubscriber.prototype.applySingleValue = function (value) {
        if (this.seenValue) {
            this.destination.error('Sequence contains more than one element');
        }
        else {
            this.seenValue = true;
            this.singleValue = value;
        }
    };
    SingleSubscriber.prototype._next = function (value) {
        var index = this.index++;
        if (this.predicate) {
            this.tryNext(value, index);
        }
        else {
            this.applySingleValue(value);
        }
    };
    SingleSubscriber.prototype.tryNext = function (value, index) {
        try {
            if (this.predicate(value, index, this.source)) {
                this.applySingleValue(value);
            }
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    SingleSubscriber.prototype._complete = function () {
        var destination = this.destination;
        if (this.index > 0) {
            destination.next(this.seenValue ? this.singleValue : undefined);
            destination.complete();
        }
        else {
            destination.error(new EmptyError);
        }
    };
    return SingleSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Returns an Observable that skips the first `count` items emitted by the source Observable.
 *
 * <img src="./img/skip.png" width="100%">
 *
 * @param {Number} count - The number of times, items emitted by source Observable should be skipped.
 * @return {Observable} An Observable that skips values emitted by the source Observable.
 *
 * @method skip
 * @owner Observable
 */

var SkipOperator = /*@__PURE__*/ (function () {
    function SkipOperator(total) {
        this.total = total;
    }
    SkipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipSubscriber(subscriber, this.total));
    };
    return SkipOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipSubscriber, _super);
    function SkipSubscriber(destination, total) {
        var _this = _super.call(this, destination) || this;
        _this.total = total;
        _this.count = 0;
        return _this;
    }
    SkipSubscriber.prototype._next = function (x) {
        if (++this.count > this.total) {
            this.destination.next(x);
        }
    };
    return SkipSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_util_ArgumentOutOfRangeError PURE_IMPORTS_END */
/**
 * Skip the last `count` values emitted by the source Observable.
 *
 * <img src="./img/skipLast.png" width="100%">
 *
 * `skipLast` returns an Observable that accumulates a queue with a length
 * enough to store the first `count` values. As more values are received,
 * values are taken from the front of the queue and produced on the result
 * sequence. This causes values to be delayed.
 *
 * @example <caption>Skip the last 2 values of an Observable with many values</caption>
 * var many = Rx.Observable.range(1, 5);
 * var skipLastTwo = many.skipLast(2);
 * skipLastTwo.subscribe(x => console.log(x));
 *
 * // Results in:
 * // 1 2 3
 *
 * @see {@link skip}
 * @see {@link skipUntil}
 * @see {@link skipWhile}
 * @see {@link take}
 *
 * @throws {ArgumentOutOfRangeError} When using `skipLast(i)`, it throws
 * ArgumentOutOrRangeError if `i < 0`.
 *
 * @param {number} count Number of elements to skip from the end of the source Observable.
 * @returns {Observable<T>} An Observable that skips the last count values
 * emitted by the source Observable.
 * @method skipLast
 * @owner Observable
 */

var SkipLastOperator = /*@__PURE__*/ (function () {
    function SkipLastOperator(_skipCount) {
        this._skipCount = _skipCount;
        if (this._skipCount < 0) {
            throw new ArgumentOutOfRangeError;
        }
    }
    SkipLastOperator.prototype.call = function (subscriber, source) {
        if (this._skipCount === 0) {
            // If we don't want to skip any values then just subscribe
            // to Subscriber without any further logic.
            return source.subscribe(new Subscriber(subscriber));
        }
        else {
            return source.subscribe(new SkipLastSubscriber(subscriber, this._skipCount));
        }
    };
    return SkipLastOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipLastSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipLastSubscriber, _super);
    function SkipLastSubscriber(destination, _skipCount) {
        var _this = _super.call(this, destination) || this;
        _this._skipCount = _skipCount;
        _this._count = 0;
        _this._ring = new Array(_skipCount);
        return _this;
    }
    SkipLastSubscriber.prototype._next = function (value) {
        var skipCount = this._skipCount;
        var count = this._count++;
        if (count < skipCount) {
            this._ring[count] = value;
        }
        else {
            var currentIndex = count % skipCount;
            var ring = this._ring;
            var oldValue = ring[currentIndex];
            ring[currentIndex] = value;
            this.destination.next(oldValue);
        }
    };
    return SkipLastSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Returns an Observable that skips items emitted by the source Observable until a second Observable emits an item.
 *
 * <img src="./img/skipUntil.png" width="100%">
 *
 * @param {Observable} notifier - The second Observable that has to emit an item before the source Observable's elements begin to
 * be mirrored by the resulting Observable.
 * @return {Observable<T>} An Observable that skips items from the source Observable until the second Observable emits
 * an item, then emits the remaining items.
 * @method skipUntil
 * @owner Observable
 */

var SkipUntilOperator = /*@__PURE__*/ (function () {
    function SkipUntilOperator(notifier) {
        this.notifier = notifier;
    }
    SkipUntilOperator.prototype.call = function (destination, source) {
        return source.subscribe(new SkipUntilSubscriber(destination, this.notifier));
    };
    return SkipUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipUntilSubscriber, _super);
    function SkipUntilSubscriber(destination, notifier) {
        var _this = _super.call(this, destination) || this;
        _this.hasValue = false;
        _this.add(_this.innerSubscription = subscribeToResult(_this, notifier));
        return _this;
    }
    SkipUntilSubscriber.prototype._next = function (value) {
        if (this.hasValue) {
            _super.prototype._next.call(this, value);
        }
    };
    SkipUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.hasValue = true;
        if (this.innerSubscription) {
            this.innerSubscription.unsubscribe();
        }
    };
    SkipUntilSubscriber.prototype.notifyComplete = function () {
        /* do nothing */
    };
    return SkipUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Returns an Observable that skips all items emitted by the source Observable as long as a specified condition holds
 * true, but emits all further source items as soon as the condition becomes false.
 *
 * <img src="./img/skipWhile.png" width="100%">
 *
 * @param {Function} predicate - A function to test each item emitted from the source Observable.
 * @return {Observable<T>} An Observable that begins emitting items emitted by the source Observable when the
 * specified predicate becomes false.
 * @method skipWhile
 * @owner Observable
 */

var SkipWhileOperator = /*@__PURE__*/ (function () {
    function SkipWhileOperator(predicate) {
        this.predicate = predicate;
    }
    SkipWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SkipWhileSubscriber(subscriber, this.predicate));
    };
    return SkipWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SkipWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SkipWhileSubscriber, _super);
    function SkipWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.skipping = true;
        _this.index = 0;
        return _this;
    }
    SkipWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        if (this.skipping) {
            this.tryCallPredicate(value);
        }
        if (!this.skipping) {
            destination.next(value);
        }
    };
    SkipWhileSubscriber.prototype.tryCallPredicate = function (value) {
        try {
            var result = this.predicate(value, this.index++);
            this.skipping = Boolean(result);
        }
        catch (err) {
            this.destination.error(err);
        }
    };
    return SkipWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START _observable_fromArray,_observable_scalar,_observable_empty,_observable_concat,_util_isScheduler PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Returns an Observable that emits the items you specify as arguments before it begins to emit
 * items emitted by the source Observable.
 *
 * <img src="./img/startWith.png" width="100%">
 *
 * @param {...T} values - Items you want the modified Observable to emit first.
 * @param {Scheduler} [scheduler] - A {@link IScheduler} to use for scheduling
 * the emissions of the `next` notifications.
 * @return {Observable} An Observable that emits the items in the specified Iterable and then emits the items
 * emitted by the source Observable.
 * @method startWith
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_Observable,_scheduler_asap,_util_isNumeric PURE_IMPORTS_END */
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @extends {Ignored}
 * @hide true
 */
var SubscribeOnObservable = /*@__PURE__*/ (function (_super) {
    __extends(SubscribeOnObservable, _super);
    function SubscribeOnObservable(source, delayTime, scheduler) {
        if (delayTime === void 0) {
            delayTime = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.delayTime = delayTime;
        _this.scheduler = scheduler;
        if (!isNumeric(delayTime) || delayTime < 0) {
            _this.delayTime = 0;
        }
        if (!scheduler || typeof scheduler.schedule !== 'function') {
            _this.scheduler = asap;
        }
        return _this;
    }
    /** @nocollapse */
    SubscribeOnObservable.create = function (source, delay, scheduler) {
        if (delay === void 0) {
            delay = 0;
        }
        if (scheduler === void 0) {
            scheduler = asap;
        }
        return new SubscribeOnObservable(source, delay, scheduler);
    };
    /** @nocollapse */
    SubscribeOnObservable.dispatch = function (arg) {
        var source = arg.source, subscriber = arg.subscriber;
        return this.add(source.subscribe(subscriber));
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    SubscribeOnObservable.prototype._subscribe = function (subscriber) {
        var delay = this.delayTime;
        var source = this.source;
        var scheduler = this.scheduler;
        return scheduler.schedule(SubscribeOnObservable.dispatch, delay, {
            source: source, subscriber: subscriber
        });
    };
    return SubscribeOnObservable;
}(Observable));

/** PURE_IMPORTS_START _observable_SubscribeOnObservable PURE_IMPORTS_END */
/**
 * Asynchronously subscribes Observers to this Observable on the specified IScheduler.
 *
 * <img src="./img/subscribeOn.png" width="100%">
 *
 * @param {Scheduler} scheduler - The IScheduler to perform subscription actions on.
 * @return {Observable<T>} The source Observable modified so that its subscriptions happen on the specified IScheduler.
 .
 * @method subscribeOn
 * @owner Observable
 */

var SubscribeOnOperator = /*@__PURE__*/ (function () {
    function SubscribeOnOperator(scheduler, delay) {
        this.scheduler = scheduler;
        this.delay = delay;
    }
    SubscribeOnOperator.prototype.call = function (subscriber, source) {
        return new SubscribeOnObservable(source, this.delay, this.scheduler).subscribe(subscriber);
    };
    return SubscribeOnOperator;
}());

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult,_map,_observable_from PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable, emitting values only from the most recently projected Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link switch}.</span>
 *
 * <img src="./img/switchMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an (so-called "inner") Observable. Each time it observes one of these
 * inner Observables, the output Observable begins emitting the items emitted by
 * that inner Observable. When a new inner Observable is emitted, `switchMap`
 * stops emitting items from the earlier-emitted inner Observable and begins
 * emitting items from the new one. It continues to behave like this for
 * subsequent inner Observables.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMap((ev) => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link mergeMap}
 * @see {@link switch}
 * @see {@link switchMapTo}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and taking only the values from the most recently
 * projected inner Observable.
 * @method switchMap
 * @owner Observable
 */

var SwitchMapOperator = /*@__PURE__*/ (function () {
    function SwitchMapOperator(project) {
        this.project = project;
    }
    SwitchMapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new SwitchMapSubscriber(subscriber, this.project));
    };
    return SwitchMapOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SwitchMapSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(SwitchMapSubscriber, _super);
    function SwitchMapSubscriber(destination, project) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.index = 0;
        return _this;
    }
    SwitchMapSubscriber.prototype._next = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (error) {
            this.destination.error(error);
            return;
        }
        this._innerSub(result, value, index);
    };
    SwitchMapSubscriber.prototype._innerSub = function (result, value, index) {
        var innerSubscription = this.innerSubscription;
        if (innerSubscription) {
            innerSubscription.unsubscribe();
        }
        this.add(this.innerSubscription = subscribeToResult(this, result, value, index));
    };
    SwitchMapSubscriber.prototype._complete = function () {
        var innerSubscription = this.innerSubscription;
        if (!innerSubscription || innerSubscription.closed) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype._unsubscribe = function () {
        this.innerSubscription = null;
    };
    SwitchMapSubscriber.prototype.notifyComplete = function (innerSub) {
        this.remove(innerSub);
        this.innerSubscription = null;
        if (this.isStopped) {
            _super.prototype._complete.call(this);
        }
    };
    SwitchMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    return SwitchMapSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _switchMap,_util_identity PURE_IMPORTS_END */

/** PURE_IMPORTS_START _switchMap PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Projects each source value to the same Observable which is flattened multiple
 * times with {@link switch} in the output Observable.
 *
 * <span class="informal">It's like {@link switchMap}, but maps each value
 * always to the same inner Observable.</span>
 *
 * <img src="./img/switchMapTo.png" width="100%">
 *
 * Maps each source value to the given Observable `innerObservable` regardless
 * of the source value, and then flattens those resulting Observables into one
 * single Observable, which is the output Observable. The output Observables
 * emits values only from the most recently emitted instance of
 * `innerObservable`.
 *
 * @example <caption>Rerun an interval Observable on every click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.switchMapTo(Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link concatMapTo}
 * @see {@link switch}
 * @see {@link switchMap}
 * @see {@link mergeMapTo}
 *
 * @param {ObservableInput} innerObservable An Observable to replace each value from
 * the source Observable.
 * @return {Observable} An Observable that emits items from the given
 * `innerObservable` (and optionally transformed through `resultSelector`) every
 * time a value is emitted on the source Observable, and taking only the values
 * from the most recently projected inner Observable.
 * @method switchMapTo
 * @owner Observable
 */

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Emits the values emitted by the source Observable until a `notifier`
 * Observable emits a value.
 *
 * <span class="informal">Lets values pass until a second Observable,
 * `notifier`, emits a value. Then, it completes.</span>
 *
 * <img src="./img/takeUntil.png" width="100%">
 *
 * `takeUntil` subscribes and begins mirroring the source Observable. It also
 * monitors a second Observable, `notifier` that you provide. If the `notifier`
 * emits a value, the output Observable stops mirroring the source Observable
 * and completes. If the `notifier` doesn't emit any value and completes
 * then `takeUntil` will pass all values.
 *
 * @example <caption>Tick every second until the first click happens</caption>
 * var interval = Rx.Observable.interval(1000);
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = interval.takeUntil(clicks);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeWhile}
 * @see {@link skip}
 *
 * @param {Observable} notifier The Observable whose first emitted value will
 * cause the output Observable of `takeUntil` to stop emitting values from the
 * source Observable.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable until such time as `notifier` emits its first value.
 * @method takeUntil
 * @owner Observable
 */

var TakeUntilOperator = /*@__PURE__*/ (function () {
    function TakeUntilOperator(notifier) {
        this.notifier = notifier;
    }
    TakeUntilOperator.prototype.call = function (subscriber, source) {
        var takeUntilSubscriber = new TakeUntilSubscriber(subscriber);
        var notifierSubscription = subscribeToResult(takeUntilSubscriber, this.notifier);
        if (notifierSubscription && !notifierSubscription.closed) {
            takeUntilSubscriber.add(notifierSubscription);
            return source.subscribe(takeUntilSubscriber);
        }
        return takeUntilSubscriber;
    };
    return TakeUntilOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeUntilSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeUntilSubscriber, _super);
    function TakeUntilSubscriber(destination) {
        return _super.call(this, destination) || this;
    }
    TakeUntilSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.complete();
    };
    TakeUntilSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    return TakeUntilSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber PURE_IMPORTS_END */
/**
 * Emits values emitted by the source Observable so long as each value satisfies
 * the given `predicate`, and then completes as soon as this `predicate` is not
 * satisfied.
 *
 * <span class="informal">Takes values from the source only while they pass the
 * condition given. When the first value does not satisfy, it completes.</span>
 *
 * <img src="./img/takeWhile.png" width="100%">
 *
 * `takeWhile` subscribes and begins mirroring the source Observable. Each value
 * emitted on the source is given to the `predicate` function which returns a
 * boolean, representing a condition to be satisfied by the source values. The
 * output Observable emits the source values until such time as the `predicate`
 * returns false, at which point `takeWhile` stops mirroring the source
 * Observable and completes the output Observable.
 *
 * @example <caption>Emit click events only while the clientX property is greater than 200</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.takeWhile(ev => ev.clientX > 200);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link take}
 * @see {@link takeLast}
 * @see {@link takeUntil}
 * @see {@link skip}
 *
 * @param {function(value: T, index: number): boolean} predicate A function that
 * evaluates a value emitted by the source Observable and returns a boolean.
 * Also takes the (zero-based) index as the second argument.
 * @return {Observable<T>} An Observable that emits the values from the source
 * Observable so long as each value satisfies the condition defined by the
 * `predicate`, then completes.
 * @method takeWhile
 * @owner Observable
 */

var TakeWhileOperator = /*@__PURE__*/ (function () {
    function TakeWhileOperator(predicate) {
        this.predicate = predicate;
    }
    TakeWhileOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TakeWhileSubscriber(subscriber, this.predicate));
    };
    return TakeWhileOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TakeWhileSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TakeWhileSubscriber, _super);
    function TakeWhileSubscriber(destination, predicate) {
        var _this = _super.call(this, destination) || this;
        _this.predicate = predicate;
        _this.index = 0;
        return _this;
    }
    TakeWhileSubscriber.prototype._next = function (value) {
        var destination = this.destination;
        var result;
        try {
            result = this.predicate(value, this.index++);
        }
        catch (err) {
            destination.error(err);
            return;
        }
        this.nextOrComplete(value, result);
    };
    TakeWhileSubscriber.prototype.nextOrComplete = function (value, predicateResult) {
        var destination = this.destination;
        if (Boolean(predicateResult)) {
            destination.next(value);
        }
        else {
            destination.complete();
        }
    };
    return TakeWhileSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */

/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for a duration determined by another Observable, then repeats this
 * process.
 *
 * <span class="informal">It's like {@link throttleTime}, but the silencing
 * duration is determined by a second Observable.</span>
 *
 * <img src="./img/throttle.png" width="100%">
 *
 * `throttle` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled by calling the `durationSelector` function with the source value,
 * which returns the "duration" Observable. When the duration Observable emits a
 * value or completes, the timer is disabled, and this process repeats for the
 * next source value.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttle(ev => Rx.Observable.interval(1000));
 * result.subscribe(x => console.log(x));
 *
 * @see {@link audit}
 * @see {@link debounce}
 * @see {@link delayWhen}
 * @see {@link sample}
 * @see {@link throttleTime}
 *
 * @param {function(value: T): SubscribableOrPromise} durationSelector A function
 * that receives a value from the source Observable, for computing the silencing
 * duration for each source value, returned as an Observable or a Promise.
 * @param {Object} config a configuration object to define `leading` and `trailing` behavior. Defaults
 * to `{ leading: true, trailing: false }`.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttle
 * @owner Observable
 */

var ThrottleOperator = /*@__PURE__*/ (function () {
    function ThrottleOperator(durationSelector, leading, trailing) {
        this.durationSelector = durationSelector;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleSubscriber(subscriber, this.durationSelector, this.leading, this.trailing));
    };
    return ThrottleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc
 * @ignore
 * @extends {Ignored}
 */
var ThrottleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleSubscriber, _super);
    function ThrottleSubscriber(destination, durationSelector, _leading, _trailing) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.durationSelector = durationSelector;
        _this._leading = _leading;
        _this._trailing = _trailing;
        _this._hasValue = false;
        return _this;
    }
    ThrottleSubscriber.prototype._next = function (value) {
        this._hasValue = true;
        this._sendValue = value;
        if (!this._throttled) {
            if (this._leading) {
                this.send();
            }
            else {
                this.throttle(value);
            }
        }
    };
    ThrottleSubscriber.prototype.send = function () {
        var _a = this, _hasValue = _a._hasValue, _sendValue = _a._sendValue;
        if (_hasValue) {
            this.destination.next(_sendValue);
            this.throttle(_sendValue);
        }
        this._hasValue = false;
        this._sendValue = null;
    };
    ThrottleSubscriber.prototype.throttle = function (value) {
        var duration = this.tryDurationSelector(value);
        if (duration) {
            this.add(this._throttled = subscribeToResult(this, duration));
        }
    };
    ThrottleSubscriber.prototype.tryDurationSelector = function (value) {
        try {
            return this.durationSelector(value);
        }
        catch (err) {
            this.destination.error(err);
            return null;
        }
    };
    ThrottleSubscriber.prototype.throttlingDone = function () {
        var _a = this, _throttled = _a._throttled, _trailing = _a._trailing;
        if (_throttled) {
            _throttled.unsubscribe();
        }
        this._throttled = null;
        if (_trailing) {
            this.send();
        }
    };
    ThrottleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.throttlingDone();
    };
    ThrottleSubscriber.prototype.notifyComplete = function () {
        this.throttlingDone();
    };
    return ThrottleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_scheduler_async,_throttle PURE_IMPORTS_END */
/**
 * Emits a value from the source Observable, then ignores subsequent source
 * values for `duration` milliseconds, then repeats this process.
 *
 * <span class="informal">Lets a value pass, then ignores source values for the
 * next `duration` milliseconds.</span>
 *
 * <img src="./img/throttleTime.png" width="100%">
 *
 * `throttleTime` emits the source Observable values on the output Observable
 * when its internal timer is disabled, and ignores source values when the timer
 * is enabled. Initially, the timer is disabled. As soon as the first source
 * value arrives, it is forwarded to the output Observable, and then the timer
 * is enabled. After `duration` milliseconds (or the time unit determined
 * internally by the optional `scheduler`) has passed, the timer is disabled,
 * and this process repeats for the next source value. Optionally takes a
 * {@link IScheduler} for managing timers.
 *
 * @example <caption>Emit clicks at a rate of at most one click per second</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.throttleTime(1000);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link auditTime}
 * @see {@link debounceTime}
 * @see {@link delay}
 * @see {@link sampleTime}
 * @see {@link throttle}
 *
 * @param {number} duration Time to wait before emitting another value after
 * emitting the last value, measured in milliseconds or the time unit determined
 * internally by the optional `scheduler`.
 * @param {Scheduler} [scheduler=async] The {@link IScheduler} to use for
 * managing the timers that handle the throttling.
 * @param {Object} config a configuration object to define `leading` and
 * `trailing` behavior. Defaults to `{ leading: true, trailing: false }`.
 * @return {Observable<T>} An Observable that performs the throttle operation to
 * limit the rate of emissions from the source.
 * @method throttleTime
 * @owner Observable
 */

var ThrottleTimeOperator = /*@__PURE__*/ (function () {
    function ThrottleTimeOperator(duration, scheduler, leading, trailing) {
        this.duration = duration;
        this.scheduler = scheduler;
        this.leading = leading;
        this.trailing = trailing;
    }
    ThrottleTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ThrottleTimeSubscriber(subscriber, this.duration, this.scheduler, this.leading, this.trailing));
    };
    return ThrottleTimeOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ThrottleTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(ThrottleTimeSubscriber, _super);
    function ThrottleTimeSubscriber(destination, duration, scheduler, leading, trailing) {
        var _this = _super.call(this, destination) || this;
        _this.duration = duration;
        _this.scheduler = scheduler;
        _this.leading = leading;
        _this.trailing = trailing;
        _this._hasTrailingValue = false;
        _this._trailingValue = null;
        return _this;
    }
    ThrottleTimeSubscriber.prototype._next = function (value) {
        if (this.throttled) {
            if (this.trailing) {
                this._trailingValue = value;
                this._hasTrailingValue = true;
            }
        }
        else {
            this.add(this.throttled = this.scheduler.schedule(dispatchNext$3, this.duration, { subscriber: this }));
            if (this.leading) {
                this.destination.next(value);
            }
        }
    };
    ThrottleTimeSubscriber.prototype._complete = function () {
        if (this._hasTrailingValue) {
            this.destination.next(this._trailingValue);
            this.destination.complete();
        }
        else {
            this.destination.complete();
        }
    };
    ThrottleTimeSubscriber.prototype.clearThrottle = function () {
        var throttled = this.throttled;
        if (throttled) {
            if (this.trailing && this._hasTrailingValue) {
                this.destination.next(this._trailingValue);
                this._trailingValue = null;
                this._hasTrailingValue = false;
            }
            throttled.unsubscribe();
            this.remove(throttled);
            this.throttled = null;
        }
    };
    return ThrottleTimeSubscriber;
}(Subscriber));
function dispatchNext$3(arg) {
    var subscriber = arg.subscriber;
    subscriber.clearThrottle();
}

/** PURE_IMPORTS_START _scheduler_async,_scan,_observable_defer,_map PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_scheduler_async,_util_isDate,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 *
 * Errors if Observable does not emit a value in given time span, in case of which
 * subscribes to the second Observable.
 *
 * <span class="informal">It's a version of `timeout` operator that let's you specify fallback Observable.</span>
 *
 * <img src="./img/timeoutWith.png" width="100%">
 *
 * `timeoutWith` is a variation of `timeout` operator. It behaves exactly the same,
 * still accepting as a first argument either a number or a Date, which control - respectively -
 * when values of source Observable should be emitted or when it should complete.
 *
 * The only difference is that it accepts a second, required parameter. This parameter
 * should be an Observable which will be subscribed when source Observable fails any timeout check.
 * So whenever regular `timeout` would emit an error, `timeoutWith` will instead start re-emitting
 * values from second Observable. Note that this fallback Observable is not checked for timeouts
 * itself, so it can emit values and complete at arbitrary points in time. From the moment of a second
 * subscription, Observable returned from `timeoutWith` simply mirrors fallback stream. When that
 * stream completes, it completes as well.
 *
 * Scheduler, which in case of `timeout` is provided as as second argument, can be still provided
 * here - as a third, optional parameter. It still is used to schedule timeout checks and -
 * as a consequence - when second Observable will be subscribed, since subscription happens
 * immediately after failing check.
 *
 * @example <caption>Add fallback observable</caption>
 * const seconds = Rx.Observable.interval(1000);
 * const minutes = Rx.Observable.interval(60 * 1000);
 *
 * seconds.timeoutWith(900, minutes)
 *     .subscribe(
 *         value => console.log(value), // After 900ms, will start emitting `minutes`,
 *                                      // since first value of `seconds` will not arrive fast enough.
 *         err => console.log(err) // Would be called after 900ms in case of `timeout`,
 *                                 // but here will never be called.
 *     );
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Observable<T>} withObservable Observable which will be subscribed if source fails timeout check.
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source or, when timeout check fails, of an Observable
 *                          passed as a second parameter.
 * @method timeoutWith
 * @owner Observable
 */

var TimeoutWithOperator = /*@__PURE__*/ (function () {
    function TimeoutWithOperator(waitFor, absoluteTimeout, withObservable, scheduler) {
        this.waitFor = waitFor;
        this.absoluteTimeout = absoluteTimeout;
        this.withObservable = withObservable;
        this.scheduler = scheduler;
    }
    TimeoutWithOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new TimeoutWithSubscriber(subscriber, this.absoluteTimeout, this.waitFor, this.withObservable, this.scheduler));
    };
    return TimeoutWithOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var TimeoutWithSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(TimeoutWithSubscriber, _super);
    function TimeoutWithSubscriber(destination, absoluteTimeout, waitFor, withObservable, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.absoluteTimeout = absoluteTimeout;
        _this.waitFor = waitFor;
        _this.withObservable = withObservable;
        _this.scheduler = scheduler;
        _this.action = null;
        _this.scheduleTimeout();
        return _this;
    }
    TimeoutWithSubscriber.dispatchTimeout = function (subscriber) {
        var withObservable = subscriber.withObservable;
        subscriber._unsubscribeAndRecycle();
        subscriber.add(subscribeToResult(subscriber, withObservable));
    };
    TimeoutWithSubscriber.prototype.scheduleTimeout = function () {
        var action = this.action;
        if (action) {
            // Recycle the action if we've already scheduled one. All the production
            // Scheduler Actions mutate their state/delay time and return themeselves.
            // VirtualActions are immutable, so they create and return a clone. In this
            // case, we need to set the action reference to the most recent VirtualAction,
            // to ensure that's the one we clone from next time.
            this.action = action.schedule(this, this.waitFor);
        }
        else {
            this.add(this.action = this.scheduler.schedule(TimeoutWithSubscriber.dispatchTimeout, this.waitFor, this));
        }
    };
    TimeoutWithSubscriber.prototype._next = function (value) {
        if (!this.absoluteTimeout) {
            this.scheduleTimeout();
        }
        _super.prototype._next.call(this, value);
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    TimeoutWithSubscriber.prototype._unsubscribe = function () {
        this.action = null;
        this.scheduler = null;
        this.withObservable = null;
    };
    return TimeoutWithSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _scheduler_async,_util_TimeoutError,_timeoutWith,_observable_throwError PURE_IMPORTS_END */
/**
 *
 * Errors if Observable does not emit a value in given time span.
 *
 * <span class="informal">Timeouts on Observable that doesn't emit values fast enough.</span>
 *
 * <img src="./img/timeout.png" width="100%">
 *
 * `timeout` operator accepts as an argument either a number or a Date.
 *
 * If number was provided, it returns an Observable that behaves like a source
 * Observable, unless there is a period of time where there is no value emitted.
 * So if you provide `100` as argument and first value comes after 50ms from
 * the moment of subscription, this value will be simply re-emitted by the resulting
 * Observable. If however after that 100ms passes without a second value being emitted,
 * stream will end with an error and source Observable will be unsubscribed.
 * These checks are performed throughout whole lifecycle of Observable - from the moment
 * it was subscribed to, until it completes or errors itself. Thus every value must be
 * emitted within specified period since previous value.
 *
 * If provided argument was Date, returned Observable behaves differently. It throws
 * if Observable did not complete before provided Date. This means that periods between
 * emission of particular values do not matter in this case. If Observable did not complete
 * before provided Date, source Observable will be unsubscribed. Other than that, resulting
 * stream behaves just as source Observable.
 *
 * `timeout` accepts also a Scheduler as a second parameter. It is used to schedule moment (or moments)
 * when returned Observable will check if source stream emitted value or completed.
 *
 * @example <caption>Check if ticks are emitted within certain timespan</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(1100) // Let's use bigger timespan to be safe,
 *                       // since `interval` might fire a bit later then scheduled.
 * .subscribe(
 *     value => console.log(value), // Will emit numbers just as regular `interval` would.
 *     err => console.log(err) // Will never be called.
 * );
 *
 * seconds.timeout(900).subscribe(
 *     value => console.log(value), // Will never be called.
 *     err => console.log(err) // Will emit error before even first value is emitted,
 *                             // since it did not arrive within 900ms period.
 * );
 *
 * @example <caption>Use Date to check if Observable completed</caption>
 * const seconds = Rx.Observable.interval(1000);
 *
 * seconds.timeout(new Date("December 17, 2020 03:24:00"))
 * .subscribe(
 *     value => console.log(value), // Will emit values as regular `interval` would
 *                                  // until December 17, 2020 at 03:24:00.
 *     err => console.log(err) // On December 17, 2020 at 03:24:00 it will emit an error,
 *                             // since Observable did not complete by then.
 * );
 *
 * @see {@link timeoutWith}
 *
 * @param {number|Date} due Number specifying period within which Observable must emit values
 *                          or Date specifying before when Observable should complete
 * @param {Scheduler} [scheduler] Scheduler controlling when timeout checks occur.
 * @return {Observable<T>} Observable that mirrors behaviour of source, unless timeout checks fail.
 * @method timeout
 * @owner Observable
 */

/** PURE_IMPORTS_START _scheduler_async,_map PURE_IMPORTS_END */
/**
 * @param scheduler
 * @return {Observable<Timestamp<any>>|WebSocketSubject<T>|Observable<T>}
 * @method timestamp
 * @owner Observable
 */

/** PURE_IMPORTS_START _reduce PURE_IMPORTS_END */

/** PURE_IMPORTS_START tslib,_Subject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Branch out the source Observable values as a nested Observable whenever
 * `windowBoundaries` emits.
 *
 * <span class="informal">It's like {@link buffer}, but emits a nested Observable
 * instead of an array.</span>
 *
 * <img src="./img/window.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping
 * windows. It emits the current window and opens a new one whenever the
 * Observable `windowBoundaries` emits an item. Because each window is an
 * Observable, the output is a higher-order Observable.
 *
 * @example <caption>In every window of 1 second each, emit at most 2 click events</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var interval = Rx.Observable.interval(1000);
 * var result = clicks.window(interval)
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link buffer}
 *
 * @param {Observable<any>} windowBoundaries An Observable that completes the
 * previous window and starts a new window.
 * @return {Observable<Observable<T>>} An Observable of windows, which are
 * Observables emitting values of the source Observable.
 * @method window
 * @owner Observable
 */

var WindowOperator = /*@__PURE__*/ (function () {
    function WindowOperator(windowBoundaries) {
        this.windowBoundaries = windowBoundaries;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        var windowSubscriber = new WindowSubscriber(subscriber);
        var sourceSubscription = source.subscribe(windowSubscriber);
        if (!sourceSubscription.closed) {
            windowSubscriber.add(subscribeToResult(windowSubscriber, this.windowBoundaries));
        }
        return sourceSubscription;
    };
    return WindowOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.window = new Subject();
        destination.next(_this.window);
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow();
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this._complete();
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    WindowSubscriber.prototype._unsubscribe = function () {
        this.window = null;
    };
    WindowSubscriber.prototype.openWindow = function () {
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var destination = this.destination;
        var newWindow = this.window = new Subject();
        destination.next(newWindow);
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subscriber,_Subject PURE_IMPORTS_END */
/**
 * Branch out the source Observable values as a nested Observable with each
 * nested Observable emitting at most `windowSize` values.
 *
 * <span class="informal">It's like {@link bufferCount}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowCount.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows every `startWindowEvery`
 * items, each containing no more than `windowSize` items. When the source
 * Observable completes or encounters an error, the output Observable emits
 * the current window and propagates the notification from the source
 * Observable. If `startWindowEvery` is not provided, then new windows are
 * started immediately at the start of the source and when each window completes
 * with size `windowSize`.
 *
 * @example <caption>Ignore every 3rd click event, starting from the first one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(3)
 *   .map(win => win.skip(1)) // skip first of every 3 clicks
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Ignore every 3rd click event, starting from the third one</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks.windowCount(2, 3)
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link windowWhen}
 * @see {@link bufferCount}
 *
 * @param {number} windowSize The maximum number of values emitted by each
 * window.
 * @param {number} [startWindowEvery] Interval at which to start a new window.
 * For example if `startWindowEvery` is `2`, then a new window will be started
 * on every other value from the source. A new window is started at the
 * beginning of the source by default.
 * @return {Observable<Observable<T>>} An Observable of windows, which in turn
 * are Observable of values.
 * @method windowCount
 * @owner Observable
 */

var WindowCountOperator = /*@__PURE__*/ (function () {
    function WindowCountOperator(windowSize, startWindowEvery) {
        this.windowSize = windowSize;
        this.startWindowEvery = startWindowEvery;
    }
    WindowCountOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowCountSubscriber(subscriber, this.windowSize, this.startWindowEvery));
    };
    return WindowCountOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowCountSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowCountSubscriber, _super);
    function WindowCountSubscriber(destination, windowSize, startWindowEvery) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowSize = windowSize;
        _this.startWindowEvery = startWindowEvery;
        _this.windows = [new Subject()];
        _this.count = 0;
        destination.next(_this.windows[0]);
        return _this;
    }
    WindowCountSubscriber.prototype._next = function (value) {
        var startWindowEvery = (this.startWindowEvery > 0) ? this.startWindowEvery : this.windowSize;
        var destination = this.destination;
        var windowSize = this.windowSize;
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len && !this.closed; i++) {
            windows[i].next(value);
        }
        var c = this.count - windowSize + 1;
        if (c >= 0 && c % startWindowEvery === 0 && !this.closed) {
            windows.shift().complete();
        }
        if (++this.count % startWindowEvery === 0 && !this.closed) {
            var window_1 = new Subject();
            windows.push(window_1);
            destination.next(window_1);
        }
    };
    WindowCountSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().error(err);
            }
        }
        this.destination.error(err);
    };
    WindowCountSubscriber.prototype._complete = function () {
        var windows = this.windows;
        if (windows) {
            while (windows.length > 0 && !this.closed) {
                windows.shift().complete();
            }
        }
        this.destination.complete();
    };
    WindowCountSubscriber.prototype._unsubscribe = function () {
        this.count = 0;
        this.windows = null;
    };
    return WindowCountSubscriber;
}(Subscriber));

/** PURE_IMPORTS_START tslib,_Subject,_scheduler_async,_Subscriber,_util_isNumeric,_util_isScheduler PURE_IMPORTS_END */

var WindowTimeOperator = /*@__PURE__*/ (function () {
    function WindowTimeOperator(windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        this.windowTimeSpan = windowTimeSpan;
        this.windowCreationInterval = windowCreationInterval;
        this.maxWindowSize = maxWindowSize;
        this.scheduler = scheduler;
    }
    WindowTimeOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowTimeSubscriber(subscriber, this.windowTimeSpan, this.windowCreationInterval, this.maxWindowSize, this.scheduler));
    };
    return WindowTimeOperator;
}());
var CountedSubject = /*@__PURE__*/ (function (_super) {
    __extends(CountedSubject, _super);
    function CountedSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._numberOfNextedValues = 0;
        return _this;
    }
    CountedSubject.prototype.next = function (value) {
        this._numberOfNextedValues++;
        _super.prototype.next.call(this, value);
    };
    Object.defineProperty(CountedSubject.prototype, "numberOfNextedValues", {
        get: function () {
            return this._numberOfNextedValues;
        },
        enumerable: true,
        configurable: true
    });
    return CountedSubject;
}(Subject));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowTimeSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowTimeSubscriber, _super);
    function WindowTimeSubscriber(destination, windowTimeSpan, windowCreationInterval, maxWindowSize, scheduler) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.windowTimeSpan = windowTimeSpan;
        _this.windowCreationInterval = windowCreationInterval;
        _this.maxWindowSize = maxWindowSize;
        _this.scheduler = scheduler;
        _this.windows = [];
        var window = _this.openWindow();
        if (windowCreationInterval !== null && windowCreationInterval >= 0) {
            var closeState = { subscriber: _this, window: window, context: null };
            var creationState = { windowTimeSpan: windowTimeSpan, windowCreationInterval: windowCreationInterval, subscriber: _this, scheduler: scheduler };
            _this.add(scheduler.schedule(dispatchWindowClose, windowTimeSpan, closeState));
            _this.add(scheduler.schedule(dispatchWindowCreation, windowCreationInterval, creationState));
        }
        else {
            var timeSpanOnlyState = { subscriber: _this, window: window, windowTimeSpan: windowTimeSpan };
            _this.add(scheduler.schedule(dispatchWindowTimeSpanOnly, windowTimeSpan, timeSpanOnlyState));
        }
        return _this;
    }
    WindowTimeSubscriber.prototype._next = function (value) {
        var windows = this.windows;
        var len = windows.length;
        for (var i = 0; i < len; i++) {
            var window_1 = windows[i];
            if (!window_1.closed) {
                window_1.next(value);
                if (window_1.numberOfNextedValues >= this.maxWindowSize) {
                    this.closeWindow(window_1);
                }
            }
        }
    };
    WindowTimeSubscriber.prototype._error = function (err) {
        var windows = this.windows;
        while (windows.length > 0) {
            windows.shift().error(err);
        }
        this.destination.error(err);
    };
    WindowTimeSubscriber.prototype._complete = function () {
        var windows = this.windows;
        while (windows.length > 0) {
            var window_2 = windows.shift();
            if (!window_2.closed) {
                window_2.complete();
            }
        }
        this.destination.complete();
    };
    WindowTimeSubscriber.prototype.openWindow = function () {
        var window = new CountedSubject();
        this.windows.push(window);
        var destination = this.destination;
        destination.next(window);
        return window;
    };
    WindowTimeSubscriber.prototype.closeWindow = function (window) {
        window.complete();
        var windows = this.windows;
        windows.splice(windows.indexOf(window), 1);
    };
    return WindowTimeSubscriber;
}(Subscriber));
function dispatchWindowTimeSpanOnly(state) {
    var subscriber = state.subscriber, windowTimeSpan = state.windowTimeSpan, window = state.window;
    if (window) {
        subscriber.closeWindow(window);
    }
    state.window = subscriber.openWindow();
    this.schedule(state, windowTimeSpan);
}
function dispatchWindowCreation(state) {
    var windowTimeSpan = state.windowTimeSpan, subscriber = state.subscriber, scheduler = state.scheduler, windowCreationInterval = state.windowCreationInterval;
    var window = subscriber.openWindow();
    var action = this;
    var context = { action: action, subscription: null };
    var timeSpanState = { subscriber: subscriber, window: window, context: context };
    context.subscription = scheduler.schedule(dispatchWindowClose, windowTimeSpan, timeSpanState);
    action.add(context.subscription);
    action.schedule(state, windowCreationInterval);
}
function dispatchWindowClose(state) {
    var subscriber = state.subscriber, window = state.window, context = state.context;
    if (context && context.action && context.subscription) {
        context.action.remove(context.subscription);
    }
    subscriber.closeWindow(window);
}

/** PURE_IMPORTS_START tslib,_Subject,_Subscription,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Branch out the source Observable values as a nested Observable starting from
 * an emission from `openings` and ending when the output of `closingSelector`
 * emits.
 *
 * <span class="informal">It's like {@link bufferToggle}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowToggle.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits windows that contain those items
 * emitted by the source Observable between the time when the `openings`
 * Observable emits an item and when the Observable returned by
 * `closingSelector` emits an item.
 *
 * @example <caption>Every other second, emit the click events from the next 500ms</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var openings = Rx.Observable.interval(1000);
 * var result = clicks.windowToggle(openings, i =>
 *   i % 2 ? Rx.Observable.interval(500) : Rx.Observable.empty()
 * ).mergeAll();
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowWhen}
 * @see {@link bufferToggle}
 *
 * @param {Observable<O>} openings An observable of notifications to start new
 * windows.
 * @param {function(value: O): Observable} closingSelector A function that takes
 * the value emitted by the `openings` observable and returns an Observable,
 * which, when it emits (either `next` or `complete`), signals that the
 * associated window should complete.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowToggle
 * @owner Observable
 */

var WindowToggleOperator = /*@__PURE__*/ (function () {
    function WindowToggleOperator(openings, closingSelector) {
        this.openings = openings;
        this.closingSelector = closingSelector;
    }
    WindowToggleOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowToggleSubscriber(subscriber, this.openings, this.closingSelector));
    };
    return WindowToggleOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowToggleSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WindowToggleSubscriber, _super);
    function WindowToggleSubscriber(destination, openings, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.openings = openings;
        _this.closingSelector = closingSelector;
        _this.contexts = [];
        _this.add(_this.openSubscription = subscribeToResult(_this, openings, openings));
        return _this;
    }
    WindowToggleSubscriber.prototype._next = function (value) {
        var contexts = this.contexts;
        if (contexts) {
            var len = contexts.length;
            for (var i = 0; i < len; i++) {
                contexts[i].window.next(value);
            }
        }
    };
    WindowToggleSubscriber.prototype._error = function (err) {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_1 = contexts[index];
                context_1.window.error(err);
                context_1.subscription.unsubscribe();
            }
        }
        _super.prototype._error.call(this, err);
    };
    WindowToggleSubscriber.prototype._complete = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_2 = contexts[index];
                context_2.window.complete();
                context_2.subscription.unsubscribe();
            }
        }
        _super.prototype._complete.call(this);
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    WindowToggleSubscriber.prototype._unsubscribe = function () {
        var contexts = this.contexts;
        this.contexts = null;
        if (contexts) {
            var len = contexts.length;
            var index = -1;
            while (++index < len) {
                var context_3 = contexts[index];
                context_3.window.unsubscribe();
                context_3.subscription.unsubscribe();
            }
        }
    };
    WindowToggleSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (outerValue === this.openings) {
            var closingSelector = this.closingSelector;
            var closingNotifier = tryCatch(closingSelector)(innerValue);
            if (closingNotifier === errorObject) {
                return this.error(errorObject.e);
            }
            else {
                var window_1 = new Subject();
                var subscription = new Subscription();
                var context_4 = { window: window_1, subscription: subscription };
                this.contexts.push(context_4);
                var innerSubscription = subscribeToResult(this, closingNotifier, context_4);
                if (innerSubscription.closed) {
                    this.closeWindow(this.contexts.length - 1);
                }
                else {
                    innerSubscription.context = context_4;
                    subscription.add(innerSubscription);
                }
                this.destination.next(window_1);
            }
        }
        else {
            this.closeWindow(this.contexts.indexOf(outerValue));
        }
    };
    WindowToggleSubscriber.prototype.notifyError = function (err) {
        this.error(err);
    };
    WindowToggleSubscriber.prototype.notifyComplete = function (inner) {
        if (inner !== this.openSubscription) {
            this.closeWindow(this.contexts.indexOf(inner.context));
        }
    };
    WindowToggleSubscriber.prototype.closeWindow = function (index) {
        if (index === -1) {
            return;
        }
        var contexts = this.contexts;
        var context = contexts[index];
        var window = context.window, subscription = context.subscription;
        contexts.splice(index, 1);
        window.complete();
        subscription.unsubscribe();
    };
    return WindowToggleSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_Subject,_util_tryCatch,_util_errorObject,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/**
 * Branch out the source Observable values as a nested Observable using a
 * factory function of closing Observables to determine when to start a new
 * window.
 *
 * <span class="informal">It's like {@link bufferWhen}, but emits a nested
 * Observable instead of an array.</span>
 *
 * <img src="./img/windowWhen.png" width="100%">
 *
 * Returns an Observable that emits windows of items it collects from the source
 * Observable. The output Observable emits connected, non-overlapping windows.
 * It emits the current window and opens a new one whenever the Observable
 * produced by the specified `closingSelector` function emits an item. The first
 * window is opened immediately when subscribing to the output Observable.
 *
 * @example <caption>Emit only the first two clicks events in every window of [1-5] random seconds</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var result = clicks
 *   .windowWhen(() => Rx.Observable.interval(1000 + Math.random() * 4000))
 *   .map(win => win.take(2)) // each window has at most 2 emissions
 *   .mergeAll(); // flatten the Observable-of-Observables
 * result.subscribe(x => console.log(x));
 *
 * @see {@link window}
 * @see {@link windowCount}
 * @see {@link windowTime}
 * @see {@link windowToggle}
 * @see {@link bufferWhen}
 *
 * @param {function(): Observable} closingSelector A function that takes no
 * arguments and returns an Observable that signals (on either `next` or
 * `complete`) when to close the previous window and start a new one.
 * @return {Observable<Observable<T>>} An observable of windows, which in turn
 * are Observables.
 * @method windowWhen
 * @owner Observable
 */

var WindowOperator$1 = /*@__PURE__*/ (function () {
    function WindowOperator(closingSelector) {
        this.closingSelector = closingSelector;
    }
    WindowOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WindowSubscriber$1(subscriber, this.closingSelector));
    };
    return WindowOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WindowSubscriber$1 = /*@__PURE__*/ (function (_super) {
    __extends(WindowSubscriber, _super);
    function WindowSubscriber(destination, closingSelector) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        _this.closingSelector = closingSelector;
        _this.openWindow();
        return _this;
    }
    WindowSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype.notifyError = function (error, innerSub) {
        this._error(error);
    };
    WindowSubscriber.prototype.notifyComplete = function (innerSub) {
        this.openWindow(innerSub);
    };
    WindowSubscriber.prototype._next = function (value) {
        this.window.next(value);
    };
    WindowSubscriber.prototype._error = function (err) {
        this.window.error(err);
        this.destination.error(err);
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype._complete = function () {
        this.window.complete();
        this.destination.complete();
        this.unsubscribeClosingNotification();
    };
    WindowSubscriber.prototype.unsubscribeClosingNotification = function () {
        if (this.closingNotification) {
            this.closingNotification.unsubscribe();
        }
    };
    WindowSubscriber.prototype.openWindow = function (innerSub) {
        if (innerSub === void 0) {
            innerSub = null;
        }
        if (innerSub) {
            this.remove(innerSub);
            innerSub.unsubscribe();
        }
        var prevWindow = this.window;
        if (prevWindow) {
            prevWindow.complete();
        }
        var window = this.window = new Subject();
        this.destination.next(window);
        var closingNotifier = tryCatch(this.closingSelector)();
        if (closingNotifier === errorObject) {
            var err = errorObject.e;
            this.destination.error(err);
            this.window.error(err);
        }
        else {
            this.add(this.closingNotification = subscribeToResult(this, closingNotifier));
        }
    };
    return WindowSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START tslib,_OuterSubscriber,_util_subscribeToResult PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * Combines the source Observable with other Observables to create an Observable
 * whose values are calculated from the latest values of each, only when the
 * source emits.
 *
 * <span class="informal">Whenever the source Observable emits a value, it
 * computes a formula using that value plus the latest values from other input
 * Observables, then emits the output of that formula.</span>
 *
 * <img src="./img/withLatestFrom.png" width="100%">
 *
 * `withLatestFrom` combines each value from the source Observable (the
 * instance) with the latest values from the other input Observables only when
 * the source emits a value, optionally using a `project` function to determine
 * the value to be emitted on the output Observable. All input Observables must
 * emit at least one value before the output Observable will emit a value.
 *
 * @example <caption>On every click event, emit an array with the latest timer event plus the click event</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var result = clicks.withLatestFrom(timer);
 * result.subscribe(x => console.log(x));
 *
 * @see {@link combineLatest}
 *
 * @param {ObservableInput} other An input Observable to combine with the source
 * Observable. More than one input Observables may be given as argument.
 * @param {Function} [project] Projection function for combining values
 * together. Receives all values in order of the Observables passed, where the
 * first parameter is a value from the source Observable. (e.g.
 * `a.withLatestFrom(b, c, (a1, b1, c1) => a1 + b1 + c1)`). If this is not
 * passed, arrays will be emitted on the output Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 * @method withLatestFrom
 * @owner Observable
 */

var WithLatestFromOperator = /*@__PURE__*/ (function () {
    function WithLatestFromOperator(observables, project) {
        this.observables = observables;
        this.project = project;
    }
    WithLatestFromOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new WithLatestFromSubscriber(subscriber, this.observables, this.project));
    };
    return WithLatestFromOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var WithLatestFromSubscriber = /*@__PURE__*/ (function (_super) {
    __extends(WithLatestFromSubscriber, _super);
    function WithLatestFromSubscriber(destination, observables, project) {
        var _this = _super.call(this, destination) || this;
        _this.observables = observables;
        _this.project = project;
        _this.toRespond = [];
        var len = observables.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            _this.toRespond.push(i);
        }
        for (var i = 0; i < len; i++) {
            var observable = observables[i];
            _this.add(subscribeToResult(_this, observable, observable, i));
        }
        return _this;
    }
    WithLatestFromSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        var toRespond = this.toRespond;
        if (toRespond.length > 0) {
            var found = toRespond.indexOf(outerIndex);
            if (found !== -1) {
                toRespond.splice(found, 1);
            }
        }
    };
    WithLatestFromSubscriber.prototype.notifyComplete = function () {
        // noop
    };
    WithLatestFromSubscriber.prototype._next = function (value) {
        if (this.toRespond.length === 0) {
            var args = [value].concat(this.values);
            if (this.project) {
                this._tryProject(args);
            }
            else {
                this.destination.next(args);
            }
        }
    };
    WithLatestFromSubscriber.prototype._tryProject = function (args) {
        var result;
        try {
            result = this.project.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return WithLatestFromSubscriber;
}(OuterSubscriber));

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */
/* tslint:enable:max-line-length */
/**
 * @deprecated Deprecated in favor of static zip.
 */

/** PURE_IMPORTS_START _observable_zip PURE_IMPORTS_END */

/* Operator exports */
/** PURE_IMPORTS_START  PURE_IMPORTS_END */

/**
 * @license Angular v6.0.4
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Transforms an `HttpRequest` into a stream of `HttpEvent`s, one of which will likely be a
 * `HttpResponse`.
 *
 * `HttpHandler` is injectable. When injected, the handler instance dispatches requests to the
 * first interceptor in the chain, which dispatches to the second, etc, eventually reaching the
 * `HttpBackend`.
 *
 * In an `HttpInterceptor`, the `HttpHandler` parameter is the next interceptor in the chain.
 *
 *
 */
var HttpHandler = /** @class */ (function () {
    function HttpHandler() {
    }
    return HttpHandler;
}());
/**
 * A final `HttpHandler` which will dispatch the request via browser HTTP APIs to a backend.
 *
 * Interceptors sit between the `HttpClient` interface and the `HttpBackend`.
 *
 * When injected, `HttpBackend` dispatches requests directly to the backend, without going
 * through the interceptor chain.
 *
 *
 */
var HttpBackend = /** @class */ (function () {
    function HttpBackend() {
    }
    return HttpBackend;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Immutable set of Http headers, with lazy parsing.
 *
 */
var HttpHeaders = /** @class */ (function () {
    function HttpHeaders(headers) {
        var _this = this;
        /**
         * Internal map of lowercased header names to the normalized
         * form of the name (the form seen first).
         */
        this.normalizedNames = new Map();
        /**
         * Queued updates to be materialized the next initialization.
         */
        this.lazyUpdate = null;
        if (!headers) {
            this.headers = new Map();
        }
        else if (typeof headers === 'string') {
            this.lazyInit = function () {
                _this.headers = new Map();
                headers.split('\n').forEach(function (line) {
                    var index = line.indexOf(':');
                    if (index > 0) {
                        var name_1 = line.slice(0, index);
                        var key = name_1.toLowerCase();
                        var value = line.slice(index + 1).trim();
                        _this.maybeSetNormalizedName(name_1, key);
                        if (_this.headers.has(key)) {
                            _this.headers.get(key).push(value);
                        }
                        else {
                            _this.headers.set(key, [value]);
                        }
                    }
                });
            };
        }
        else {
            this.lazyInit = function () {
                _this.headers = new Map();
                Object.keys(headers).forEach(function (name) {
                    var values = headers[name];
                    var key = name.toLowerCase();
                    if (typeof values === 'string') {
                        values = [values];
                    }
                    if (values.length > 0) {
                        _this.headers.set(key, values);
                        _this.maybeSetNormalizedName(name, key);
                    }
                });
            };
        }
    }
    /**
     * Checks for existence of header by given name.
     */
    HttpHeaders.prototype.has = function (name) {
        this.init();
        return this.headers.has(name.toLowerCase());
    };
    /**
     * Returns first header that matches given name.
     */
    HttpHeaders.prototype.get = function (name) {
        this.init();
        var values = this.headers.get(name.toLowerCase());
        return values && values.length > 0 ? values[0] : null;
    };
    /**
     * Returns the names of the headers
     */
    HttpHeaders.prototype.keys = function () {
        this.init();
        return Array.from(this.normalizedNames.values());
    };
    /**
     * Returns list of header values for a given name.
     */
    HttpHeaders.prototype.getAll = function (name) {
        this.init();
        return this.headers.get(name.toLowerCase()) || null;
    };
    HttpHeaders.prototype.append = function (name, value) {
        return this.clone({ name: name, value: value, op: 'a' });
    };
    HttpHeaders.prototype.set = function (name, value) {
        return this.clone({ name: name, value: value, op: 's' });
    };
    HttpHeaders.prototype.delete = function (name, value) {
        return this.clone({ name: name, value: value, op: 'd' });
    };
    HttpHeaders.prototype.maybeSetNormalizedName = function (name, lcName) {
        if (!this.normalizedNames.has(lcName)) {
            this.normalizedNames.set(lcName, name);
        }
    };
    HttpHeaders.prototype.init = function () {
        var _this = this;
        if (!!this.lazyInit) {
            if (this.lazyInit instanceof HttpHeaders) {
                this.copyFrom(this.lazyInit);
            }
            else {
                this.lazyInit();
            }
            this.lazyInit = null;
            if (!!this.lazyUpdate) {
                this.lazyUpdate.forEach(function (update) { return _this.applyUpdate(update); });
                this.lazyUpdate = null;
            }
        }
    };
    HttpHeaders.prototype.copyFrom = function (other) {
        var _this = this;
        other.init();
        Array.from(other.headers.keys()).forEach(function (key) {
            _this.headers.set(key, other.headers.get(key));
            _this.normalizedNames.set(key, other.normalizedNames.get(key));
        });
    };
    HttpHeaders.prototype.clone = function (update) {
        var clone = new HttpHeaders();
        clone.lazyInit =
            (!!this.lazyInit && this.lazyInit instanceof HttpHeaders) ? this.lazyInit : this;
        clone.lazyUpdate = (this.lazyUpdate || []).concat([update]);
        return clone;
    };
    HttpHeaders.prototype.applyUpdate = function (update) {
        var key = update.name.toLowerCase();
        switch (update.op) {
            case 'a':
            case 's':
                var value = update.value;
                if (typeof value === 'string') {
                    value = [value];
                }
                if (value.length === 0) {
                    return;
                }
                this.maybeSetNormalizedName(update.name, key);
                var base = (update.op === 'a' ? this.headers.get(key) : undefined) || [];
                base.push.apply(base, __spread(value));
                this.headers.set(key, base);
                break;
            case 'd':
                var toDelete_1 = update.value;
                if (!toDelete_1) {
                    this.headers.delete(key);
                    this.normalizedNames.delete(key);
                }
                else {
                    var existing = this.headers.get(key);
                    if (!existing) {
                        return;
                    }
                    existing = existing.filter(function (value) { return toDelete_1.indexOf(value) === -1; });
                    if (existing.length === 0) {
                        this.headers.delete(key);
                        this.normalizedNames.delete(key);
                    }
                    else {
                        this.headers.set(key, existing);
                    }
                }
                break;
        }
    };
    /**
     * @internal
     */
    HttpHeaders.prototype.forEach = function (fn) {
        var _this = this;
        this.init();
        Array.from(this.normalizedNames.keys())
            .forEach(function (key) { return fn(_this.normalizedNames.get(key), _this.headers.get(key)); });
    };
    return HttpHeaders;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * A `HttpParameterCodec` that uses `encodeURIComponent` and `decodeURIComponent` to
 * serialize and parse URL parameter keys and values.
 *
 *
 */
var HttpUrlEncodingCodec = /** @class */ (function () {
    function HttpUrlEncodingCodec() {
    }
    HttpUrlEncodingCodec.prototype.encodeKey = function (k) { return standardEncoding(k); };
    HttpUrlEncodingCodec.prototype.encodeValue = function (v) { return standardEncoding(v); };
    HttpUrlEncodingCodec.prototype.decodeKey = function (k) { return decodeURIComponent(k); };
    HttpUrlEncodingCodec.prototype.decodeValue = function (v) { return decodeURIComponent(v); };
    return HttpUrlEncodingCodec;
}());
function paramParser(rawParams, codec) {
    var map$$1 = new Map();
    if (rawParams.length > 0) {
        var params = rawParams.split('&');
        params.forEach(function (param) {
            var eqIdx = param.indexOf('=');
            var _a = __read(eqIdx == -1 ?
                [codec.decodeKey(param), ''] :
                [codec.decodeKey(param.slice(0, eqIdx)), codec.decodeValue(param.slice(eqIdx + 1))], 2), key = _a[0], val = _a[1];
            var list = map$$1.get(key) || [];
            list.push(val);
            map$$1.set(key, list);
        });
    }
    return map$$1;
}
function standardEncoding(v) {
    return encodeURIComponent(v)
        .replace(/%40/gi, '@')
        .replace(/%3A/gi, ':')
        .replace(/%24/gi, '$')
        .replace(/%2C/gi, ',')
        .replace(/%3B/gi, ';')
        .replace(/%2B/gi, '+')
        .replace(/%3D/gi, '=')
        .replace(/%3F/gi, '?')
        .replace(/%2F/gi, '/');
}
/**
 * An HTTP request/response body that represents serialized parameters,
 * per the MIME type `application/x-www-form-urlencoded`.
 *
 * This class is immutable - all mutation operations return a new instance.
 *
 *
 */
var HttpParams = /** @class */ (function () {
    function HttpParams(options) {
        if (options === void 0) { options = {}; }
        var _this = this;
        this.updates = null;
        this.cloneFrom = null;
        this.encoder = options.encoder || new HttpUrlEncodingCodec();
        if (!!options.fromString) {
            if (!!options.fromObject) {
                throw new Error("Cannot specify both fromString and fromObject.");
            }
            this.map = paramParser(options.fromString, this.encoder);
        }
        else if (!!options.fromObject) {
            this.map = new Map();
            Object.keys(options.fromObject).forEach(function (key) {
                var value = options.fromObject[key];
                _this.map.set(key, Array.isArray(value) ? value : [value]);
            });
        }
        else {
            this.map = null;
        }
    }
    /**
     * Check whether the body has one or more values for the given parameter name.
     */
    HttpParams.prototype.has = function (param) {
        this.init();
        return this.map.has(param);
    };
    /**
     * Get the first value for the given parameter name, or `null` if it's not present.
     */
    HttpParams.prototype.get = function (param) {
        this.init();
        var res = this.map.get(param);
        return !!res ? res[0] : null;
    };
    /**
     * Get all values for the given parameter name, or `null` if it's not present.
     */
    HttpParams.prototype.getAll = function (param) {
        this.init();
        return this.map.get(param) || null;
    };
    /**
     * Get all the parameter names for this body.
     */
    HttpParams.prototype.keys = function () {
        this.init();
        return Array.from(this.map.keys());
    };
    /**
     * Construct a new body with an appended value for the given parameter name.
     */
    HttpParams.prototype.append = function (param, value) { return this.clone({ param: param, value: value, op: 'a' }); };
    /**
     * Construct a new body with a new value for the given parameter name.
     */
    HttpParams.prototype.set = function (param, value) { return this.clone({ param: param, value: value, op: 's' }); };
    /**
     * Construct a new body with either the given value for the given parameter
     * removed, if a value is given, or all values for the given parameter removed
     * if not.
     */
    HttpParams.prototype.delete = function (param, value) { return this.clone({ param: param, value: value, op: 'd' }); };
    /**
     * Serialize the body to an encoded string, where key-value pairs (separated by `=`) are
     * separated by `&`s.
     */
    HttpParams.prototype.toString = function () {
        var _this = this;
        this.init();
        return this.keys()
            .map(function (key) {
            var eKey = _this.encoder.encodeKey(key);
            return _this.map.get(key).map(function (value) { return eKey + '=' + _this.encoder.encodeValue(value); })
                .join('&');
        })
            .join('&');
    };
    HttpParams.prototype.clone = function (update) {
        var clone = new HttpParams({ encoder: this.encoder });
        clone.cloneFrom = this.cloneFrom || this;
        clone.updates = (this.updates || []).concat([update]);
        return clone;
    };
    HttpParams.prototype.init = function () {
        var _this = this;
        if (this.map === null) {
            this.map = new Map();
        }
        if (this.cloneFrom !== null) {
            this.cloneFrom.init();
            this.cloneFrom.keys().forEach(function (key) { return _this.map.set(key, _this.cloneFrom.map.get(key)); });
            this.updates.forEach(function (update) {
                switch (update.op) {
                    case 'a':
                    case 's':
                        var base = (update.op === 'a' ? _this.map.get(update.param) : undefined) || [];
                        base.push(update.value);
                        _this.map.set(update.param, base);
                        break;
                    case 'd':
                        if (update.value !== undefined) {
                            var base_1 = _this.map.get(update.param) || [];
                            var idx = base_1.indexOf(update.value);
                            if (idx !== -1) {
                                base_1.splice(idx, 1);
                            }
                            if (base_1.length > 0) {
                                _this.map.set(update.param, base_1);
                            }
                            else {
                                _this.map.delete(update.param);
                            }
                        }
                        else {
                            _this.map.delete(update.param);
                            break;
                        }
                }
            });
            this.cloneFrom = null;
        }
    };
    return HttpParams;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Determine whether the given HTTP method may include a body.
 */
function mightHaveBody(method) {
    switch (method) {
        case 'DELETE':
        case 'GET':
        case 'HEAD':
        case 'OPTIONS':
        case 'JSONP':
            return false;
        default:
            return true;
    }
}
/**
 * Safely assert whether the given value is an ArrayBuffer.
 *
 * In some execution environments ArrayBuffer is not defined.
 */
function isArrayBuffer(value) {
    return typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer;
}
/**
 * Safely assert whether the given value is a Blob.
 *
 * In some execution environments Blob is not defined.
 */
function isBlob(value) {
    return typeof Blob !== 'undefined' && value instanceof Blob;
}
/**
 * Safely assert whether the given value is a FormData instance.
 *
 * In some execution environments FormData is not defined.
 */
function isFormData(value) {
    return typeof FormData !== 'undefined' && value instanceof FormData;
}
/**
 * An outgoing HTTP request with an optional typed body.
 *
 * `HttpRequest` represents an outgoing request, including URL, method,
 * headers, body, and other request configuration options. Instances should be
 * assumed to be immutable. To modify a `HttpRequest`, the `clone`
 * method should be used.
 *
 *
 */
var HttpRequest = /** @class */ (function () {
    function HttpRequest(method, url, third, fourth) {
        this.url = url;
        /**
         * The request body, or `null` if one isn't set.
         *
         * Bodies are not enforced to be immutable, as they can include a reference to any
         * user-defined data type. However, interceptors should take care to preserve
         * idempotence by treating them as such.
         */
        this.body = null;
        /**
         * Whether this request should be made in a way that exposes progress events.
         *
         * Progress events are expensive (change detection runs on each event) and so
         * they should only be requested if the consumer intends to monitor them.
         */
        this.reportProgress = false;
        /**
         * Whether this request should be sent with outgoing credentials (cookies).
         */
        this.withCredentials = false;
        /**
         * The expected response type of the server.
         *
         * This is used to parse the response appropriately before returning it to
         * the requestee.
         */
        this.responseType = 'json';
        this.method = method.toUpperCase();
        // Next, need to figure out which argument holds the HttpRequestInit
        // options, if any.
        var options;
        // Check whether a body argument is expected. The only valid way to omit
        // the body argument is to use a known no-body method like GET.
        if (mightHaveBody(this.method) || !!fourth) {
            // Body is the third argument, options are the fourth.
            this.body = (third !== undefined) ? third : null;
            options = fourth;
        }
        else {
            // No body required, options are the third argument. The body stays null.
            options = third;
        }
        // If options have been passed, interpret them.
        if (options) {
            // Normalize reportProgress and withCredentials.
            this.reportProgress = !!options.reportProgress;
            this.withCredentials = !!options.withCredentials;
            // Override default response type of 'json' if one is provided.
            if (!!options.responseType) {
                this.responseType = options.responseType;
            }
            // Override headers if they're provided.
            if (!!options.headers) {
                this.headers = options.headers;
            }
            if (!!options.params) {
                this.params = options.params;
            }
        }
        // If no headers have been passed in, construct a new HttpHeaders instance.
        if (!this.headers) {
            this.headers = new HttpHeaders();
        }
        // If no parameters have been passed in, construct a new HttpUrlEncodedParams instance.
        if (!this.params) {
            this.params = new HttpParams();
            this.urlWithParams = url;
        }
        else {
            // Encode the parameters to a string in preparation for inclusion in the URL.
            var params = this.params.toString();
            if (params.length === 0) {
                // No parameters, the visible URL is just the URL given at creation time.
                this.urlWithParams = url;
            }
            else {
                // Does the URL already have query parameters? Look for '?'.
                var qIdx = url.indexOf('?');
                // There are 3 cases to handle:
                // 1) No existing parameters -> append '?' followed by params.
                // 2) '?' exists and is followed by existing query string ->
                //    append '&' followed by params.
                // 3) '?' exists at the end of the url -> append params directly.
                // This basically amounts to determining the character, if any, with
                // which to join the URL and parameters.
                var sep = qIdx === -1 ? '?' : (qIdx < url.length - 1 ? '&' : '');
                this.urlWithParams = url + sep + params;
            }
        }
    }
    /**
     * Transform the free-form body into a serialized format suitable for
     * transmission to the server.
     */
    HttpRequest.prototype.serializeBody = function () {
        // If no body is present, no need to serialize it.
        if (this.body === null) {
            return null;
        }
        // Check whether the body is already in a serialized form. If so,
        // it can just be returned directly.
        if (isArrayBuffer(this.body) || isBlob(this.body) || isFormData(this.body) ||
            typeof this.body === 'string') {
            return this.body;
        }
        // Check whether the body is an instance of HttpUrlEncodedParams.
        if (this.body instanceof HttpParams) {
            return this.body.toString();
        }
        // Check whether the body is an object or array, and serialize with JSON if so.
        if (typeof this.body === 'object' || typeof this.body === 'boolean' ||
            Array.isArray(this.body)) {
            return JSON.stringify(this.body);
        }
        // Fall back on toString() for everything else.
        return this.body.toString();
    };
    /**
     * Examine the body and attempt to infer an appropriate MIME type
     * for it.
     *
     * If no such type can be inferred, this method will return `null`.
     */
    HttpRequest.prototype.detectContentTypeHeader = function () {
        // An empty body has no content type.
        if (this.body === null) {
            return null;
        }
        // FormData bodies rely on the browser's content type assignment.
        if (isFormData(this.body)) {
            return null;
        }
        // Blobs usually have their own content type. If it doesn't, then
        // no type can be inferred.
        if (isBlob(this.body)) {
            return this.body.type || null;
        }
        // Array buffers have unknown contents and thus no type can be inferred.
        if (isArrayBuffer(this.body)) {
            return null;
        }
        // Technically, strings could be a form of JSON data, but it's safe enough
        // to assume they're plain strings.
        if (typeof this.body === 'string') {
            return 'text/plain';
        }
        // `HttpUrlEncodedParams` has its own content-type.
        if (this.body instanceof HttpParams) {
            return 'application/x-www-form-urlencoded;charset=UTF-8';
        }
        // Arrays, objects, and numbers will be encoded as JSON.
        if (typeof this.body === 'object' || typeof this.body === 'number' ||
            Array.isArray(this.body)) {
            return 'application/json';
        }
        // No type could be inferred.
        return null;
    };
    HttpRequest.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        // For method, url, and responseType, take the current value unless
        // it is overridden in the update hash.
        var method = update.method || this.method;
        var url = update.url || this.url;
        var responseType = update.responseType || this.responseType;
        // The body is somewhat special - a `null` value in update.body means
        // whatever current body is present is being overridden with an empty
        // body, whereas an `undefined` value in update.body implies no
        // override.
        var body = (update.body !== undefined) ? update.body : this.body;
        // Carefully handle the boolean options to differentiate between
        // `false` and `undefined` in the update args.
        var withCredentials = (update.withCredentials !== undefined) ? update.withCredentials : this.withCredentials;
        var reportProgress = (update.reportProgress !== undefined) ? update.reportProgress : this.reportProgress;
        // Headers and params may be appended to if `setHeaders` or
        // `setParams` are used.
        var headers = update.headers || this.headers;
        var params = update.params || this.params;
        // Check whether the caller has asked to add headers.
        if (update.setHeaders !== undefined) {
            // Set every requested header.
            headers =
                Object.keys(update.setHeaders)
                    .reduce(function (headers, name) { return headers.set(name, update.setHeaders[name]); }, headers);
        }
        // Check whether the caller has asked to set params.
        if (update.setParams) {
            // Set every requested param.
            params = Object.keys(update.setParams)
                .reduce(function (params, param) { return params.set(param, update.setParams[param]); }, params);
        }
        // Finally, construct the new HttpRequest using the pieces from above.
        return new HttpRequest(method, url, body, {
            params: params, headers: headers, reportProgress: reportProgress, responseType: responseType, withCredentials: withCredentials,
        });
    };
    return HttpRequest;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Type enumeration for the different kinds of `HttpEvent`.
 *
 *
 */
var HttpEventType;
(function (HttpEventType) {
    /**
     * The request was sent out over the wire.
     */
    HttpEventType[HttpEventType["Sent"] = 0] = "Sent";
    /**
     * An upload progress event was received.
     */
    HttpEventType[HttpEventType["UploadProgress"] = 1] = "UploadProgress";
    /**
     * The response status code and headers were received.
     */
    HttpEventType[HttpEventType["ResponseHeader"] = 2] = "ResponseHeader";
    /**
     * A download progress event was received.
     */
    HttpEventType[HttpEventType["DownloadProgress"] = 3] = "DownloadProgress";
    /**
     * The full response including the body was received.
     */
    HttpEventType[HttpEventType["Response"] = 4] = "Response";
    /**
     * A custom event from an interceptor or a backend.
     */
    HttpEventType[HttpEventType["User"] = 5] = "User";
})(HttpEventType || (HttpEventType = {}));
/**
 * Base class for both `HttpResponse` and `HttpHeaderResponse`.
 *
 *
 */
var HttpResponseBase = /** @class */ (function () {
    /**
     * Super-constructor for all responses.
     *
     * The single parameter accepted is an initialization hash. Any properties
     * of the response passed there will override the default values.
     */
    function HttpResponseBase(init, defaultStatus, defaultStatusText) {
        if (defaultStatus === void 0) { defaultStatus = 200; }
        if (defaultStatusText === void 0) { defaultStatusText = 'OK'; }
        // If the hash has values passed, use them to initialize the response.
        // Otherwise use the default values.
        this.headers = init.headers || new HttpHeaders();
        this.status = init.status !== undefined ? init.status : defaultStatus;
        this.statusText = init.statusText || defaultStatusText;
        this.url = init.url || null;
        // Cache the ok value to avoid defining a getter.
        this.ok = this.status >= 200 && this.status < 300;
    }
    return HttpResponseBase;
}());
/**
 * A partial HTTP response which only includes the status and header data,
 * but no response body.
 *
 * `HttpHeaderResponse` is a `HttpEvent` available on the response
 * event stream, only when progress events are requested.
 *
 *
 */
var HttpHeaderResponse = /** @class */ (function (_super) {
    __extends(HttpHeaderResponse, _super);
    /**
     * Create a new `HttpHeaderResponse` with the given parameters.
     */
    function HttpHeaderResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.ResponseHeader;
        return _this;
    }
    /**
     * Copy this `HttpHeaderResponse`, overriding its contents with the
     * given parameter hash.
     */
    HttpHeaderResponse.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        // Perform a straightforward initialization of the new HttpHeaderResponse,
        // overriding the current parameters with new ones if given.
        return new HttpHeaderResponse({
            headers: update.headers || this.headers,
            status: update.status !== undefined ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpHeaderResponse;
}(HttpResponseBase));
/**
 * A full HTTP response, including a typed response body (which may be `null`
 * if one was not returned).
 *
 * `HttpResponse` is a `HttpEvent` available on the response event
 * stream.
 *
 *
 */
var HttpResponse = /** @class */ (function (_super) {
    __extends(HttpResponse, _super);
    /**
     * Construct a new `HttpResponse`.
     */
    function HttpResponse(init) {
        if (init === void 0) { init = {}; }
        var _this = _super.call(this, init) || this;
        _this.type = HttpEventType.Response;
        _this.body = init.body !== undefined ? init.body : null;
        return _this;
    }
    HttpResponse.prototype.clone = function (update) {
        if (update === void 0) { update = {}; }
        return new HttpResponse({
            body: (update.body !== undefined) ? update.body : this.body,
            headers: update.headers || this.headers,
            status: (update.status !== undefined) ? update.status : this.status,
            statusText: update.statusText || this.statusText,
            url: update.url || this.url || undefined,
        });
    };
    return HttpResponse;
}(HttpResponseBase));
/**
 * A response that represents an error or failure, either from a
 * non-successful HTTP status, an error while executing the request,
 * or some other failure which occurred during the parsing of the response.
 *
 * Any error returned on the `Observable` response stream will be
 * wrapped in an `HttpErrorResponse` to provide additional context about
 * the state of the HTTP layer when the error occurred. The error property
 * will contain either a wrapped Error object or the error response returned
 * from the server.
 *
 *
 */
var HttpErrorResponse = /** @class */ (function (_super) {
    __extends(HttpErrorResponse, _super);
    function HttpErrorResponse(init) {
        var _this = 
        // Initialize with a default status of 0 / Unknown Error.
        _super.call(this, init, 0, 'Unknown Error') || this;
        _this.name = 'HttpErrorResponse';
        /**
         * Errors are never okay, even when the status code is in the 2xx success range.
         */
        _this.ok = false;
        // If the response was successful, then this was a parse error. Otherwise, it was
        // a protocol-level failure of some sort. Either the request failed in transit
        // or the server returned an unsuccessful status code.
        if (_this.status >= 200 && _this.status < 300) {
            _this.message = "Http failure during parsing for " + (init.url || '(unknown url)');
        }
        else {
            _this.message =
                "Http failure response for " + (init.url || '(unknown url)') + ": " + init.status + " " + init.statusText;
        }
        _this.error = init.error || null;
        return _this;
    }
    return HttpErrorResponse;
}(HttpResponseBase));

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * Construct an instance of `HttpRequestOptions<T>` from a source `HttpMethodOptions` and
 * the given `body`. Basically, this clones the object and adds the body.
 */
function addBody(options, body) {
    return {
        body: body,
        headers: options.headers,
        observe: options.observe,
        params: options.params,
        reportProgress: options.reportProgress,
        responseType: options.responseType,
        withCredentials: options.withCredentials,
    };
}
/**
 * Perform HTTP requests.
 *
 * `HttpClient` is available as an injectable class, with methods to perform HTTP requests.
 * Each request method has multiple signatures, and the return type varies according to which
 * signature is called (mainly the values of `observe` and `responseType`).
 *
 *
 */
var HttpClient = /** @class */ (function () {
    function HttpClient(handler) {
        this.handler = handler;
    }
    /**
     * Constructs an `Observable` for a particular HTTP request that, when subscribed,
     * fires the request through the chain of registered interceptors and on to the
     * server.
     *
     * This method can be called in one of two ways. Either an `HttpRequest`
     * instance can be passed directly as the only parameter, or a method can be
     * passed as the first parameter, a string URL as the second, and an
     * options hash as the third.
     *
     * If a `HttpRequest` object is passed directly, an `Observable` of the
     * raw `HttpEvent` stream will be returned.
     *
     * If a request is instead built by providing a URL, the options object
     * determines the return type of `request()`. In addition to configuring
     * request parameters such as the outgoing headers and/or the body, the options
     * hash specifies two key pieces of information about the request: the
     * `responseType` and what to `observe`.
     *
     * The `responseType` value determines how a successful response body will be
     * parsed. If `responseType` is the default `json`, a type interface for the
     * resulting object may be passed as a type parameter to `request()`.
     *
     * The `observe` value determines the return type of `request()`, based on what
     * the consumer is interested in observing. A value of `events` will return an
     * `Observable<HttpEvent>` representing the raw `HttpEvent` stream,
     * including progress events by default. A value of `response` will return an
     * `Observable<HttpResponse<T>>` where the `T` parameter of `HttpResponse`
     * depends on the `responseType` and any optionally provided type parameter.
     * A value of `body` will return an `Observable<T>` with the same `T` body type.
     */
    HttpClient.prototype.request = function (first, url, options) {
        var _this = this;
        if (options === void 0) { options = {}; }
        var req;
        // Firstly, check whether the primary argument is an instance of `HttpRequest`.
        if (first instanceof HttpRequest) {
            // It is. The other arguments must be undefined (per the signatures) and can be
            // ignored.
            req = first;
        }
        else {
            // It's a string, so it represents a URL. Construct a request based on it,
            // and incorporate the remaining arguments (assuming GET unless a method is
            // provided.
            // Figure out the headers.
            var headers = undefined;
            if (options.headers instanceof HttpHeaders) {
                headers = options.headers;
            }
            else {
                headers = new HttpHeaders(options.headers);
            }
            // Sort out parameters.
            var params = undefined;
            if (!!options.params) {
                if (options.params instanceof HttpParams) {
                    params = options.params;
                }
                else {
                    params = new HttpParams({ fromObject: options.params });
                }
            }
            // Construct the request.
            req = new HttpRequest(first, url, (options.body !== undefined ? options.body : null), {
                headers: headers,
                params: params,
                reportProgress: options.reportProgress,
                // By default, JSON is assumed to be returned for all calls.
                responseType: options.responseType || 'json',
                withCredentials: options.withCredentials,
            });
        }
        // Start with an Observable.of() the initial request, and run the handler (which
        // includes all interceptors) inside a concatMap(). This way, the handler runs
        // inside an Observable chain, which causes interceptors to be re-run on every
        // subscription (this also makes retries re-run the handler, including interceptors).
        var events$ = of(req).pipe(concatMap(function (req) { return _this.handler.handle(req); }));
        // If coming via the API signature which accepts a previously constructed HttpRequest,
        // the only option is to get the event stream. Otherwise, return the event stream if
        // that is what was requested.
        if (first instanceof HttpRequest || options.observe === 'events') {
            return events$;
        }
        // The requested stream contains either the full response or the body. In either
        // case, the first step is to filter the event stream to extract a stream of
        // responses(s).
        var res$ = events$.pipe(filter(function (event) { return event instanceof HttpResponse; }));
        // Decide which stream to return.
        switch (options.observe || 'body') {
            case 'body':
                // The requested stream is the body. Map the response stream to the response
                // body. This could be done more simply, but a misbehaving interceptor might
                // transform the response body into a different format and ignore the requested
                // responseType. Guard against this by validating that the response is of the
                // requested type.
                switch (req.responseType) {
                    case 'arraybuffer':
                        return res$.pipe(map(function (res) {
                            // Validate that the body is an ArrayBuffer.
                            if (res.body !== null && !(res.body instanceof ArrayBuffer)) {
                                throw new Error('Response is not an ArrayBuffer.');
                            }
                            return res.body;
                        }));
                    case 'blob':
                        return res$.pipe(map(function (res) {
                            // Validate that the body is a Blob.
                            if (res.body !== null && !(res.body instanceof Blob)) {
                                throw new Error('Response is not a Blob.');
                            }
                            return res.body;
                        }));
                    case 'text':
                        return res$.pipe(map(function (res) {
                            // Validate that the body is a string.
                            if (res.body !== null && typeof res.body !== 'string') {
                                throw new Error('Response is not a string.');
                            }
                            return res.body;
                        }));
                    case 'json':
                    default:
                        // No validation needed for JSON responses, as they can be of any type.
                        return res$.pipe(map(function (res) { return res.body; }));
                }
            case 'response':
                // The response stream was requested directly, so return it.
                return res$;
            default:
                // Guard against new future observe types being added.
                throw new Error("Unreachable: unhandled observe type " + options.observe + "}");
        }
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * DELETE request to be executed on the server. See the individual overloads for
     * details of `delete()`'s return type based on the provided options.
     */
    HttpClient.prototype.delete = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('DELETE', url, options);
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * GET request to be executed on the server. See the individual overloads for
     * details of `get()`'s return type based on the provided options.
     */
    HttpClient.prototype.get = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('GET', url, options);
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * HEAD request to be executed on the server. See the individual overloads for
     * details of `head()`'s return type based on the provided options.
     */
    HttpClient.prototype.head = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('HEAD', url, options);
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause a request
     * with the special method `JSONP` to be dispatched via the interceptor pipeline.
     *
     * A suitable interceptor must be installed (e.g. via the `HttpClientJsonpModule`).
     * If no such interceptor is reached, then the `JSONP` request will likely be
     * rejected by the configured backend.
     */
    HttpClient.prototype.jsonp = function (url, callbackParam) {
        return this.request('JSONP', url, {
            params: new HttpParams().append(callbackParam, 'JSONP_CALLBACK'),
            observe: 'body',
            responseType: 'json',
        });
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * OPTIONS request to be executed on the server. See the individual overloads for
     * details of `options()`'s return type based on the provided options.
     */
    HttpClient.prototype.options = function (url, options) {
        if (options === void 0) { options = {}; }
        return this.request('OPTIONS', url, options);
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * PATCH request to be executed on the server. See the individual overloads for
     * details of `patch()`'s return type based on the provided options.
     */
    HttpClient.prototype.patch = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PATCH', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     */
    HttpClient.prototype.post = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('POST', url, addBody(options, body));
    };
    /**
     * Constructs an `Observable` which, when subscribed, will cause the configured
     * POST request to be executed on the server. See the individual overloads for
     * details of `post()`'s return type based on the provided options.
     */
    HttpClient.prototype.put = function (url, body, options) {
        if (options === void 0) { options = {}; }
        return this.request('PUT', url, addBody(options, body));
    };
    HttpClient.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    HttpClient.ctorParameters = function () { return [
        { type: HttpHandler }
    ]; };
    return HttpClient;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * `HttpHandler` which applies an `HttpInterceptor` to an `HttpRequest`.
 *
 *
 */
var HttpInterceptorHandler = /** @class */ (function () {
    function HttpInterceptorHandler(next, interceptor) {
        this.next = next;
        this.interceptor = interceptor;
    }
    HttpInterceptorHandler.prototype.handle = function (req) {
        return this.interceptor.intercept(req, this.next);
    };
    return HttpInterceptorHandler;
}());
/**
 * A multi-provider token which represents the array of `HttpInterceptor`s that
 * are registered.
 *
 *
 */
var HTTP_INTERCEPTORS = new i0.InjectionToken('HTTP_INTERCEPTORS');
var NoopInterceptor = /** @class */ (function () {
    function NoopInterceptor() {
    }
    NoopInterceptor.prototype.intercept = function (req, next) {
        return next.handle(req);
    };
    NoopInterceptor.decorators = [
        { type: i0.Injectable }
    ];
    return NoopInterceptor;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
// Every request made through JSONP needs a callback name that's unique across the
// whole page. Each request is assigned an id and the callback name is constructed
// from that. The next id to be assigned is tracked in a global variable here that
// is shared among all applications on the page.
var nextRequestId = 0;
// Error text given when a JSONP script is injected, but doesn't invoke the callback
// passed in its URL.
var JSONP_ERR_NO_CALLBACK = 'JSONP injected script did not invoke callback.';
// Error text given when a request is passed to the JsonpClientBackend that doesn't
// have a request method JSONP.
var JSONP_ERR_WRONG_METHOD = 'JSONP requests must use JSONP request method.';
var JSONP_ERR_WRONG_RESPONSE_TYPE = 'JSONP requests must use Json response type.';
/**
 * DI token/abstract type representing a map of JSONP callbacks.
 *
 * In the browser, this should always be the `window` object.
 *
 *
 */
var JsonpCallbackContext = /** @class */ (function () {
    function JsonpCallbackContext() {
    }
    return JsonpCallbackContext;
}());
/**
 * `HttpBackend` that only processes `HttpRequest` with the JSONP method,
 * by performing JSONP style requests.
 *
 *
 */
var JsonpClientBackend = /** @class */ (function () {
    function JsonpClientBackend(callbackMap, document) {
        this.callbackMap = callbackMap;
        this.document = document;
    }
    /**
     * Get the name of the next callback method, by incrementing the global `nextRequestId`.
     */
    JsonpClientBackend.prototype.nextCallback = function () { return "ng_jsonp_callback_" + nextRequestId++; };
    /**
     * Process a JSONP request and return an event stream of the results.
     */
    JsonpClientBackend.prototype.handle = function (req) {
        var _this = this;
        // Firstly, check both the method and response type. If either doesn't match
        // then the request was improperly routed here and cannot be handled.
        if (req.method !== 'JSONP') {
            throw new Error(JSONP_ERR_WRONG_METHOD);
        }
        else if (req.responseType !== 'json') {
            throw new Error(JSONP_ERR_WRONG_RESPONSE_TYPE);
        }
        // Everything else happens inside the Observable boundary.
        return new Observable(function (observer) {
            // The first step to make a request is to generate the callback name, and replace the
            // callback placeholder in the URL with the name. Care has to be taken here to ensure
            // a trailing &, if matched, gets inserted back into the URL in the correct place.
            var callback = _this.nextCallback();
            var url = req.urlWithParams.replace(/=JSONP_CALLBACK(&|$)/, "=" + callback + "$1");
            // Construct the <script> tag and point it at the URL.
            var node = _this.document.createElement('script');
            node.src = url;
            // A JSONP request requires waiting for multiple callbacks. These variables
            // are closed over and track state across those callbacks.
            // The response object, if one has been received, or null otherwise.
            var body = null;
            // Whether the response callback has been called.
            var finished = false;
            // Whether the request has been cancelled (and thus any other callbacks)
            // should be ignored.
            var cancelled = false;
            // Set the response callback in this.callbackMap (which will be the window
            // object in the browser. The script being loaded via the <script> tag will
            // eventually call this callback.
            _this.callbackMap[callback] = function (data) {
                // Data has been received from the JSONP script. Firstly, delete this callback.
                delete _this.callbackMap[callback];
                // Next, make sure the request wasn't cancelled in the meantime.
                if (cancelled) {
                    return;
                }
                // Set state to indicate data was received.
                body = data;
                finished = true;
            };
            // cleanup() is a utility closure that removes the <script> from the page and
            // the response callback from the window. This logic is used in both the
            // success, error, and cancellation paths, so it's extracted out for convenience.
            var cleanup = function () {
                // Remove the <script> tag if it's still on the page.
                if (node.parentNode) {
                    node.parentNode.removeChild(node);
                }
                // Remove the response callback from the callbackMap (window object in the
                // browser).
                delete _this.callbackMap[callback];
            };
            // onLoad() is the success callback which runs after the response callback
            // if the JSONP script loads successfully. The event itself is unimportant.
            // If something went wrong, onLoad() may run without the response callback
            // having been invoked.
            var onLoad = function (event) {
                // Do nothing if the request has been cancelled.
                if (cancelled) {
                    return;
                }
                // Cleanup the page.
                cleanup();
                // Check whether the response callback has run.
                if (!finished) {
                    // It hasn't, something went wrong with the request. Return an error via
                    // the Observable error path. All JSONP errors have status 0.
                    observer.error(new HttpErrorResponse({
                        url: url,
                        status: 0,
                        statusText: 'JSONP Error',
                        error: new Error(JSONP_ERR_NO_CALLBACK),
                    }));
                    return;
                }
                // Success. body either contains the response body or null if none was
                // returned.
                observer.next(new HttpResponse({
                    body: body,
                    status: 200,
                    statusText: 'OK', url: url,
                }));
                // Complete the stream, the response is over.
                observer.complete();
            };
            // onError() is the error callback, which runs if the script returned generates
            // a Javascript error. It emits the error via the Observable error channel as
            // a HttpErrorResponse.
            var onError = function (error) {
                // If the request was already cancelled, no need to emit anything.
                if (cancelled) {
                    return;
                }
                cleanup();
                // Wrap the error in a HttpErrorResponse.
                observer.error(new HttpErrorResponse({
                    error: error,
                    status: 0,
                    statusText: 'JSONP Error', url: url,
                }));
            };
            // Subscribe to both the success (load) and error events on the <script> tag,
            // and add it to the page.
            node.addEventListener('load', onLoad);
            node.addEventListener('error', onError);
            _this.document.body.appendChild(node);
            // The request has now been successfully sent.
            observer.next({ type: HttpEventType.Sent });
            // Cancellation handler.
            return function () {
                // Track the cancellation so event listeners won't do anything even if already scheduled.
                cancelled = true;
                // Remove the event listeners so they won't run if the events later fire.
                node.removeEventListener('load', onLoad);
                node.removeEventListener('error', onError);
                // And finally, clean up the page.
                cleanup();
            };
        });
    };
    JsonpClientBackend.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    JsonpClientBackend.ctorParameters = function () { return [
        { type: JsonpCallbackContext },
        { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] }
    ]; };
    return JsonpClientBackend;
}());
/**
 * An `HttpInterceptor` which identifies requests with the method JSONP and
 * shifts them to the `JsonpClientBackend`.
 *
 *
 */
var JsonpInterceptor = /** @class */ (function () {
    function JsonpInterceptor(jsonp) {
        this.jsonp = jsonp;
    }
    JsonpInterceptor.prototype.intercept = function (req, next) {
        if (req.method === 'JSONP') {
            return this.jsonp.handle(req);
        }
        // Fall through for normal HTTP requests.
        return next.handle(req);
    };
    JsonpInterceptor.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    JsonpInterceptor.ctorParameters = function () { return [
        { type: JsonpClientBackend }
    ]; };
    return JsonpInterceptor;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSSI_PREFIX = /^\)\]\}',?\n/;
/**
 * Determine an appropriate URL for the response, by checking either
 * XMLHttpRequest.responseURL or the X-Request-URL header.
 */
function getResponseUrl(xhr) {
    if ('responseURL' in xhr && xhr.responseURL) {
        return xhr.responseURL;
    }
    if (/^X-Request-URL:/m.test(xhr.getAllResponseHeaders())) {
        return xhr.getResponseHeader('X-Request-URL');
    }
    return null;
}
/**
 * A wrapper around the `XMLHttpRequest` constructor.
 *
 *
 */
var XhrFactory = /** @class */ (function () {
    function XhrFactory() {
    }
    return XhrFactory;
}());
/**
 * A factory for @{link HttpXhrBackend} that uses the `XMLHttpRequest` browser API.
 *
 *
 */
var BrowserXhr = /** @class */ (function () {
    function BrowserXhr() {
    }
    BrowserXhr.prototype.build = function () { return (new XMLHttpRequest()); };
    BrowserXhr.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    BrowserXhr.ctorParameters = function () { return []; };
    return BrowserXhr;
}());
/**
 * An `HttpBackend` which uses the XMLHttpRequest API to send
 * requests to a backend server.
 *
 *
 */
var HttpXhrBackend = /** @class */ (function () {
    function HttpXhrBackend(xhrFactory) {
        this.xhrFactory = xhrFactory;
    }
    /**
     * Process a request and return a stream of response events.
     */
    HttpXhrBackend.prototype.handle = function (req) {
        var _this = this;
        // Quick check to give a better error message when a user attempts to use
        // HttpClient.jsonp() without installing the JsonpClientModule
        if (req.method === 'JSONP') {
            throw new Error("Attempted to construct Jsonp request without JsonpClientModule installed.");
        }
        // Everything happens on Observable subscription.
        return new Observable(function (observer) {
            // Start by setting up the XHR object with request method, URL, and withCredentials flag.
            var xhr = _this.xhrFactory.build();
            xhr.open(req.method, req.urlWithParams);
            if (!!req.withCredentials) {
                xhr.withCredentials = true;
            }
            // Add all the requested headers.
            req.headers.forEach(function (name, values) { return xhr.setRequestHeader(name, values.join(',')); });
            // Add an Accept header if one isn't present already.
            if (!req.headers.has('Accept')) {
                xhr.setRequestHeader('Accept', 'application/json, text/plain, */*');
            }
            // Auto-detect the Content-Type header if one isn't present already.
            if (!req.headers.has('Content-Type')) {
                var detectedType = req.detectContentTypeHeader();
                // Sometimes Content-Type detection fails.
                if (detectedType !== null) {
                    xhr.setRequestHeader('Content-Type', detectedType);
                }
            }
            // Set the responseType if one was requested.
            if (req.responseType) {
                var responseType = req.responseType.toLowerCase();
                // JSON responses need to be processed as text. This is because if the server
                // returns an XSSI-prefixed JSON response, the browser will fail to parse it,
                // xhr.response will be null, and xhr.responseText cannot be accessed to
                // retrieve the prefixed JSON data in order to strip the prefix. Thus, all JSON
                // is parsed by first requesting text and then applying JSON.parse.
                xhr.responseType = ((responseType !== 'json') ? responseType : 'text');
            }
            // Serialize the request body if one is present. If not, this will be set to null.
            var reqBody = req.serializeBody();
            // If progress events are enabled, response headers will be delivered
            // in two events - the HttpHeaderResponse event and the full HttpResponse
            // event. However, since response headers don't change in between these
            // two events, it doesn't make sense to parse them twice. So headerResponse
            // caches the data extracted from the response whenever it's first parsed,
            // to ensure parsing isn't duplicated.
            var headerResponse = null;
            // partialFromXhr extracts the HttpHeaderResponse from the current XMLHttpRequest
            // state, and memoizes it into headerResponse.
            var partialFromXhr = function () {
                if (headerResponse !== null) {
                    return headerResponse;
                }
                // Read status and normalize an IE9 bug (http://bugs.jquery.com/ticket/1450).
                var status = xhr.status === 1223 ? 204 : xhr.status;
                var statusText = xhr.statusText || 'OK';
                // Parse headers from XMLHttpRequest - this step is lazy.
                var headers = new HttpHeaders(xhr.getAllResponseHeaders());
                // Read the response URL from the XMLHttpResponse instance and fall back on the
                // request URL.
                var url = getResponseUrl(xhr) || req.url;
                // Construct the HttpHeaderResponse and memoize it.
                headerResponse = new HttpHeaderResponse({ headers: headers, status: status, statusText: statusText, url: url });
                return headerResponse;
            };
            // Next, a few closures are defined for the various events which XMLHttpRequest can
            // emit. This allows them to be unregistered as event listeners later.
            // First up is the load event, which represents a response being fully available.
            var onLoad = function () {
                // Read response state from the memoized partial data.
                var _a = partialFromXhr(), headers = _a.headers, status = _a.status, statusText = _a.statusText, url = _a.url;
                // The body will be read out if present.
                var body = null;
                if (status !== 204) {
                    // Use XMLHttpRequest.response if set, responseText otherwise.
                    body = (typeof xhr.response === 'undefined') ? xhr.responseText : xhr.response;
                }
                // Normalize another potential bug (this one comes from CORS).
                if (status === 0) {
                    status = !!body ? 200 : 0;
                }
                // ok determines whether the response will be transmitted on the event or
                // error channel. Unsuccessful status codes (not 2xx) will always be errors,
                // but a successful status code can still result in an error if the user
                // asked for JSON data and the body cannot be parsed as such.
                var ok = status >= 200 && status < 300;
                // Check whether the body needs to be parsed as JSON (in many cases the browser
                // will have done that already).
                if (req.responseType === 'json' && typeof body === 'string') {
                    // Save the original body, before attempting XSSI prefix stripping.
                    var originalBody = body;
                    body = body.replace(XSSI_PREFIX, '');
                    try {
                        // Attempt the parse. If it fails, a parse error should be delivered to the user.
                        body = body !== '' ? JSON.parse(body) : null;
                    }
                    catch (error) {
                        // Since the JSON.parse failed, it's reasonable to assume this might not have been a
                        // JSON response. Restore the original body (including any XSSI prefix) to deliver
                        // a better error response.
                        body = originalBody;
                        // If this was an error request to begin with, leave it as a string, it probably
                        // just isn't JSON. Otherwise, deliver the parsing error to the user.
                        if (ok) {
                            // Even though the response status was 2xx, this is still an error.
                            ok = false;
                            // The parse error contains the text of the body that failed to parse.
                            body = { error: error, text: body };
                        }
                    }
                }
                if (ok) {
                    // A successful response is delivered on the event stream.
                    observer.next(new HttpResponse({
                        body: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                    // The full body has been received and delivered, no further events
                    // are possible. This request is complete.
                    observer.complete();
                }
                else {
                    // An unsuccessful request is delivered on the error channel.
                    observer.error(new HttpErrorResponse({
                        // The error in this case is the response body (error from the server).
                        error: body,
                        headers: headers,
                        status: status,
                        statusText: statusText,
                        url: url || undefined,
                    }));
                }
            };
            // The onError callback is called when something goes wrong at the network level.
            // Connection timeout, DNS error, offline, etc. These are actual errors, and are
            // transmitted on the error channel.
            var onError = function (error) {
                var res = new HttpErrorResponse({
                    error: error,
                    status: xhr.status || 0,
                    statusText: xhr.statusText || 'Unknown Error',
                });
                observer.error(res);
            };
            // The sentHeaders flag tracks whether the HttpResponseHeaders event
            // has been sent on the stream. This is necessary to track if progress
            // is enabled since the event will be sent on only the first download
            // progerss event.
            var sentHeaders = false;
            // The download progress event handler, which is only registered if
            // progress events are enabled.
            var onDownProgress = function (event) {
                // Send the HttpResponseHeaders event if it hasn't been sent already.
                if (!sentHeaders) {
                    observer.next(partialFromXhr());
                    sentHeaders = true;
                }
                // Start building the download progress event to deliver on the response
                // event stream.
                var progressEvent = {
                    type: HttpEventType.DownloadProgress,
                    loaded: event.loaded,
                };
                // Set the total number of bytes in the event if it's available.
                if (event.lengthComputable) {
                    progressEvent.total = event.total;
                }
                // If the request was for text content and a partial response is
                // available on XMLHttpRequest, include it in the progress event
                // to allow for streaming reads.
                if (req.responseType === 'text' && !!xhr.responseText) {
                    progressEvent.partialText = xhr.responseText;
                }
                // Finally, fire the event.
                observer.next(progressEvent);
            };
            // The upload progress event handler, which is only registered if
            // progress events are enabled.
            var onUpProgress = function (event) {
                // Upload progress events are simpler. Begin building the progress
                // event.
                var progress = {
                    type: HttpEventType.UploadProgress,
                    loaded: event.loaded,
                };
                // If the total number of bytes being uploaded is available, include
                // it.
                if (event.lengthComputable) {
                    progress.total = event.total;
                }
                // Send the event.
                observer.next(progress);
            };
            // By default, register for load and error events.
            xhr.addEventListener('load', onLoad);
            xhr.addEventListener('error', onError);
            // Progress events are only enabled if requested.
            if (req.reportProgress) {
                // Download progress is always enabled if requested.
                xhr.addEventListener('progress', onDownProgress);
                // Upload progress depends on whether there is a body to upload.
                if (reqBody !== null && xhr.upload) {
                    xhr.upload.addEventListener('progress', onUpProgress);
                }
            }
            // Fire the request, and notify the event stream that it was fired.
            xhr.send(reqBody);
            observer.next({ type: HttpEventType.Sent });
            // This is the return from the Observable function, which is the
            // request cancellation handler.
            return function () {
                // On a cancellation, remove all registered event listeners.
                xhr.removeEventListener('error', onError);
                xhr.removeEventListener('load', onLoad);
                if (req.reportProgress) {
                    xhr.removeEventListener('progress', onDownProgress);
                    if (reqBody !== null && xhr.upload) {
                        xhr.upload.removeEventListener('progress', onUpProgress);
                    }
                }
                // Finally, abort the in-flight request.
                xhr.abort();
            };
        });
    };
    HttpXhrBackend.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    HttpXhrBackend.ctorParameters = function () { return [
        { type: XhrFactory }
    ]; };
    return HttpXhrBackend;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var XSRF_COOKIE_NAME = new i0.InjectionToken('XSRF_COOKIE_NAME');
var XSRF_HEADER_NAME = new i0.InjectionToken('XSRF_HEADER_NAME');
/**
 * Retrieves the current XSRF token to use with the next outgoing request.
 *
 *
 */
var HttpXsrfTokenExtractor = /** @class */ (function () {
    function HttpXsrfTokenExtractor() {
    }
    return HttpXsrfTokenExtractor;
}());
/**
 * `HttpXsrfTokenExtractor` which retrieves the token from a cookie.
 */
var HttpXsrfCookieExtractor = /** @class */ (function () {
    function HttpXsrfCookieExtractor(doc, platform, cookieName) {
        this.doc = doc;
        this.platform = platform;
        this.cookieName = cookieName;
        this.lastCookieString = '';
        this.lastToken = null;
        /**
         * @internal for testing
         */
        this.parseCount = 0;
    }
    HttpXsrfCookieExtractor.prototype.getToken = function () {
        if (this.platform === 'server') {
            return null;
        }
        var cookieString = this.doc.cookie || '';
        if (cookieString !== this.lastCookieString) {
            this.parseCount++;
            this.lastToken = common.parseCookieValue(cookieString, this.cookieName);
            this.lastCookieString = cookieString;
        }
        return this.lastToken;
    };
    HttpXsrfCookieExtractor.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    HttpXsrfCookieExtractor.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [common.DOCUMENT,] }] },
        { type: String, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] },
        { type: String, decorators: [{ type: i0.Inject, args: [XSRF_COOKIE_NAME,] }] }
    ]; };
    return HttpXsrfCookieExtractor;
}());
/**
 * `HttpInterceptor` which adds an XSRF token to eligible outgoing requests.
 */
var HttpXsrfInterceptor = /** @class */ (function () {
    function HttpXsrfInterceptor(tokenService, headerName) {
        this.tokenService = tokenService;
        this.headerName = headerName;
    }
    HttpXsrfInterceptor.prototype.intercept = function (req, next) {
        var lcUrl = req.url.toLowerCase();
        // Skip both non-mutating requests and absolute URLs.
        // Non-mutating requests don't require a token, and absolute URLs require special handling
        // anyway as the cookie set
        // on our origin is not the same as the token expected by another origin.
        if (req.method === 'GET' || req.method === 'HEAD' || lcUrl.startsWith('http://') ||
            lcUrl.startsWith('https://')) {
            return next.handle(req);
        }
        var token = this.tokenService.getToken();
        // Be careful not to overwrite an existing header of the same name.
        if (token !== null && !req.headers.has(this.headerName)) {
            req = req.clone({ headers: req.headers.set(this.headerName, token) });
        }
        return next.handle(req);
    };
    HttpXsrfInterceptor.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    HttpXsrfInterceptor.ctorParameters = function () { return [
        { type: HttpXsrfTokenExtractor },
        { type: String, decorators: [{ type: i0.Inject, args: [XSRF_HEADER_NAME,] }] }
    ]; };
    return HttpXsrfInterceptor;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * An `HttpHandler` that applies a bunch of `HttpInterceptor`s
 * to a request before passing it to the given `HttpBackend`.
 *
 * The interceptors are loaded lazily from the injector, to allow
 * interceptors to themselves inject classes depending indirectly
 * on `HttpInterceptingHandler` itself.
 */
var HttpInterceptingHandler = /** @class */ (function () {
    function HttpInterceptingHandler(backend, injector) {
        this.backend = backend;
        this.injector = injector;
        this.chain = null;
    }
    HttpInterceptingHandler.prototype.handle = function (req) {
        if (this.chain === null) {
            var interceptors = this.injector.get(HTTP_INTERCEPTORS, []);
            this.chain = interceptors.reduceRight(function (next, interceptor) { return new HttpInterceptorHandler(next, interceptor); }, this.backend);
        }
        return this.chain.handle(req);
    };
    HttpInterceptingHandler.decorators = [
        { type: i0.Injectable }
    ];
    /** @nocollapse */
    HttpInterceptingHandler.ctorParameters = function () { return [
        { type: HttpBackend },
        { type: i0.Injector }
    ]; };
    return HttpInterceptingHandler;
}());
/**
 * `NgModule` which adds XSRF protection support to outgoing requests.
 *
 * Provided the server supports a cookie-based XSRF protection system, this
 * module can be used directly to configure XSRF protection with the correct
 * cookie and header names.
 *
 * If no such names are provided, the default is to use `X-XSRF-TOKEN` for
 * the header name and `XSRF-TOKEN` for the cookie name.
 *
 *
 */
var HttpClientXsrfModule = /** @class */ (function () {
    function HttpClientXsrfModule() {
    }
    /**
     * Disable the default XSRF protection.
     */
    HttpClientXsrfModule.disable = function () {
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                { provide: HttpXsrfInterceptor, useClass: NoopInterceptor },
            ],
        };
    };
    /**
     * Configure XSRF protection to use the given cookie name or header name,
     * or the default names (as described above) if not provided.
     */
    HttpClientXsrfModule.withOptions = function (options) {
        if (options === void 0) { options = {}; }
        return {
            ngModule: HttpClientXsrfModule,
            providers: [
                options.cookieName ? { provide: XSRF_COOKIE_NAME, useValue: options.cookieName } : [],
                options.headerName ? { provide: XSRF_HEADER_NAME, useValue: options.headerName } : [],
            ],
        };
    };
    HttpClientXsrfModule.decorators = [
        { type: i0.NgModule, args: [{
                    providers: [
                        HttpXsrfInterceptor,
                        { provide: HTTP_INTERCEPTORS, useExisting: HttpXsrfInterceptor, multi: true },
                        { provide: HttpXsrfTokenExtractor, useClass: HttpXsrfCookieExtractor },
                        { provide: XSRF_COOKIE_NAME, useValue: 'XSRF-TOKEN' },
                        { provide: XSRF_HEADER_NAME, useValue: 'X-XSRF-TOKEN' },
                    ],
                },] }
    ];
    return HttpClientXsrfModule;
}());
/**
 * `NgModule` which provides the `HttpClient` and associated services.
 *
 * Interceptors can be added to the chain behind `HttpClient` by binding them
 * to the multiprovider for `HTTP_INTERCEPTORS`.
 *
 *
 */
var HttpClientModule = /** @class */ (function () {
    function HttpClientModule() {
    }
    HttpClientModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        HttpClientXsrfModule.withOptions({
                            cookieName: 'XSRF-TOKEN',
                            headerName: 'X-XSRF-TOKEN',
                        }),
                    ],
                    providers: [
                        HttpClient,
                        { provide: HttpHandler, useClass: HttpInterceptingHandler },
                        HttpXhrBackend,
                        { provide: HttpBackend, useExisting: HttpXhrBackend },
                        BrowserXhr,
                        { provide: XhrFactory, useExisting: BrowserXhr },
                    ],
                },] }
    ];
    return HttpClientModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DisplayFieldService = /** @class */ (function () {
    function DisplayFieldService() {
    }
    /**
     * @param {?} dataIndex
     * @param {?} data
     * @return {?}
     */
    DisplayFieldService.prototype.findValue = /**
     * @param {?} dataIndex
     * @param {?} data
     * @return {?}
     */
    function (dataIndex, data) {
        this.rowData = data;
        if (dataIndex != null) {
            var /** @type {?} */ index = dataIndex.split('.');
            if (index.includes('')) {
                index.splice(1);
            }
            for (var _i = 0, index_1 = index; _i < index_1.length; _i++) {
                var ir = index_1[_i];
                this.rowData = this.rowData[ir];
            }
            return this.rowData;
        }
    };
    DisplayFieldService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root',
                },] },
    ];
    /** @nocollapse */
    DisplayFieldService.ctorParameters = function () { return []; };
    /** @nocollapse */ DisplayFieldService.ngInjectableDef = i0.defineInjectable({ factory: function DisplayFieldService_Factory() { return new DisplayFieldService(); }, token: DisplayFieldService, providedIn: "root" });
    return DisplayFieldService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DisplayFieldComponent = /** @class */ (function () {
    function DisplayFieldComponent(displayFieldService) {
        this.displayFieldService = displayFieldService;
    }
    /**
     * @return {?}
     */
    DisplayFieldComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.findDisplayValues();
    };
    /**
     * @return {?}
     */
    DisplayFieldComponent.prototype.findDisplayValues = /**
     * @return {?}
     */
    function () {
        this.rowData = this.displayFieldService.findValue(this.dataIndex, this.data);
    };
    DisplayFieldComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-display-field',
                    template: "\n    {{rowData}}\n  ",
                },] },
    ];
    /** @nocollapse */
    DisplayFieldComponent.ctorParameters = function () { return [
        { type: DisplayFieldService }
    ]; };
    DisplayFieldComponent.propDecorators = {
        data: [{ type: i0.Input }],
        dataIndex: [{ type: i0.Input, args: ['data-index',] }]
    };
    return DisplayFieldComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var DropDownListComponent = /** @class */ (function () {
    function DropDownListComponent(elementRef) {
        this.elementRef = elementRef;
        this.itemclick = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    DropDownListComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DropDownListComponent.prototype.onDropDownListClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.itemclick.emit(event);
    };
    /**
     * @param {?} rowindex
     * @return {?}
     */
    DropDownListComponent.prototype.scroll = /**
     * @param {?} rowindex
     * @return {?}
     */
    function (rowindex) {
        var /** @type {?} */ listitems = this.elementRef.nativeElement.getElementsByClassName('list-items')[rowindex];
        if (listitems) {
            listitems.scrollIntoView({ behavior: 'smooth' });
        }
    };
    /**
     * @return {?}
     */
    DropDownListComponent.prototype.selectedItem = /**
     * @return {?}
     */
    function () {
        return this.elementRef.nativeElement.getElementsByClassName('list-items list-items-selected');
    };
    DropDownListComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'dropdown-list-item',
                    template: "\n          <ul role=\"list\"  class=\"dropdown-list\">\n              <li role=\"listitem\" [ngClass]=\"{'list-items-selected': (i === highlightrow)}\" \n                   class=\"list-items\" \n                   [attr.valuefield]=\"item[valuefield]\" \n                   [attr.displayfield]=\"item[displayfield]\" \n                   *ngFor=\"let item of viewdata | async | filterpipe : displayfield : displayValue ; index as i\"  \n                  (mousedown)=\"onDropDownListClick(item)\"\n                  id=\"{{item.index}}\">\n                  <ng-container *ngIf=\"!template\">\n                      <div><amexio-display-field [data]=\"item\" [data-index]=\"displayfield\"></amexio-display-field></div>    \n                  </ng-container>\n\n                  <ng-container *ngIf=\"template\">\n                      <ng-template [ngTemplateOutlet]=\"template\" [ngTemplateOutletContext]=\"{ $implicit: { text : row }, row: item }\">\n                      </ng-template>\n                  </ng-container>\n    \n              </li>\n          </ul>\n    ",
                },] },
    ];
    /** @nocollapse */
    DropDownListComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    DropDownListComponent.propDecorators = {
        viewdata: [{ type: i0.Input, args: ['data',] }],
        highlightrow: [{ type: i0.Input, args: ['highlight-row',] }],
        valuefield: [{ type: i0.Input, args: ['value-field',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        displayValue: [{ type: i0.Input, args: ['display-value',] }],
        itemclick: [{ type: i0.Output }]
    };
    return DropDownListComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var FilterPipe = /** @class */ (function () {
    function FilterPipe() {
    }
    /**
     * @param {?} items
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    FilterPipe.prototype.transform = /**
     * @param {?} items
     * @param {?} field
     * @param {?} value
     * @return {?}
     */
    function (items, field, value) {
        if (!items) {
            return [];
        }
        if (!field || !value) {
            return items;
        }
        return items.filter(function (singleItem) {
            return singleItem[field].toLowerCase().startsWith(value.toLowerCase());
        });
    };
    FilterPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'filterpipe',
                },] },
        { type: i0.Injectable },
    ];
    return FilterPipe;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var faFaCaretIcon = 'fa fa-caret-down';
var faFaTimesIcon = 'fa fa-times';
var ICON_MAPPING = [
    {
        component: 'datepicker_previous',
        fa: 'fa fa-chevron-left',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'datepicker_calendar',
        fa: 'fa fa-calendar',
        mat: 'date_range',
    },
    {
        component: 'datepicker_next',
        fa: 'fa fa-chevron-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'datepicker_previous_fast',
        fa: 'fa fa-step-backward',
        mat: 'fast_rewind',
    },
    {
        component: 'datepicker_next_fast',
        fa: 'fa fa-step-forward',
        mat: 'fast_forward',
    },
    {
        component: 'accordion_expand',
        fa: 'fa fa-plus',
        mat: 'add',
    },
    {
        component: 'accordion_collapse',
        fa: 'fa fa-minus',
        mat: 'remove',
    },
    {
        component: 'tree_expand',
        fa: 'fa fa-chevron-down',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'tree_collapse',
        fa: 'fa fa-chevron-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'dropdown_caret',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'tab_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'window_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'window_maximize',
        fa: 'fa fa-window-maximize',
        mat: 'open_with',
    },
    {
        component: 'window_restore',
        fa: 'fa fa-window-restore',
        mat: 'indeterminate_check_box',
    },
    {
        component: 'paginator_previous',
        fa: 'fa fa-angle-left',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'paginator_next',
        fa: 'fa fa-angle-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'paginator_first',
        fa: 'fa fa-angle-double-left',
        mat: 'first_page',
    },
    {
        component: 'paginator_last',
        fa: 'fa fa-angle-double-right',
        mat: 'last_page',
    },
    {
        component: 'itemselector_caretup',
        fa: 'fa fa-caret-up',
        mat: 'arrow_drop_up',
    },
    {
        component: 'itemselector_caretdown',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'itemselector_arrowup',
        fa: 'fa fa-arrow-up',
        mat: 'arrow_upward',
    },
    {
        component: 'itemselector_arrowdown',
        fa: 'fa fa-arrow-down',
        mat: 'arrow_downward',
    },
    {
        component: 'itemselector_arrowleft',
        fa: 'fa fa-arrow-left',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'itemselector_arrowright',
        fa: 'fa fa-arrow-right',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'tab_previous',
        fa: 'fa fa-angle-left fa-2x',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'tab_next',
        fa: 'fa fa-angle-right  fa-2x',
    },
    {
        component: 'tab_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'fieldset_expand',
        fa: 'fa fa-plus',
        mat: 'add',
    },
    {
        component: 'fieldset_collpase',
        fa: 'fa fa-minus',
        mat: 'remove',
    },
    {
        component: 'carousel_previous',
        fa: 'fa fa-angle-left fa-2x',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'carousel_next',
        fa: 'fa fa-angle-right  fa-2x',
    },
    {
        component: 'dockbar_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'notify_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'sidenav_bar',
        fa: 'fa fa-bars fa-2x',
        mat: 'menu',
    },
    {
        component: 'sidenav_close',
        fa: faFaTimesIcon,
        mat: 'close',
    },
    {
        component: 'datagrid_arrowdown',
        fa: 'fa fa-arrow-down',
        mat: 'arrow_downward',
    },
    {
        component: 'datagrid_arrowup',
        fa: 'fa fa-arrow-up',
        mat: 'arrow_upward',
    },
    {
        component: 'datagrid_list',
        fa: 'fa fa-th-list',
        mat: 'view_list',
    },
    {
        component: 'datagrid_expand',
        fa: 'fa fa-caret-right',
        mat: '',
    },
    {
        component: 'datagrid_collapse',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'datagrid_collapse',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'datagrid_filter',
        fa: 'fa fa-filter',
        mat: 'filter_list',
    },
    {
        component: 'tree_filter',
        fa: 'fa fa-filter',
        mat: 'filter_list',
    },
    {
        component: 'data_check',
        fa: 'fa fa-check',
        mat: 'check',
    },
    {
        component: 'button_caret-down',
        fa: faFaCaretIcon,
        mat: 'arrow_drop_down',
    },
    {
        component: 'button_angle-right',
        fa: 'fa fa-angle-right',
        mat: 'arrow_drop_right',
    },
    {
        component: 'button_angle-down',
        fa: 'fa fa-angle-down',
        mat: 'arrow_drop_down',
    },
    {
        component: 'menubar_ravelry',
        fa: 'fa fa-ravelry',
        mat: 'done',
    },
    {
        component: 'sidenav-angle-up',
        fa: 'fa fa-angle-up',
        mat: 'keyboard_arrow_up',
    },
    {
        component: 'sidenav-angle-down',
        fa: 'fa fa-angle-down',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-error',
        fa: 'fa fa-exclamation-triangle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-warning',
        fa: 'fa fa-exclamation-triangle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-help',
        fa: 'fa fa-question-circle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'window-msgtype-confirm',
        fa: 'fa fa-check-circle fa-2x fa-fw',
        mat: 'keyboard_arrow_down',
    },
    {
        component: 'horizontal-tree-expanded',
        fa: 'fa fa-caret-right fa-fw',
        mat: 'keyboard_arrow_right',
    },
    {
        component: 'horizontal-tree-collapse',
        fa: 'fa fa-caret-left fa-fw',
        mat: 'keyboard_arrow_left',
    },
    {
        component: 'button-loading-icon',
        fa: 'fa fa-refresh fa-spin',
        mat: 'cached',
    },
    {
        component: 'datepicker-clock-icon',
        fa: 'fa fa-clock-o',
        mat: 'access_time',
    },
    {
        component: 'sidenavnode-icon',
        fa: 'fa fa-user-circle',
        mat: 'person_pin',
    },
];
var IconLoaderService = /** @class */ (function () {
    function IconLoaderService() {
        this.iconMappings = ICON_MAPPING;
    }
    Object.defineProperty(IconLoaderService.prototype, "iconToUse", {
        get: /**
         * @return {?}
         */
        function () {
            if (this._iconToUse == null) {
                return 'fa';
            }
            else {
                return this._iconToUse;
            }
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._iconToUse = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} componentKey
     * @param {?} newValue
     * @return {?}
     */
    IconLoaderService.prototype.modifyIconClass = /**
     * @param {?} componentKey
     * @param {?} newValue
     * @return {?}
     */
    function (componentKey, newValue) {
        var _this = this;
        if (this.iconMappings != null) {
            this.iconMappings.forEach(function (icon) {
                if (icon.component === componentKey) {
                    icon[_this._iconToUse.toString()] = newValue;
                }
            });
        }
    };
    // TO GET ICON OBJECT
    /**
     * @param {?} componentName
     * @return {?}
     */
    IconLoaderService.prototype.getIconObject = /**
     * @param {?} componentName
     * @return {?}
     */
    function (componentName) {
        var /** @type {?} */ obj = null;
        if (this.iconMappings !== null) {
            this.iconMappings.forEach(function (object) {
                if (object.component === componentName) {
                    obj = object;
                }
            });
        }
        return obj;
    };
    IconLoaderService.decorators = [
        { type: i0.Injectable },
    ];
    /** @nocollapse */
    IconLoaderService.ctorParameters = function () { return []; };
    return IconLoaderService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by  Pratik on 21/12/17.
*/
var CommonIconComponent = /** @class */ (function () {
    function CommonIconComponent(iconLoaderService) {
        this.iconLoaderService = iconLoaderService;
        /*
        Properties
        name : label
        datatype : string
        version : 5.5.5 onwards
        default : none
        description : sets the key for icon
        */
        this.label = '';
        /*
        Events
        name : onClick
        datatype : any
        version : none
        default : none
        description : Event is fired when button is click
        */
        this.onClick = new i0.EventEmitter();
        this.faiconcolor = '';
    }
    /**
     * @return {?}
     */
    CommonIconComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.iconClass = this.getIconClass();
    };
    /**
     * @return {?}
     */
    CommonIconComponent.prototype.getIconClass = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.iconLoaderService.iconMappings != null) {
            var /** @type {?} */ iconObject = this.iconLoaderService.iconMappings.find(function (obj) { return obj.component === _this.key; });
            if (iconObject != null) {
                return iconObject[this.iconLoaderService.iconToUse.toString()];
            }
            else {
                return '';
            }
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    CommonIconComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['key']) {
            this.key = changes["key"].currentValue;
            this.iconClass = this.getIconClass();
        }
    };
    CommonIconComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-c-icon',
                    template: "\n   <ng-container *ngIf=\"iconLoaderService.iconToUse == 'fa'\">\n\n   <ng-container *ngIf=\"customclass != null\">\n     <span [ngStyle]=\"{'color':color}\" class=\"{{customclass}}\" aria-hidden=\"true\"\n     (click)=\"onClick.emit($event)\">\n     <ng-container *ngIf=\"label != ''\">\n     <span class=\"font-with-label\" >\n     {{label}}</span>\n     </ng-container>\n     </span>\n   </ng-container>\n   <ng-container *ngIf=\"customclass == null\">\n     <span [ngStyle]=\"{'color':color}\" class=\"{{iconClass}}\" aria-hidden=\"true\"\n     (click)=\"onClick.emit($event)\">\n     <ng-container *ngIf=\"label != ''\">\n     <span class=\"font-with-label\">\n     {{label}}\n     </span>\n     </ng-container>\n     </span>\n   </ng-container>\n\n </ng-container>\n\n <ng-container *ngIf=\"iconLoaderService.iconToUse == 'mat'\">\n\n   <ng-container *ngIf=\"customclass != null\">\n     <i [ngStyle]=\"{'color':color}\" class=\"material-icons\"\n     (click)=\"onClick.emit($event)\">{{customclass}}</i>\n<ng-container *ngIf=\"label != ''\">\n     <span class=\"font-with-label\"> {{label}}</span>\n</ng-container>\n   </ng-container>\n\n   <ng-container *ngIf=\"customclass == null\">\n     <i [ngStyle]=\"{'color':color}\" class=\"material-icons\"\n     (click)=\"onClick.emit($event)\">{{iconClass}}</i>\n     <ng-container *ngIf=\"label != ''\">\n     <span class=\"font-with-label\"> {{label}}</span>\n     </ng-container>\n   </ng-container>\n\n\n </ng-container>\n  ",
                    styles: ["\n  .fa-2x,.fa-3x, .fa-4x, .fa-5x {\n    margin-top:0px!important;\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    CommonIconComponent.ctorParameters = function () { return [
        { type: IconLoaderService }
    ]; };
    CommonIconComponent.propDecorators = {
        key: [{ type: i0.Input }],
        label: [{ type: i0.Input }],
        onClick: [{ type: i0.Output }],
        customclass: [{ type: i0.Input }],
        color: [{ type: i0.Input }],
        faiconcolor: [{ type: i0.Input }]
    };
    return CommonIconComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var COMMON_COMPONENTS = [
    DisplayFieldComponent,
    DropDownListComponent,
    FilterPipe,
    CommonIconComponent,
];
var AmexioCommonModule = /** @class */ (function () {
    function AmexioCommonModule() {
    }
    /**
     * @return {?}
     */
    AmexioCommonModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioCommonModule,
            providers: [IconLoaderService, DisplayFieldService],
        };
    };
    AmexioCommonModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        HttpClientModule,
                    ],
                    exports: COMMON_COMPONENTS,
                    declarations: COMMON_COMPONENTS,
                    providers: [],
                },] },
    ];
    return AmexioCommonModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var defaultclass = /** @class */ (function () {
    function class_1() {
    }
    return class_1;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioRuntimeComponent = /** @class */ (function () {
    function AmexioRuntimeComponent(_compiler, _injector, _m) {
        this._compiler = _compiler;
        this._injector = _injector;
        this._m = _m;
        this.oninit = new i0.EventEmitter();
    }
    Object.defineProperty(AmexioRuntimeComponent.prototype, "htmltemplate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._htmlTemplate;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v != null && v.length > 0) {
                this._htmlTemplate = v;
                this.render();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioRuntimeComponent.prototype, "tsclass", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tsclass;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v != null) {
                this._tsclass = v;
                this.render();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioRuntimeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioRuntimeComponent.prototype.render = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.htmltemplate || this.htmltemplate.length === 0) {
            return;
        }
        if (!this.tsclass) {
            this.tsclass = defaultclass;
        }
        var /** @type {?} */ tmpCmp = i0.Component({ template: this.htmltemplate })(this.tsclass);
        var /** @type {?} */ tmpModule = i0.NgModule({
            providers: [HttpClientModule], imports: [forms.FormsModule, AmexioWidgetModule, HttpClientModule],
            declarations: [tmpCmp],
            entryComponents: [tmpCmp],
        })(defaultclass);
        this._compiler.compileModuleAsync(tmpModule)
            .then(function (moduleFactory) {
            var /** @type {?} */ resolver = moduleFactory.create(_this._injector).componentFactoryResolver;
            var /** @type {?} */ f = resolver.resolveComponentFactory(tmpCmp);
            var /** @type {?} */ cmpRef = f.create(_this._injector, [], null, _this._m);
            _this._container.insert(cmpRef.hostView);
            var /** @type {?} */ object = { reference: cmpRef, instance: cmpRef.instance };
            _this.oninit.emit(object);
        });
    };
    AmexioRuntimeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-runtime',
                    template: '<div #vc></div>',
                },] },
    ];
    /** @nocollapse */
    AmexioRuntimeComponent.ctorParameters = function () { return [
        { type: i0.Compiler },
        { type: i0.Injector },
        { type: i0.NgModuleRef }
    ]; };
    AmexioRuntimeComponent.propDecorators = {
        _container: [{ type: i0.ViewChild, args: ['vc', { read: i0.ViewContainerRef },] }],
        htmltemplate: [{ type: i0.Input, args: ['html-template',] }],
        tsclass: [{ type: i0.Input, args: ['ts-class',] }],
        oninit: [{ type: i0.Output, args: ['onInit',] }]
    };
    return AmexioRuntimeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CommonDataService = /** @class */ (function () {
    function CommonDataService(_http) {
        this._http = _http;
        this.filteredObject = [];
    }
    /**
     * @param {?} serviceUrl
     * @param {?} methodType
     * @return {?}
     */
    CommonDataService.prototype.fetchData = /**
     * @param {?} serviceUrl
     * @param {?} methodType
     * @return {?}
     */
    function (serviceUrl, methodType) {
        var /** @type {?} */ requestJson = {};
        var /** @type {?} */ headers = new HttpHeaders().append('Content-Type', 'application/json;charset=UTF-8');
        if (methodType === 'post') {
            return this._http.post(serviceUrl, requestJson, { headers: headers });
        }
        else if (methodType === 'get') {
            return this._http.get(serviceUrl, { headers: headers });
        }
    };
    /**
     * @param {?} serviceUrl
     * @param {?} methodType
     * @param {?} requestData
     * @return {?}
     */
    CommonDataService.prototype.uploadFile = /**
     * @param {?} serviceUrl
     * @param {?} methodType
     * @param {?} requestData
     * @return {?}
     */
    function (serviceUrl, methodType, requestData) {
        var /** @type {?} */ requestJson = requestData;
        var /** @type {?} */ headers = new HttpHeaders().append('Access-Control-Allow-Origin', '*');
        if (methodType.toUpperCase() === 'POST') {
            return this._http.post(serviceUrl, requestJson, { headers: headers });
        }
    };
    CommonDataService.decorators = [
        { type: i0.Injectable },
    ];
    /** @nocollapse */
    CommonDataService.ctorParameters = function () { return [
        { type: HttpClient }
    ]; };
    return CommonDataService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FORM_COMPONENTS = [
    AmexioRuntimeComponent,
];
var AmexioRuntimeModule = /** @class */ (function () {
    function AmexioRuntimeModule() {
    }
    /**
     * @return {?}
     */
    AmexioRuntimeModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioRuntimeModule,
            providers: [],
        };
    };
    AmexioRuntimeModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        HttpClientModule,
                        AmexioCommonModule.forRoot(),
                    ],
                    exports: FORM_COMPONENTS,
                    declarations: FORM_COMPONENTS,
                    providers: [],
                },] },
    ];
    return AmexioRuntimeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var AmexioContextMenuComponent = /** @class */ (function () {
    function AmexioContextMenuComponent(renderer) {
        this.renderer = renderer;
        this.onRightClick = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    AmexioContextMenuComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    AmexioContextMenuComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this.isflagshow = true;
        this.contextStyle = this.getContextMenuStyle();
    };
    /**
     * @return {?}
     */
    AmexioContextMenuComponent.prototype.getContextMenuStyle = /**
     * @return {?}
     */
    function () {
        return {
            'cursor': 'default',
            'position': 'fixed',
            'display': this.isflagshow ? 'block' : 'none',
            'left': this.mouseLocationLeft + 'px',
            'top': this.mouseLocationTop + 'px',
            'box-shadow': '1px 1px 2px #000000',
            'width': '15%',
        };
    };
    /**
     * @param {?} itemConfig
     * @return {?}
     */
    AmexioContextMenuComponent.prototype.onContextNodeClick = /**
     * @param {?} itemConfig
     * @return {?}
     */
    function (itemConfig) {
        if (!itemConfig.disabled) {
            var /** @type {?} */ obj = {
                menuData: itemConfig,
                nodeData: this.rightClickData,
            };
            this.isflagshow = false;
            this.onRightClick.emit(obj);
        }
    };
    AmexioContextMenuComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'base-contextmenu',
                    template: "\n    <span [ngStyle]=\"contextStyle\"> \n        <ul class=\"context-menu-list\" [ngClass]=\"{'dropdown-up' : posixUp}\">\n            <li (click)=\"onContextNodeClick(itemConfig)\" class=\"context-menu-list-items\"\n             [ngStyle]=\"{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}\"\n                [ngClass]=\"{'context-menu-separator':itemConfig.seperator}\" *ngFor=\"let itemConfig of contextmenu\">\n                <em [ngStyle]=\"{'padding-left': itemConfig.icon ? '5px':'19px'}\" [ngClass]=\"itemConfig.icon\"></em>\n                <span style=\"white-space: nowrap;display: inline ; padding-left:5px\">{{itemConfig.text}}\n                </span>\n            </li>\n        </ul>\n    </span>\n  ",
                    styles: ["\n    .context-menu-list{display:block;position:absolute;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;min-width:180px;cursor:pointer;max-height:150px;z-index:1;padding:10px 0;overflow-y:auto;-webkit-box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12)}\n  "],
                },] },
    ];
    /** @nocollapse */
    AmexioContextMenuComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };
    AmexioContextMenuComponent.propDecorators = {
        isflagshow: [{ type: i0.Input, args: ['is-FlagShow',] }],
        contextmenu: [{ type: i0.Input, args: ['base-context-menu',] }],
        posixUp: [{ type: i0.Input, args: ['position-up',] }],
        onRightClick: [{ type: i0.Output }],
        rightClickData: [{ type: i0.Input, args: ['right-click-data',] }],
        mouseLocationLeft: [{ type: i0.Input, args: ['mouse-location-left',] }],
        mouseLocationTop: [{ type: i0.Input, args: ['mouse-location-top',] }]
    };
    return AmexioContextMenuComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CONTEXTMENU_COMPONENTS = [
    AmexioContextMenuComponent,
];
var AmexioBaseContextMenuModule = /** @class */ (function () {
    function AmexioBaseContextMenuModule() {
    }
    /**
     * @return {?}
     */
    AmexioBaseContextMenuModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioBaseContextMenuModule,
            providers: [CommonDataService, IconLoaderService],
        };
    };
    AmexioBaseContextMenuModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        HttpClientModule,
                    ],
                    exports: CONTEXTMENU_COMPONENTS,
                    declarations: CONTEXTMENU_COMPONENTS,
                    providers: [CommonDataService, IconLoaderService],
                },] },
    ];
    return AmexioBaseContextMenuModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 1/4/18.
*/
var AmexioNavMenuComponent = /** @class */ (function () {
    function AmexioNavMenuComponent() {
        /*
          Events
          name : navLinkClick
          datatype : any
          version : none
          default : none
          description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
          */
        this.navLinkClick = new i0.EventEmitter();
        this.onNavItemClick = new i0.EventEmitter();
        this.mobilemode = false;
        this.issubmenu = false;
        this.position = 'right';
        this.ishovered = true;
    }
    /**
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} flag
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.setMobileMode = /**
     * @param {?} flag
     * @return {?}
     */
    function (flag) {
        this.mobilemode = flag;
    };
    /**
     * @param {?} n
     * @param {?} _event
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.dataObject = /**
     * @param {?} n
     * @param {?} _event
     * @return {?}
     */
    function (n, _event) {
        return { data: n, event: _event };
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.onHeaderClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ node = {
            header: true,
            title: this.title,
            icon: this.icon,
        };
        this.onClick(node, event);
    };
    /**
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.onNodeHover = /**
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    function (node, event) {
        var _this = this;
        this.ishovered = false;
        // clear hover flag;
        this.data.forEach(function (element) {
            _this.clearNodeHover(element);
        });
        if (node.submenus && (node.submenus.length > 0)) {
            node.ishover = true;
            this.data.forEach(function (element) {
                if (node === element) {
                    _this.setNodeHover(node);
                }
            });
        }
        this.position = this.getMenuPosition(event);
        event.stopPropagation();
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.setNodeHover = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        node.ishover = true;
        if (node.submenus && (node.submenus.length > 0)) {
            this.setNodeHover(node.submenus);
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.clearNodeHover = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        node.ishover = false;
        if (node.submenus && (node.submenus.length > 0)) {
            node.submenus.forEach(function (element) {
                _this.clearNodeHover(element);
            });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.getMenuPosition = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ remainingleft = event.currentTarget.getBoundingClientRect().left;
        var /** @type {?} */ remainingright = window.screen.width - event.currentTarget.getBoundingClientRect().right;
        var /** @type {?} */ directionflag;
        if (remainingright > remainingleft) {
            directionflag = 'right';
        }
        else {
            directionflag = 'left';
        }
        return directionflag;
    };
    /**
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.clearhover = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            _this.data.forEach(function (element) {
                _this.clearNodeHover(element);
            });
        }, 0);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.onMouseoverTitle = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.position = this.getMenuPosition(event);
    };
    /**
     * @param {?} _node
     * @param {?} _event
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.onClick = /**
     * @param {?} _node
     * @param {?} _event
     * @return {?}
     */
    function (_node, _event) {
        var /** @type {?} */ n = {
            title: this.title,
            data: this.data,
            icon: this.icon,
            node: _node,
            mobilemode: this.mobilemode,
        };
        this.onNavItemClick.emit(this.dataObject(n, _event));
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavMenuComponent.prototype.navItemClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.event.stopPropagation();
        this.onNavItemClick.emit(event);
    };
    AmexioNavMenuComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-nav-menu',
                    template: "\n    <div class=\"nav-dropdown\">\n        <a class=\"nav-dropbtn\" [ngStyle]=\"{'color':color}\" (mouseover)=\"onMouseoverTitle($event)\" (click)=\"onHeaderClick($event)\">\n            <span>\n                <i *ngIf=\"icon\" [ngClass]=\"icon\"></i>\n            </span>\n            <span>{{title}}</span>\n        \n            <span>\n                <i class=\"dropdownicon fa fa-angle-down\"></i>\n            </span>\n        </a>\n\n        <div class=\"nav-dropdown-content\">\n\n            <a *ngFor=\"let node of data\" (click)=\"onClick(node, $event)\" (mouseover)=\"onNodeHover(node, $event)\">\n\n                <div>\n                    <span class=\"nav-dropdown-content-node\">\n                        <i *ngIf=\"icon\" [ngClass]=\"node.icon\"></i>&nbsp;\n                        <span>\n                            <span *ngIf=\"position == 'left' && node.submenus\">\n                                <i class=\"fa fa-angle-left\" style=\"padding-bottom:6px; padding-right:6px;\" aria-hidden=\"true\"></i>\n                            </span>\n                            {{node.text}}\n                    \n                            <span *ngIf=\"position == 'right' && node.submenus\">\n                                <i class=\"fa fa-angle-right\" style=\"float:right ;padding-top:5px\" aria-hidden=\"true\"></i>\n\n                            </span>\n                        </span>\n                    </span>\n\n                    <span [ngClass]=\"{'submenunodes':position == 'right', 'submenunodesright':position == 'left' }\" *ngIf=\"node.submenus\">\n                        <amexio-nav-innermenu [color]=\"itemcolor\" [submenuposition]=\"position\" [data]=\"node.submenus\" (navLinkClick)=\"navItemClick($event)\">\n                        </amexio-nav-innermenu>\n                    </span>\n                </div>\n            </a>\n\n            <div *ngIf=\"type==='menucontainer'\" class=\"nav-menu-container\">\n                <a *ngFor=\"let node of data\" (click)=\"onClick(node, $event)\">\n                    <i *ngIf=\"icon\" [ngClass]=\"node.icon\"></i>&nbsp;{{node.text}}</a>\n                <ng-content></ng-content>\n            </div>\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioNavMenuComponent.ctorParameters = function () { return []; };
    AmexioNavMenuComponent.propDecorators = {
        type: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        data: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        navLinkClick: [{ type: i0.Output }],
        onNavItemClick: [{ type: i0.Output }],
        rightflag: [{ type: i0.Input }],
        color: [{ type: i0.Input, args: ['color',] }]
    };
    return AmexioNavMenuComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 1/4/18.
*/
var noop$1 = function () {
};
var AmexioNavItemComponent = /** @class */ (function () {
    function AmexioNavItemComponent(elementref) {
        this.elementref = elementref;
        /*
          Events
          name : onNavItemClick
          datatype : any
          version : none
          default : none
          description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
          */
        this.onNavItemClick = new i0.EventEmitter();
        this.mobilemode = false;
        this.isAction = false;
        this.isTextField = false;
        this.isMenu = false;
        this.isMenuContainer = false;
        this.innerValue = '';
        this.onTouchedCallback = noop$1;
        this.onChangeCallback = noop$1;
    }
    /**
     * @return {?}
     */
    AmexioNavItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.type === 'link' || this.type === 'button' || this.type === 'toggle') {
            this.isAction = true;
        }
        else if (this.type === 'textfield') {
            this.isTextField = true;
        }
        else if (this.type === 'menu') {
            this.isMenu = true;
        }
        else if (this.type === 'menucontainer') {
            this.isMenuContainer = true;
        }
    };
    /**
     * @return {?}
     */
    AmexioNavItemComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioNavItemComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            _this.right = _this.elementref.nativeElement.getBoundingClientRect().right;
        }, 100);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioNavItemComponent.prototype.setSubmenuIcon = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (node.submenus && (node.submenus.length > 0)) {
            node.submenus['iconposition'] = 'left';
            this.setSubmenuIcon(node.submenus);
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioNavItemComponent.prototype.setHoverattr = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        node['ishover'] = false;
        if (node.submenus && (node.submenus.length > 0)) {
            this.setHoverattr(node.submenus);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavItemComponent.prototype.navItemClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onNavItemClick.emit(event);
    };
    /**
     * @param {?} flag
     * @return {?}
     */
    AmexioNavItemComponent.prototype.setMobileMode = /**
     * @param {?} flag
     * @return {?}
     */
    function (flag) {
        this.mobilemode = flag;
    };
    /**
     * @param {?} navbarwidth
     * @return {?}
     */
    AmexioNavItemComponent.prototype.setNavbarWidth = /**
     * @param {?} navbarwidth
     * @return {?}
     */
    function (navbarwidth) {
        var _this = this;
        setTimeout(function () {
            _this.navbarwidth = navbarwidth;
            if ((_this.navbarwidth - _this.elementref.nativeElement.getBoundingClientRect().left) < 165) {
                _this.enablerightclass = true;
            }
        }, 0);
    };
    Object.defineProperty(AmexioNavItemComponent.prototype, "value", {
        //  MODEL BINDING FOR TEXT FIELD
        // The internal dataviews model
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        // get accessor
        get: /**
         * @return {?}
         */
        function () {
            return this.innerValue;
        },
        // set accessor including call the onchange callback
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v !== this.innerValue) {
                this.innerValue = v;
                this.onChangeCallback(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioNavItemComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioNavItemComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioNavItemComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @return {?}
     */
    AmexioNavItemComponent.prototype.hoverfun = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.data.forEach(function (node) {
            _this.ResetHoverattr(node);
        });
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioNavItemComponent.prototype.ResetHoverattr = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        node.ishover = false;
        if (node.submenus && (node.submenus.length > 0)) {
            node.submenus.forEach(function (element) {
                _this.ResetHoverattr(node.submenus);
            });
        }
    };
    AmexioNavItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-nav-item',
                    template: "\n    <div class=\"topnavmainbarinneritems\" [ngClass]=\"{'topnavmainbarinneritems-mobile':mobilemode,\n     'nav-dropdown-content-right':enablerightclass}\">\n        <amexio-nav-action *ngIf=\"isAction\" [color]=\"itemcolor\" [type]=\"type\" [title]=\"title\" [icon]=\"icon\" (navLinkClick)=\"navItemClick($event)\"></amexio-nav-action>\n        <amexio-nav-textfield *ngIf=\"isTextField\" [color]=\"itemcolor\" [(ngModel)]=\"value\" [title]=\"title\"></amexio-nav-textfield>\n        <amexio-nav-menu *ngIf=\"isMenu\" [color]=\"itemcolor\" [title]=\"title\" [icon]=\"icon\" [data]=\"data\" (onNavItemClick)=\"navItemClick($event)\">\n        </amexio-nav-menu>\n        <amexio-nav-menu *ngIf=\"isMenuContainer\" [color]=\"itemcolor\" [title]=\"title\" [icon]=\"icon\" [type]=\"type\" (navLinkClick)=\"navItemClick($event)\">\n            <ng-content></ng-content>\n        </amexio-nav-menu>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioNavItemComponent; }), multi: true,
                        }],
                    encapsulation: i0.ViewEncapsulation.None,
                },] },
    ];
    /** @nocollapse */
    AmexioNavItemComponent.ctorParameters = function () { return [
        { type: i0.ElementRef }
    ]; };
    AmexioNavItemComponent.propDecorators = {
        type: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        data: [{ type: i0.Input }],
        onNavItemClick: [{ type: i0.Output }],
        navmenus: [{ type: i0.ContentChildren, args: [AmexioNavMenuComponent,] }]
    };
    return AmexioNavItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var DeviceQueryService = /** @class */ (function () {
    function DeviceQueryService(platformId) {
        this.platformId = platformId;
        this.rules = {
            print: 'print',
            screen: 'screen',
            phone: '(max-width: 767px)',
            tablet: '(min-width: 768px) and (max-width: 1024px)',
            desktop: '(min-width: 1025px)',
            portrait: '(orientation: portrait)',
            landscape: '(orientation: landscape)',
            retina: '(-webkit-min-device-pixel-ratio: 2) and (min-resolution: 192dpi)',
        };
        this.Check = function (mq) {
            if (common.isPlatformBrowser(this.platformId)) {
                if (!mq) {
                    return;
                }
                return window.matchMedia(mq).matches;
            }
            else {
                return;
            }
        };
        this.IsTablet = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.tablet).matches;
            }
            else {
                return null;
            }
        };
        this.IsDesktop = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.desktop).matches;
            }
            else {
                return null;
            }
        };
        this.IsPortrait = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.portrait).matches;
            }
            else {
                return null;
            }
        };
        this.IsLandscape = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.landscape).matches;
            }
            else {
                return null;
            }
        };
        this.IsRetina = function () {
            if (common.isPlatformBrowser(this.platformId)) {
                return window.matchMedia(this.rules.retina).matches;
            }
            else {
                return null;
            }
        };
        this.browserWindow = function () {
            return window;
        };
    }
    /**********************************************
     METHODS FOR CHECKING TYPE
     **********************************************/
    /**
     * *******************************************
     * METHODS FOR CHECKING TYPE
     * ********************************************
     * @return {?}
     */
    DeviceQueryService.prototype.IsPhone = /**
     * *******************************************
     * METHODS FOR CHECKING TYPE
     * ********************************************
     * @return {?}
     */
    function () {
        if (common.isPlatformBrowser(this.platformId)) {
            return window.matchMedia(this.rules.phone).matches;
        }
        else {
            return null;
        }
    };
    /**********************************************
     EVENT LISTENERS BY TYPE
     **********************************************/
    /**
     * *******************************************
     * EVENT LISTENERS BY TYPE
     * ********************************************
     * @param {?} callBack
     * @return {?}
     */
    DeviceQueryService.prototype.OnPhone = /**
     * *******************************************
     * EVENT LISTENERS BY TYPE
     * ********************************************
     * @param {?} callBack
     * @return {?}
     */
    function (callBack) {
        if (typeof callBack === 'function' && common.isPlatformBrowser(this.platformId)) {
            var /** @type {?} */ mql = window.matchMedia(this.rules.phone);
            this.mqlMethod(callBack, mql);
        }
    };
    /**
     * @param {?} callBack
     * @return {?}
     */
    DeviceQueryService.prototype.OnTablet = /**
     * @param {?} callBack
     * @return {?}
     */
    function (callBack) {
        if (typeof callBack === 'function' && common.isPlatformBrowser(this.platformId)) {
            var /** @type {?} */ mql = window.matchMedia(this.rules.tablet);
            this.mqlMethod(callBack, mql);
        }
    };
    /**
     * @param {?} callBack
     * @return {?}
     */
    DeviceQueryService.prototype.OnDesktop = /**
     * @param {?} callBack
     * @return {?}
     */
    function (callBack) {
        if (typeof callBack === 'function' && common.isPlatformBrowser(this.platformId)) {
            var /** @type {?} */ mql = window.matchMedia(this.rules.desktop);
            this.mqlMethod(callBack, mql);
        }
    };
    /**
     * @param {?} callBack
     * @return {?}
     */
    DeviceQueryService.prototype.OnPortrait = /**
     * @param {?} callBack
     * @return {?}
     */
    function (callBack) {
        if (typeof callBack === 'function' && common.isPlatformBrowser(this.platformId)) {
            var /** @type {?} */ mql = window.matchMedia(this.rules.portrait);
            this.mqlMethod(callBack, mql);
        }
    };
    /**
     * @param {?} callBack
     * @return {?}
     */
    DeviceQueryService.prototype.OnLandscape = /**
     * @param {?} callBack
     * @return {?}
     */
    function (callBack) {
        if (typeof callBack === 'function' && common.isPlatformBrowser(this.platformId)) {
            var /** @type {?} */ mql = window.matchMedia(this.rules.landscape);
            this.mqlMethod(callBack, mql);
        }
    };
    /**
     * @param {?} callBack
     * @param {?} mql
     * @return {?}
     */
    DeviceQueryService.prototype.mqlMethod = /**
     * @param {?} callBack
     * @param {?} mql
     * @return {?}
     */
    function (callBack, mql) {
        mql.addListener(function (mql1) {
            if (mql1.matches) {
                callBack(mql);
            }
        });
    };
    DeviceQueryService.decorators = [
        { type: i0.Injectable },
    ];
    /** @nocollapse */
    DeviceQueryService.ctorParameters = function () { return [
        { type: undefined, decorators: [{ type: i0.Inject, args: [i0.PLATFORM_ID,] }] }
    ]; };
    return DeviceQueryService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by ketangote on 12/8/17.
*/
var AmexioNavBarComponent = /** @class */ (function () {
    function AmexioNavBarComponent(matchMediaService) {
        this.matchMediaService = matchMediaService;
        /*
        Properties
        name : logo
        datatype : string
        version : 4.0 onwards
        default : none
        description : Logo of navbar.
        */
        this.logo = '';
        /*
        Properties
        name : enable-side-nav-position
        datatype : boolean
        version : 4.0 onwards
        default : none
        description : Indicate if side-nav-bar is present
        */
        this.sidenavspace = false;
        /*
        Properties
        name : enable-side-nav-position
        datatype : boolean
        version : 4.0 onwards
        default : none
        description : transparent nav bar
        */
        this.transparent = false;
        this.onNavLogoClick = new i0.EventEmitter();
        this.onNavTitleClick = new i0.EventEmitter();
        this.onIconArrowClick = new i0.EventEmitter();
        this.onIconClick = new i0.EventEmitter();
        this.navSubmenuClick = new i0.EventEmitter();
        this.toggle = true;
        this.mobilemode = false;
        this.sidenav = false;
        this.isIconLeft = true;
        this.isLHSHide = false;
        this.lhsWidth = '5%';
        this.isExpand = false;
        this.isPhone = false;
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.mobilemode = true;
            this.isPhone = true;
        }
        else {
            this.mobilemode = false;
            this.isPhone = false;
        }
    }
    /**
     * @return {?}
     */
    AmexioNavBarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioNavBarComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (!this.logo) {
            this.loadNavItems();
        }
    };
    /**
     * @return {?}
     */
    AmexioNavBarComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.navItemComponents = this.navitems.toArray();
        this.navItemComponents.forEach(function (element) {
            element.itemcolor = _this.color;
        });
    };
    /**
     * @return {?}
     */
    AmexioNavBarComponent.prototype.onImageLoad = /**
     * @return {?}
     */
    function () {
        this.loadNavItems();
    };
    /**
     * @return {?}
     */
    AmexioNavBarComponent.prototype.loadNavItems = /**
     * @return {?}
     */
    function () {
        this.handleNavItems();
        if (this.navbaritems2.nativeElement) {
            this.navitemwidth = (5 +
                (this.navbaritems2.nativeElement.offsetWidth) +
                (this.navbaritems2.nativeElement.offsetWidth) +
                (this.navbaritems3.nativeElement.offsetWidth));
            this.handleDeviceSetting();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavBarComponent.prototype.toggleDrawerPanel = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.toggle = !this.toggle;
    };
    /**
     * @return {?}
     */
    AmexioNavBarComponent.prototype.handleNavItems = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.navItemComponents = this.navitems.toArray();
        this.navItemComponents.forEach(function (node) { return node.onNavItemClick.subscribe(function (eventdata) { return _this.handleNavItemEvent(eventdata); }); });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavBarComponent.prototype.handleNavItemEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event && event.data && event.data.node && !event.data.node.header && this.mobilemode) {
            this.toggle = false;
        }
    };
    /**
     * @param {?} navbarwidth
     * @return {?}
     */
    AmexioNavBarComponent.prototype.notifyNavItems = /**
     * @param {?} navbarwidth
     * @return {?}
     */
    function (navbarwidth) {
        var _this = this;
        if (this.navItemComponents) {
            this.navItemComponents.forEach(function (node) {
                node.setMobileMode(_this.mobilemode);
                node.setNavbarWidth(navbarwidth);
            });
        }
    };
    /**
     * @return {?}
     */
    AmexioNavBarComponent.prototype.handleDeviceSetting = /**
     * @return {?}
     */
    function () {
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.mobilemode = true;
            this.isPhone = true;
        }
        else {
            this.mobilemode = false;
            this.isPhone = false;
        }
        if (this.sidenavspace) {
            this.sideNavbar();
        }
        var /** @type {?} */ navbarwidth = this.navbar.nativeElement.offsetWidth;
        var /** @type {?} */ navbarheight = this.navbar.nativeElement.offsetHeight;
        if (!this.navfixeditem) {
            this.navfixeditem = this.navbarfixed.nativeElement.offsetWidth;
        }
        if (!this.navitemwidth) {
            var /** @type {?} */ navbaritems1Width = 0;
            var /** @type {?} */ navbaritems2Width = 0;
            var /** @type {?} */ navbaritems3Width = 0;
            if (this.navbaritems1) {
                navbaritems1Width = this.navbaritems1.nativeElement.offsetWidth;
            }
            if (this.navbaritems2) {
                navbaritems2Width = this.navbaritems2.nativeElement.offsetWidth;
            }
            if (this.navbaritems3) {
                navbaritems3Width = this.navbaritems3.nativeElement.offsetWidth;
            }
            this.navitemwidth = (this.navfixeditem + navbaritems1Width + navbaritems2Width + navbaritems3Width);
        }
        var /** @type {?} */ navbaravailablewidth = (navbarwidth - (this.navfixeditem + this.navitemwidth));
        if ((navbaravailablewidth < 10 || navbarheight > 100)) {
            this.mobilemode = true;
            this.toggle = false;
            this.notifyNavItems(navbarwidth);
        }
        else {
            this.mobilemode = false;
            this.toggle = true;
            this.notifyNavItems(navbarwidth);
        }
    };
    /**
     * @return {?}
     */
    AmexioNavBarComponent.prototype.sideNavbar = /**
     * @return {?}
     */
    function () {
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.sidenav = true;
        }
        else {
            this.sidenav = false;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavBarComponent.prototype.resize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.handleDeviceSetting();
        if (this.homepageType === '3') {
            if (!this.isExpand) {
                this.lhsWidth = '0 0 19%';
            }
            else {
                this.isLHSHide = true;
                this.lhsWidth = '0 0 5%';
            }
            this.isExpand = !this.isExpand;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavBarComponent.prototype.onArrowClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onIconArrowClick.emit();
        this.isIconLeft = !this.isIconLeft;
    };
    // THIS EVENT IS HOME COMPOENNT USE.NOT EXPOSED
    /**
     * @return {?}
     */
    AmexioNavBarComponent.prototype.onExpandIconClick = /**
     * @return {?}
     */
    function () {
        if (this.homepageType === '3') {
            if (!this.isExpand) {
                this.lhsWidth = '0 0 19%';
            }
            else {
                this.isLHSHide = true;
                this.lhsWidth = '0 0 5%';
            }
            this.onIconClick.emit(!this.isExpand);
            this.isExpand = !this.isExpand;
        }
    };
    AmexioNavBarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-nav', template: "\n    <nav #navbar class=\"topnav\" [ngStyle]=\"{'color': color, 'top': top, 'opacity': opacity}\" [ngClass]=\"{'topnav-mobile':mobilemode, 'transparentNav':transparent}\" (window:resize)=\"resize($event)\">\n\n        <div #navbarfixed  [ngClass]=\"{'lhs-mobile':mobilemode}\"\n         [ngStyle]=\"{'flex': !title || !logo ? 'none':''}\">\n            <div class=\"topnav-lhs-inner\" [ngClass]=\"{'topnav-lhs-inner-mobile':mobilemode, 'topnav-lhs-nologo': logo==''}\">\n                <span>\n\n                <span style=\"padding-left: 40px;\" *ngIf=\"sidenav\">  &nbsp;</span>\n\n                <span *ngIf=\"(!(mobilemode && sidenav) && homepageType ==='1')\" class=\"homepage-bar-collapse\" (click)=\"onArrowClick($event)\"><amexio-image [icon-class]=\" 'fa fa-bars' \"></amexio-image> &nbsp;</span>\n\n                <img alt=\"title \" style=\"cursor: pointer \" (click)=\"onNavLogoClick.emit($event) \" (load)=\"onImageLoad() \" *ngIf=\"logo \" [attr.src]=\"logo \" class=\"navbar-logo \">\n                <a (click)=\"onNavTitleClick.emit($event) \">{{title}}</a>\n\n\n                <ng-container *ngIf=\"homepageType=='2' && !sidenav\">\n                    <ng-container *ngIf=\"!isIconLeft\">\n                        <span class=\"collaspe-icon-style\" (click)=\"onArrowClick($event)\"><amexio-image [icon-class]=\" 'fa fa-chevron-right' \"></amexio-image></span>\n                    </ng-container>\n                    <ng-container *ngIf=\"isIconLeft\">\n                        <span class=\"collaspe-icon-style\" (click)=\"onArrowClick($event)\"><amexio-image  [icon-class]=\" 'fa fa-chevron-left' \"></amexio-image></span>\n                    </ng-container>\n                </ng-container>\n\n                </span>\n\n                <span *ngIf=\"mobilemode\" class=\"float-right mobilebar\" (click)=\"toggleDrawerPanel($event)\">\n                  <em *ngIf=\"!toggle\" class=\"fa fa-caret-down fa-2x\"></em>\n                  <em *ngIf=\"toggle\" class=\"fa fa-caret-up fa-2x\"></em>\n              </span>\n            </div>\n        </div>\n\n        <div #navbaritems *ngIf=\"toggle\" class=\"topnav-rhs\" [ngClass]=\"{'rhs-mobile':mobilemode, 'transparentNav1':transparent && mobilemode}\">\n            <div class=\"topnavmainbar\" [ngClass]=\"{'topnavmainbar-mobile':mobilemode}\">\n                <div #navbaritems1 class=\"topnavmainbaritems\" [ngClass]=\"{'topnavmainbaritems-mobile':mobilemode}\">\n                    <ng-content select=\"[position-left]\"></ng-content>\n                </div>\n                <div #navbaritems2 class=\"topnavmainbaritems\" [ngClass]=\"{'topnavmainbaritems-mobile':mobilemode}\">\n                    <ng-content select=\"[position-center]\"></ng-content>\n                </div>\n                <div #navbaritems3 class=\"topnavmainbaritems\" [ngClass]=\"{'topnavmainbaritems-mobile':mobilemode}\">\n                    <ng-content select=\"[position-right]\"></ng-content>\n                </div>\n            </div>\n        </div>\n        <!--\n      <div #navbarfixed [ngStyle]=\"{'flex': !mobilemode ? lhsWidth : '','flex-width': !mobilemode ? lhsWidth :'' }\"\n                   [ngClass]=\"{ ' topnav-lhs-mobile':mobilemode,'topnav-lhs topnav-lhs-color':!mobilemode} \">\n          <div [ngClass]=\"{'homepage-expand': (isExpand && !mobilemode),'homepage-collapse':(!isExpand && !mobilemode) }\">\n\n              <ng-container *ngIf=\"!isLHSHide || mobilemode\">\n                  <span [ngClass]=\" sidenav ? 'sidenav-padding':'' \" [ngStyle]=\"{ 'padding-left':sidenav ? '40px': '0px'} \">\n                <span *ngIf=\"homepageType=='1' && !isPhone\" class=\"homepage-bar-collapse\"  (click)=\"onArrowClick($event)\"  ><amexio-image [icon-class]=\" 'fa fa-bars' \"></amexio-image></span>\n                  <img alt=\"title \" style=\"cursor: pointer \" (click)=\"onNavLogoClick.emit($event) \" (load)=\"onImageLoad() \" *ngIf=\"logo \" [attr.src]=\"logo \" class=\"navbar-logo \">\n                  <a (click)=\"onNavTitleClick.emit($event) \">{{title}}</a>\n                  </span>\n              </ng-container>\n              <ng-container *ngIf=\"!isPhone\">\n                  <span *ngIf=\"homepageType=='3' || isLHSHide \" (click)=\"onExpandIconClick($event) \" class=\"homepage3-bar\">\n                <amexio-image *ngIf=\"!isExpand\" [icon-class]=\" 'fa fa-bars' \"></amexio-image>\n                <amexio-image *ngIf=\"isExpand\" [icon-class]=\" 'fa fa-times-circle' \"></amexio-image>\n              </span>\n              </ng-container>\n              <ng-container *ngIf=\"homepageType=='2' && !sidenav\">\n                  <ng-container *ngIf=\"!isIconLeft\">\n                      <span class=\"collaspe-icon-style\" (click)=\"onArrowClick($event)\"><amexio-image [icon-class]=\" 'fa fa-chevron-right' \"></amexio-image></span>\n                  </ng-container>\n                  <ng-container *ngIf=\"isIconLeft\">\n                      <span class=\"collaspe-icon-style\" (click)=\"onArrowClick($event)\"><amexio-image  [icon-class]=\" 'fa fa-chevron-left' \"></amexio-image></span>\n                  </ng-container>\n              </ng-container>\n          </div>\n          <div *ngIf=\"mobilemode\" class=\"float-right mobilebar\" (click)=\"toggleDrawerPanel($event)\">\n              <em *ngIf=\"!toggle\" class=\"fa fa-caret-down fa-2x\"></em>\n              <em *ngIf=\"toggle\" class=\"fa fa-caret-up fa-2x\"></em>\n          </div>\n      </div>\n      <div #navbaritems *ngIf=\"toggle\" [ngClass]=\"{'topnav-rhs topnav-rhs-color':!mobilemode}\">\n          <div class=\"topnavmainbar\" [ngClass]=\"{'topnavmainbar-mobile':mobilemode}\">\n              <div #navbaritems1 class=\"topnavmainbaritems\" [ngClass]=\"{'topnavmainbaritems-mobile':mobilemode}\">\n                  <ng-content select=\"[position-left]\"></ng-content>\n              </div>\n              <div #navbaritems2 class=\"topnavmainbaritems\" [ngClass]=\"{'topnavmainbaritems-mobile':mobilemode}\">\n                  <ng-content select=\"[position-center]\"></ng-content>\n              </div>\n              <div #navbaritems3 class=\"topnavmainbaritems\" [ngClass]=\"{'topnavmainbaritems-mobile':mobilemode}\">\n                  <ng-content select=\"[position-right]\"></ng-content>\n              </div>\n\n          </div>\n      </div>\n\n    -->\n    </nav>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioNavBarComponent.ctorParameters = function () { return [
        { type: DeviceQueryService }
    ]; };
    AmexioNavBarComponent.propDecorators = {
        title: [{ type: i0.Input }],
        logo: [{ type: i0.Input }],
        sidenavspace: [{ type: i0.Input, args: ['enable-side-nav-position',] }],
        transparent: [{ type: i0.Input, args: ['transparent',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        homepageType: [{ type: i0.Input, args: ['home-page-type',] }],
        onNavLogoClick: [{ type: i0.Output }],
        onNavTitleClick: [{ type: i0.Output }],
        onIconArrowClick: [{ type: i0.Output }],
        onIconClick: [{ type: i0.Output }],
        navSubmenuClick: [{ type: i0.Output }],
        navitems: [{ type: i0.ContentChildren, args: [AmexioNavItemComponent,] }],
        navbar: [{ type: i0.ViewChild, args: ['navbar', { read: i0.ElementRef },] }],
        navbarfixed: [{ type: i0.ViewChild, args: ['navbarfixed', { read: i0.ElementRef },] }],
        navbaritems: [{ type: i0.ViewChild, args: ['navbaritems', { read: i0.ElementRef },] }],
        navbaritems1: [{ type: i0.ViewChild, args: ['navbaritems1', { read: i0.ElementRef },] }],
        navbaritems2: [{ type: i0.ViewChild, args: ['navbaritems2', { read: i0.ElementRef },] }],
        navbaritems3: [{ type: i0.ViewChild, args: ['navbaritems3', { read: i0.ElementRef },] }]
    };
    return AmexioNavBarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
var SideNavNodeComponent = /** @class */ (function () {
    function SideNavNodeComponent(matchMediaService, iconService) {
        this.matchMediaService = matchMediaService;
        this.iconService = iconService;
        /*
           Events
           name : nodeClick
           datatype : none
           version : none
           default : none
           description : Fire when sidenav bar menu click
           */
        this.nodeClick = new i0.EventEmitter();
        /*
           Events
           name : onDrag
           datatype : none
           version : 4.2.9
           default : none
           description : Fire when you drag node
           */
        this.onDrag = new i0.EventEmitter();
        this.nodeEmitToSideNav = new i0.EventEmitter();
        this.expand = false;
        this.isMobile = false;
        this.isDefaultUserIcon = false;
        this.displaykey = 'text';
        this.childarraykey = 'children';
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isMobile = true;
        }
    }
    /**
     * @return {?}
     */
    SideNavNodeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.node && !this.label) {
            this.expand = true;
            this.collapsable = false;
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    SideNavNodeComponent.prototype.onClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.expand = !this.expand;
        if (this.nodedata) {
            if (this.nodedata.children && this.expand === false) {
                this.nodedata.children.forEach(function (element) {
                    element['tabindex'] = '-1';
                });
            }
            else if (this.nodedata.children && this.expand === true) {
                this.nodedata.children.forEach(function (element) {
                    element['tabindex'] = '1';
                });
            }
        }
        this.nodeClick.emit(node);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    SideNavNodeComponent.prototype.onNodeClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.nodeClick.emit(node);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SideNavNodeComponent.prototype.dragStartEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.enabledrag) {
            event.event.dataTransfer.setData('dragData', JSON.stringify(event.data));
            this.onDrag.emit(event);
        }
    };
    /**
     * @param {?} allNodeData
     * @return {?}
     */
    SideNavNodeComponent.prototype.emittednodedata = /**
     * @param {?} allNodeData
     * @return {?}
     */
    function (allNodeData) {
        this.nodeEmitToSideNav.emit(allNodeData);
    };
    /**
     * @param {?} divref
     * @param {?} nodedata
     * @return {?}
     */
    SideNavNodeComponent.prototype.onenterClick = /**
     * @param {?} divref
     * @param {?} nodedata
     * @return {?}
     */
    function (divref, nodedata) {
        if (divref.tabIndex === 1 && nodedata.children) {
            nodedata.expand = !nodedata.expand;
        }
        if (nodedata.children && nodedata.expand === true) {
            nodedata.children.forEach(function (element, index) {
                element['tabindex'] = '1';
            });
        }
        this.onClick(nodedata);
    };
    /**
     * @param {?} isIcon
     * @return {?}
     */
    SideNavNodeComponent.prototype.setShowOnlyIconFlag = /**
     * @param {?} isIcon
     * @return {?}
     */
    function (isIcon) {
        var /** @type {?} */ icon = '';
        var /** @type {?} */ iconObject = this.iconService.getIconObject('sidenavnode-icon');
        if (this.iconService.iconToUse === 'fa') {
            icon = iconObject.fa;
        }
        else {
            icon = iconObject.mat;
        }
        if (this.isDefaultUserIcon && this.icon === 'fa fa-user-circle') {
            this.icon = '';
            this.isDefaultUserIcon = false;
        }
        else if ((!this.icon || this.icon === '') && !this.isDefaultUserIcon) {
            this.icon = icon;
            this.isDefaultUserIcon = true;
        }
        this.isShowOnlyIcon = isIcon;
    };
    SideNavNodeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-sidenav-node', template: "\n    <!-- node {{node | json}} -->\n    <li>\n        <div *ngIf=\"enableborder\" class=\"border\"></div>\n        <div tabindex=\"1\" (keyup.enter)=\"onenterClick(currentdivref,nodedata)\" *ngIf=\"label || badge || icon\" [attr.draggable]=\"enabledrag\" (dragstart)=\"dragStartEvent({event:$event,data:node})\" class=\"headernode\" [ngClass]=\"{'activenode':active}\" (click)=\"onClick(nodedata)\">\n            <ng-container *ngIf=\"icon\">\n                <amexio-c-icon class=\"node-icon\" [customclass]=\"icon\" [color]=\"iconcolor\"></amexio-c-icon>\n                <ng-container *ngIf=\"!isShowOnlyIcon || isMobile\">\n                <span>{{label}} </span>\n            \n                <span *ngIf=\"badge\" class=\"nav-badge\">{{badge}}</span>\n            \n                <ng-container *ngIf=\"(node && (node.length>0)) || collapsable\">\n                <span style=\"padding-right: 10px; float: right\" *ngIf=\"expand\">\n                <amexio-c-icon key=\"sidenav-angle-up\"></amexio-c-icon>\n                </span>\n                <span style=\"padding-right: 10px;float: right\" *ngIf=\"!expand\">\n                <amexio-c-icon key=\"sidenav-angle-down\"></amexio-c-icon>\n                </span>\n                </ng-container>\n                </ng-container>\n            </ng-container>\n            \n            <ng-container *ngIf=\"!icon\">\n                <amexio-c-icon class=\"node-icon\" [customclass]=\"icon\" [color]=\"iconcolor\"></amexio-c-icon>\n                <ng-container *ngIf=\"!isShowOnlyIcon || isMobile\">\n                <span style=\"padding-left: 20px;\">{{label}} </span>\n            \n                <span *ngIf=\"badge\" class=\"nav-badge\">{{badge}}</span>\n            \n                <ng-container *ngIf=\"(node && (node.length>0)) || collapsable\">\n                <span style=\"padding-right: 10px; float: right\" *ngIf=\"expand\">\n                <amexio-c-icon key=\"sidenav-angle-up\"></amexio-c-icon>\n                </span>\n                <span style=\"padding-right: 10px;float: right\" *ngIf=\"!expand\">\n                <amexio-c-icon key=\"sidenav-angle-down\"></amexio-c-icon>\n                </span>\n                </ng-container>\n                </ng-container>\n            </ng-container>\n        </div>\n\n        <!-- id [data] given      </div>\n     (emitNode) = \"emittednodedata($event)\" -->\n        <div *ngIf=\"node && !isShowOnlyIcon\" class=\"sidenav-submenu-details sidenav-submenu-expanded\" [ngClass]=\"{'sidenav-submenu-expanded':expand}\">\n            <amexio-sidenav-innernode *ngIf=\"node && (node.length>0)\" (onClick)=\"onNodeClick($event)\" [display-key]=\"displaykey\" [child-array-key]=\"childarraykey\" [enable-drag]=\"enabledrag\" (emitNode)=\"emittednodedata($event)\" (onDrag)=\"dragStartEvent($event)\" [data]=\"node\">\n            </amexio-sidenav-innernode>\n        </div>\n        <!-- ng content block-->\n        <div class=\"sidenav-submenu-details\" style=\"padding-right: 20px;\" [ngClass]=\"{'sidenav-submenu-expanded':expand}\">\n            <ng-content *ngIf=\"!isShowOnlyIcon\"></ng-content>\n        </div>\n    </li>\n  ",
                },] },
    ];
    /** @nocollapse */
    SideNavNodeComponent.ctorParameters = function () { return [
        { type: DeviceQueryService },
        { type: IconLoaderService }
    ]; };
    SideNavNodeComponent.propDecorators = {
        nodedata: [{ type: i0.Input, args: ['node',] }],
        currentdivref: [{ type: i0.Input, args: ['currentdivref',] }],
        badge: [{ type: i0.Input, args: ['badge',] }],
        icon: [{ type: i0.Input, args: ['icon',] }],
        label: [{ type: i0.Input, args: ['label',] }],
        enableborder: [{ type: i0.Input, args: ['enable-border',] }],
        active: [{ type: i0.Input, args: ['active',] }],
        collapsable: [{ type: i0.Input, args: ['collapsable',] }],
        node: [{ type: i0.Input, args: ['data',] }],
        enabledrag: [{ type: i0.Input, args: ['enable-drag',] }],
        nodeClick: [{ type: i0.Output }],
        onDrag: [{ type: i0.Output }],
        nodeEmitToSideNav: [{ type: i0.Output }],
        displaykey: [{ type: i0.Input, args: ['display-key',] }],
        childarraykey: [{ type: i0.Input, args: ['child-array-key',] }],
        expand: [{ type: i0.Input }],
        iconcolor: [{ type: i0.Input, args: ['icon-color',] }],
        isShowOnlyIcon: [{ type: i0.Input, args: ['show-only-icon',] }]
    };
    return SideNavNodeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
var AmexioSideNavComponent = /** @class */ (function () {
    function AmexioSideNavComponent(dataService, matchMediaService, element, cd) {
        this.dataService = dataService;
        this.matchMediaService = matchMediaService;
        this.element = element;
        this.cd = cd;
        /*
           Events
           name : nodeClick
           datatype : none
           version : none
           default : none
           description : Fire when sidenav bar menu click
           */
        this.nodeClick = new i0.EventEmitter();
        /*
           Events
           name : onDrag
           datatype : none
           version : 4.2.9
           default : none
           description : Fire when you drag node
           */
        this.onDrag = new i0.EventEmitter();
        /*
           Properties
           name : enable-border
           datatype : boolean
           version : 5.5.5 onwards
           default : true
           description : By default enable-border is enabled
           */
        this.enableborder = true;
        this.onMouseLeave = new i0.EventEmitter();
        this.onMouseOver = new i0.EventEmitter();
        this.nodes = [];
        this.isShowOnlyIcon = false;
        this.isSideNavEnable = true;
        this.position = 'left';
        this.smalldevice = false;
        this.sidenavexpandedinsmalldevice = false;
        this.width = '0%';
        var /** @type {?} */ that = this;
        this.displaykey = 'text';
        this.childarraykey = 'children';
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.smalldevice = true;
            this.width = '0%';
        }
        else {
            this.width = '19%';
        }
        /*---------------------------------------------------
             TAP INTO LISTENERS FOR WHEN DEVICE WIDTH CHANGES
             ---------------------------------------------------*/
        this.matchMediaService.OnPhone(function (mediaQueryList) {
            that.handleDeviceSettings(false);
        });
        this.matchMediaService.OnTablet(function (mediaQueryList) {
            that.handleDeviceSettings(false);
        });
        this.matchMediaService.OnDesktop(function (mediaQueryList) {
            that.handleDeviceSettings(false);
        });
    }
    /**
     * @return {?}
     */
    AmexioSideNavComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        if (this.data && (!this.httpmethod || !this.httpurl)) {
            this.setData(this.data);
        }
        if (this.position == null) {
            this.position = 'left';
        }
        if (!this.height) {
            this.height = '100%';
        }
    };
    /**
     * @return {?}
     */
    AmexioSideNavComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.nodearray = this.sidennavnodearray.toArray();
        this.nodearray.forEach(function (element) {
            element.nodeEmitToSideNav.subscribe(function (node) {
                node.forEach(function (nodeelement) {
                    if (nodeelement.active === true) {
                        _this.activenode = nodeelement;
                    }
                });
                _this.activateNode = JSON.parse(JSON.stringify(node));
                _this.findObj(node);
            });
        });
    };
    /**
     * @param {?} currentnode
     * @return {?}
     */
    AmexioSideNavComponent.prototype.findObj = /**
     * @param {?} currentnode
     * @return {?}
     */
    function (currentnode) {
        var _this = this;
        this.nodearray.forEach(function (element) {
            if (element.node && (element.node.length > 0)) {
                (element.node).forEach(function (individualnode) {
                    if ((_this.activenode.text === individualnode.text)
                        && (_this.activenode.active === individualnode.active)) {
                        individualnode.active = true;
                    }
                    else {
                        individualnode.active = false;
                    }
                });
            }
        });
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioSideNavComponent.prototype.onClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.nodeClick.emit(node);
        this.activateNode(this.data, node);
        if (this.smalldevice && (!node.children || node.children === null || node.children === '')) {
            this.isSideNavEnable = false;
        }
        else {
            this.isSideNavEnable = true;
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioSideNavComponent.prototype.generateIndex = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        data.forEach(function (element, index) {
            if (element[_this.childarraykey]) {
                element[_this.childarraykey].forEach(function (innerelement) {
                    innerelement['tabindex'] = '-1';
                    if (innerelement[_this.childarraykey]) {
                        innerelement[_this.childarraykey].forEach(function (innerelement2) {
                            innerelement2['tabindex'] = '-1';
                        });
                    }
                });
            }
        });
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioSideNavComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        // Check if key is added?
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.generateIndex(this.data);
        this.activateNode(this.data, null);
        this.handleDeviceSettings(false);
    };
    /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    AmexioSideNavComponent.prototype.activateNode = /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    function (data, node) {
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var i = data_1[_i];
            if (node === i && !i[this.childarraykey]) {
                i['active'] = true;
            }
            else {
                i['active'] = false;
            }
            if (i[this.childarraykey]) {
                this.activateNode(i[this.childarraykey], node);
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioSideNavComponent.prototype.toggleSideNav = /**
     * @return {?}
     */
    function () {
        this.isSideNavEnable = true;
        this.handleDeviceSettings(!this.isSideNavExpand);
    };
    /**
     * @return {?}
     */
    AmexioSideNavComponent.prototype.close = /**
     * @return {?}
     */
    function () {
        this.handleDeviceSettings(false);
    };
    /**
     * @param {?} expand
     * @return {?}
     */
    AmexioSideNavComponent.prototype.handleDeviceSettings = /**
     * @param {?} expand
     * @return {?}
     */
    function (expand) {
        if (this.position !== 'relative') {
            if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
                this.smalldevice = true;
                if (expand) {
                    this.width = '80%';
                    this.isSideNavExpand = true;
                    this.sidenavexpandedinsmalldevice = true;
                }
                else {
                    this.width = '0%';
                    this.isSideNavExpand = false;
                    this.sidenavexpandedinsmalldevice = false;
                }
            }
            else {
                if (this.isShowOnlyIcon) {
                    this.width = '5%';
                }
                else {
                    this.width = '19%';
                }
                this.smalldevice = false;
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSideNavComponent.prototype.getNodeDragEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onDrag.emit(event);
    };
    // THIS METHOD IS USED FOR SETTING HOMEPAGE TYPE
    /**
     * @param {?} type
     * @return {?}
     */
    AmexioSideNavComponent.prototype.setHomePageType = /**
     * @param {?} type
     * @return {?}
     */
    function (type) {
        var _this = this;
        this.homepageType = type;
        if (this.homepageType === '3') {
            this.nodearray.forEach(function (element) {
                element.setShowOnlyIconFlag(_this.isShowOnlyIcon);
            });
        }
        this.cd.detectChanges();
    };
    AmexioSideNavComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-side-nav', template: "\n    <div *ngIf=\"(position !='relative' && smalldevice )\" [ngClass]=\"{'sidenav-mobile-bar-left':(position=='left' && position!='relative'),'sidenav-mobile-bar-right':(position=='right' && position!='relative')}\" class=\"sidenav-mobile-bar\"\n        (click)=\"toggleSideNav()\">\n        <amexio-c-icon class=\"homepage3-bar\" key=\"sidenav_bar\" [color]=\"\"></amexio-c-icon>\n    </div>\n    <div *ngIf=\"isSideNavEnable\" style=\"height: 100%\" [style.width]=\"width\" [ngStyle]=\"{'background': bgimage ? 'url(' + bgimage + ') center/cover no-repeat' : null}\" [ngClass]=\"{'left':(position=='left' && position!='relative'),'right':(position=='right' && position!='relative')}\">\n        <div class=\"sidenav\" [ngClass]=\"{'sidenav-color': !background}\" [style.color]=\"color\" [style.background]=\"background\" [style.height]=\"height\">\n            <ul>\n                <li>\n                    <div *ngIf=\"sidenavtitle\" class=\"title\">\n                        <ng-container *ngIf=\"titleimage\">\n                            <p>\n                                <img [attr.src]=\"titleimage\" alt=\" Title image\" style=\"width: 60px;height: 60px;padding-left: 80px;\" />\n                            </p>\n                        </ng-container>\n                        <ng-container *ngIf=\"sidenavtitle\">\n                            <p>{{sidenavtitle}}</p>\n                        </ng-container>\n                        <span *ngIf=\"sidenavexpandedinsmalldevice\" style=\"padding-right: 10px; float: right\" (click)=\"close()\">\n                        <amexio-c-icon key=\"sidenav_close\"></amexio-c-icon>\n                    </span>\n                    </div>\n                </li>\n                <!-- (nodeEmitToSideNav) = \"getNodesData($event)\" -->\n                <div #currentdivref role=\"option\" *ngFor=\"let node of data\" id=\"{{node.index}}\">\n                    <amexio-sidenav-node [show-only-icon]=\"isShowOnlyIcon\" [enable-border]=\"enableborder && (node && node[childarraykey] && (node[childarraykey].length>0))\" [currentdivref]=\"currentdivref\" [active]=\"(node && node.active)\" [icon]=\"node.icon\" [badge]=\"node.badge\"\n                        [enable-drag]=\"enabledrag\" (nodeClick)=\"onClick($event)\" (onDrag)=\"getNodeDragEvent($event)\" [expand]=\"node?.expand\" [label]=\"node[displaykey]\" [node]=\"node\" [icon-color]=\"node.iconcolor\" [data]=\"node[childarraykey]\">\n                    </amexio-sidenav-node>\n                </div>\n\n                <ng-content></ng-content>\n            </ul>\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioSideNavComponent.ctorParameters = function () { return [
        { type: CommonDataService },
        { type: DeviceQueryService },
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef }
    ]; };
    AmexioSideNavComponent.propDecorators = {
        data: [{ type: i0.Input }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        position: [{ type: i0.Input }],
        titleimage: [{ type: i0.Input }],
        nodeClick: [{ type: i0.Output }],
        onDrag: [{ type: i0.Output }],
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        sidenavtitle: [{ type: i0.Input, args: ['title',] }],
        enabledrag: [{ type: i0.Input, args: ['enable-drag',] }],
        displaykey: [{ type: i0.Input, args: ['display-key',] }],
        childarraykey: [{ type: i0.Input, args: ['child-array-key',] }],
        enableborder: [{ type: i0.Input, args: ['enable-border',] }],
        background: [{ type: i0.Input, args: ['background',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        bgimage: [{ type: i0.Input, args: ['bg-image',] }],
        onMouseLeave: [{ type: i0.Output }],
        onMouseOver: [{ type: i0.Output }],
        sidennavnodearray: [{ type: i0.ContentChildren, args: [SideNavNodeComponent,] }]
    };
    return AmexioSideNavComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioHomePageNorthPanelComponent = /** @class */ (function () {
    function AmexioHomePageNorthPanelComponent(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.enableIcon = false;
        this.nothPanelIconClick = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    AmexioHomePageNorthPanelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioHomePageNorthPanelComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.amexioNavBarComponent && this.type === '2' && !(this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone())) {
            this.amexioNavBarComponent.homepageType = this.type;
        }
        this.amexioNavBarComponent.onIconArrowClick.subscribe(function (eventdata) {
            return _this.westPanelShowHideClick(eventdata);
        });
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioHomePageNorthPanelComponent.prototype.westPanelShowHideClick = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.nothPanelIconClick.emit();
    };
    AmexioHomePageNorthPanelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-homepage-northpanel',
                    template: "\n    <ng-content></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioHomePageNorthPanelComponent.ctorParameters = function () { return [
        { type: DeviceQueryService }
    ]; };
    AmexioHomePageNorthPanelComponent.propDecorators = {
        enableIcon: [{ type: i0.Input, args: ['enable-icon',] }],
        type: [{ type: i0.Input, args: ['type',] }],
        nothPanelIconClick: [{ type: i0.Output }],
        amexioNavBarComponent: [{ type: i0.ContentChild, args: [AmexioNavBarComponent,] }]
    };
    return AmexioHomePageNorthPanelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioHomePageComponent = /** @class */ (function () {
    function AmexioHomePageComponent(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.type = '1';
        this.isDisableWestPanel = true;
        this.isPhone = false;
        this.westPanelWidth = '0 0 19%';
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isPhone = true;
        }
    }
    /**
     * @return {?}
     */
    AmexioHomePageComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    AmexioHomePageComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.sideNavComponents = this.sideNavList.toArray();
        if (this.type === '3') {
            this.sideNavComponents[0].isShowOnlyIcon = true;
            this.sideNavComponents[0].width = '5%';
            this.westPanelWidth = '0 0 5%';
            this.sideNavComponents[0].setHomePageType(this.type);
            // NAVBAR
            this.amexioNavBarComponent.isLHSHide = true;
            this.amexioNavBarComponent.lhsWidth = '0 0 5%';
            this.amexioNavBarComponent.onIconClick.subscribe(function (eventdata) {
                return _this.northPanelClick(eventdata);
            });
        }
        if (this.amexoHomePageNorthpanel) {
            this.amexoHomePageNorthpanel.type = this.type;
            this.amexoHomePageNorthpanel.nothPanelIconClick.subscribe(function (eventdata) { return _this.showHideWestPanel(); });
        }
        this.amexioNavBarComponent.homepageType = this.type;
    };
    // tslint:disable-next-line:no-identical-functions
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioHomePageComponent.prototype.resize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isPhone = true;
        }
        else {
            this.isPhone = false;
        }
    };
    /**
     * @return {?}
     */
    AmexioHomePageComponent.prototype.showHideWestPanel = /**
     * @return {?}
     */
    function () {
        this.isDisableWestPanel = !this.isDisableWestPanel;
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isPhone = true;
        }
    };
    // ON NORTH PANEL CLICK
    /**
     * @param {?} isExpand
     * @return {?}
     */
    AmexioHomePageComponent.prototype.northPanelClick = /**
     * @param {?} isExpand
     * @return {?}
     */
    function (isExpand) {
        if (isExpand) {
            this.amexioNavBarComponent.isLHSHide = false;
            // SIDE NAV
            this.sideNavComponents[0].isShowOnlyIcon = false;
            this.sideNavComponents[0].width = '19%';
            this.westPanelWidth = '0 0 19%';
        }
        else {
            this.amexioNavBarComponent.isLHSHide = true;
            // SIDE NAV
            this.sideNavComponents[0].isShowOnlyIcon = true;
            this.sideNavComponents[0].width = '5%';
            this.westPanelWidth = '0 0 5%';
        }
        this.sideNavComponents[0].setHomePageType(this.type);
    };
    AmexioHomePageComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-homepage-ce',
                    template: "\n    <div class=\"{{'homepage-'+type}}\" (window:resize)=\"resize($event)\">\n        <div class=\"homepage-northpanel-flex\">\n            <ng-content select=\"amexio-homepage-northpanel\">\n            </ng-content>\n        </div>\n        <div [ngStyle]=\"{'display': !isPhone ? 'flex':'','flex-direction': isDisableWestPanel ? 'row' : 'column'}\">\n            <div [ngStyle]=\"{'flex':isPhone ? '0 0 0%':westPanelWidth}\">\n                <ng-content *ngIf=\"isDisableWestPanel\" select=\"amexio-homepage-westpanel\">\n                </ng-content>\n            </div>\n            <div [ngClass]=\"{'homepage-centerpanel-flex':!isPhone || (isDisableWestPanel && !isPhone), 'homepage-centerpanel-flex-fullview':(!isDisableWestPanel && !isPhone) }\">\n                <ng-content select=\"amexio-homepage-centerpanel\">\n                </ng-content>\n            </div>\n            <!-- <div [ngStyle]=\"{'flex':isPhone ? '0 0 0%':'0 0 19%'}\">\n            <ng-content select=\"amexio-homepage-eastpanel\">\n            </ng-content>\n        </div> -->\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioHomePageComponent.ctorParameters = function () { return [
        { type: DeviceQueryService }
    ]; };
    AmexioHomePageComponent.propDecorators = {
        type: [{ type: i0.Input, args: ['type',] }],
        amexoHomePageNorthpanel: [{ type: i0.ContentChild, args: [AmexioHomePageNorthPanelComponent,] }],
        sideNavList: [{ type: i0.ContentChildren, args: [AmexioSideNavComponent, { descendants: true },] }],
        amexioNavBarComponent: [{ type: i0.ContentChild, args: [AmexioNavBarComponent,] }]
    };
    return AmexioHomePageComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by pratik on 18/12/17.
 */
var AmexioFooterComponent = /** @class */ (function () {
    function AmexioFooterComponent() {
        this.className = 'modal-window-footer';
        this.footer = false;
    }
    /**
     * @return {?}
     */
    AmexioFooterComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setFooterAlignment(this.footeralign);
    };
    /**
     * @param {?} footeralign
     * @return {?}
     */
    AmexioFooterComponent.prototype.setFooterAlignment = /**
     * @param {?} footeralign
     * @return {?}
     */
    function (footeralign) {
        switch (footeralign) {
            case 'right': {
                this.alignClass = 'flex-end';
                break;
            }
            case 'center': {
                this.alignClass = 'center';
                break;
            }
            case 'left': {
                this.alignClass = 'flex-start';
                break;
            }
            default: {
                this.alignClass = 'flex-end';
                break;
            }
        }
    };
    AmexioFooterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-action', template: "\n    <ng-container *ngIf=\"footer\">\n      <ng-content></ng-content>\n    </ng-container>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioFooterComponent.ctorParameters = function () { return []; };
    AmexioFooterComponent.propDecorators = {
        className: [{ type: i0.HostBinding, args: ['attr.class',] }],
        footeralign: [{ type: i0.Input, args: ['footer-align',] }],
        alignClass: [{ type: i0.HostBinding, args: ['style.justify-content',] }],
        padding: [{ type: i0.Input }]
    };
    return AmexioFooterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by pratik on 18/12/17.
 */
var AmexioBodyComponent = /** @class */ (function () {
    function AmexioBodyComponent() {
        this.className = 'window-middle';
    }
    /**
     * @return {?}
     */
    AmexioBodyComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.height = this.bodyHeight + '%';
    };
    AmexioBodyComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-body', template: "\n    <ng-content></ng-content>\n  "
                },] },
    ];
    /** @nocollapse */
    AmexioBodyComponent.ctorParameters = function () { return []; };
    AmexioBodyComponent.propDecorators = {
        height: [{ type: i0.HostBinding, args: ['style.height',] }],
        className: [{ type: i0.HostBinding, args: ['attr.class',] }],
        bodyHeight: [{ type: i0.Input, args: ['body-height',] }],
        padding: [{ type: i0.Input }]
    };
    return AmexioBodyComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 Component Name : Amexio Carousel
 Component Selector : <[amexioTemplate]>
 Component Description : Amexio CarouselView displays a collection of
 images or other content in a horizontal layout with built-in navigation between the items.

*/
var AmexioTemplateDirective = /** @class */ (function () {
    function AmexioTemplateDirective(template) {
        this.template = template;
    }
    /**
     * @return {?}
     */
    AmexioTemplateDirective.prototype.getType = /**
     * @return {?}
     */
    function () {
        return this.name;
    };
    AmexioTemplateDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[amexioTemplate]',
                },] },
    ];
    /** @nocollapse */
    AmexioTemplateDirective.ctorParameters = function () { return [
        { type: i0.TemplateRef }
    ]; };
    AmexioTemplateDirective.propDecorators = {
        type: [{ type: i0.Input }],
        name: [{ type: i0.Input, args: ['amexioTemplate',] }]
    };
    return AmexioTemplateDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 28/12/17.
*/
var AmexioCarouselComponent = /** @class */ (function () {
    function AmexioCarouselComponent() {
        // @ViewChild('kk') kk: ElementRef;
        this.prevImage = -1;
        this.nextImage = -1;
        this.currImage = 0;
    }
    /**
     * @return {?}
     */
    AmexioCarouselComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.startTimeInterval();
    };
    /**
     * @return {?}
     */
    AmexioCarouselComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.templates.forEach(function (item) {
            _this.itemTemplate = item.template;
        });
    };
    /**
     * @return {?}
     */
    AmexioCarouselComponent.prototype.scrollData = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioCarouselComponent.prototype.next = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ nxt = this.tabs.nativeElement;
        nxt.scrollLeft = nxt.scrollLeft + 200;
    };
    /**
     * @return {?}
     */
    AmexioCarouselComponent.prototype.previous = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ prev = this.tabs.nativeElement;
        prev.scrollLeft = prev.scrollLeft - 200;
    };
    /**
     * @return {?}
     */
    AmexioCarouselComponent.prototype.shuffle = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioCarouselComponent.prototype.onArrowRight = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.data.length - 1 > item) {
            var /** @type {?} */ currentitem = item + 1;
            var /** @type {?} */ itemId = this.header + currentitem;
            document.getElementById(itemId).focus();
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioCarouselComponent.prototype.onArrowLeft = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item > 0) {
            var /** @type {?} */ currentitem = item - 1;
            var /** @type {?} */ itemId = this.header + currentitem;
            document.getElementById(itemId).focus();
        }
    };
    /**
     * @return {?}
     */
    AmexioCarouselComponent.prototype.startTimeInterval = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.shuffleinterval != null) {
            this.timeInterval = setInterval(function () {
                var /** @type {?} */ carouselItemPosix = _this.tabs.nativeElement;
                if (!((carouselItemPosix.scrollWidth - carouselItemPosix.offsetWidth - carouselItemPosix.scrollLeft) <= 0)) {
                    // go next
                    carouselItemPosix.scrollLeft = carouselItemPosix.scrollLeft + 200;
                }
                else if (carouselItemPosix.scrollLeft > 0) {
                    // go previous
                    carouselItemPosix.scrollLeft = carouselItemPosix.scrollLeft - 200;
                }
            }, this.shuffleinterval);
        }
    };
    /**
     * @return {?}
     */
    AmexioCarouselComponent.prototype.stopTimeInterval = /**
     * @return {?}
     */
    function () {
        clearTimeout(this.timeInterval);
    };
    AmexioCarouselComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-carousel',
                    template: "\n    <h4>{{header}}</h4>\n    <div class=\"tabwrapper\">\n      <div class=\"carouselnavigation float-left\" (click)=\"previous()\">\n        <amexio-c-icon key=\"carousel_previous\"></amexio-c-icon>\n      </div>\n      <div class=\"carouselnavigation float-right\" (click)=\"next()\">\n        <amexio-c-icon key=\"carousel_next\"></amexio-c-icon>\n      </div>\n      <ul #tab class=\"tab\">\n        <li attr.aria-label=\"'carousel {{rowno}}'\" tabindex=\"1\" id=\"{{header}}{{rowno}}\" class=\"tablistitems\" *ngFor=\"let item of data let rowno= index\" [ngClass]=\"{'list-carousel-items':item.isSelected}\"\n          (mouseover)=\"stopTimeInterval($event)\" (mouseleave)=\"startTimeInterval($event)\" (keyup.arrowleft)=\"onArrowLeft(rowno)\"\n          (keyup.arrowright)=\"onArrowRight(rowno)\">\n          <ng-template tabindex=\"1\" [amexioTemplateWrapper]=\"itemTemplate\" [item]=\"item\"></ng-template>\n        </li>\n      </ul>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioCarouselComponent.ctorParameters = function () { return []; };
    AmexioCarouselComponent.propDecorators = {
        header: [{ type: i0.Input }],
        data: [{ type: i0.Input }],
        shuffleinterval: [{ type: i0.Input, args: ['shuffle-interval',] }],
        templates: [{ type: i0.ContentChildren, args: [AmexioTemplateDirective,] }],
        tabs: [{ type: i0.ViewChild, args: ['tab', { read: i0.ElementRef },] }]
    };
    return AmexioCarouselComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioTemplateWrapperDirective = /** @class */ (function () {
    function AmexioTemplateWrapperDirective(viewContainer) {
        this.viewContainer = viewContainer;
    }
    /**
     * @return {?}
     */
    AmexioTemplateWrapperDirective.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.render();
    };
    Object.defineProperty(AmexioTemplateWrapperDirective.prototype, "item", {
        /*
     Properties
     name : get item
     datatype :   any
     version : 4.0 onwards
     default : none
     description : gets the carousel item
     */
        get: /**
         * @return {?}
         */
        function () {
            return this._item;
        },
        set: /**
         * @param {?} item
         * @return {?}
         */
        function (item) {
            this._item = item;
            if (this.view) {
                this.view.destroy();
                this.render();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioTemplateWrapperDirective.prototype.render = /**
     * @return {?}
     */
    function () {
        this.view = this.viewContainer.createEmbeddedView(this.templateRef, {
            $implicit: this.item, index: this.index,
        });
    };
    /**
     * @return {?}
     */
    AmexioTemplateWrapperDirective.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.view.destroy();
    };
    AmexioTemplateWrapperDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[amexioTemplateWrapper]',
                },] },
    ];
    /** @nocollapse */
    AmexioTemplateWrapperDirective.ctorParameters = function () { return [
        { type: i0.ViewContainerRef }
    ]; };
    AmexioTemplateWrapperDirective.propDecorators = {
        index: [{ type: i0.Input }],
        templateRef: [{ type: i0.Input, args: ['amexioTemplateWrapper',] }],
        item: [{ type: i0.Input }]
    };
    return AmexioTemplateWrapperDirective;
}());

/**
 * @license Angular v6.0.4
 * (c) 2010-2018 Google, Inc. https://angular.io/
 * License: MIT
 */

/**
 * AnimationBuilder is an injectable service that is available when the {@link
 * BrowserAnimationsModule BrowserAnimationsModule} or {@link NoopAnimationsModule
 * NoopAnimationsModule} modules are used within an application.
 *
 * The purpose if this service is to produce an animation sequence programmatically within an
 * angular component or directive.
 *
 * Programmatic animations are first built and then a player is created when the build animation is
 * attached to an element.
 *
 * ```ts
 * // remember to include the BrowserAnimationsModule module for this to work...
 * import {AnimationBuilder} from '@angular/animations';
 *
 * class MyCmp {
 *   constructor(private _builder: AnimationBuilder) {}
 *
 *   makeAnimation(element: any) {
 *     // first build the animation
 *     const myAnimation = this._builder.build([
 *       style({ width: 0 }),
 *       animate(1000, style({ width: '100px' }))
 *     ]);
 *
 *     // then create a player from it
 *     const player = myAnimation.create(element);
 *
 *     player.play();
 *   }
 * }
 * ```
 *
 * When an animation is built an instance of {@link AnimationFactory AnimationFactory} will be
 * returned. Using that an {@link AnimationPlayer AnimationPlayer} can be created which can then be
 * used to start the animation.
 *
 * @experimental Animation support is experimental.
 */
/**
 * `trigger` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the
 * {@link Component#animations component animations metadata page} to gain a better
 * understanding of how animations in Angular are used.
 *
 * `trigger` Creates an animation trigger which will a list of {@link state state} and
 * {@link transition transition} entries that will be evaluated when the expression
 * bound to the trigger changes.
 *
 * Triggers are registered within the component annotation data under the
 * {@link Component#animations animations section}. An animation trigger can be placed on an element
 * within a template by referencing the name of the trigger followed by the expression value that
 the
 * trigger is bound to (in the form of `[@triggerName]="expression"`.
 *
 * Animation trigger bindings strigify values and then match the previous and current values against
 * any linked transitions. If a boolean value is provided into the trigger binding then it will both
 * be represented as `1` or `true` and `0` or `false` for a true and false boolean values
 * respectively.
 *
 * ### Usage
 *
 * `trigger` will create an animation trigger reference based on the provided `name` value. The
 * provided `animation` value is expected to be an array consisting of {@link state state} and
 * {@link transition transition} declarations.
 *
 * ```typescript
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'my-component-tpl.html',
 *   animations: [
 *     trigger("myAnimationTrigger", [
 *       state(...),
 *       state(...),
 *       transition(...),
 *       transition(...)
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "something";
 * }
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger` animation
 trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * ### Using an inline function
 * The `transition` animation method also supports reading an inline function which can decide
 * if its associated animation should be run.
 *
 * ```
 * // this method will be run each time the `myAnimationTrigger`
 * // trigger value changes...
 * function myInlineMatcherFn(fromState: string, toState: string, element: any, params: {[key:
 string]: any}): boolean {
 *   // notice that `element` and `params` are also available here
 *   return toState == 'yes-please-animate';
 * }
 *
 * @Component({
 *   selector: 'my-component',
 *   templateUrl: 'my-component-tpl.html',
 *   animations: [
 *     trigger('myAnimationTrigger', [
 *       transition(myInlineMatcherFn, [
 *         // the animation sequence code
 *       ]),
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   myStatusExp = "yes-please-animate";
 * }
 * ```
 *
 * The inline method will be run each time the trigger
 * value changes
 *
 * ## Disable Animations
 * A special animation control binding called `@.disabled` can be placed on an element which will
 then disable animations for any inner animation triggers situated within the element as well as
 any animations on the element itself.
 *
 * When true, the `@.disabled` binding will prevent all animations from rendering. The example
 below shows how to use this feature:
 *
 * ```ts
 * @Component({
 *   selector: 'my-component',
 *   template: `
 *     <div [@.disabled]="isDisabled">
 *       <div [@childAnimation]="exp"></div>
 *     </div>
 *   `,
 *   animations: [
 *     trigger("childAnimation", [
 *       // ...
 *     ])
 *   ]
 * })
 * class MyComponent {
 *   isDisabled = true;
 *   exp = '...';
 * }
 * ```
 *
 * The `@childAnimation` trigger will not animate because `@.disabled` prevents it from happening
 (when true).
 *
 * Note that `@.disabled` will only disable all animations (this means any animations running on
 * the same element will also be disabled).
 *
 * ### Disabling Animations Application-wide
 * When an area of the template is set to have animations disabled, **all** inner components will
 also have their animations disabled as well. This means that all animations for an angular
 application can be disabled by placing a host binding set on `@.disabled` on the topmost Angular
 component.
 *
 * ```ts
 * import {Component, HostBinding} from '@angular/core';
 *
 * @Component({
 *   selector: 'app-component',
 *   templateUrl: 'app.component.html',
 * })
 * class AppComponent {
 *   @HostBinding('@.disabled')
 *   public animationsDisabled = true;
 * }
 * ```
 *
 * ### What about animations that us `query()` and `animateChild()`?
 * Despite inner animations being disabled, a parent animation can {@link query query} for inner
 elements located in disabled areas of the template and still animate them as it sees fit. This is
 also the case for when a sub animation is queried by a parent and then later animated using {@link
 animateChild animateChild}.

 * ### Detecting when an animation is disabled
 * If a region of the DOM (or the entire application) has its animations disabled, then animation
 * trigger callbacks will still fire just as normal (only for zero seconds).
 *
 * When a trigger callback fires it will provide an instance of an {@link AnimationEvent}. If
 animations
 * are disabled then the `.disabled` flag on the event will be true.
 *
 * @experimental Animation support is experimental.
 */
function trigger(name, definitions) {
    return { type: 7 /* Trigger */, name: name, definitions: definitions, options: {} };
}
/**
 * `animate` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `animate` specifies an animation step that will apply the provided `styles` data for a given
 * amount of time based on the provided `timing` expression value. Calls to `animate` are expected
 * to be used within {@link sequence an animation sequence}, {@link group group}, or {@link
 * transition transition}.
 *
 * ### Usage
 *
 * The `animate` function accepts two input parameters: `timing` and `styles`:
 *
 * - `timing` is a string based value that can be a combination of a duration with optional delay
 * and easing values. The format for the expression breaks down to `duration delay easing`
 * (therefore a value such as `1s 100ms ease-out` will be parse itself into `duration=1000,
 * delay=100, easing=ease-out`. If a numeric value is provided then that will be used as the
 * `duration` value in millisecond form.
 * - `styles` is the style input data which can either be a call to {@link style style} or {@link
 * keyframes keyframes}. If left empty then the styles from the destination state will be collected
 * and used (this is useful when describing an animation step that will complete an animation by
 * {@link transition#the-final-animate-call animating to the final state}).
 *
 * ```typescript
 * // various functions for specifying timing data
 * animate(500, style(...))
 * animate("1s", style(...))
 * animate("100ms 0.5s", style(...))
 * animate("5s ease", style(...))
 * animate("5s 10ms cubic-bezier(.17,.67,.88,.1)", style(...))
 *
 * // either style() of keyframes() can be used
 * animate(500, style({ background: "red" }))
 * animate(500, keyframes([
 *   style({ background: "blue" })),
 *   style({ background: "red" }))
 * ])
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
function animate(timings, styles) {
    if (styles === void 0) { styles = null; }
    return { type: 4 /* Animate */, styles: styles, timings: timings };
}
/**
 * `style` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `style` declares a key/value object containing CSS properties/styles that can then be used for
 * {@link state animation states}, within an {@link sequence animation sequence}, or as styling data
 * for both {@link animate animate} and {@link keyframes keyframes}.
 *
 * ### Usage
 *
 * `style` takes in a key/value string map as data and expects one or more CSS property/value pairs
 * to be defined.
 *
 * ```typescript
 * // string values are used for css properties
 * style({ background: "red", color: "blue" })
 *
 * // numerical (pixel) values are also supported
 * style({ width: 100, height: 0 })
 * ```
 *
 * #### Auto-styles (using `*`)
 *
 * When an asterix (`*`) character is used as a value then it will be detected from the element
 * being animated and applied as animation data when the animation starts.
 *
 * This feature proves useful for a state depending on layout and/or environment factors; in such
 * cases the styles are calculated just before the animation starts.
 *
 * ```typescript
 * // the steps below will animate from 0 to the
 * // actual height of the element
 * style({ height: 0 }),
 * animate("1s", style({ height: "*" }))
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
function style(tokens) {
    return { type: 6 /* Style */, styles: tokens, offset: null };
}
/**
 * `state` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `state` declares an animation state within the given trigger. When a state is active within a
 * component then its associated styles will persist on the element that the trigger is attached to
 * (even when the animation ends).
 *
 * To animate between states, have a look at the animation {@link transition transition} DSL
 * function. To register states to an animation trigger please have a look at the {@link trigger
 * trigger} function.
 *
 * #### The `void` state
 *
 * The `void` state value is a reserved word that angular uses to determine when the element is not
 * apart of the application anymore (e.g. when an `ngIf` evaluates to false then the state of the
 * associated element is void).
 *
 * #### The `*` (default) state
 *
 * The `*` state (when styled) is a fallback state that will be used if the state that is being
 * animated is not declared within the trigger.
 *
 * ### Usage
 *
 * `state` will declare an animation state with its associated styles
 * within the given trigger.
 *
 * - `stateNameExpr` can be one or more state names separated by commas.
 * - `styles` refers to the {@link style styling data} that will be persisted on the element once
 * the state has been reached.
 *
 * ```typescript
 * // "void" is a reserved name for a state and is used to represent
 * // the state in which an element is detached from from the application.
 * state("void", style({ height: 0 }))
 *
 * // user-defined states
 * state("closed", style({ height: 0 }))
 * state("open, visible", style({ height: "*" }))
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
function state(name, styles, options) {
    return { type: 0 /* State */, name: name, styles: styles, options: options };
}
/**
 * `transition` is an animation-specific function that is designed to be used inside of Angular's
 * animation DSL language. If this information is new, please navigate to the {@link
 * Component#animations component animations metadata page} to gain a better understanding of
 * how animations in Angular are used.
 *
 * `transition` declares the {@link sequence sequence of animation steps} that will be run when the
 * provided `stateChangeExpr` value is satisfied. The `stateChangeExpr` consists of a `state1 =>
 * state2` which consists of two known states (use an asterix (`*`) to refer to a dynamic starting
 * and/or ending state).
 *
 * A function can also be provided as the `stateChangeExpr` argument for a transition and this
 * function will be executed each time a state change occurs. If the value returned within the
 * function is true then the associated animation will be run.
 *
 * Animation transitions are placed within an {@link trigger animation trigger}. For an transition
 * to animate to a state value and persist its styles then one or more {@link state animation
 * states} is expected to be defined.
 *
 * ### Usage
 *
 * An animation transition is kicked off the `stateChangeExpr` predicate evaluates to true based on
 * what the previous state is and what the current state has become. In other words, if a transition
 * is defined that matches the old/current state criteria then the associated animation will be
 * triggered.
 *
 * ```typescript
 * // all transition/state changes are defined within an animation trigger
 * trigger("myAnimationTrigger", [
 *   // if a state is defined then its styles will be persisted when the
 *   // animation has fully completed itself
 *   state("on", style({ background: "green" })),
 *   state("off", style({ background: "grey" })),
 *
 *   // a transition animation that will be kicked off when the state value
 *   // bound to "myAnimationTrigger" changes from "on" to "off"
 *   transition("on => off", animate(500)),
 *
 *   // it is also possible to do run the same animation for both directions
 *   transition("on <=> off", animate(500)),
 *
 *   // or to define multiple states pairs separated by commas
 *   transition("on => off, off => void", animate(500)),
 *
 *   // this is a catch-all state change for when an element is inserted into
 *   // the page and the destination state is unknown
 *   transition("void => *", [
 *     style({ opacity: 0 }),
 *     animate(500)
 *   ]),
 *
 *   // this will capture a state change between any states
 *   transition("* => *", animate("1s 0s")),
 *
 *   // you can also go full out and include a function
 *   transition((fromState, toState) => {
 *     // when `true` then it will allow the animation below to be invoked
 *     return fromState == "off" && toState == "on";
 *   }, animate("1s 0s"))
 * ])
 * ```
 *
 * The template associated with this component will make use of the `myAnimationTrigger` animation
 * trigger by binding to an element within its template code.
 *
 * ```html
 * <!-- somewhere inside of my-component-tpl.html -->
 * <div [@myAnimationTrigger]="myStatusExp">...</div>
 * ```
 *
 * #### The final `animate` call
 *
 * If the final step within the transition steps is a call to `animate()` that **only** uses a
 * timing value with **no style data** then it will be automatically used as the final animation arc
 * for the element to animate itself to the final state. This involves an automatic mix of
 * adding/removing CSS styles so that the element will be in the exact state it should be for the
 * applied state to be presented correctly.
 *
 * ```
 * // start off by hiding the element, but make sure that it animates properly to whatever state
 * // is currently active for "myAnimationTrigger"
 * transition("void => *", [
 *   style({ opacity: 0 }),
 *   animate(500)
 * ])
 * ```
 *
 * ### Using :enter and :leave
 *
 * Given that enter (insertion) and leave (removal) animations are so common, the `transition`
 * function accepts both `:enter` and `:leave` values which are aliases for the `void => *` and `*
 * => void` state changes.
 *
 * ```
 * transition(":enter", [
 *   style({ opacity: 0 }),
 *   animate(500, style({ opacity: 1 }))
 * ]),
 * transition(":leave", [
 *   animate(500, style({ opacity: 0 }))
 * ])
 * ```
 *
 * ### Boolean values
 * if a trigger binding value is a boolean value then it can be matched using a transition
 * expression that compares `true` and `false` or `1` and `0`.
 *
 * ```
 * // in the template
 * <div [@openClose]="open ? true : false">...</div>
 *
 * // in the component metadata
 * trigger('openClose', [
 *   state('true', style({ height: '*' })),
 *   state('false', style({ height: '0px' })),
 *   transition('false <=> true', animate(500))
 * ])
 * ```
 *
 * ### Using :increment and :decrement
 * In addition to the :enter and :leave transition aliases, the :increment and :decrement aliases
 * can be used to kick off a transition when a numeric value has increased or decreased in value.
 *
 * ```
 * import {group, animate, query, transition, style, trigger} from '@angular/animations';
 * import {Component} from '@angular/core';
 *
 * @Component({
 *   selector: 'banner-carousel-component',
 *   styles: [`
 *     .banner-container {
 *        position:relative;
 *        height:500px;
 *        overflow:hidden;
 *      }
 *     .banner-container > .banner {
 *        position:absolute;
 *        left:0;
 *        top:0;
 *        font-size:200px;
 *        line-height:500px;
 *        font-weight:bold;
 *        text-align:center;
 *        width:100%;
 *      }
 *   `],
 *   template: `
 *     <button (click)="previous()">Previous</button>
 *     <button (click)="next()">Next</button>
 *     <hr>
 *     <div [@bannerAnimation]="selectedIndex" class="banner-container">
 *       <div class="banner" *ngFor="let banner of banners"> {{ banner }} </div>
 *     </div>
 *   `,
 *   animations: [
 *     trigger('bannerAnimation', [
 *       transition(":increment", group([
 *         query(':enter', [
 *           style({ left: '100%' }),
 *           animate('0.5s ease-out', style('*'))
 *         ]),
 *         query(':leave', [
 *           animate('0.5s ease-out', style({ left: '-100%' }))
 *         ])
 *       ])),
 *       transition(":decrement", group([
 *         query(':enter', [
 *           style({ left: '-100%' }),
 *           animate('0.5s ease-out', style('*'))
 *         ]),
 *         query(':leave', [
 *           animate('0.5s ease-out', style({ left: '100%' }))
 *         ])
 *       ]))
 *     ])
 *   ]
 * })
 * class BannerCarouselComponent {
 *   allBanners: string[] = ['1', '2', '3', '4'];
 *   selectedIndex: number = 0;
 *
 *   get banners() {
 *      return [this.allBanners[this.selectedIndex]];
 *   }
 *
 *   previous() {
 *     this.selectedIndex = Math.max(this.selectedIndex - 1, 0);
 *   }
 *
 *   next() {
 *     this.selectedIndex = Math.min(this.selectedIndex + 1, this.allBanners.length - 1);
 *   }
 * }
 * ```
 *
 * {@example core/animation/ts/dsl/animation_example.ts region='Component'}
 *
 * @experimental Animation support is experimental.
 */
function transition(stateChangeExpr, steps, options) {
    if (options === void 0) { options = null; }
    return { type: 1 /* Transition */, expr: stateChangeExpr, animation: steps, options: options };
}
/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
function scheduleMicroTask(cb) {
    Promise.resolve(null).then(cb);
}

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
/**
 * @experimental Animation support is experimental.
 */
var NoopAnimationPlayer = /** @class */ (function () {
    function NoopAnimationPlayer(duration, delay) {
        if (duration === void 0) { duration = 0; }
        if (delay === void 0) { delay = 0; }
        this._onDoneFns = [];
        this._onStartFns = [];
        this._onDestroyFns = [];
        this._started = false;
        this._destroyed = false;
        this._finished = false;
        this.parentPlayer = null;
        this.totalTime = duration + delay;
    }
    NoopAnimationPlayer.prototype._onFinish = function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    NoopAnimationPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
    NoopAnimationPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
    NoopAnimationPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };
    NoopAnimationPlayer.prototype.hasStarted = function () { return this._started; };
    NoopAnimationPlayer.prototype.init = function () { };
    NoopAnimationPlayer.prototype.play = function () {
        if (!this.hasStarted()) {
            this._onStart();
            this.triggerMicrotask();
        }
        this._started = true;
    };
    /* @internal */
    NoopAnimationPlayer.prototype.triggerMicrotask = function () {
        var _this = this;
        scheduleMicroTask(function () { return _this._onFinish(); });
    };
    NoopAnimationPlayer.prototype._onStart = function () {
        this._onStartFns.forEach(function (fn) { return fn(); });
        this._onStartFns = [];
    };
    NoopAnimationPlayer.prototype.pause = function () { };
    NoopAnimationPlayer.prototype.restart = function () { };
    NoopAnimationPlayer.prototype.finish = function () { this._onFinish(); };
    NoopAnimationPlayer.prototype.destroy = function () {
        if (!this._destroyed) {
            this._destroyed = true;
            if (!this.hasStarted()) {
                this._onStart();
            }
            this.finish();
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    NoopAnimationPlayer.prototype.reset = function () { };
    NoopAnimationPlayer.prototype.setPosition = function (p) { };
    NoopAnimationPlayer.prototype.getPosition = function () { return 0; };
    /* @internal */
    NoopAnimationPlayer.prototype.triggerCallback = function (phaseName) {
        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
        methods.forEach(function (fn) { return fn(); });
        methods.length = 0;
    };
    return NoopAnimationPlayer;
}());

/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
var AnimationGroupPlayer = /** @class */ (function () {
    function AnimationGroupPlayer(_players) {
        var _this = this;
        this._onDoneFns = [];
        this._onStartFns = [];
        this._finished = false;
        this._started = false;
        this._destroyed = false;
        this._onDestroyFns = [];
        this.parentPlayer = null;
        this.totalTime = 0;
        this.players = _players;
        var doneCount = 0;
        var destroyCount = 0;
        var startCount = 0;
        var total = this.players.length;
        if (total == 0) {
            scheduleMicroTask(function () { return _this._onFinish(); });
        }
        else {
            this.players.forEach(function (player) {
                player.onDone(function () {
                    if (++doneCount == total) {
                        _this._onFinish();
                    }
                });
                player.onDestroy(function () {
                    if (++destroyCount == total) {
                        _this._onDestroy();
                    }
                });
                player.onStart(function () {
                    if (++startCount == total) {
                        _this._onStart();
                    }
                });
            });
        }
        this.totalTime = this.players.reduce(function (time, player) { return Math.max(time, player.totalTime); }, 0);
    }
    AnimationGroupPlayer.prototype._onFinish = function () {
        if (!this._finished) {
            this._finished = true;
            this._onDoneFns.forEach(function (fn) { return fn(); });
            this._onDoneFns = [];
        }
    };
    AnimationGroupPlayer.prototype.init = function () { this.players.forEach(function (player) { return player.init(); }); };
    AnimationGroupPlayer.prototype.onStart = function (fn) { this._onStartFns.push(fn); };
    AnimationGroupPlayer.prototype._onStart = function () {
        if (!this.hasStarted()) {
            this._started = true;
            this._onStartFns.forEach(function (fn) { return fn(); });
            this._onStartFns = [];
        }
    };
    AnimationGroupPlayer.prototype.onDone = function (fn) { this._onDoneFns.push(fn); };
    AnimationGroupPlayer.prototype.onDestroy = function (fn) { this._onDestroyFns.push(fn); };
    AnimationGroupPlayer.prototype.hasStarted = function () { return this._started; };
    AnimationGroupPlayer.prototype.play = function () {
        if (!this.parentPlayer) {
            this.init();
        }
        this._onStart();
        this.players.forEach(function (player) { return player.play(); });
    };
    AnimationGroupPlayer.prototype.pause = function () { this.players.forEach(function (player) { return player.pause(); }); };
    AnimationGroupPlayer.prototype.restart = function () { this.players.forEach(function (player) { return player.restart(); }); };
    AnimationGroupPlayer.prototype.finish = function () {
        this._onFinish();
        this.players.forEach(function (player) { return player.finish(); });
    };
    AnimationGroupPlayer.prototype.destroy = function () { this._onDestroy(); };
    AnimationGroupPlayer.prototype._onDestroy = function () {
        if (!this._destroyed) {
            this._destroyed = true;
            this._onFinish();
            this.players.forEach(function (player) { return player.destroy(); });
            this._onDestroyFns.forEach(function (fn) { return fn(); });
            this._onDestroyFns = [];
        }
    };
    AnimationGroupPlayer.prototype.reset = function () {
        this.players.forEach(function (player) { return player.reset(); });
        this._destroyed = false;
        this._finished = false;
        this._started = false;
    };
    AnimationGroupPlayer.prototype.setPosition = function (p) {
        var timeAtPosition = p * this.totalTime;
        this.players.forEach(function (player) {
            var position = player.totalTime ? Math.min(1, timeAtPosition / player.totalTime) : 1;
            player.setPosition(position);
        });
    };
    AnimationGroupPlayer.prototype.getPosition = function () {
        var min = 0;
        this.players.forEach(function (player) {
            var p = player.getPosition();
            min = Math.min(p, min);
        });
        return min;
    };
    AnimationGroupPlayer.prototype.beforeDestroy = function () {
        this.players.forEach(function (player) {
            if (player.beforeDestroy) {
                player.beforeDestroy();
            }
        });
    };
    /* @internal */
    AnimationGroupPlayer.prototype.triggerCallback = function (phaseName) {
        var methods = phaseName == 'start' ? this._onStartFns : this._onDoneFns;
        methods.forEach(function (fn) { return fn(); });
        methods.length = 0;
    };
    return AnimationGroupPlayer;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexiodialoguePaneComponent = /** @class */ (function () {
    function AmexiodialoguePaneComponent(renderer) {
        this.renderer = renderer;
        /*
           Properties
           name : button-size
           datatype :  string
           version : 4.2 onwards
           default :
           description : Different Sizes of Buttons availabe : large, default, small & xsmall
           */
        this.buttonsize = 'large' || 'small' || 'default' || 'xsmall';
        this.showChange = new i0.EventEmitter();
        /*
           Events
           name : actionStatus
           datatype :  none
           version : none
           default : none
           description : Fire when click on yes or no button
           */
        this.actionStatus = new i0.EventEmitter();
        /*
           Events
           name : onSuccess
           datatype :  none
           version : none
           default : none
           description : Fire when click on yes or no button
           */
        this.onSuccess = new i0.EventEmitter();
        /*
           Events
           name : onFailure
           datatype :  none
           version : none
           default : none
           description : Fire when click on yes or no button
           */
        this.onCancel = new i0.EventEmitter();
        /*
           Events
           name : close
           datatype :  none
           version : none
           default : none
           description : Fire when user close dialogue
           */
        this.close = new i0.EventEmitter();
        this.value = 0;
        this.closable = true;
        this.secondaryactionlabel = 'Cancel';
        this.primaryactionlabel = 'Ok';
        this.custom = false;
        this.buttonsize = 'default';
        this.buttontype = 'theme-color';
        this.closeonescape = true;
    }
    /**
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.showdialogue) {
            this.show = this.showdialogue;
        }
        if (this.footeralign == null) {
            this.footeralign = 'right';
        }
        if (this.contentalign == null || this.contentalign === '') {
            this.contentalign = 'center';
        }
        if (this.type == null) {
            this.type = 'confirm';
        }
        this.defaultStyle = this.getDefaultStyle();
        this.buttontype = this.getStyle();
        this.componentId = this.createCompId('dialog', this.type);
    };
    /**
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.amexioFooter) {
            this.amexioFooter.toArray().forEach(function (footer) {
                footer.footer = true;
            });
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['show']) {
            this.show = changes["show"].currentValue;
            this.escapeMethod();
        }
        else if (changes['showdialogue']) {
            this.show = changes["showdialogue"].currentValue;
            this.escapeMethod();
        }
    };
    // Method called on escape
    /**
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.escapeMethod = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.show && this.closeonescape) {
            this.globalListenFunc = this.renderer.listen('document', 'keyup.esc', function (e) {
                _this.showdialogue = false;
                _this.show = false;
                _this.showChange.emit(false);
            });
        }
        else if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    };
    /**
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.onCloseClick = /**
     * @return {?}
     */
    function () {
        if (this.closable) {
            this.showdialogue = false;
            this.show = false;
            this.showChange.emit(false);
            this.close.emit(false);
        }
    };
    /**
     * @param {?} v
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.getStatus = /**
     * @param {?} v
     * @return {?}
     */
    function (v) {
        this.onCloseClick();
        this.actionStatus.emit(v);
        if (v === 'ok') {
            this.onSuccess.emit(v);
        }
        else {
            this.onCancel.emit(v);
        }
    };
    /**
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.getDefaultStyle = /**
     * @return {?}
     */
    function () {
        if (this.materialDesign) {
            return 'transparent';
        }
        else {
            return 'defualt';
        }
    };
    /**
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.getStyle = /**
     * @return {?}
     */
    function () {
        if (this.materialDesign) {
            this.buttontype = 'transparent';
            return this.buttontype;
        }
        else {
            return this.buttontype;
        }
    };
    /**
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    };
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    AmexiodialoguePaneComponent.prototype.createCompId = /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    function (inputType, name) {
        return inputType + '_' + name + '_' + Math.floor(Math.random() * 1000 + 999);
    };
    AmexiodialoguePaneComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-dialogue',
                    template: "\n    <div class=\"root-window\" *ngIf=\"show\">\n        <!-- Generate BG shade for below modal -->\n    </div>\n\n    <div class=\"dialogue-sm\" [@animation]=\"{value: 'visible', params: {transitionParams: transitionOptions}}\" *ngIf=\"show\">\n        <div role=\"dialog\" attr.aria-labelledby=\"componentId\" class=\"dialogue-content\">\n            <header [ngClass]=\"{'dialogue-material-design':materialDesign ,'dialogue-header':!materialDesign }\">\n                <div id=\"{{componentId}}\" tabindex=\"1\" class=\"dialogue-table\">\n                    <div class=\"tablerow\">\n                        <div class=\"tablecol\">\n                            {{title}}\n                        </div>\n                        <div tabindex=\"1\" aria-label=\"close button\" class=\"tablecol float-right\">\n                            <div *ngIf=\"closable\" class=\"icon-style\">\n                                <amexio-c-icon [key]=\"'window_close'\" (onClick)=\"onCloseClick()\"></amexio-c-icon>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </header>\n            <div class=\"dialogue-middle\" [ngStyle]=\"{'text-align':custom ? contentalign :'center'}\">\n                <span role=\"dialog\" attr.aria-labelledby=\"componentId\" class=\"dialogue-icon\">\n            <span  [ngClass]=\"{'dialogue-success': messagetype  == 'help','dialogue-danger':messagetype  == 'error',\n                          'dialogue-warning': messagetype  == 'warning'}\"\n              *ngIf=\"messagetype  || messagetype  != '' \">\n              <amexio-c-icon [key]=\"'window-msgtype-'+ messagetype \"></amexio-c-icon>\n            </span>\n                <ng-container *ngIf=\"!custom\">\n                    <span id=\"{{componentId}}\" tabindex=\"1\" class=\"dialogue-message\">\n                {{message}}\n              </span>\n                </ng-container>\n                </span>\n                <ng-container *ngIf=\"custom\">\n                    <ng-content select=\"amexio-body\"></ng-content>\n                </ng-container>\n\n            </div>\n            <footer *ngIf=\"custom\" class=\"dialogue-footer\" [ngClass]=\"{'flex-start':(footeralign=='left'),'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}\">\n                <ng-content select=\"amexio-action\"></ng-content>\n            </footer>\n\n            <footer *ngIf=\"!custom\" class=\"dialogue-footer\" [ngClass]=\"{'dialogue-material-design-footer':materialDesign ,\n                            'dialogue-footer':!materialDesign, 'flex-start':(footeralign=='left'),\n                            'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}\">\n                <amexio-button *ngIf=\"type =='confirm'\" [size]=\"buttonsize\" [label]=\"secondaryactionlabel\" [type]=\"defaultStyle\" (onClick)=\"getStatus('cancel')\"></amexio-button>\n                <div class=\"custom-btn\">\n                    <amexio-button *ngIf=\"type =='confirm' || type == 'alert'\" [size]=\"buttonsize\" [label]=\"primaryactionlabel\" [ngStyle]=\"{'color':materialDesign ? 'blue':'white'}\" [type]=\"buttontype\" (onClick)=\"getStatus('ok')\">\n                    </amexio-button>\n                </div>\n\n            </footer>\n        </div>\n    </div>\n  ",
                    animations: [
                        trigger('animation', [
                            state('void', style({
                                transform: 'translate3d(0, 25%, 0) scale(0.9)',
                                opacity: 0,
                            })),
                            state('visible', style({
                                transform: 'none',
                                opacity: 1,
                            })),
                            transition('* => *', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexiodialoguePaneComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };
    AmexiodialoguePaneComponent.propDecorators = {
        closeonescape: [{ type: i0.Input, args: ['close-on-escape',] }],
        buttontype: [{ type: i0.Input, args: ['button-type',] }],
        buttonsize: [{ type: i0.Input, args: ['button-size',] }],
        footeralign: [{ type: i0.Input, args: ['footer-align',] }],
        contentalign: [{ type: i0.Input, args: ['content-align',] }],
        showdialogue: [{ type: i0.Input, args: ['show-dialogue',] }],
        show: [{ type: i0.Input }],
        showChange: [{ type: i0.Output }],
        closable: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        message: [{ type: i0.Input }],
        custom: [{ type: i0.Input }],
        type: [{ type: i0.Input }],
        primaryactionlabel: [{ type: i0.Input, args: ['primary-action-label',] }],
        secondaryactionlabel: [{ type: i0.Input, args: ['secondary-action-label',] }],
        messagetype: [{ type: i0.Input, args: ['message-type',] }],
        materialDesign: [{ type: i0.Input, args: ['material-design',] }],
        actionStatus: [{ type: i0.Output }],
        onSuccess: [{ type: i0.Output }],
        onCancel: [{ type: i0.Output }],
        close: [{ type: i0.Output }],
        amexioFooter: [{ type: i0.ContentChildren, args: [AmexioFooterComponent,] }]
    };
    return AmexiodialoguePaneComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioFieldSetComponent = /** @class */ (function () {
    function AmexioFieldSetComponent() {
    }
    /**
     * @return {?}
     */
    AmexioFieldSetComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.collapsible) {
            this.isActive = true;
        }
    };
    /**
     * @return {?}
     */
    AmexioFieldSetComponent.prototype.onLegendClick = /**
     * @return {?}
     */
    function () {
        if (this.collapsible) {
            this.isActive = !this.isActive;
        }
    };
    AmexioFieldSetComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-fieldset',
                    template: "\n    <fieldset>\n        <legend tabindex=\"1\" (keyup.enter)=\"onLegendClick()\" (keyup.space)=\"onLegendClick()\" role=\"heading\" aria-expanded=\" true\"\n            *ngIf=\"(title && title.length>0) || collapsible \" class=\"collapsible-legend\" (click)=\"onLegendClick()\">\n            <ng-container *ngIf=\"!collapsible\">\n                {{title}}\n            </ng-container>\n            <ng-container *ngIf=\"collapsible && !isActive\">\n                <amexio-c-icon [attr.aria-exapnded]=\"isActive\" style=\"padding-right:5px\" key=\"fieldset_expand\"></amexio-c-icon>{{title}}\n            </ng-container>\n            <ng-container *ngIf=\"collapsible && isActive\">\n                <amexio-c-icon style=\"padding-right:5px\" key=\"fieldset_collpase\"></amexio-c-icon>{{title}}\n            </ng-container>\n        </legend>\n        <div class=\"collapsible-fieldset\" [@fieldsetContent]=\"!isActive ? {value: 'hidden', params: {transitionParams: '400ms cubic-bezier(0.86, 0, 0.07, 1)'}} : {value: 'visible', params: {transitionParams: '400ms cubic-bezier(0.86, 0, 0.07, 1)'}}\"\n        [ngStyle]=\"{'overflow': isActive ? '': 'hidden'}\">\n            <ng-content></ng-content>\n        </div>\n    </fieldset> \n  ",
                    animations: [
                        trigger('fieldsetContent', [
                            state('hidden', style({
                                height: '0px',
                            })),
                            state('visible', style({
                                height: '*',
                            })),
                            transition('visible => hidden', animate('400ms cubic-bezier(0.86, 0, 0.07, 1)')),
                            transition('hidden => visible', animate('400ms cubic-bezier(0.86, 0, 0.07, 1)')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioFieldSetComponent.ctorParameters = function () { return []; };
    AmexioFieldSetComponent.propDecorators = {
        collapsible: [{ type: i0.Input }],
        title: [{ type: i0.Input }]
    };
    return AmexioFieldSetComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 11/23/17.
*/
var COMPONENT_CLASS_MAP = {
    primary: 'btn-primary-badge',
    secondary: 'btn-secondary-badge',
};
var AmexioButtonComponent = /** @class */ (function () {
    // THIS METHOD IS USED FOR ADDING CSS CLASS DYNAMICALLY
    function AmexioButtonComponent() {
        /*
          Properties
          name : disabled
          datatype : boolean
          version : 4.0 onwards
          default : false
          description : Enable/Disables the button
          */
        this.disabled = false;
        /*
          Events
          name : onClick
          datatype :  none
          version : none
          default : none
          description : Fire when button click
          */
        this.onClick = new i0.EventEmitter();
        this.bgBorderColor = '';
        this.badgeCssClass = '';
        this.ispressed = false;
        this.bgColorClass = '';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioButtonComponent.prototype.buttonClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.ispressed = !this.ispressed;
        if (!this.disabled) {
            this.onClick.emit(event);
        }
    };
    /**
     * @return {?}
     */
    AmexioButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.getBGStyle() !== null) {
            this.bgColorClass = this.getBGStyle();
        }
        this.badgeCssClass = this.badgeClass();
    };
    /**
     * @return {?}
     */
    AmexioButtonComponent.prototype.badgeClass = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ className = '';
        if (this.type === 'primary' || this.type === 'theme-color') {
            className = 'btn-primary-badge';
        }
        if (this.type === 'secondary' || this.type === 'theme-backgroundcolor') {
            className = 'btn-secondary-badge';
        }
        if (this.type === 'success' || this.type === 'green') {
            className = 'btn-success-badge';
        }
        if (this.type === 'danger' || this.type === 'red') {
            className = 'btn-danger-badge';
        }
        if (this.type === 'warning' || this.type === 'yellow') {
            className = 'btn-warning-badge';
        }
        if (this.type === 'transparent') {
            className = 'btn-transparent-badge';
        }
        return className;
    };
    // THIS METHOD SET DISABLED PROPERTY FOR BUTTON
    /**
     * @param {?} disabled
     * @return {?}
     */
    AmexioButtonComponent.prototype.setDisabled = /**
     * @param {?} disabled
     * @return {?}
     */
    function (disabled) {
        this.disabled = disabled;
    };
    // THIS FUNCTION IS ADDING BACKGROUND AND COLOR STYTLE TO BUTTON
    /**
     * @return {?}
     */
    AmexioButtonComponent.prototype.getBGStyle = /**
     * @return {?}
     */
    function () {
        if (this.bgcolor && this.color) {
            this.type = 'default';
            this.bgBorderColor = 'none';
            return {
                'background-color': this.bgcolor,
                'color': this.color,
            };
        }
        return null;
    };
    AmexioButtonComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-button',
                    template: "\n    <button #button class=\"button\" role=\"button\" tabindex=\"1\" [attr.aria-pressed]=\"ispressed\" [ngStyle]=\"{'cursor': disabled ? 'not-allowed':'pointer','background-color':bgcolor,'color':color,'box-shadow':bgBorderColor}\" ng-disabled=\"disabled ? true: null\"\n        [attr.title]=\"tooltip\" [ngClass]=\"{'button-default': size=='default'\n            || size ==null,\n            'button-small': size=='small',\n            'button-large' : size=='large',\n            'button-block': block==true ,\n            'button-primary' : (type == 'primary' || type == 'theme-color') && disabled == false,\n            'button-secondary' : type == 'secondary' || type == 'theme-backgroundcolor' && disabled == false,\n            'button-success' : type == 'success' || type == 'green' && disabled == false,\n            'button-danger' : type=='danger' || type == 'red' && disabled == false,\n            'button-warning' : type=='warning' || type == 'yellow' && disabled == false,\n            'button-transparent' : type=='transparent' && disabled == false,\n            'disabled' : (type =='transparent' && disabled) || (type == 'secondary' || type == 'theme-backgroundcolor') && disabled,\n            'button-primary-disabled' : (type == 'primary' || type == 'theme-color') && disabled,\n            'button-success-disabled' : (type == 'success' || type == 'green') && disabled,\n            'button-danger-disabled' : (type == 'danger' || type == 'red') && disabled,\n            'button-warning-disabled' : (type == 'warning' || type == 'yellow') && disabled}\" (click)=\"buttonClick($event)\">\n            <span class=\"button-text\">\n              <span style=\"padding-right: 5px;\" *ngIf=\"icon\">\n                <amexio-c-icon [customclass]=\"icon\" [label]=\"label\">\n                </amexio-c-icon>\n              </span>\n              <span style=\"padding-right: 5px;\" *ngIf=\"loading\">\n                <amexio-c-icon key=\"button-loading-icon\" [label]=\"label\"></amexio-c-icon>\n              </span>\n              <ng-container *ngIf=\"!icon\">{{label}}</ng-container>\n\n              <ng-container *ngIf=\"badge\">\n                <span [ngClass]=\"badgeCssClass\" >{{badge}}</span>\n             </ng-container>\n          </span>\n\n\n    </button>\n  ",
                    styles: ["\n\n  "],
                },] },
    ];
    /** @nocollapse */
    AmexioButtonComponent.ctorParameters = function () { return []; };
    AmexioButtonComponent.propDecorators = {
        label: [{ type: i0.Input }],
        badge: [{ type: i0.Input, args: ['badge',] }],
        icon: [{ type: i0.Input }],
        type: [{ type: i0.Input }],
        tooltip: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        formbind: [{ type: i0.Input, args: ['form-bind',] }],
        size: [{ type: i0.Input }],
        loading: [{ type: i0.Input }],
        onClick: [{ type: i0.Output }],
        block: [{ type: i0.Input }],
        bgcolor: [{ type: i0.Input, args: ['bg-color',] }],
        color: [{ type: i0.Input, args: ['color',] }]
    };
    return AmexioButtonComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioButtonGroupComponent = /** @class */ (function () {
    function AmexioButtonGroupComponent() {
        /* for internal use*/
        this._buttonGroupLocalData = [];
        this.ispressed = false;
        this.getButton = new i0.EventEmitter();
        this.buttons = [];
    }
    Object.defineProperty(AmexioButtonGroupComponent.prototype, "buttonGroupLocalData", {
        get: /**
         * @return {?}
         */
        function () {
            return this._buttonGroupLocalData;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._buttonGroupLocalData = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioButtonGroupComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (JSON.stringify(this.buttonGroupPreviewData) !== JSON.stringify(this.buttonGroupLocalData)) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.buttons = this.buttonGroupLocalData;
            this.setButtonSizes(this.buttons);
        }
    };
    /**
     * @param {?} change
     * @return {?}
     */
    AmexioButtonGroupComponent.prototype.ngOnChanges = /**
     * @param {?} change
     * @return {?}
     */
    function (change) {
        if (change["size"] && !change["size"].isFirstChange()) {
            this.updateButtonSizes(change["size"]);
        }
    };
    /**
     * @param {?} clickEvent
     * @param {?} btnObj
     * @return {?}
     */
    AmexioButtonGroupComponent.prototype.buttonGroupClick = /**
     * @param {?} clickEvent
     * @param {?} btnObj
     * @return {?}
     */
    function (clickEvent, btnObj) {
        this.ispressed = !this.ispressed;
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.getButton.emit({ event: clickEvent, buttonObject: btnObj });
        }
        else {
            btnObj.onClick.emit(clickEvent);
        }
    };
    /**
     * @return {?}
     */
    AmexioButtonGroupComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.buttons = this.buttonGroupLocalData;
        }
        else {
            this.buttons = this.btns.toArray();
            this.addBadgeCssClass();
        }
        this.setButtonSizes(this.buttons);
        this.componentLoaded = true;
    };
    /**
     * @return {?}
     */
    AmexioButtonGroupComponent.prototype.addBadgeCssClass = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.buttons.forEach(function (btn) {
            btn.badgeCssClass = _this.badgeClass(btn);
        });
    };
    /**
     * @param {?} button
     * @return {?}
     */
    AmexioButtonGroupComponent.prototype.badgeClass = /**
     * @param {?} button
     * @return {?}
     */
    function (button) {
        var /** @type {?} */ btnStyleClass = '';
        switch (button.type) {
            case 'primary': {
                return 'btn-group-primary-badge';
            }
            case 'theme-color': {
                return 'btn-group-primary-badge';
            }
            case 'secondary': {
                return 'btn-group-secondary-badge';
            }
            case 'theme-backgroundcolor': {
                return 'btn-group-secondary-badge';
            }
            case 'success': {
                return 'btn-group-success-badge';
            }
            case 'green': {
                return 'btn-group-success-badge';
            }
        }
        btnStyleClass = this.badgeMoreClass(button);
        return btnStyleClass;
    };
    /**
     * @param {?} btnArray
     * @return {?}
     */
    AmexioButtonGroupComponent.prototype.setButtonSizes = /**
     * @param {?} btnArray
     * @return {?}
     */
    function (btnArray) {
        var _this = this;
        if (btnArray.length > 0) {
            btnArray.forEach(function (btn) {
                btn.size = _this.size;
            });
        }
    };
    /**
     * @param {?} button
     * @return {?}
     */
    AmexioButtonGroupComponent.prototype.badgeMoreClass = /**
     * @param {?} button
     * @return {?}
     */
    function (button) {
        var /** @type {?} */ className = '';
        if (button.type === 'danger' || button.type === 'red') {
            className = 'btn-group-danger-badge';
        }
        if (button.type === 'warning' || button.type === 'yellow') {
            className = 'btn-group-warning-badge';
        }
        if (button.type === 'transparent') {
            className = 'btn-group-transparent-badge';
        }
        return className;
    };
    /**
     * @param {?} size
     * @return {?}
     */
    AmexioButtonGroupComponent.prototype.updateButtonSizes = /**
     * @param {?} size
     * @return {?}
     */
    function (size) {
        this.buttons.forEach(function (btn) {
            btn.size = size;
        });
    };
    AmexioButtonGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-btn-group',
                    template: "\n    <div class=\"btn-group\">\n      <ng-container *ngFor=\"let button of buttons\">\n          <button [ngStyle]=\"{'cursor': disabled ? 'not-allowed':'pointer','background-color':button.bgcolor,'color':button.color,'box-shadow':bgBorderColor}\" \n          role=\"button\" tabindex=\"1\" [attr.aria-pressed]=\"ispressed\" [attr.disabled]=\"button.disabled ? true: null\" [attr.title]=\"button.tooltip\" \n          (click)=\"buttonGroupClick($event,button)\" \n      [ngClass]=\"{'button-default': button.size=='default'\n      || size ==null,\n      'button-small': button.size=='small',\n      'button-large' : button.size=='large',\n      'button-block': button.block==true ,\n      'button-primary' : (button.type == 'primary' || button.type == 'theme-color') && button.disabled == false,\n      'button-secondary' : button.type == 'secondary' || button.type == 'theme-backgroundcolor' && button.disabled == false,\n      'button-success' : button.type == 'success' || button.type == 'green' && button.disabled == false,\n      'button-danger' : button.type =='danger' || button.type == 'red' && button.disabled == false,\n      'button-warning' : button.type =='warning' || button.type == 'yellow' && button.disabled == false,\n      'button-transparent' : button.type=='transparent' && button.disabled == false,\n      'disabled' : (button.type =='transparent' && button.disabled) || (button.type == 'secondary' || button.type == 'theme-backgroundcolor') && disabled,\n      'button-primary-disabled' : (button.type == 'primary' || button.type == 'theme-color') && button.disabled,\n      'button-success-disabled' : (button.type == 'success' || button.type == 'green') && button.disabled,\n      'button-danger-disabled' : (button.type == 'danger' || button.type == 'red') && button.disabled,\n      'button-warning-disabled' : (button.type == 'warning' || button.type == 'yellow') && button.disabled}\">\n        <ng-container *ngIf=\"button.icon!=null\">\n          <amexio-c-icon style=\"padding-right: 5px;\" [customclass]=\"button.icon\"></amexio-c-icon>\n        </ng-container>\n\n        {{button.label}}\n        <ng-container *ngIf=\"button.badge\">\n          <span [ngClass]=\"button.badgeCssClass\" >{{button.badge}}</span>\n       </ng-container>\n      </button>\n      </ng-container>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioButtonGroupComponent.ctorParameters = function () { return []; };
    AmexioButtonGroupComponent.propDecorators = {
        size: [{ type: i0.Input }],
        buttonGroupLocalData: [{ type: i0.Input, args: ['buttonGroupLocalData',] }],
        badge: [{ type: i0.Input, args: ['badge',] }],
        getButton: [{ type: i0.Output }],
        btns: [{ type: i0.ContentChildren, args: [AmexioButtonComponent,] }]
    };
    return AmexioButtonGroupComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Component Name : Amexio Form Action
* Component Selector : <amexio-form-action>
* Component Description : Amexio Form actions contains the action items within form
*/
var AmexioFormActionComponent = /** @class */ (function () {
    function AmexioFormActionComponent() {
        this.buttons = [];
    }
    /**
     * @return {?}
     */
    AmexioFormActionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioFormActionComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.btns.length > 0) {
            this.buttons = this.btns.toArray();
        }
        else if (this.btngrp.length > 0) {
            this.buttons = this.btngrp.toArray()[0].buttons;
        }
    };
    AmexioFormActionComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-form-action', template: '<ng-content></ng-content>',
                },] },
    ];
    /** @nocollapse */
    AmexioFormActionComponent.ctorParameters = function () { return []; };
    AmexioFormActionComponent.propDecorators = {
        padding: [{ type: i0.Input }],
        btns: [{ type: i0.ContentChildren, args: [AmexioButtonComponent,] }],
        btngrp: [{ type: i0.ContentChildren, args: [AmexioButtonGroupComponent,] }]
    };
    return AmexioFormActionComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioFormBodyComponent = /** @class */ (function () {
    function AmexioFormBodyComponent() {
    }
    /**
     * @return {?}
     */
    AmexioFormBodyComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioFormBodyComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-form-body', template: '<ng-content></ng-content>',
                },] },
    ];
    /** @nocollapse */
    AmexioFormBodyComponent.ctorParameters = function () { return []; };
    AmexioFormBodyComponent.propDecorators = {
        padding: [{ type: i0.Input }]
    };
    return AmexioFormBodyComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*Created by ashwini on 01/03/19.
*/
var LifeCycleBaseComponent = /** @class */ (function () {
    function LifeCycleBaseComponent() {
        this.initiated = new i0.EventEmitter();
        this.ready = new i0.EventEmitter();
        this.destroy = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    LifeCycleBaseComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.enableLifeCycleEvents === 'all' || this.enableLifeCycleEvents === 'init') {
            this.lifeCycleInit();
        }
    };
    /**
     * @return {?}
     */
    LifeCycleBaseComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.enableLifeCycleEvents === 'all' || this.enableLifeCycleEvents === 'ready') {
            this.lifeCycleAfterViewInit();
        }
    };
    /**
     * @return {?}
     */
    LifeCycleBaseComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.enableLifeCycleEvents === 'all' || this.enableLifeCycleEvents === 'destroy') {
            this.lifeCycleDestroy();
        }
    };
    /**
     * @return {?}
     */
    LifeCycleBaseComponent.prototype.lifeCycleInit = /**
     * @return {?}
     */
    function () {
        this.initiated.emit();
    };
    /**
     * @return {?}
     */
    LifeCycleBaseComponent.prototype.lifeCycleAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.ready.emit();
    };
    /**
     * @return {?}
     */
    LifeCycleBaseComponent.prototype.lifeCycleDestroy = /**
     * @return {?}
     */
    function () {
        this.destroy.emit();
    };
    LifeCycleBaseComponent.propDecorators = {
        enableLifeCycleEvents: [{ type: i0.Input, args: ['enable-lifecycle-events',] }],
        initiated: [{ type: i0.Output }],
        ready: [{ type: i0.Output }],
        destroy: [{ type: i0.Output }]
    };
    return LifeCycleBaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioFormGroupDirective = /** @class */ (function () {
    function AmexioFormGroupDirective() {
    }
    /**
     * @return {?}
     */
    AmexioFormGroupDirective.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.modelsarray = this.models.toArray();
    };
    AmexioFormGroupDirective.decorators = [
        { type: i0.Directive, args: [{
                    selector: '[form-group]',
                },] },
    ];
    AmexioFormGroupDirective.propDecorators = {
        group: [{ type: i0.Input, args: ['form-group',] }],
        models: [{ type: i0.ContentChildren, args: [forms.NgModel, { descendants: true },] }]
    };
    return AmexioFormGroupDirective;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioFormHeaderComponent = /** @class */ (function () {
    function AmexioFormHeaderComponent() {
    }
    /**
     * @return {?}
     */
    AmexioFormHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioFormHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-form-header', template: "\n        <ng-content></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioFormHeaderComponent.ctorParameters = function () { return []; };
    AmexioFormHeaderComponent.propDecorators = {
        padding: [{ type: i0.Input }]
    };
    return AmexioFormHeaderComponent;
}());

var __extends$1 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioFormComponent = /** @class */ (function (_super) {
    __extends$1(AmexioFormComponent, _super);
    function AmexioFormComponent(formBuilder) {
        var _this = _super.call(this) || this;
        _this.formBuilder = formBuilder;
        /*
        Properties
        name : show-error
        datatype : boolean
        version : 4.2 onwards
        default : false
        description : Flag to show form invalid error messages
        */
        _this.showError = false;
        /*
        Events
        name : showErrorMsg
        datatype : any
        version : none
        default :
        description : Event fired if showError msg info button is clicked
        */
        _this.showErrorMsg = new i0.EventEmitter();
        _this.componentError = [];
        _this.checkForm = false;
        _this.isFormValid = false;
        _this.showDialogue = false;
        _this.headeralign = 'left';
        _this.footeralign = 'right';
        _this.errorMsgArray = [];
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // FOR HEADER PADING
        this.headerComponentList = this.amexioHeader.toArray();
        this.headerComponentList.forEach(function (item, currentIndex) {
            if (item.padding) {
                _this.headerPadding = item.padding;
            }
        });
        // FOR BODY PADDING
        this.bodyComponentList = this.amexioBody.toArray();
        this.bodyComponentList.forEach(function (item, currentIndex) {
            if (item.padding) {
                _this.bodyPadding = item.padding;
            }
        });
        // FOR FOOTER PADDING
        this.footerComponentList = this.amexioFooter.toArray();
        this.footerComponentList.forEach(function (item, currentIndex) {
            if (item.padding) {
                _this.footerPadding = item.padding;
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.onResize = /**
     * @return {?}
     */
    function () {
        if (this.bodyheight) {
            var /** @type {?} */ h = (window.innerHeight / 100) * this.bodyheight;
            if (this.formHeader && this.formHeader.nativeElement && this.formHeader.nativeElement.offsetHeight) {
                h = h - this.formHeader.nativeElement.offsetHeight;
            }
            if (this.formFooter && this.formFooter.nativeElement && this.formFooter.nativeElement.offsetHeight) {
                h = h - this.formFooter.nativeElement.offsetHeight;
            }
            if (this.bodyheight === 100) {
                h = h - 40;
            }
            this.minHeight = h;
            this.height = h;
        }
    };
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.buttons = [];
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        _super.prototype.ngAfterViewInit.call(this);
        var /** @type {?} */ ngContentModels = this.models.toArray();
        var /** @type {?} */ innerModelArray = [];
        this.fb.forEach(function (fbnode) {
            var /** @type {?} */ modelarray = fbnode.modelsarray;
            var /** @type {?} */ fgc = {};
            modelarray.forEach(function (m) {
                fgc[m.name] = m.control;
                innerModelArray.push(m);
            });
            var /** @type {?} */ grp = _this.formBuilder.group(fgc);
            _this.form.form.registerControl(fbnode.group, grp);
        });
        ngContentModels.forEach(function (model) {
            if (!_this.isFieldPresentInParentAndChildBoth(innerModelArray, model.name)) {
                if (!model.name || model.name === null) {
                    model.name = model.valueAccessor['name'];
                }
                _this.form.control.registerControl(model.name, model.control);
            }
        });
        this.clearTimeout = setTimeout(function () {
            _this.form.form.updateValueAndValidity();
        }, 100);
        this.btns.toArray().forEach(function (btnCom) {
            if ((btnCom.formbind === _this.fname) && !btnCom.disabled) {
                _this.buttons.push(btnCom);
            }
        });
        this.validateForm();
        this.onResize();
    };
    /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    AmexioFormComponent.prototype.isFieldPresentInParentAndChildBoth = /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    function (innerModelArray, name) {
        var /** @type {?} */ isPresent = false;
        innerModelArray.forEach(function (innerModel) {
            if (name === innerModel.name) {
                isPresent = true;
            }
        });
        return isPresent;
    };
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.closeDialogue = /**
     * @return {?}
     */
    function () {
        this.showDialogue = !this.showDialogue;
    };
    // THIS METHOD IS USED FOR ADDING MSG
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.addErrorMsg = /**
     * @return {?}
     */
    function () {
        if (this.form && this.form.status === 'INVALID') {
            for (var _i = 0, _a = Object.entries(this.form.controls); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], value = _b[1];
                if (value && value.status === 'INVALID') {
                    var /** @type {?} */ errorObject = {};
                    errorObject['label'] = key;
                    this.errorMsgArray.push(errorObject);
                }
            }
        }
    };
    // REMOVE OBJECT FROM ARRAY
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioFormComponent.prototype.showErrors = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.errorMsgArray = [];
        this.addErrorMsg();
        this.showDialogue = !this.isFormValid;
        if (!this.isFormValid) {
            this.showDialogue = true;
        }
        else {
            this.showDialogue = false;
        }
    };
    // THIS METHOD IS USED FOR DISABLE BUTTON
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.validateForm = /**
     * @return {?}
     */
    function () {
        if (this.form && this.form.status === 'INVALID') {
            this.disableButton(true);
        }
        else {
            this.disableButton(false);
        }
    };
    /**
     * @param {?} flag
     * @return {?}
     */
    AmexioFormComponent.prototype.disableButton = /**
     * @param {?} flag
     * @return {?}
     */
    function (flag) {
        this.buttons.forEach(function (btn) {
            btn.disabled = flag;
        });
    };
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        this.validateForm();
    };
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.findformStyleClass = /**
     * @return {?}
     */
    function () {
        if (this.headeralign === 'right') {
            return 'flex-end';
        }
        if (this.headeralign === 'left') {
            return 'flex-start';
        }
        if (this.headeralign === 'center') {
            return 'flex-center';
        }
    };
    /**
     * @return {?}
     */
    AmexioFormComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        clearTimeout(this.clearTimeout);
    };
    AmexioFormComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-form',
                    template: "\n    <form name=\"fname\" class=\"form-container form-group\" (window:resize)=\"onResize()\">\n\n        <header #formHeader class=\"form-header\" [style.padding]=\"headerPadding\" *ngIf=\"header\" [ngClass]=\"findformStyleClass()\">\n            <ng-content select=\"amexio-form-header\"></ng-content>\n        </header>\n\n        <div class=\"form-body formbody\" [style.padding]=\"bodyPadding\" [ngStyle]=\"{'height.px' : height,'overflow-y' : height!= null ? 'auto' : '','min-height.px' : minHeight}\">\n            <ng-content select=\"amexio-form-body\"></ng-content>\n        </div>\n\n        <footer #formFooter class=\"form-footer\" [style.padding]=\"footerPadding\" [ngClass]=\"{'flex-start':(footeralign=='left'),'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}\">\n            <ng-content select=\"amexio-form-action\"></ng-content>\n            <br/>\n            <div *ngIf=\"!form.valid\" style=\"padding: 5px;\">\n                <button class=\"button\" [attr.title]=\"'click'\" (click)=\"showErrors($event)\" [ngClass]=\"'button-warning button-small button-round'\">\n                            <span class=\"button-text\">\n                              <span style=\"padding-right: 5px;\" *ngIf=\"icon\">\n                                <amexio-c-icon [customclass]=\"icon\" >\n                                </amexio-c-icon>\n                              </span>\n                              <span style=\"padding-right: 5px;\" *ngIf=\"loading\">\n                                <amexio-c-icon key=\"button-loading-icon\"></amexio-c-icon>\n                              </span>\n                              ?\n                            </span>\n                    </button>\n                <amexio-dialogue [close-on-escape]=\"true\" [(show)]=\"showDialogue\" [custom]=\"true\" [content-align]=\"'left'\" [closable]=\"false\" [title]=\"'Invalid Fields'\" [type]=\"'confirm'\">\n\n                    <amexio-body *ngFor=\"let msg of errorMsgArray let index=index\">\n                        <amexio-label>{{index+1}}) {{msg.label}}</amexio-label><br>\n                    </amexio-body>\n\n                    <amexio-action>\n                        <amexio-button type=\"primary\" (onClick)=\"closeDialogue()\" [label]=\"'OK'\">\n                        </amexio-button>\n                    </amexio-action>\n                </amexio-dialogue>\n            </div>\n        </footer>\n    </form>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioFormComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder }
    ]; };
    AmexioFormComponent.propDecorators = {
        headeralign: [{ type: i0.Input, args: ['header-align',] }],
        footeralign: [{ type: i0.Input, args: ['footer-align',] }],
        fname: [{ type: i0.Input, args: ['form-name',] }],
        header: [{ type: i0.Input, args: ['header',] }],
        showError: [{ type: i0.Input, args: ['show-error',] }],
        height: [{ type: i0.Input }],
        minHeight: [{ type: i0.Input, args: ['min-height',] }],
        bodyheight: [{ type: i0.Input, args: ['body-height',] }],
        formHeader: [{ type: i0.ViewChild, args: ['formHeader', { read: i0.ElementRef },] }],
        formFooter: [{ type: i0.ViewChild, args: ['formFooter', { read: i0.ElementRef },] }],
        showErrorMsg: [{ type: i0.Output }],
        amexioHeader: [{ type: i0.ContentChildren, args: [AmexioFormHeaderComponent,] }],
        amexioBody: [{ type: i0.ContentChildren, args: [AmexioFormBodyComponent,] }],
        amexioFooter: [{ type: i0.ContentChildren, args: [AmexioFormActionComponent,] }],
        btns: [{ type: i0.ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
        form: [{ type: i0.ViewChild, args: [forms.NgForm,] }],
        models: [{ type: i0.ContentChildren, args: [forms.NgModel, { descendants: true },] }],
        fb: [{ type: i0.ContentChildren, args: [AmexioFormGroupDirective, { descendants: true },] }]
    };
    return AmexioFormComponent;
}(LifeCycleBaseComponent));

var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};



function unwrapExports (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, module) {
	return module = { exports: {} }, fn(module, module.exports), module.exports;
}

var isFunction_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isFunction(x) {
    return typeof x === 'function';
}
exports.isFunction = isFunction;

});

unwrapExports(isFunction_1);

var config$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _enable_super_gross_mode_that_will_cause_bad_things = false;
/**
 * The global configuration object for RxJS, used to configure things
 * like what Promise contructor should used to create Promises
 */
exports.config = {
    /**
     * The promise constructor used by default for methods such as
     * {@link toPromise} and {@link forEach}
     */
    Promise: undefined,
    /**
     * If true, turns on synchronous error rethrowing, which is a deprecated behavior
     * in v6 and higher. This behavior enables bad patterns like wrapping a subscribe
     * call in a try/catch block. It also enables producer interference, a nasty bug
     * where a multicast can be broken for all observers by a downstream consumer with
     * an unhandled error. DO NOT USE THIS FLAG UNLESS IT'S NEEDED TO BY TIME
     * FOR MIGRATION REASONS.
     */
    set useDeprecatedSynchronousErrorHandling(value) {
        if (value) {
            var error = new Error();
            console.warn('DEPRECATED! RxJS was set to use deprecated synchronous error handling behavior by code at: \n' + error.stack);
        }
        else if (_enable_super_gross_mode_that_will_cause_bad_things) {
            console.log('RxJS: Back to a better error behavior. Thank you. <3');
        }
        _enable_super_gross_mode_that_will_cause_bad_things = value;
    },
    get useDeprecatedSynchronousErrorHandling() {
        return _enable_super_gross_mode_that_will_cause_bad_things;
    },
};

});

unwrapExports(config$1);

var hostReportError_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Throws an error on another job so that it's picked up by the runtime's
 * uncaught error handling mechanism.
 * @param err the error to throw
 */
function hostReportError(err) {
    setTimeout(function () { throw err; });
}
exports.hostReportError = hostReportError;

});

unwrapExports(hostReportError_1);

var Observer = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


exports.empty = {
    closed: true,
    next: function (value) { },
    error: function (err) {
        if (config$1.config.useDeprecatedSynchronousErrorHandling) {
            throw err;
        }
        else {
            hostReportError_1.hostReportError(err);
        }
    },
    complete: function () { }
};

});

unwrapExports(Observer);

var isArray$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArray = Array.isArray || (function (x) { return x && typeof x.length === 'number'; });

});

unwrapExports(isArray$1);

var isObject_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isObject(x) {
    return x != null && typeof x === 'object';
}
exports.isObject = isObject;

});

unwrapExports(isObject_1);

var errorObject$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// typeof any so that it we don't have to cast when comparing a result to the error object
exports.errorObject = { e: {} };

});

unwrapExports(errorObject$1);

var tryCatch_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

var tryCatchTarget;
function tryCatcher() {
    try {
        return tryCatchTarget.apply(this, arguments);
    }
    catch (e) {
        errorObject$1.errorObject.e = e;
        return errorObject$1.errorObject;
    }
}
function tryCatch(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
}
exports.tryCatch = tryCatch;

});

unwrapExports(tryCatch_1);

var UnsubscriptionError_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An error thrown when one or more errors have occurred during the
 * `unsubscribe` of a {@link Subscription}.
 */
var UnsubscriptionError = /** @class */ (function (_super) {
    __extends(UnsubscriptionError, _super);
    function UnsubscriptionError(errors) {
        var _this = _super.call(this, errors ?
            errors.length + " errors occurred during unsubscription:\n  " + errors.map(function (err, i) { return i + 1 + ") " + err.toString(); }).join('\n  ') : '') || this;
        _this.errors = errors;
        _this.name = 'UnsubscriptionError';
        Object.setPrototypeOf(_this, UnsubscriptionError.prototype);
        return _this;
    }
    return UnsubscriptionError;
}(Error));
exports.UnsubscriptionError = UnsubscriptionError;

});

unwrapExports(UnsubscriptionError_1);

var Subscription_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * Represents a disposable resource, such as the execution of an Observable. A
 * Subscription has one important method, `unsubscribe`, that takes no argument
 * and just disposes the resource held by the subscription.
 *
 * Additionally, subscriptions may be grouped together through the `add()`
 * method, which will attach a child Subscription to the current Subscription.
 * When a Subscription is unsubscribed, all its children (and its grandchildren)
 * will be unsubscribed as well.
 *
 * @class Subscription
 */
var Subscription = /** @class */ (function () {
    /**
     * @param {function(): void} [unsubscribe] A function describing how to
     * perform the disposal of resources when the `unsubscribe` method is called.
     */
    function Subscription(unsubscribe) {
        /**
         * A flag to indicate whether this Subscription has already been unsubscribed.
         * @type {boolean}
         */
        this.closed = false;
        /** @internal */
        this._parent = null;
        /** @internal */
        this._parents = null;
        /** @internal */
        this._subscriptions = null;
        if (unsubscribe) {
            this._unsubscribe = unsubscribe;
        }
    }
    /**
     * Disposes the resources held by the subscription. May, for instance, cancel
     * an ongoing Observable execution or cancel any other type of work that
     * started when the Subscription was created.
     * @return {void}
     */
    Subscription.prototype.unsubscribe = function () {
        var hasErrors = false;
        var errors;
        if (this.closed) {
            return;
        }
        var _a = this, _parent = _a._parent, _parents = _a._parents, _unsubscribe = _a._unsubscribe, _subscriptions = _a._subscriptions;
        this.closed = true;
        this._parent = null;
        this._parents = null;
        // null out _subscriptions first so any child subscriptions that attempt
        // to remove themselves from this subscription will noop
        this._subscriptions = null;
        var index = -1;
        var len = _parents ? _parents.length : 0;
        // if this._parent is null, then so is this._parents, and we
        // don't have to remove ourselves from any parent subscriptions.
        while (_parent) {
            _parent.remove(this);
            // if this._parents is null or index >= len,
            // then _parent is set to null, and the loop exits
            _parent = ++index < len && _parents[index] || null;
        }
        if (isFunction_1.isFunction(_unsubscribe)) {
            var trial = tryCatch_1.tryCatch(_unsubscribe).call(this);
            if (trial === errorObject$1.errorObject) {
                hasErrors = true;
                errors = errors || (errorObject$1.errorObject.e instanceof UnsubscriptionError_1.UnsubscriptionError ?
                    flattenUnsubscriptionErrors(errorObject$1.errorObject.e.errors) : [errorObject$1.errorObject.e]);
            }
        }
        if (isArray$1.isArray(_subscriptions)) {
            index = -1;
            len = _subscriptions.length;
            while (++index < len) {
                var sub = _subscriptions[index];
                if (isObject_1.isObject(sub)) {
                    var trial = tryCatch_1.tryCatch(sub.unsubscribe).call(sub);
                    if (trial === errorObject$1.errorObject) {
                        hasErrors = true;
                        errors = errors || [];
                        var err = errorObject$1.errorObject.e;
                        if (err instanceof UnsubscriptionError_1.UnsubscriptionError) {
                            errors = errors.concat(flattenUnsubscriptionErrors(err.errors));
                        }
                        else {
                            errors.push(err);
                        }
                    }
                }
            }
        }
        if (hasErrors) {
            throw new UnsubscriptionError_1.UnsubscriptionError(errors);
        }
    };
    /**
     * Adds a tear down to be called during the unsubscribe() of this
     * Subscription.
     *
     * If the tear down being added is a subscription that is already
     * unsubscribed, is the same reference `add` is being called on, or is
     * `Subscription.EMPTY`, it will not be added.
     *
     * If this subscription is already in an `closed` state, the passed
     * tear down logic will be executed immediately.
     *
     * @param {TeardownLogic} teardown The additional logic to execute on
     * teardown.
     * @return {Subscription} Returns the Subscription used or created to be
     * added to the inner subscriptions list. This Subscription can be used with
     * `remove()` to remove the passed teardown logic from the inner subscriptions
     * list.
     */
    Subscription.prototype.add = function (teardown) {
        if (!teardown || (teardown === Subscription.EMPTY)) {
            return Subscription.EMPTY;
        }
        if (teardown === this) {
            return this;
        }
        var subscription = teardown;
        switch (typeof teardown) {
            case 'function':
                subscription = new Subscription(teardown);
            case 'object':
                if (subscription.closed || typeof subscription.unsubscribe !== 'function') {
                    return subscription;
                }
                else if (this.closed) {
                    subscription.unsubscribe();
                    return subscription;
                }
                else if (typeof subscription._addParent !== 'function' /* quack quack */) {
                    var tmp = subscription;
                    subscription = new Subscription();
                    subscription._subscriptions = [tmp];
                }
                break;
            default:
                throw new Error('unrecognized teardown ' + teardown + ' added to Subscription.');
        }
        var subscriptions = this._subscriptions || (this._subscriptions = []);
        subscriptions.push(subscription);
        subscription._addParent(this);
        return subscription;
    };
    /**
     * Removes a Subscription from the internal list of subscriptions that will
     * unsubscribe during the unsubscribe process of this Subscription.
     * @param {Subscription} subscription The subscription to remove.
     * @return {void}
     */
    Subscription.prototype.remove = function (subscription) {
        var subscriptions = this._subscriptions;
        if (subscriptions) {
            var subscriptionIndex = subscriptions.indexOf(subscription);
            if (subscriptionIndex !== -1) {
                subscriptions.splice(subscriptionIndex, 1);
            }
        }
    };
    /** @internal */
    Subscription.prototype._addParent = function (parent) {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        if (!_parent || _parent === parent) {
            // If we don't have a parent, or the new parent is the same as the
            // current parent, then set this._parent to the new parent.
            this._parent = parent;
        }
        else if (!_parents) {
            // If there's already one parent, but not multiple, allocate an Array to
            // store the rest of the parent Subscriptions.
            this._parents = [parent];
        }
        else if (_parents.indexOf(parent) === -1) {
            // Only add the new parent to the _parents list if it's not already there.
            _parents.push(parent);
        }
    };
    /** @nocollapse */
    Subscription.EMPTY = (function (empty) {
        empty.closed = true;
        return empty;
    }(new Subscription()));
    return Subscription;
}());
exports.Subscription = Subscription;
function flattenUnsubscriptionErrors(errors) {
    return errors.reduce(function (errs, err) { return errs.concat((err instanceof UnsubscriptionError_1.UnsubscriptionError) ? err.errors : err); }, []);
}

});

unwrapExports(Subscription_1);

var rxSubscriber$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.rxSubscriber = (typeof Symbol === 'function' && typeof Symbol.for === 'function')
    ? Symbol.for('rxSubscriber')
    : '@@rxSubscriber';
/**
 * @deprecated use rxSubscriber instead
 */
exports.$$rxSubscriber = exports.rxSubscriber;

});

unwrapExports(rxSubscriber$1);

var Subscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * Implements the {@link Observer} interface and extends the
 * {@link Subscription} class. While the {@link Observer} is the public API for
 * consuming the values of an {@link Observable}, all Observers get converted to
 * a Subscriber, in order to provide Subscription-like capabilities such as
 * `unsubscribe`. Subscriber is a common type in RxJS, and crucial for
 * implementing operators, but it is rarely used as a public API.
 *
 * @class Subscriber<T>
 */
var Subscriber = /** @class */ (function (_super) {
    __extends(Subscriber, _super);
    /**
     * @param {Observer|function(value: T): void} [destinationOrNext] A partially
     * defined Observer or a `next` callback function.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     */
    function Subscriber(destinationOrNext, error, complete) {
        var _this = _super.call(this) || this;
        /** @internal */ _this.syncErrorValue = null;
        /** @internal */ _this.syncErrorThrown = false;
        /** @internal */ _this.syncErrorThrowable = false;
        _this.isStopped = false;
        switch (arguments.length) {
            case 0:
                _this.destination = Observer.empty;
                break;
            case 1:
                if (!destinationOrNext) {
                    _this.destination = Observer.empty;
                    break;
                }
                if (typeof destinationOrNext === 'object') {
                    // HACK(benlesh): For situations where Node has multiple copies of rxjs in
                    // node_modules, we cannot rely on `instanceof` checks
                    if (isTrustedSubscriber(destinationOrNext)) {
                        var trustedSubscriber = destinationOrNext[rxSubscriber$1.rxSubscriber]();
                        _this.syncErrorThrowable = trustedSubscriber.syncErrorThrowable;
                        _this.destination = trustedSubscriber;
                        trustedSubscriber.add(_this);
                    }
                    else {
                        _this.syncErrorThrowable = true;
                        _this.destination = new SafeSubscriber(_this, destinationOrNext);
                    }
                    break;
                }
            default:
                _this.syncErrorThrowable = true;
                _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete);
                break;
        }
        return _this;
    }
    Subscriber.prototype[rxSubscriber$1.rxSubscriber] = function () { return this; };
    /**
     * A static factory for a Subscriber, given a (potentially partial) definition
     * of an Observer.
     * @param {function(x: ?T): void} [next] The `next` callback of an Observer.
     * @param {function(e: ?any): void} [error] The `error` callback of an
     * Observer.
     * @param {function(): void} [complete] The `complete` callback of an
     * Observer.
     * @return {Subscriber<T>} A Subscriber wrapping the (partially defined)
     * Observer represented by the given arguments.
     * @nocollapse
     */
    Subscriber.create = function (next, error, complete) {
        var subscriber = new Subscriber(next, error, complete);
        subscriber.syncErrorThrowable = false;
        return subscriber;
    };
    /**
     * The {@link Observer} callback to receive notifications of type `next` from
     * the Observable, with a value. The Observable may call this method 0 or more
     * times.
     * @param {T} [value] The `next` value.
     * @return {void}
     */
    Subscriber.prototype.next = function (value) {
        if (!this.isStopped) {
            this._next(value);
        }
    };
    /**
     * The {@link Observer} callback to receive notifications of type `error` from
     * the Observable, with an attached {@link Error}. Notifies the Observer that
     * the Observable has experienced an error condition.
     * @param {any} [err] The `error` exception.
     * @return {void}
     */
    Subscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            this.isStopped = true;
            this._error(err);
        }
    };
    /**
     * The {@link Observer} callback to receive a valueless notification of type
     * `complete` from the Observable. Notifies the Observer that the Observable
     * has finished sending push-based notifications.
     * @return {void}
     */
    Subscriber.prototype.complete = function () {
        if (!this.isStopped) {
            this.isStopped = true;
            this._complete();
        }
    };
    Subscriber.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.isStopped = true;
        _super.prototype.unsubscribe.call(this);
    };
    Subscriber.prototype._next = function (value) {
        this.destination.next(value);
    };
    Subscriber.prototype._error = function (err) {
        this.destination.error(err);
        this.unsubscribe();
    };
    Subscriber.prototype._complete = function () {
        this.destination.complete();
        this.unsubscribe();
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Subscriber.prototype._unsubscribeAndRecycle = function () {
        var _a = this, _parent = _a._parent, _parents = _a._parents;
        this._parent = null;
        this._parents = null;
        this.unsubscribe();
        this.closed = false;
        this.isStopped = false;
        this._parent = _parent;
        this._parents = _parents;
        return this;
    };
    return Subscriber;
}(Subscription_1.Subscription));
exports.Subscriber = Subscriber;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SafeSubscriber = /** @class */ (function (_super) {
    __extends(SafeSubscriber, _super);
    function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
        var _this = _super.call(this) || this;
        _this._parentSubscriber = _parentSubscriber;
        var next;
        var context = _this;
        if (isFunction_1.isFunction(observerOrNext)) {
            next = observerOrNext;
        }
        else if (observerOrNext) {
            next = observerOrNext.next;
            error = observerOrNext.error;
            complete = observerOrNext.complete;
            if (observerOrNext !== Observer.empty) {
                context = Object.create(observerOrNext);
                if (isFunction_1.isFunction(context.unsubscribe)) {
                    _this.add(context.unsubscribe.bind(context));
                }
                context.unsubscribe = _this.unsubscribe.bind(_this);
            }
        }
        _this._context = context;
        _this._next = next;
        _this._error = error;
        _this._complete = complete;
        return _this;
    }
    SafeSubscriber.prototype.next = function (value) {
        if (!this.isStopped && this._next) {
            var _parentSubscriber = this._parentSubscriber;
            if (!config$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                this.__tryOrUnsub(this._next, value);
            }
            else if (this.__tryOrSetError(_parentSubscriber, this._next, value)) {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.error = function (err) {
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            var useDeprecatedSynchronousErrorHandling = config$1.config.useDeprecatedSynchronousErrorHandling;
            if (this._error) {
                if (!useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(this._error, err);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, this._error, err);
                    this.unsubscribe();
                }
            }
            else if (!_parentSubscriber.syncErrorThrowable) {
                this.unsubscribe();
                if (useDeprecatedSynchronousErrorHandling) {
                    throw err;
                }
                hostReportError_1.hostReportError(err);
            }
            else {
                if (useDeprecatedSynchronousErrorHandling) {
                    _parentSubscriber.syncErrorValue = err;
                    _parentSubscriber.syncErrorThrown = true;
                }
                else {
                    hostReportError_1.hostReportError(err);
                }
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.complete = function () {
        var _this = this;
        if (!this.isStopped) {
            var _parentSubscriber = this._parentSubscriber;
            if (this._complete) {
                var wrappedComplete = function () { return _this._complete.call(_this._context); };
                if (!config$1.config.useDeprecatedSynchronousErrorHandling || !_parentSubscriber.syncErrorThrowable) {
                    this.__tryOrUnsub(wrappedComplete);
                    this.unsubscribe();
                }
                else {
                    this.__tryOrSetError(_parentSubscriber, wrappedComplete);
                    this.unsubscribe();
                }
            }
            else {
                this.unsubscribe();
            }
        }
    };
    SafeSubscriber.prototype.__tryOrUnsub = function (fn, value) {
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            this.unsubscribe();
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                throw err;
            }
            else {
                hostReportError_1.hostReportError(err);
            }
        }
    };
    SafeSubscriber.prototype.__tryOrSetError = function (parent, fn, value) {
        if (!config$1.config.useDeprecatedSynchronousErrorHandling) {
            throw new Error('bad call');
        }
        try {
            fn.call(this._context, value);
        }
        catch (err) {
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                parent.syncErrorValue = err;
                parent.syncErrorThrown = true;
                return true;
            }
            else {
                hostReportError_1.hostReportError(err);
                return true;
            }
        }
        return false;
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    SafeSubscriber.prototype._unsubscribe = function () {
        var _parentSubscriber = this._parentSubscriber;
        this._context = null;
        this._parentSubscriber = null;
        _parentSubscriber.unsubscribe();
    };
    return SafeSubscriber;
}(Subscriber));
function isTrustedSubscriber(obj) {
    return obj instanceof Subscriber || ('syncErrorThrowable' in obj && obj[rxSubscriber$1.rxSubscriber]);
}

});

unwrapExports(Subscriber_1);

var toSubscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function toSubscriber(nextOrObserver, error, complete) {
    if (nextOrObserver) {
        if (nextOrObserver instanceof Subscriber_1.Subscriber) {
            return nextOrObserver;
        }
        if (nextOrObserver[rxSubscriber$1.rxSubscriber]) {
            return nextOrObserver[rxSubscriber$1.rxSubscriber]();
        }
    }
    if (!nextOrObserver && !error && !complete) {
        return new Subscriber_1.Subscriber(Observer.empty);
    }
    return new Subscriber_1.Subscriber(nextOrObserver, error, complete);
}
exports.toSubscriber = toSubscriber;

});

unwrapExports(toSubscriber_1);

var observable$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/** Symbol.observable or a string "@@observable". Used for interop */
exports.observable = typeof Symbol === 'function' && Symbol.observable || '@@observable';

});

unwrapExports(observable$1);

var noop_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable:no-empty */
function noop() { }
exports.noop = noop;

});

unwrapExports(noop_1);

var pipe_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/* tslint:enable:max-line-length */
function pipe() {
    var fns = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        fns[_i] = arguments[_i];
    }
    return pipeFromArray(fns);
}
exports.pipe = pipe;
/* @internal */
function pipeFromArray(fns) {
    if (!fns) {
        return noop_1.noop;
    }
    if (fns.length === 1) {
        return fns[0];
    }
    return function piped(input) {
        return fns.reduce(function (prev, fn) { return fn(prev); }, input);
    };
}
exports.pipeFromArray = pipeFromArray;

});

unwrapExports(pipe_1);

var Observable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * A representation of any set of values over any amount of time. This is the most basic building block
 * of RxJS.
 *
 * @class Observable<T>
 */
var Observable = /** @class */ (function () {
    /**
     * @constructor
     * @param {Function} subscribe the function that is called when the Observable is
     * initially subscribed to. This function is given a Subscriber, to which new values
     * can be `next`ed, or an `error` method can be called to raise an error, or
     * `complete` can be called to notify of a successful completion.
     */
    function Observable(subscribe) {
        /** Internal implementation detail, do not use directly. */
        this._isScalar = false;
        if (subscribe) {
            this._subscribe = subscribe;
        }
    }
    /**
     * Creates a new Observable, with this Observable as the source, and the passed
     * operator defined as the new observable's operator.
     * @method lift
     * @param {Operator} operator the operator defining the operation to take on the observable
     * @return {Observable} a new observable with the Operator applied
     */
    Observable.prototype.lift = function (operator) {
        var observable = new Observable();
        observable.source = this;
        observable.operator = operator;
        return observable;
    };
    /**
     * Invokes an execution of an Observable and registers Observer handlers for notifications it will emit.
     *
     * <span class="informal">Use it when you have all these Observables, but still nothing is happening.</span>
     *
     * `subscribe` is not a regular operator, but a method that calls Observable's internal `subscribe` function. It
     * might be for example a function that you passed to a {@link create} static factory, but most of the time it is
     * a library implementation, which defines what and when will be emitted by an Observable. This means that calling
     * `subscribe` is actually the moment when Observable starts its work, not when it is created, as it is often
     * thought.
     *
     * Apart from starting the execution of an Observable, this method allows you to listen for values
     * that an Observable emits, as well as for when it completes or errors. You can achieve this in two
     * following ways.
     *
     * The first way is creating an object that implements {@link Observer} interface. It should have methods
     * defined by that interface, but note that it should be just a regular JavaScript object, which you can create
     * yourself in any way you want (ES6 class, classic function constructor, object literal etc.). In particular do
     * not attempt to use any RxJS implementation details to create Observers - you don't need them. Remember also
     * that your object does not have to implement all methods. If you find yourself creating a method that doesn't
     * do anything, you can simply omit it. Note however, that if `error` method is not provided, all errors will
     * be left uncaught.
     *
     * The second way is to give up on Observer object altogether and simply provide callback functions in place of its methods.
     * This means you can provide three functions as arguments to `subscribe`, where first function is equivalent
     * of a `next` method, second of an `error` method and third of a `complete` method. Just as in case of Observer,
     * if you do not need to listen for something, you can omit a function, preferably by passing `undefined` or `null`,
     * since `subscribe` recognizes these functions by where they were placed in function call. When it comes
     * to `error` function, just as before, if not provided, errors emitted by an Observable will be thrown.
     *
     * Whatever style of calling `subscribe` you use, in both cases it returns a Subscription object.
     * This object allows you to call `unsubscribe` on it, which in turn will stop work that an Observable does and will clean
     * up all resources that an Observable used. Note that cancelling a subscription will not call `complete` callback
     * provided to `subscribe` function, which is reserved for a regular completion signal that comes from an Observable.
     *
     * Remember that callbacks provided to `subscribe` are not guaranteed to be called asynchronously.
     * It is an Observable itself that decides when these functions will be called. For example {@link of}
     * by default emits all its values synchronously. Always check documentation for how given Observable
     * will behave when subscribed and if its default behavior can be modified with a {@link Scheduler}.
     *
     * @example <caption>Subscribe with an Observer</caption>
     * const sumObserver = {
     *   sum: 0,
     *   next(value) {
     *     console.log('Adding: ' + value);
     *     this.sum = this.sum + value;
     *   },
     *   error() { // We actually could just remove this method,
     *   },        // since we do not really care about errors right now.
     *   complete() {
     *     console.log('Sum equals: ' + this.sum);
     *   }
     * };
     *
     * Rx.Observable.of(1, 2, 3) // Synchronously emits 1, 2, 3 and then completes.
     * .subscribe(sumObserver);
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Subscribe with functions</caption>
     * let sum = 0;
     *
     * Rx.Observable.of(1, 2, 3)
     * .subscribe(
     *   function(value) {
     *     console.log('Adding: ' + value);
     *     sum = sum + value;
     *   },
     *   undefined,
     *   function() {
     *     console.log('Sum equals: ' + sum);
     *   }
     * );
     *
     * // Logs:
     * // "Adding: 1"
     * // "Adding: 2"
     * // "Adding: 3"
     * // "Sum equals: 6"
     *
     *
     * @example <caption>Cancel a subscription</caption>
     * const subscription = Rx.Observable.interval(1000).subscribe(
     *   num => console.log(num),
     *   undefined,
     *   () => console.log('completed!') // Will not be called, even
     * );                                // when cancelling subscription
     *
     *
     * setTimeout(() => {
     *   subscription.unsubscribe();
     *   console.log('unsubscribed!');
     * }, 2500);
     *
     * // Logs:
     * // 0 after 1s
     * // 1 after 2s
     * // "unsubscribed!" after 2.5s
     *
     *
     * @param {Observer|Function} observerOrNext (optional) Either an observer with methods to be called,
     *  or the first of three possible handlers, which is the handler for each value emitted from the subscribed
     *  Observable.
     * @param {Function} error (optional) A handler for a terminal event resulting from an error. If no error handler is provided,
     *  the error will be thrown as unhandled.
     * @param {Function} complete (optional) A handler for a terminal event resulting from successful completion.
     * @return {ISubscription} a subscription reference to the registered handlers
     * @method subscribe
     */
    Observable.prototype.subscribe = function (observerOrNext, error, complete) {
        var operator = this.operator;
        var sink = toSubscriber_1.toSubscriber(observerOrNext, error, complete);
        if (operator) {
            operator.call(sink, this.source);
        }
        else {
            sink.add(this.source || !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink));
        }
        if (config$1.config.useDeprecatedSynchronousErrorHandling) {
            if (sink.syncErrorThrowable) {
                sink.syncErrorThrowable = false;
                if (sink.syncErrorThrown) {
                    throw sink.syncErrorValue;
                }
            }
        }
        return sink;
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Observable.prototype._trySubscribe = function (sink) {
        try {
            return this._subscribe(sink);
        }
        catch (err) {
            if (config$1.config.useDeprecatedSynchronousErrorHandling) {
                sink.syncErrorThrown = true;
                sink.syncErrorValue = err;
            }
            sink.error(err);
        }
    };
    /**
     * @method forEach
     * @param {Function} next a handler for each value emitted by the observable
     * @param {PromiseConstructor} [promiseCtor] a constructor function used to instantiate the Promise
     * @return {Promise} a promise that either resolves on observable completion or
     *  rejects with the handled error
     */
    Observable.prototype.forEach = function (next, promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            // Must be declared in a separate statement to avoid a RefernceError when
            // accessing subscription below in the closure due to Temporal Dead Zone.
            var subscription;
            subscription = _this.subscribe(function (value) {
                try {
                    next(value);
                }
                catch (err) {
                    reject(err);
                    if (subscription) {
                        subscription.unsubscribe();
                    }
                }
            }, reject, resolve);
        });
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Observable.prototype._subscribe = function (subscriber) {
        var source = this.source;
        return source && source.subscribe(subscriber);
    };
    /**
     * An interop point defined by the es7-observable spec https://github.com/zenparsing/es-observable
     * @method Symbol.observable
     * @return {Observable} this instance of the observable
     */
    Observable.prototype[observable$1.observable] = function () {
        return this;
    };
    /* tslint:enable:max-line-length */
    /**
     * Used to stitch together functional operators into a chain.
     * @method pipe
     * @return {Observable} the Observable result of all of the operators having
     * been called in the order they were passed in.
     *
     * @example
     *
     * import { map, filter, scan } from 'rxjs/operators';
     *
     * Rx.Observable.interval(1000)
     *   .pipe(
     *     filter(x => x % 2 === 0),
     *     map(x => x + x),
     *     scan((acc, x) => acc + x)
     *   )
     *   .subscribe(x => console.log(x))
     */
    Observable.prototype.pipe = function () {
        var operations = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            operations[_i] = arguments[_i];
        }
        if (operations.length === 0) {
            return this;
        }
        return pipe_1.pipeFromArray(operations)(this);
    };
    /* tslint:enable:max-line-length */
    Observable.prototype.toPromise = function (promiseCtor) {
        var _this = this;
        promiseCtor = getPromiseCtor(promiseCtor);
        return new promiseCtor(function (resolve, reject) {
            var value;
            _this.subscribe(function (x) { return value = x; }, function (err) { return reject(err); }, function () { return resolve(value); });
        });
    };
    // HACK: Since TypeScript inherits static properties too, we have to
    // fight against TypeScript here so Subject can have a different static create signature
    /**
     * Creates a new cold Observable by calling the Observable constructor
     * @static true
     * @owner Observable
     * @method create
     * @param {Function} subscribe? the subscriber function to be passed to the Observable constructor
     * @return {Observable} a new cold observable
     * @nocollapse
     */
    Observable.create = function (subscribe) {
        return new Observable(subscribe);
    };
    return Observable;
}());
exports.Observable = Observable;
/**
 * Decides between a passed promise constructor from consuming code,
 * A default configured promise constructor, and the native promise
 * constructor and returns it. If nothing can be found, it will throw
 * an error.
 * @param promiseCtor The optional promise constructor to passed by consuming code
 */
function getPromiseCtor(promiseCtor) {
    if (!promiseCtor) {
        promiseCtor = config$1.config.Promise || Promise;
    }
    if (!promiseCtor) {
        throw new Error('no Promise impl found');
    }
    return promiseCtor;
}

});

unwrapExports(Observable_1);

var ObjectUnsubscribedError_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An error thrown when an action is invalid because the object has been
 * unsubscribed.
 *
 * @see {@link Subject}
 * @see {@link BehaviorSubject}
 *
 * @class ObjectUnsubscribedError
 */
var ObjectUnsubscribedError = /** @class */ (function (_super) {
    __extends(ObjectUnsubscribedError, _super);
    function ObjectUnsubscribedError() {
        var _this = _super.call(this, 'object unsubscribed') || this;
        _this.name = 'ObjectUnsubscribedError';
        Object.setPrototypeOf(_this, ObjectUnsubscribedError.prototype);
        return _this;
    }
    return ObjectUnsubscribedError;
}(Error));
exports.ObjectUnsubscribedError = ObjectUnsubscribedError;

});

unwrapExports(ObjectUnsubscribedError_1);

var SubjectSubscription_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var SubjectSubscription = /** @class */ (function (_super) {
    __extends(SubjectSubscription, _super);
    function SubjectSubscription(subject, subscriber) {
        var _this = _super.call(this) || this;
        _this.subject = subject;
        _this.subscriber = subscriber;
        _this.closed = false;
        return _this;
    }
    SubjectSubscription.prototype.unsubscribe = function () {
        if (this.closed) {
            return;
        }
        this.closed = true;
        var subject = this.subject;
        var observers = subject.observers;
        this.subject = null;
        if (!observers || observers.length === 0 || subject.isStopped || subject.closed) {
            return;
        }
        var subscriberIndex = observers.indexOf(this.subscriber);
        if (subscriberIndex !== -1) {
            observers.splice(subscriberIndex, 1);
        }
    };
    return SubjectSubscription;
}(Subscription_1.Subscription));
exports.SubjectSubscription = SubjectSubscription;

});

unwrapExports(SubjectSubscription_1);

var Subject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * @class SubjectSubscriber<T>
 */
var SubjectSubscriber = /** @class */ (function (_super) {
    __extends(SubjectSubscriber, _super);
    function SubjectSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.destination = destination;
        return _this;
    }
    return SubjectSubscriber;
}(Subscriber_1.Subscriber));
exports.SubjectSubscriber = SubjectSubscriber;
/**
 * @class Subject<T>
 */
var Subject = /** @class */ (function (_super) {
    __extends(Subject, _super);
    function Subject() {
        var _this = _super.call(this) || this;
        _this.observers = [];
        _this.closed = false;
        _this.isStopped = false;
        _this.hasError = false;
        _this.thrownError = null;
        return _this;
    }
    Subject.prototype[rxSubscriber$1.rxSubscriber] = function () {
        return new SubjectSubscriber(this);
    };
    Subject.prototype.lift = function (operator) {
        var subject = new AnonymousSubject(this, this);
        subject.operator = operator;
        return subject;
    };
    Subject.prototype.next = function (value) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        if (!this.isStopped) {
            var observers = this.observers;
            var len = observers.length;
            var copy = observers.slice();
            for (var i = 0; i < len; i++) {
                copy[i].next(value);
            }
        }
    };
    Subject.prototype.error = function (err) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.hasError = true;
        this.thrownError = err;
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].error(err);
        }
        this.observers.length = 0;
    };
    Subject.prototype.complete = function () {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        this.isStopped = true;
        var observers = this.observers;
        var len = observers.length;
        var copy = observers.slice();
        for (var i = 0; i < len; i++) {
            copy[i].complete();
        }
        this.observers.length = 0;
    };
    Subject.prototype.unsubscribe = function () {
        this.isStopped = true;
        this.closed = true;
        this.observers = null;
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Subject.prototype._trySubscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return _super.prototype._trySubscribe.call(this, subscriber);
        }
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    Subject.prototype._subscribe = function (subscriber) {
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.isStopped) {
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            return new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
    };
    Subject.prototype.asObservable = function () {
        var observable = new Observable_1.Observable();
        observable.source = this;
        return observable;
    };
    /**@nocollapse */
    Subject.create = function (destination, source) {
        return new AnonymousSubject(destination, source);
    };
    return Subject;
}(Observable_1.Observable));
exports.Subject = Subject;
/**
 * @class AnonymousSubject<T>
 */
var AnonymousSubject = /** @class */ (function (_super) {
    __extends(AnonymousSubject, _super);
    function AnonymousSubject(destination, source) {
        var _this = _super.call(this) || this;
        _this.destination = destination;
        _this.source = source;
        return _this;
    }
    AnonymousSubject.prototype.next = function (value) {
        var destination = this.destination;
        if (destination && destination.next) {
            destination.next(value);
        }
    };
    AnonymousSubject.prototype.error = function (err) {
        var destination = this.destination;
        if (destination && destination.error) {
            this.destination.error(err);
        }
    };
    AnonymousSubject.prototype.complete = function () {
        var destination = this.destination;
        if (destination && destination.complete) {
            this.destination.complete();
        }
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    AnonymousSubject.prototype._subscribe = function (subscriber) {
        var source = this.source;
        if (source) {
            return this.source.subscribe(subscriber);
        }
        else {
            return Subscription_1.Subscription.EMPTY;
        }
    };
    return AnonymousSubject;
}(Subject));
exports.AnonymousSubject = AnonymousSubject;

});

unwrapExports(Subject_1);

var refCount_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

function refCount() {
    return function refCountOperatorFunction(source) {
        return source.lift(new RefCountOperator(source));
    };
}
exports.refCount = refCount;
var RefCountOperator = /** @class */ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /** @class */ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(refCount_1);

var ConnectableObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * @class ConnectableObservable<T>
 */
var ConnectableObservable = /** @class */ (function (_super) {
    __extends(ConnectableObservable, _super);
    function ConnectableObservable(source, subjectFactory) {
        var _this = _super.call(this) || this;
        _this.source = source;
        _this.subjectFactory = subjectFactory;
        _this._refCount = 0;
        /** @internal */
        _this._isComplete = false;
        return _this;
    }
    /** @deprecated This is an internal implementation detail, do not use. */
    ConnectableObservable.prototype._subscribe = function (subscriber) {
        return this.getSubject().subscribe(subscriber);
    };
    ConnectableObservable.prototype.getSubject = function () {
        var subject = this._subject;
        if (!subject || subject.isStopped) {
            this._subject = this.subjectFactory();
        }
        return this._subject;
    };
    ConnectableObservable.prototype.connect = function () {
        var connection = this._connection;
        if (!connection) {
            this._isComplete = false;
            connection = this._connection = new Subscription_1.Subscription();
            connection.add(this.source
                .subscribe(new ConnectableSubscriber(this.getSubject(), this)));
            if (connection.closed) {
                this._connection = null;
                connection = Subscription_1.Subscription.EMPTY;
            }
            else {
                this._connection = connection;
            }
        }
        return connection;
    };
    ConnectableObservable.prototype.refCount = function () {
        return refCount_1.refCount()(this);
    };
    return ConnectableObservable;
}(Observable_1.Observable));
exports.ConnectableObservable = ConnectableObservable;
var connectableProto = ConnectableObservable.prototype;
exports.connectableObservableDescriptor = {
    operator: { value: null },
    _refCount: { value: 0, writable: true },
    _subject: { value: null, writable: true },
    _connection: { value: null, writable: true },
    _subscribe: { value: connectableProto._subscribe },
    _isComplete: { value: connectableProto._isComplete, writable: true },
    getSubject: { value: connectableProto.getSubject },
    connect: { value: connectableProto.connect },
    refCount: { value: connectableProto.refCount }
};
var ConnectableSubscriber = /** @class */ (function (_super) {
    __extends(ConnectableSubscriber, _super);
    function ConnectableSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    ConnectableSubscriber.prototype._error = function (err) {
        this._unsubscribe();
        _super.prototype._error.call(this, err);
    };
    ConnectableSubscriber.prototype._complete = function () {
        this.connectable._isComplete = true;
        this._unsubscribe();
        _super.prototype._complete.call(this);
    };
    ConnectableSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (connectable) {
            this.connectable = null;
            var connection = connectable._connection;
            connectable._refCount = 0;
            connectable._subject = null;
            connectable._connection = null;
            if (connection) {
                connection.unsubscribe();
            }
        }
    };
    return ConnectableSubscriber;
}(Subject_1.SubjectSubscriber));
var RefCountOperator = /** @class */ (function () {
    function RefCountOperator(connectable) {
        this.connectable = connectable;
    }
    RefCountOperator.prototype.call = function (subscriber, source) {
        var connectable = this.connectable;
        connectable._refCount++;
        var refCounter = new RefCountSubscriber(subscriber, connectable);
        var subscription = source.subscribe(refCounter);
        if (!refCounter.closed) {
            refCounter.connection = connectable.connect();
        }
        return subscription;
    };
    return RefCountOperator;
}());
var RefCountSubscriber = /** @class */ (function (_super) {
    __extends(RefCountSubscriber, _super);
    function RefCountSubscriber(destination, connectable) {
        var _this = _super.call(this, destination) || this;
        _this.connectable = connectable;
        return _this;
    }
    RefCountSubscriber.prototype._unsubscribe = function () {
        var connectable = this.connectable;
        if (!connectable) {
            this.connection = null;
            return;
        }
        this.connectable = null;
        var refCount = connectable._refCount;
        if (refCount <= 0) {
            this.connection = null;
            return;
        }
        connectable._refCount = refCount - 1;
        if (refCount > 1) {
            this.connection = null;
            return;
        }
        ///
        // Compare the local RefCountSubscriber's connection Subscription to the
        // connection Subscription on the shared ConnectableObservable. In cases
        // where the ConnectableObservable source synchronously emits values, and
        // the RefCountSubscriber's downstream Observers synchronously unsubscribe,
        // execution continues to here before the RefCountOperator has a chance to
        // supply the RefCountSubscriber with the shared connection Subscription.
        // For example:
        // ```
        // Observable.range(0, 10)
        //   .publish()
        //   .refCount()
        //   .take(5)
        //   .subscribe();
        // ```
        // In order to account for this case, RefCountSubscriber should only dispose
        // the ConnectableObservable's shared connection Subscription if the
        // connection Subscription exists, *and* either:
        //   a. RefCountSubscriber doesn't have a reference to the shared connection
        //      Subscription yet, or,
        //   b. RefCountSubscriber's connection Subscription reference is identical
        //      to the shared connection Subscription
        ///
        var connection = this.connection;
        var sharedConnection = connectable._connection;
        this.connection = null;
        if (sharedConnection && (!connection || sharedConnection === connection)) {
            sharedConnection.unsubscribe();
        }
    };
    return RefCountSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(ConnectableObservable_1);

var groupBy_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });




/* tslint:enable:max-line-length */
/**
 * Groups the items emitted by an Observable according to a specified criterion,
 * and emits these grouped items as `GroupedObservables`, one
 * {@link GroupedObservable} per group.
 *
 * <img src="./img/groupBy.png" width="100%">
 *
 * @example <caption>Group objects by id and return as array</caption>
 * Observable.of<Obj>({id: 1, name: 'aze1'},
 *                    {id: 2, name: 'sf2'},
 *                    {id: 2, name: 'dg2'},
 *                    {id: 1, name: 'erg1'},
 *                    {id: 1, name: 'df1'},
 *                    {id: 2, name: 'sfqfb2'},
 *                    {id: 3, name: 'qfs3'},
 *                    {id: 2, name: 'qsgqsfg2'}
 *     )
 *     .groupBy(p => p.id)
 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], []))
 *     .subscribe(p => console.log(p));
 *
 * // displays:
 * // [ { id: 1, name: 'aze1' },
 * //   { id: 1, name: 'erg1' },
 * //   { id: 1, name: 'df1' } ]
 * //
 * // [ { id: 2, name: 'sf2' },
 * //   { id: 2, name: 'dg2' },
 * //   { id: 2, name: 'sfqfb2' },
 * //   { id: 2, name: 'qsgqsfg2' } ]
 * //
 * // [ { id: 3, name: 'qfs3' } ]
 *
 * @example <caption>Pivot data on the id field</caption>
 * Observable.of<Obj>({id: 1, name: 'aze1'},
 *                    {id: 2, name: 'sf2'},
 *                    {id: 2, name: 'dg2'},
 *                    {id: 1, name: 'erg1'},
 *                    {id: 1, name: 'df1'},
 *                    {id: 2, name: 'sfqfb2'},
 *                    {id: 3, name: 'qfs1'},
 *                    {id: 2, name: 'qsgqsfg2'}
 *                   )
 *     .groupBy(p => p.id, p => p.name)
 *     .flatMap( (group$) => group$.reduce((acc, cur) => [...acc, cur], ["" + group$.key]))
 *     .map(arr => ({'id': parseInt(arr[0]), 'values': arr.slice(1)}))
 *     .subscribe(p => console.log(p));
 *
 * // displays:
 * // { id: 1, values: [ 'aze1', 'erg1', 'df1' ] }
 * // { id: 2, values: [ 'sf2', 'dg2', 'sfqfb2', 'qsgqsfg2' ] }
 * // { id: 3, values: [ 'qfs1' ] }
 *
 * @param {function(value: T): K} keySelector A function that extracts the key
 * for each item.
 * @param {function(value: T): R} [elementSelector] A function that extracts the
 * return element for each item.
 * @param {function(grouped: GroupedObservable<K,R>): Observable<any>} [durationSelector]
 * A function that returns an Observable to determine how long each group should
 * exist.
 * @return {Observable<GroupedObservable<K,R>>} An Observable that emits
 * GroupedObservables, each of which corresponds to a unique key value and each
 * of which emits those items from the source Observable that share that key
 * value.
 * @method groupBy
 * @owner Observable
 */
function groupBy(keySelector, elementSelector, durationSelector, subjectSelector) {
    return function (source) {
        return source.lift(new GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector));
    };
}
exports.groupBy = groupBy;
var GroupByOperator = /** @class */ (function () {
    function GroupByOperator(keySelector, elementSelector, durationSelector, subjectSelector) {
        this.keySelector = keySelector;
        this.elementSelector = elementSelector;
        this.durationSelector = durationSelector;
        this.subjectSelector = subjectSelector;
    }
    GroupByOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new GroupBySubscriber(subscriber, this.keySelector, this.elementSelector, this.durationSelector, this.subjectSelector));
    };
    return GroupByOperator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupBySubscriber = /** @class */ (function (_super) {
    __extends(GroupBySubscriber, _super);
    function GroupBySubscriber(destination, keySelector, elementSelector, durationSelector, subjectSelector) {
        var _this = _super.call(this, destination) || this;
        _this.keySelector = keySelector;
        _this.elementSelector = elementSelector;
        _this.durationSelector = durationSelector;
        _this.subjectSelector = subjectSelector;
        _this.groups = null;
        _this.attemptedToUnsubscribe = false;
        _this.count = 0;
        return _this;
    }
    GroupBySubscriber.prototype._next = function (value) {
        var key;
        try {
            key = this.keySelector(value);
        }
        catch (err) {
            this.error(err);
            return;
        }
        this._group(value, key);
    };
    GroupBySubscriber.prototype._group = function (value, key) {
        var groups = this.groups;
        if (!groups) {
            groups = this.groups = new Map();
        }
        var group = groups.get(key);
        var element;
        if (this.elementSelector) {
            try {
                element = this.elementSelector(value);
            }
            catch (err) {
                this.error(err);
            }
        }
        else {
            element = value;
        }
        if (!group) {
            group = (this.subjectSelector ? this.subjectSelector() : new Subject_1.Subject());
            groups.set(key, group);
            var groupedObservable = new GroupedObservable(key, group, this);
            this.destination.next(groupedObservable);
            if (this.durationSelector) {
                var duration = void 0;
                try {
                    duration = this.durationSelector(new GroupedObservable(key, group));
                }
                catch (err) {
                    this.error(err);
                    return;
                }
                this.add(duration.subscribe(new GroupDurationSubscriber(key, group, this)));
            }
        }
        if (!group.closed) {
            group.next(element);
        }
    };
    GroupBySubscriber.prototype._error = function (err) {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.error(err);
            });
            groups.clear();
        }
        this.destination.error(err);
    };
    GroupBySubscriber.prototype._complete = function () {
        var groups = this.groups;
        if (groups) {
            groups.forEach(function (group, key) {
                group.complete();
            });
            groups.clear();
        }
        this.destination.complete();
    };
    GroupBySubscriber.prototype.removeGroup = function (key) {
        this.groups.delete(key);
    };
    GroupBySubscriber.prototype.unsubscribe = function () {
        if (!this.closed) {
            this.attemptedToUnsubscribe = true;
            if (this.count === 0) {
                _super.prototype.unsubscribe.call(this);
            }
        }
    };
    return GroupBySubscriber;
}(Subscriber_1.Subscriber));
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var GroupDurationSubscriber = /** @class */ (function (_super) {
    __extends(GroupDurationSubscriber, _super);
    function GroupDurationSubscriber(key, group, parent) {
        var _this = _super.call(this, group) || this;
        _this.key = key;
        _this.group = group;
        _this.parent = parent;
        return _this;
    }
    GroupDurationSubscriber.prototype._next = function (value) {
        this.complete();
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    GroupDurationSubscriber.prototype._unsubscribe = function () {
        var _a = this, parent = _a.parent, key = _a.key;
        this.key = this.parent = null;
        if (parent) {
            parent.removeGroup(key);
        }
    };
    return GroupDurationSubscriber;
}(Subscriber_1.Subscriber));
/**
 * An Observable representing values belonging to the same group represented by
 * a common key. The values emitted by a GroupedObservable come from the source
 * Observable. The common key is available as the field `key` on a
 * GroupedObservable instance.
 *
 * @class GroupedObservable<K, T>
 */
var GroupedObservable = /** @class */ (function (_super) {
    __extends(GroupedObservable, _super);
    /** @deprecated Do not construct this type. Internal use only */
    function GroupedObservable(key, groupSubject, refCountSubscription) {
        var _this = _super.call(this) || this;
        _this.key = key;
        _this.groupSubject = groupSubject;
        _this.refCountSubscription = refCountSubscription;
        return _this;
    }
    /** @deprecated This is an internal implementation detail, do not use. */
    GroupedObservable.prototype._subscribe = function (subscriber) {
        var subscription = new Subscription_1.Subscription();
        var _a = this, refCountSubscription = _a.refCountSubscription, groupSubject = _a.groupSubject;
        if (refCountSubscription && !refCountSubscription.closed) {
            subscription.add(new InnerRefCountSubscription(refCountSubscription));
        }
        subscription.add(groupSubject.subscribe(subscriber));
        return subscription;
    };
    return GroupedObservable;
}(Observable_1.Observable));
exports.GroupedObservable = GroupedObservable;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerRefCountSubscription = /** @class */ (function (_super) {
    __extends(InnerRefCountSubscription, _super);
    function InnerRefCountSubscription(parent) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        parent.count++;
        return _this;
    }
    InnerRefCountSubscription.prototype.unsubscribe = function () {
        var parent = this.parent;
        if (!parent.closed && !this.closed) {
            _super.prototype.unsubscribe.call(this);
            parent.count -= 1;
            if (parent.count === 0 && parent.attemptedToUnsubscribe) {
                parent.unsubscribe();
            }
        }
    };
    return InnerRefCountSubscription;
}(Subscription_1.Subscription));

});

unwrapExports(groupBy_1);

var BehaviorSubject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * @class BehaviorSubject<T>
 */
var BehaviorSubject = /** @class */ (function (_super) {
    __extends(BehaviorSubject, _super);
    function BehaviorSubject(_value) {
        var _this = _super.call(this) || this;
        _this._value = _value;
        return _this;
    }
    Object.defineProperty(BehaviorSubject.prototype, "value", {
        get: function () {
            return this.getValue();
        },
        enumerable: true,
        configurable: true
    });
    /** @deprecated This is an internal implementation detail, do not use. */
    BehaviorSubject.prototype._subscribe = function (subscriber) {
        var subscription = _super.prototype._subscribe.call(this, subscriber);
        if (subscription && !subscription.closed) {
            subscriber.next(this._value);
        }
        return subscription;
    };
    BehaviorSubject.prototype.getValue = function () {
        if (this.hasError) {
            throw this.thrownError;
        }
        else if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else {
            return this._value;
        }
    };
    BehaviorSubject.prototype.next = function (value) {
        _super.prototype.next.call(this, this._value = value);
    };
    return BehaviorSubject;
}(Subject_1.Subject));
exports.BehaviorSubject = BehaviorSubject;

});

unwrapExports(BehaviorSubject_1);

var Action_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * A unit of work to be executed in a {@link Scheduler}. An action is typically
 * created from within a Scheduler and an RxJS user does not need to concern
 * themselves about creating and manipulating an Action.
 *
 * ```ts
 * class Action<T> extends Subscription {
 *   new (scheduler: Scheduler, work: (state?: T) => void);
 *   schedule(state?: T, delay: number = 0): Subscription;
 * }
 * ```
 *
 * @class Action<T>
 */
var Action = /** @class */ (function (_super) {
    __extends(Action, _super);
    function Action(scheduler, work) {
        return _super.call(this) || this;
    }
    /**
     * Schedules this action on its parent Scheduler for execution. May be passed
     * some context object, `state`. May happen at some point in the future,
     * according to the `delay` parameter, if specified.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler.
     * @return {void}
     */
    Action.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        return this;
    };
    return Action;
}(Subscription_1.Subscription));
exports.Action = Action;

});

unwrapExports(Action_1);

var AsyncAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsyncAction = /** @class */ (function (_super) {
    __extends(AsyncAction, _super);
    function AsyncAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.pending = false;
        return _this;
    }
    AsyncAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (this.closed) {
            return this;
        }
        // Always replace the current state with the new state.
        this.state = state;
        var id = this.id;
        var scheduler = this.scheduler;
        //
        // Important implementation note:
        //
        // Actions only execute once by default, unless rescheduled from within the
        // scheduled callback. This allows us to implement single and repeat
        // actions via the same code path, without adding API surface area, as well
        // as mimic traditional recursion but across asynchronous boundaries.
        //
        // However, JS runtimes and timers distinguish between intervals achieved by
        // serial `setTimeout` calls vs. a single `setInterval` call. An interval of
        // serial `setTimeout` calls can be individually delayed, which delays
        // scheduling the next `setTimeout`, and so on. `setInterval` attempts to
        // guarantee the interval callback will be invoked more precisely to the
        // interval period, regardless of load.
        //
        // Therefore, we use `setInterval` to schedule single and repeat actions.
        // If the action reschedules itself with the same delay, the interval is not
        // canceled. If the action doesn't reschedule, or reschedules with a
        // different delay, the interval will be canceled after scheduled callback
        // execution.
        //
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, delay);
        }
        // Set the pending flag indicating that this action has been scheduled, or
        // has recursively rescheduled itself.
        this.pending = true;
        this.delay = delay;
        // If this action has already an async Id, don't request a new one.
        this.id = this.id || this.requestAsyncId(scheduler, this.id, delay);
        return this;
    };
    AsyncAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return setInterval(scheduler.flush.bind(scheduler, this), delay);
    };
    AsyncAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If this action is rescheduled with the same delay time, don't clear the interval id.
        if (delay !== null && this.delay === delay && this.pending === false) {
            return id;
        }
        // Otherwise, if the action's delay time is different from the current delay,
        // or the action has been rescheduled before it's executed, clear the interval id
        return clearInterval(id) && undefined || undefined;
    };
    /**
     * Immediately executes this action and the `work` it contains.
     * @return {any}
     */
    AsyncAction.prototype.execute = function (state, delay) {
        if (this.closed) {
            return new Error('executing a cancelled action');
        }
        this.pending = false;
        var error = this._execute(state, delay);
        if (error) {
            return error;
        }
        else if (this.pending === false && this.id != null) {
            // Dequeue if the action didn't reschedule itself. Don't call
            // unsubscribe(), because the action could reschedule later.
            // For example:
            // ```
            // scheduler.schedule(function doWork(counter) {
            //   /* ... I'm a busy worker bee ... */
            //   var originalAction = this;
            //   /* wait 100ms before rescheduling the action */
            //   setTimeout(function () {
            //     originalAction.schedule(counter + 1);
            //   }, 100);
            // }, 1000);
            // ```
            this.id = this.recycleAsyncId(this.scheduler, this.id, null);
        }
    };
    AsyncAction.prototype._execute = function (state, delay) {
        var errored = false;
        var errorValue = undefined;
        try {
            this.work(state);
        }
        catch (e) {
            errored = true;
            errorValue = !!e && e || new Error(e);
        }
        if (errored) {
            this.unsubscribe();
            return errorValue;
        }
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    AsyncAction.prototype._unsubscribe = function () {
        var id = this.id;
        var scheduler = this.scheduler;
        var actions = scheduler.actions;
        var index = actions.indexOf(this);
        this.work = null;
        this.state = null;
        this.pending = false;
        this.scheduler = null;
        if (index !== -1) {
            actions.splice(index, 1);
        }
        if (id != null) {
            this.id = this.recycleAsyncId(scheduler, id, null);
        }
        this.delay = null;
    };
    return AsyncAction;
}(Action_1.Action));
exports.AsyncAction = AsyncAction;

});

unwrapExports(AsyncAction_1);

var QueueAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var QueueAction = /** @class */ (function (_super) {
    __extends(QueueAction, _super);
    function QueueAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    QueueAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (delay > 0) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.delay = delay;
        this.state = state;
        this.scheduler.flush(this);
        return this;
    };
    QueueAction.prototype.execute = function (state, delay) {
        return (delay > 0 || this.closed) ?
            _super.prototype.execute.call(this, state, delay) :
            this._execute(state, delay);
    };
    QueueAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Otherwise flush the scheduler starting with this action.
        return scheduler.flush(this);
    };
    return QueueAction;
}(AsyncAction_1.AsyncAction));
exports.QueueAction = QueueAction;

});

unwrapExports(QueueAction_1);

var Scheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An execution context and a data structure to order tasks and schedule their
 * execution. Provides a notion of (potentially virtual) time, through the
 * `now()` getter method.
 *
 * Each unit of work in a Scheduler is called an {@link Action}.
 *
 * ```ts
 * class Scheduler {
 *   now(): number;
 *   schedule(work, delay?, state?): Subscription;
 * }
 * ```
 *
 * @class Scheduler
 * @deprecated Scheduler is an internal implementation detail of RxJS, and
 * should not be used directly. Rather, create your own class and implement
 * {@link SchedulerLike}
 */
var Scheduler = /** @class */ (function () {
    function Scheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler.now; }
        this.SchedulerAction = SchedulerAction;
        this.now = now;
    }
    /**
     * Schedules a function, `work`, for execution. May happen at some point in
     * the future, according to the `delay` parameter, if specified. May be passed
     * some context object, `state`, which will be passed to the `work` function.
     *
     * The given arguments will be processed an stored as an Action object in a
     * queue of actions.
     *
     * @param {function(state: ?T): ?Subscription} work A function representing a
     * task, or some unit of work to be executed by the Scheduler.
     * @param {number} [delay] Time to wait before executing the work, where the
     * time unit is implicit and defined by the Scheduler itself.
     * @param {T} [state] Some contextual data that the `work` function uses when
     * called by the Scheduler.
     * @return {Subscription} A subscription in order to be able to unsubscribe
     * the scheduled work.
     */
    Scheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        return new this.SchedulerAction(this, work).schedule(state, delay);
    };
    /** @nocollapse */
    Scheduler.now = Date.now ? Date.now : function () { return +new Date(); };
    return Scheduler;
}());
exports.Scheduler = Scheduler;

});

unwrapExports(Scheduler_1);

var AsyncScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AsyncScheduler = /** @class */ (function (_super) {
    __extends(AsyncScheduler, _super);
    function AsyncScheduler(SchedulerAction, now) {
        if (now === void 0) { now = Scheduler_1.Scheduler.now; }
        var _this = _super.call(this, SchedulerAction, function () {
            if (AsyncScheduler.delegate && AsyncScheduler.delegate !== _this) {
                return AsyncScheduler.delegate.now();
            }
            else {
                return now();
            }
        }) || this;
        _this.actions = [];
        /**
         * A flag to indicate whether the Scheduler is currently executing a batch of
         * queued actions.
         * @type {boolean}
         * @deprecated internal use only
         */
        _this.active = false;
        /**
         * An internal ID used to track the latest asynchronous task such as those
         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and
         * others.
         * @type {any}
         * @deprecated internal use only
         */
        _this.scheduled = undefined;
        return _this;
    }
    AsyncScheduler.prototype.schedule = function (work, delay, state) {
        if (delay === void 0) { delay = 0; }
        if (AsyncScheduler.delegate && AsyncScheduler.delegate !== this) {
            return AsyncScheduler.delegate.schedule(work, delay, state);
        }
        else {
            return _super.prototype.schedule.call(this, work, delay, state);
        }
    };
    AsyncScheduler.prototype.flush = function (action) {
        var actions = this.actions;
        if (this.active) {
            actions.push(action);
            return;
        }
        var error;
        this.active = true;
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (action = actions.shift()); // exhaust the scheduler queue
        this.active = false;
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsyncScheduler;
}(Scheduler_1.Scheduler));
exports.AsyncScheduler = AsyncScheduler;

});

unwrapExports(AsyncScheduler_1);

var QueueScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var QueueScheduler = /** @class */ (function (_super) {
    __extends(QueueScheduler, _super);
    function QueueScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return QueueScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.QueueScheduler = QueueScheduler;

});

unwrapExports(QueueScheduler_1);

var queue$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/**
 *
 * Queue Scheduler
 *
 * <span class="informal">Put every next task on a queue, instead of executing it immediately</span>
 *
 * `queue` scheduler, when used with delay, behaves the same as {@link async} scheduler.
 *
 * When used without delay, it schedules given task synchronously - executes it right when
 * it is scheduled. However when called recursively, that is when inside the scheduled task,
 * another task is scheduled with queue scheduler, instead of executing immediately as well,
 * that task will be put on a queue and wait for current one to finish.
 *
 * This means that when you execute task with `queue` scheduler, you are sure it will end
 * before any other task scheduled with that scheduler will start.
 *
 * @examples <caption>Schedule recursively first, then do something</caption>
 *
 * Rx.Scheduler.queue.schedule(() => {
 *   Rx.Scheduler.queue.schedule(() => console.log('second')); // will not happen now, but will be put on a queue
 *
 *   console.log('first');
 * });
 *
 * // Logs:
 * // "first"
 * // "second"
 *
 *
 * @example <caption>Reschedule itself recursively</caption>
 *
 * Rx.Scheduler.queue.schedule(function(state) {
 *   if (state !== 0) {
 *     console.log('before', state);
 *     this.schedule(state - 1); // `this` references currently executing Action,
 *                               // which we reschedule with new state
 *     console.log('after', state);
 *   }
 * }, 0, 3);
 *
 * // In scheduler that runs recursively, you would expect:
 * // "before", 3
 * // "before", 2
 * // "before", 1
 * // "after", 1
 * // "after", 2
 * // "after", 3
 *
 * // But with queue it logs:
 * // "before", 3
 * // "after", 3
 * // "before", 2
 * // "after", 2
 * // "before", 1
 * // "after", 1
 *
 *
 * @static true
 * @name queue
 * @owner Scheduler
 */
exports.queue = new QueueScheduler_1.QueueScheduler(QueueAction_1.QueueAction);

});

unwrapExports(queue$1);

var empty_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * The same Observable instance returned by any call to {@link empty} without a
 * {@link Scheduler}. It is preferrable to use this over `empty()`.
 */
exports.EMPTY = new Observable_1.Observable(function (subscriber) { return subscriber.complete(); });
/**
 * Creates an Observable that emits no items to the Observer and immediately
 * emits a complete notification.
 *
 * <span class="informal">Just emits 'complete', and nothing else.
 * </span>
 *
 * <img src="./img/empty.png" width="100%">
 *
 * This static operator is useful for creating a simple Observable that only
 * emits the complete notification. It can be used for composing with other
 * Observables, such as in a {@link mergeMap}.
 *
 * @example <caption>Emit the number 7, then complete.</caption>
 * var result = Rx.Observable.empty().startWith(7);
 * result.subscribe(x => console.log(x));
 *
 * @example <caption>Map and flatten only odd numbers to the sequence 'a', 'b', 'c'</caption>
 * var interval = Rx.Observable.interval(1000);
 * var result = interval.mergeMap(x =>
 *   x % 2 === 1 ? Rx.Observable.of('a', 'b', 'c') : Rx.Observable.empty()
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following to the console:
 * // x is equal to the count on the interval eg(0,1,2,3,...)
 * // x will occur every 1000ms
 * // if x % 2 is equal to 1 print abc
 * // if x % 2 is not equal to 1 nothing will be output
 *
 * @see {@link create}
 * @see {@link never}
 * @see {@link of}
 * @see {@link throw}
 *
 * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
 * the emission of the complete notification.
 * @return {Observable} An "empty" Observable: emits only the complete
 * notification.
 * @static true
 * @name empty
 * @owner Observable
 * @deprecated Deprecated in favor of using EMPTY constant.
 */
function empty(scheduler) {
    return scheduler ? emptyScheduled(scheduler) : exports.EMPTY;
}
exports.empty = empty;
function emptyScheduled(scheduler) {
    return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(function () { return subscriber.complete(); }); });
}
exports.emptyScheduled = emptyScheduled;

});

unwrapExports(empty_1);

var isScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isScheduler(value) {
    return value && typeof value.schedule === 'function';
}
exports.isScheduler = isScheduler;

});

unwrapExports(isScheduler_1);

var subscribeToArray$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Subscribes to an ArrayLike with a subscriber
 * @param array The array or array-like to subscribe to
 */
exports.subscribeToArray = function (array) { return function (subscriber) {
    for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) {
        subscriber.next(array[i]);
    }
    if (!subscriber.closed) {
        subscriber.complete();
    }
}; };

});

unwrapExports(subscribeToArray$1);

var fromArray_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function fromArray(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToArray$1.subscribeToArray(input));
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            var i = 0;
            sub.add(scheduler.schedule(function () {
                if (i === input.length) {
                    subscriber.complete();
                    return;
                }
                subscriber.next(input[i++]);
                if (!subscriber.closed) {
                    sub.add(this.schedule());
                }
            }));
            return sub;
        });
    }
}
exports.fromArray = fromArray;

});

unwrapExports(fromArray_1);

var scalar_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function scalar(value) {
    var result = new Observable_1.Observable(function (subscriber) {
        subscriber.next(value);
        subscriber.complete();
    });
    result._isScalar = true;
    result.value = value;
    return result;
}
exports.scalar = scalar;

});

unwrapExports(scalar_1);

var of_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function of() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var scheduler = args[args.length - 1];
    if (isScheduler_1.isScheduler(scheduler)) {
        args.pop();
    }
    else {
        scheduler = undefined;
    }
    switch (args.length) {
        case 0:
            return empty_1.empty(scheduler);
        case 1:
            return scheduler ? fromArray_1.fromArray(args, scheduler) : scalar_1.scalar(args[0]);
        default:
            return fromArray_1.fromArray(args, scheduler);
    }
}
exports.of = of;

});

unwrapExports(of_1);

var throwError_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Creates an Observable that emits no items to the Observer and immediately
 * emits an error notification.
 *
 * <span class="informal">Just emits 'error', and nothing else.
 * </span>
 *
 * <img src="./img/throw.png" width="100%">
 *
 * This static operator is useful for creating a simple Observable that only
 * emits the error notification. It can be used for composing with other
 * Observables, such as in a {@link mergeMap}.
 *
 * @example <caption>Emit the number 7, then emit an error.</caption>
 * import { throwError, concat, of } from 'rxjs/create';
 *
 * const result = concat(of(7), throwError(new Error('oops!')));
 * result.subscribe(x => console.log(x), e => console.error(e));
 *
 * @example <caption>Map and flatten numbers to the sequence 'a', 'b', 'c', but throw an error for 13</caption>
 * import { throwError, interval, of } from 'rxjs/create';
 * import { mergeMap } from 'rxjs/operators';
 *
 * interval(1000).pipe(
 *   mergeMap(x => x === 13 ?
 *     throwError('Thirteens are bad') :
 *     of('a', 'b', 'c')
 *   )
 * ).subscribe(x => console.log(x), e => console.error(e));
 *
 * @see {@link create}
 * @see {@link empty}
 * @see {@link never}
 * @see {@link of}
 *
 * @param {any} error The particular Error to pass to the error notification.
 * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
 * the emission of the error notification.
 * @return {Observable} An error Observable: emits only the error notification
 * using the given error argument.
 * @static true
 * @name throw
 * @owner Observable
 */
function throwError(error, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) { return subscriber.error(error); });
    }
    else {
        return new Observable_1.Observable(function (subscriber) { return scheduler.schedule(dispatch, 0, { error: error, subscriber: subscriber }); });
    }
}
exports.throwError = throwError;
function dispatch(_a) {
    var error = _a.error, subscriber = _a.subscriber;
    subscriber.error(error);
}

});

unwrapExports(throwError_1);

var Notification_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * Represents a push-based event or value that an {@link Observable} can emit.
 * This class is particularly useful for operators that manage notifications,
 * like {@link materialize}, {@link dematerialize}, {@link observeOn}, and
 * others. Besides wrapping the actual delivered value, it also annotates it
 * with metadata of, for instance, what type of push message it is (`next`,
 * `error`, or `complete`).
 *
 * @see {@link materialize}
 * @see {@link dematerialize}
 * @see {@link observeOn}
 *
 * @class Notification<T>
 */
var Notification = /** @class */ (function () {
    function Notification(kind, value, error) {
        this.kind = kind;
        this.value = value;
        this.error = error;
        this.hasValue = kind === 'N';
    }
    /**
     * Delivers to the given `observer` the value wrapped by this Notification.
     * @param {Observer} observer
     * @return
     */
    Notification.prototype.observe = function (observer) {
        switch (this.kind) {
            case 'N':
                return observer.next && observer.next(this.value);
            case 'E':
                return observer.error && observer.error(this.error);
            case 'C':
                return observer.complete && observer.complete();
        }
    };
    /**
     * Given some {@link Observer} callbacks, deliver the value represented by the
     * current Notification to the correctly corresponding callback.
     * @param {function(value: T): void} next An Observer `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.do = function (next, error, complete) {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return next && next(this.value);
            case 'E':
                return error && error(this.error);
            case 'C':
                return complete && complete();
        }
    };
    /**
     * Takes an Observer or its individual callback functions, and calls `observe`
     * or `do` methods accordingly.
     * @param {Observer|function(value: T): void} nextOrObserver An Observer or
     * the `next` callback.
     * @param {function(err: any): void} [error] An Observer `error` callback.
     * @param {function(): void} [complete] An Observer `complete` callback.
     * @return {any}
     */
    Notification.prototype.accept = function (nextOrObserver, error, complete) {
        if (nextOrObserver && typeof nextOrObserver.next === 'function') {
            return this.observe(nextOrObserver);
        }
        else {
            return this.do(nextOrObserver, error, complete);
        }
    };
    /**
     * Returns a simple Observable that just delivers the notification represented
     * by this Notification instance.
     * @return {any}
     */
    Notification.prototype.toObservable = function () {
        var kind = this.kind;
        switch (kind) {
            case 'N':
                return of_1.of(this.value);
            case 'E':
                return throwError_1.throwError(this.error);
            case 'C':
                return empty_1.empty();
        }
        throw new Error('unexpected notification kind value');
    };
    /**
     * A shortcut to create a Notification instance of the type `next` from a
     * given value.
     * @param {T} value The `next` value.
     * @return {Notification<T>} The "next" Notification representing the
     * argument.
     * @nocollapse
     */
    Notification.createNext = function (value) {
        if (typeof value !== 'undefined') {
            return new Notification('N', value);
        }
        return Notification.undefinedValueNotification;
    };
    /**
     * A shortcut to create a Notification instance of the type `error` from a
     * given error.
     * @param {any} [err] The `error` error.
     * @return {Notification<T>} The "error" Notification representing the
     * argument.
     * @nocollapse
     */
    Notification.createError = function (err) {
        return new Notification('E', undefined, err);
    };
    /**
     * A shortcut to create a Notification instance of the type `complete`.
     * @return {Notification<any>} The valueless "complete" Notification.
     * @nocollapse
     */
    Notification.createComplete = function () {
        return Notification.completeNotification;
    };
    Notification.completeNotification = new Notification('C');
    Notification.undefinedValueNotification = new Notification('N', undefined);
    return Notification;
}());
exports.Notification = Notification;

});

unwrapExports(Notification_1);

var observeOn_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


/**
 *
 * Re-emits all notifications from source Observable with specified scheduler.
 *
 * <span class="informal">Ensure a specific scheduler is used, from outside of an Observable.</span>
 *
 * `observeOn` is an operator that accepts a scheduler as a first parameter, which will be used to reschedule
 * notifications emitted by the source Observable. It might be useful, if you do not have control over
 * internal scheduler of a given Observable, but want to control when its values are emitted nevertheless.
 *
 * Returned Observable emits the same notifications (nexted values, complete and error events) as the source Observable,
 * but rescheduled with provided scheduler. Note that this doesn't mean that source Observables internal
 * scheduler will be replaced in any way. Original scheduler still will be used, but when the source Observable emits
 * notification, it will be immediately scheduled again - this time with scheduler passed to `observeOn`.
 * An anti-pattern would be calling `observeOn` on Observable that emits lots of values synchronously, to split
 * that emissions into asynchronous chunks. For this to happen, scheduler would have to be passed into the source
 * Observable directly (usually into the operator that creates it). `observeOn` simply delays notifications a
 * little bit more, to ensure that they are emitted at expected moments.
 *
 * As a matter of fact, `observeOn` accepts second parameter, which specifies in milliseconds with what delay notifications
 * will be emitted. The main difference between {@link delay} operator and `observeOn` is that `observeOn`
 * will delay all notifications - including error notifications - while `delay` will pass through error
 * from source Observable immediately when it is emitted. In general it is highly recommended to use `delay` operator
 * for any kind of delaying of values in the stream, while using `observeOn` to specify which scheduler should be used
 * for notification emissions in general.
 *
 * @example <caption>Ensure values in subscribe are called just before browser repaint.</caption>
 * const intervals = Rx.Observable.interval(10); // Intervals are scheduled
 *                                               // with async scheduler by default...
 *
 * intervals
 * .observeOn(Rx.Scheduler.animationFrame)       // ...but we will observe on animationFrame
 * .subscribe(val => {                           // scheduler to ensure smooth animation.
 *   someDiv.style.height = val + 'px';
 * });
 *
 * @see {@link delay}
 *
 * @param {SchedulerLike} scheduler Scheduler that will be used to reschedule notifications from source Observable.
 * @param {number} [delay] Number of milliseconds that states with what delay every notification should be rescheduled.
 * @return {Observable<T>} Observable that emits the same notifications as the source Observable,
 * but with provided scheduler.
 *
 * @method observeOn
 * @owner Observable
 */
function observeOn(scheduler, delay) {
    if (delay === void 0) { delay = 0; }
    return function observeOnOperatorFunction(source) {
        return source.lift(new ObserveOnOperator(scheduler, delay));
    };
}
exports.observeOn = observeOn;
var ObserveOnOperator = /** @class */ (function () {
    function ObserveOnOperator(scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        this.scheduler = scheduler;
        this.delay = delay;
    }
    ObserveOnOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ObserveOnSubscriber(subscriber, this.scheduler, this.delay));
    };
    return ObserveOnOperator;
}());
exports.ObserveOnOperator = ObserveOnOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ObserveOnSubscriber = /** @class */ (function (_super) {
    __extends(ObserveOnSubscriber, _super);
    function ObserveOnSubscriber(destination, scheduler, delay) {
        if (delay === void 0) { delay = 0; }
        var _this = _super.call(this, destination) || this;
        _this.scheduler = scheduler;
        _this.delay = delay;
        return _this;
    }
    /** @nocollapse */
    ObserveOnSubscriber.dispatch = function (arg) {
        var notification = arg.notification, destination = arg.destination;
        notification.observe(destination);
        this.unsubscribe();
    };
    ObserveOnSubscriber.prototype.scheduleMessage = function (notification) {
        this.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)));
    };
    ObserveOnSubscriber.prototype._next = function (value) {
        this.scheduleMessage(Notification_1.Notification.createNext(value));
    };
    ObserveOnSubscriber.prototype._error = function (err) {
        this.scheduleMessage(Notification_1.Notification.createError(err));
    };
    ObserveOnSubscriber.prototype._complete = function () {
        this.scheduleMessage(Notification_1.Notification.createComplete());
    };
    return ObserveOnSubscriber;
}(Subscriber_1.Subscriber));
exports.ObserveOnSubscriber = ObserveOnSubscriber;
var ObserveOnMessage = /** @class */ (function () {
    function ObserveOnMessage(notification, destination) {
        this.notification = notification;
        this.destination = destination;
    }
    return ObserveOnMessage;
}());
exports.ObserveOnMessage = ObserveOnMessage;

});

unwrapExports(observeOn_1);

var ReplaySubject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






/**
 * @class ReplaySubject<T>
 */
var ReplaySubject = /** @class */ (function (_super) {
    __extends(ReplaySubject, _super);
    function ReplaySubject(bufferSize, windowTime, scheduler) {
        if (bufferSize === void 0) { bufferSize = Number.POSITIVE_INFINITY; }
        if (windowTime === void 0) { windowTime = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this) || this;
        _this.scheduler = scheduler;
        _this._events = [];
        _this._infiniteTimeWindow = false;
        _this._bufferSize = bufferSize < 1 ? 1 : bufferSize;
        _this._windowTime = windowTime < 1 ? 1 : windowTime;
        if (windowTime === Number.POSITIVE_INFINITY) {
            _this._infiniteTimeWindow = true;
            _this.next = _this.nextInfiniteTimeWindow;
        }
        else {
            _this.next = _this.nextTimeWindow;
        }
        return _this;
    }
    ReplaySubject.prototype.nextInfiniteTimeWindow = function (value) {
        var _events = this._events;
        _events.push(value);
        // Since this method is invoked in every next() call than the buffer
        // can overgrow the max size only by one item
        if (_events.length > this._bufferSize) {
            _events.shift();
        }
        _super.prototype.next.call(this, value);
    };
    ReplaySubject.prototype.nextTimeWindow = function (value) {
        this._events.push(new ReplayEvent(this._getNow(), value));
        this._trimBufferThenGetEvents();
        _super.prototype.next.call(this, value);
    };
    /** @deprecated This is an internal implementation detail, do not use. */
    ReplaySubject.prototype._subscribe = function (subscriber) {
        // When `_infiniteTimeWindow === true` then the buffer is already trimmed
        var _infiniteTimeWindow = this._infiniteTimeWindow;
        var _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents();
        var scheduler = this.scheduler;
        var len = _events.length;
        var subscription;
        if (this.closed) {
            throw new ObjectUnsubscribedError_1.ObjectUnsubscribedError();
        }
        else if (this.isStopped || this.hasError) {
            subscription = Subscription_1.Subscription.EMPTY;
        }
        else {
            this.observers.push(subscriber);
            subscription = new SubjectSubscription_1.SubjectSubscription(this, subscriber);
        }
        if (scheduler) {
            subscriber.add(subscriber = new observeOn_1.ObserveOnSubscriber(subscriber, scheduler));
        }
        if (_infiniteTimeWindow) {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i]);
            }
        }
        else {
            for (var i = 0; i < len && !subscriber.closed; i++) {
                subscriber.next(_events[i].value);
            }
        }
        if (this.hasError) {
            subscriber.error(this.thrownError);
        }
        else if (this.isStopped) {
            subscriber.complete();
        }
        return subscription;
    };
    ReplaySubject.prototype._getNow = function () {
        return (this.scheduler || queue$1.queue).now();
    };
    ReplaySubject.prototype._trimBufferThenGetEvents = function () {
        var now = this._getNow();
        var _bufferSize = this._bufferSize;
        var _windowTime = this._windowTime;
        var _events = this._events;
        var eventsCount = _events.length;
        var spliceCount = 0;
        // Trim events that fall out of the time window.
        // Start at the front of the list. Break early once
        // we encounter an event that falls within the window.
        while (spliceCount < eventsCount) {
            if ((now - _events[spliceCount].time) < _windowTime) {
                break;
            }
            spliceCount++;
        }
        if (eventsCount > _bufferSize) {
            spliceCount = Math.max(spliceCount, eventsCount - _bufferSize);
        }
        if (spliceCount > 0) {
            _events.splice(0, spliceCount);
        }
        return _events;
    };
    return ReplaySubject;
}(Subject_1.Subject));
exports.ReplaySubject = ReplaySubject;
var ReplayEvent = /** @class */ (function () {
    function ReplayEvent(time, value) {
        this.time = time;
        this.value = value;
    }
    return ReplayEvent;
}());

});

unwrapExports(ReplaySubject_1);

var AsyncSubject_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * @class AsyncSubject<T>
 */
var AsyncSubject = /** @class */ (function (_super) {
    __extends(AsyncSubject, _super);
    function AsyncSubject() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this.value = null;
        _this.hasNext = false;
        _this.hasCompleted = false;
        return _this;
    }
    /** @deprecated This is an internal implementation detail, do not use. */
    AsyncSubject.prototype._subscribe = function (subscriber) {
        if (this.hasError) {
            subscriber.error(this.thrownError);
            return Subscription_1.Subscription.EMPTY;
        }
        else if (this.hasCompleted && this.hasNext) {
            subscriber.next(this.value);
            subscriber.complete();
            return Subscription_1.Subscription.EMPTY;
        }
        return _super.prototype._subscribe.call(this, subscriber);
    };
    AsyncSubject.prototype.next = function (value) {
        if (!this.hasCompleted) {
            this.value = value;
            this.hasNext = true;
        }
    };
    AsyncSubject.prototype.error = function (error) {
        if (!this.hasCompleted) {
            _super.prototype.error.call(this, error);
        }
    };
    AsyncSubject.prototype.complete = function () {
        this.hasCompleted = true;
        if (this.hasNext) {
            _super.prototype.next.call(this, this.value);
        }
        _super.prototype.complete.call(this);
    };
    return AsyncSubject;
}(Subject_1.Subject));
exports.AsyncSubject = AsyncSubject;

});

unwrapExports(AsyncSubject_1);

var Immediate$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var nextHandle = 1;
var tasksByHandle = {};
function runIfPresent(handle) {
    var cb = tasksByHandle[handle];
    if (cb) {
        cb();
    }
}
exports.Immediate = {
    setImmediate: function (cb) {
        var handle = nextHandle++;
        tasksByHandle[handle] = cb;
        Promise.resolve().then(function () { return runIfPresent(handle); });
        return handle;
    },
    clearImmediate: function (handle) {
        delete tasksByHandle[handle];
    },
};

});

unwrapExports(Immediate$1);

var AsapAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AsapAction = /** @class */ (function (_super) {
    __extends(AsapAction, _super);
    function AsapAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AsapAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If a microtask has already been scheduled, don't schedule another
        // one. If a microtask hasn't been scheduled yet, schedule one now. Return
        // the current scheduled microtask id.
        return scheduler.scheduled || (scheduler.scheduled = Immediate$1.Immediate.setImmediate(scheduler.flush.bind(scheduler, null)));
    };
    AsapAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested microtask and
        // set the scheduled flag to undefined so the next AsapAction will schedule
        // its own.
        if (scheduler.actions.length === 0) {
            Immediate$1.Immediate.clearImmediate(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AsapAction;
}(AsyncAction_1.AsyncAction));
exports.AsapAction = AsapAction;

});

unwrapExports(AsapAction_1);

var AsapScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AsapScheduler = /** @class */ (function (_super) {
    __extends(AsapScheduler, _super);
    function AsapScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AsapScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AsapScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AsapScheduler = AsapScheduler;

});

unwrapExports(AsapScheduler_1);

var asap$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/**
 *
 * Asap Scheduler
 *
 * <span class="informal">Perform task as fast as it can be performed asynchronously</span>
 *
 * `asap` scheduler behaves the same as {@link async} scheduler when you use it to delay task
 * in time. If however you set delay to `0`, `asap` will wait for current synchronously executing
 * code to end and then it will try to execute given task as fast as possible.
 *
 * `asap` scheduler will do its best to minimize time between end of currently executing code
 * and start of scheduled task. This makes it best candidate for performing so called "deferring".
 * Traditionally this was achieved by calling `setTimeout(deferredTask, 0)`, but that technique involves
 * some (although minimal) unwanted delay.
 *
 * Note that using `asap` scheduler does not necessarily mean that your task will be first to process
 * after currently executing code. In particular, if some task was also scheduled with `asap` before,
 * that task will execute first. That being said, if you need to schedule task asynchronously, but
 * as soon as possible, `asap` scheduler is your best bet.
 *
 * @example <caption>Compare async and asap scheduler</caption>
 *
 * Rx.Scheduler.async.schedule(() => console.log('async')); // scheduling 'async' first...
 * Rx.Scheduler.asap.schedule(() => console.log('asap'));
 *
 * // Logs:
 * // "asap"
 * // "async"
 * // ... but 'asap' goes first!
 *
 * @static true
 * @name asap
 * @owner Scheduler
 */
exports.asap = new AsapScheduler_1.AsapScheduler(AsapAction_1.AsapAction);

});

unwrapExports(asap$1);

var async$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/**
 *
 * Async Scheduler
 *
 * <span class="informal">Schedule task as if you used setTimeout(task, duration)</span>
 *
 * `async` scheduler schedules tasks asynchronously, by putting them on the JavaScript
 * event loop queue. It is best used to delay tasks in time or to schedule tasks repeating
 * in intervals.
 *
 * If you just want to "defer" task, that is to perform it right after currently
 * executing synchronous code ends (commonly achieved by `setTimeout(deferredTask, 0)`),
 * better choice will be the {@link asap} scheduler.
 *
 * @example <caption>Use async scheduler to delay task</caption>
 * const task = () => console.log('it works!');
 *
 * Rx.Scheduler.async.schedule(task, 2000);
 *
 * // After 2 seconds logs:
 * // "it works!"
 *
 *
 * @example <caption>Use async scheduler to repeat task in intervals</caption>
 * function task(state) {
 *   console.log(state);
 *   this.schedule(state + 1, 1000); // `this` references currently executing Action,
 *                                   // which we reschedule with new state and delay
 * }
 *
 * Rx.Scheduler.async.schedule(task, 3000, 0);
 *
 * // Logs:
 * // 0 after 3s
 * // 1 after 4s
 * // 2 after 5s
 * // 3 after 6s
 *
 * @static true
 * @name async
 * @owner Scheduler
 */
exports.async = new AsyncScheduler_1.AsyncScheduler(AsyncAction_1.AsyncAction);

});

unwrapExports(async$1);

var AnimationFrameAction_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var AnimationFrameAction = /** @class */ (function (_super) {
    __extends(AnimationFrameAction, _super);
    function AnimationFrameAction(scheduler, work) {
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        return _this;
    }
    AnimationFrameAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay is greater than 0, request as an async action.
        if (delay !== null && delay > 0) {
            return _super.prototype.requestAsyncId.call(this, scheduler, id, delay);
        }
        // Push the action to the end of the scheduler queue.
        scheduler.actions.push(this);
        // If an animation frame has already been requested, don't request another
        // one. If an animation frame hasn't been requested yet, request one. Return
        // the current animation frame request id.
        return scheduler.scheduled || (scheduler.scheduled = requestAnimationFrame(function () { return scheduler.flush(null); }));
    };
    AnimationFrameAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        // If delay exists and is greater than 0, or if the delay is null (the
        // action wasn't rescheduled) but was originally scheduled as an async
        // action, then recycle as an async action.
        if ((delay !== null && delay > 0) || (delay === null && this.delay > 0)) {
            return _super.prototype.recycleAsyncId.call(this, scheduler, id, delay);
        }
        // If the scheduler queue is empty, cancel the requested animation frame and
        // set the scheduled flag to undefined so the next AnimationFrameAction will
        // request its own.
        if (scheduler.actions.length === 0) {
            cancelAnimationFrame(id);
            scheduler.scheduled = undefined;
        }
        // Return undefined so the action knows to request a new async id if it's rescheduled.
        return undefined;
    };
    return AnimationFrameAction;
}(AsyncAction_1.AsyncAction));
exports.AnimationFrameAction = AnimationFrameAction;

});

unwrapExports(AnimationFrameAction_1);

var AnimationFrameScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

var AnimationFrameScheduler = /** @class */ (function (_super) {
    __extends(AnimationFrameScheduler, _super);
    function AnimationFrameScheduler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    AnimationFrameScheduler.prototype.flush = function (action) {
        this.active = true;
        this.scheduled = undefined;
        var actions = this.actions;
        var error;
        var index = -1;
        var count = actions.length;
        action = action || actions.shift();
        do {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        } while (++index < count && (action = actions.shift()));
        this.active = false;
        if (error) {
            while (++index < count && (action = actions.shift())) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    return AnimationFrameScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.AnimationFrameScheduler = AnimationFrameScheduler;

});

unwrapExports(AnimationFrameScheduler_1);

var animationFrame$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/**
 *
 * Animation Frame Scheduler
 *
 * <span class="informal">Perform task when `window.requestAnimationFrame` would fire</span>
 *
 * When `animationFrame` scheduler is used with delay, it will fall back to {@link async} scheduler
 * behaviour.
 *
 * Without delay, `animationFrame` scheduler can be used to create smooth browser animations.
 * It makes sure scheduled task will happen just before next browser content repaint,
 * thus performing animations as efficiently as possible.
 *
 * @example <caption>Schedule div height animation</caption>
 * const div = document.querySelector('.some-div');
 *
 * Rx.Scheduler.animationFrame.schedule(function(height) {
 *   div.style.height = height + "px";
 *
 *   this.schedule(height + 1);  // `this` references currently executing Action,
 *                               // which we reschedule with new state
 * }, 0, 0);
 *
 * // You will see .some-div element growing in height
 *
 *
 * @static true
 * @name animationFrame
 * @owner Scheduler
 */
exports.animationFrame = new AnimationFrameScheduler_1.AnimationFrameScheduler(AnimationFrameAction_1.AnimationFrameAction);

});

unwrapExports(animationFrame$1);

var VirtualTimeScheduler_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });


var VirtualTimeScheduler = /** @class */ (function (_super) {
    __extends(VirtualTimeScheduler, _super);
    function VirtualTimeScheduler(SchedulerAction, maxFrames) {
        if (SchedulerAction === void 0) { SchedulerAction = VirtualAction; }
        if (maxFrames === void 0) { maxFrames = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, SchedulerAction, function () { return _this.frame; }) || this;
        _this.maxFrames = maxFrames;
        _this.frame = 0;
        _this.index = -1;
        return _this;
    }
    /**
     * Prompt the Scheduler to execute all of its queued actions, therefore
     * clearing its queue.
     * @return {void}
     */
    VirtualTimeScheduler.prototype.flush = function () {
        var _a = this, actions = _a.actions, maxFrames = _a.maxFrames;
        var error, action;
        while ((action = actions.shift()) && (this.frame = action.delay) <= maxFrames) {
            if (error = action.execute(action.state, action.delay)) {
                break;
            }
        }
        if (error) {
            while (action = actions.shift()) {
                action.unsubscribe();
            }
            throw error;
        }
    };
    VirtualTimeScheduler.frameTimeFactor = 10;
    return VirtualTimeScheduler;
}(AsyncScheduler_1.AsyncScheduler));
exports.VirtualTimeScheduler = VirtualTimeScheduler;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var VirtualAction = /** @class */ (function (_super) {
    __extends(VirtualAction, _super);
    function VirtualAction(scheduler, work, index) {
        if (index === void 0) { index = scheduler.index += 1; }
        var _this = _super.call(this, scheduler, work) || this;
        _this.scheduler = scheduler;
        _this.work = work;
        _this.index = index;
        _this.active = true;
        _this.index = scheduler.index = index;
        return _this;
    }
    VirtualAction.prototype.schedule = function (state, delay) {
        if (delay === void 0) { delay = 0; }
        if (!this.id) {
            return _super.prototype.schedule.call(this, state, delay);
        }
        this.active = false;
        // If an action is rescheduled, we save allocations by mutating its state,
        // pushing it to the end of the scheduler queue, and recycling the action.
        // But since the VirtualTimeScheduler is used for testing, VirtualActions
        // must be immutable so they can be inspected later.
        var action = new VirtualAction(this.scheduler, this.work);
        this.add(action);
        return action.schedule(state, delay);
    };
    VirtualAction.prototype.requestAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        this.delay = scheduler.frame + delay;
        var actions = scheduler.actions;
        actions.push(this);
        actions.sort(VirtualAction.sortActions);
        return true;
    };
    VirtualAction.prototype.recycleAsyncId = function (scheduler, id, delay) {
        if (delay === void 0) { delay = 0; }
        return undefined;
    };
    VirtualAction.prototype._execute = function (state, delay) {
        if (this.active === true) {
            return _super.prototype._execute.call(this, state, delay);
        }
    };
    VirtualAction.sortActions = function (a, b) {
        if (a.delay === b.delay) {
            if (a.index === b.index) {
                return 0;
            }
            else if (a.index > b.index) {
                return 1;
            }
            else {
                return -1;
            }
        }
        else if (a.delay > b.delay) {
            return 1;
        }
        else {
            return -1;
        }
    };
    return VirtualAction;
}(AsyncAction_1.AsyncAction));
exports.VirtualAction = VirtualAction;

});

unwrapExports(VirtualTimeScheduler_1);

var identity_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function identity(x) {
    return x;
}
exports.identity = identity;

});

unwrapExports(identity_1);

var isObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Tests to see if the object is an RxJS {@link Observable}
 * @param obj the object to test
 */
function isObservable(obj) {
    return !!obj && (obj instanceof Observable_1.Observable || (typeof obj.lift === 'function' && typeof obj.subscribe === 'function'));
}
exports.isObservable = isObservable;

});

unwrapExports(isObservable_1);

var ArgumentOutOfRangeError_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An error thrown when an element was queried at a certain index of an
 * Observable, but no such index or position exists in that sequence.
 *
 * @see {@link elementAt}
 * @see {@link take}
 * @see {@link takeLast}
 *
 * @class ArgumentOutOfRangeError
 */
var ArgumentOutOfRangeError = /** @class */ (function (_super) {
    __extends(ArgumentOutOfRangeError, _super);
    function ArgumentOutOfRangeError() {
        var _this = _super.call(this, 'argument out of range') || this;
        _this.name = 'ArgumentOutOfRangeError';
        Object.setPrototypeOf(_this, ArgumentOutOfRangeError.prototype);
        return _this;
    }
    return ArgumentOutOfRangeError;
}(Error));
exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError;

});

unwrapExports(ArgumentOutOfRangeError_1);

var EmptyError_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An error thrown when an Observable or a sequence was queried but has no
 * elements.
 *
 * @see {@link first}
 * @see {@link last}
 * @see {@link single}
 *
 * @class EmptyError
 */
var EmptyError = /** @class */ (function (_super) {
    __extends(EmptyError, _super);
    function EmptyError() {
        var _this = _super.call(this, 'no elements in sequence') || this;
        _this.name = 'EmptyError';
        Object.setPrototypeOf(_this, EmptyError.prototype);
        return _this;
    }
    return EmptyError;
}(Error));
exports.EmptyError = EmptyError;

});

unwrapExports(EmptyError_1);

var TimeoutError_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * An error thrown when duetime elapses.
 *
 * @see {@link timeout}
 *
 * @class TimeoutError
 */
var TimeoutError = /** @class */ (function (_super) {
    __extends(TimeoutError, _super);
    function TimeoutError() {
        var _this = _super.call(this, 'Timeout has occurred') || this;
        _this.name = 'TimeoutError';
        Object.setPrototypeOf(_this, TimeoutError.prototype);
        return _this;
    }
    return TimeoutError;
}(Error));
exports.TimeoutError = TimeoutError;

});

unwrapExports(TimeoutError_1);

var map_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Applies a given `project` function to each value emitted by the source
 * Observable, and emits the resulting values as an Observable.
 *
 * <span class="informal">Like [Array.prototype.map()](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map),
 * it passes each source value through a transformation function to get
 * corresponding output values.</span>
 *
 * <img src="./img/map.png" width="100%">
 *
 * Similar to the well known `Array.prototype.map` function, this operator
 * applies a projection to each value and emits that projection in the output
 * Observable.
 *
 * @example <caption>Map every click to the clientX position of that click</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var positions = clicks.map(ev => ev.clientX);
 * positions.subscribe(x => console.log(x));
 *
 * @see {@link mapTo}
 * @see {@link pluck}
 *
 * @param {function(value: T, index: number): R} project The function to apply
 * to each `value` emitted by the source Observable. The `index` parameter is
 * the number `i` for the i-th emission that has happened since the
 * subscription, starting from the number `0`.
 * @param {any} [thisArg] An optional argument to define what `this` is in the
 * `project` function.
 * @return {Observable<R>} An Observable that emits the values from the source
 * Observable transformed by the given `project` function.
 * @method map
 * @owner Observable
 */
function map(project, thisArg) {
    return function mapOperation(source) {
        if (typeof project !== 'function') {
            throw new TypeError('argument is not a function. Are you looking for `mapTo()`?');
        }
        return source.lift(new MapOperator(project, thisArg));
    };
}
exports.map = map;
var MapOperator = /** @class */ (function () {
    function MapOperator(project, thisArg) {
        this.project = project;
        this.thisArg = thisArg;
    }
    MapOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg));
    };
    return MapOperator;
}());
exports.MapOperator = MapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MapSubscriber = /** @class */ (function (_super) {
    __extends(MapSubscriber, _super);
    function MapSubscriber(destination, project, thisArg) {
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.count = 0;
        _this.thisArg = thisArg || _this;
        return _this;
    }
    // NOTE: This looks unoptimized, but it's actually purposefully NOT
    // using try/catch optimizations.
    MapSubscriber.prototype._next = function (value) {
        var result;
        try {
            result = this.project.call(this.thisArg, value, this.count++);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return MapSubscriber;
}(Subscriber_1.Subscriber));

});

unwrapExports(map_1);

var bindCallback_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });





// tslint:enable:max-line-length
/**
 * Converts a callback API to a function that returns an Observable.
 *
 * <span class="informal">Give it a function `f` of type `f(x, callback)` and
 * it will return a function `g` that when called as `g(x)` will output an
 * Observable.</span>
 *
 * `bindCallback` is not an operator because its input and output are not
 * Observables. The input is a function `func` with some parameters, the
 * last parameter must be a callback function that `func` calls when it is
 * done.
 *
 * The output of `bindCallback` is a function that takes the same parameters
 * as `func`, except the last one (the callback). When the output function
 * is called with arguments it will return an Observable. If function `func`
 * calls its callback with one argument the Observable will emit that value.
 * If on the other hand the callback is called with multiple values the resulting
 * Observable will emit an array with said values as arguments.
 *
 * It is very important to remember that input function `func` is not called
 * when the output function is, but rather when the Observable returned by the output
 * function is subscribed. This means if `func` makes an AJAX request, that request
 * will be made every time someone subscribes to the resulting Observable, but not before.
 *
 * The last optional parameter - {@link Scheduler} - can be used to control when the call
 * to `func` happens after someone subscribes to Observable, as well as when results
 * passed to callback will be emitted. By default, the subscription to  an Observable calls `func`
 * synchronously, but using `Scheduler.async` as the last parameter will defer the call to `func`,
 * just like wrapping the call in `setTimeout` with a timeout of `0` would. If you use the async Scheduler
 * and call `subscribe` on the output Observable all function calls that are currently executing
 * will end before `func` is invoked.
 *
 * By default results passed to the callback are emitted immediately after `func` invokes the callback.
 * In particular, if the callback is called synchronously the subscription of the resulting Observable
 * will call the `next` function synchronously as well.  If you want to defer that call,
 * you may use `Scheduler.async` just as before.  This means that by using `Scheduler.async` you can
 * ensure that `func` always calls its callback asynchronously, thus avoiding terrifying Zalgo.
 *
 * Note that the Observable created by the output function will always emit a single value
 * and then complete immediately. If `func` calls the callback multiple times, values from subsequent
 * calls will not appear in the stream. If you need to listen for multiple calls,
 *  you probably want to use {@link fromEvent} or {@link fromEventPattern} instead.
 *
 * If `func` depends on some context (`this` property) and is not already bound the context of `func`
 * will be the context that the output function has at call time. In particular, if `func`
 * is called as a method of some objec and if `func` is not already bound, in order to preserve the context
 * it is recommended that the context of the output function is set to that object as well.
 *
 * If the input function calls its callback in the "node style" (i.e. first argument to callback is
 * optional error parameter signaling whether the call failed or not), {@link bindNodeCallback}
 * provides convenient error handling and probably is a better choice.
 * `bindCallback` will treat such functions the same as any other and error parameters
 * (whether passed or not) will always be interpreted as regular callback argument.
 *
 *
 * @example <caption>Convert jQuery's getJSON to an Observable API</caption>
 * // Suppose we have jQuery.getJSON('/my/url', callback)
 * var getJSONAsObservable = bindCallback(jQuery.getJSON);
 * var result = getJSONAsObservable('/my/url');
 * result.subscribe(x => console.log(x), e => console.error(e));
 *
 *
 * @example <caption>Receive an array of arguments passed to a callback</caption>
 * someFunction((a, b, c) => {
 *   console.log(a); // 5
 *   console.log(b); // 'some string'
 *   console.log(c); // {someProperty: 'someValue'}
 * });
 *
 * const boundSomeFunction = bindCallback(someFunction);
 * boundSomeFunction().subscribe(values => {
 *   console.log(values) // [5, 'some string', {someProperty: 'someValue'}]
 * });
 *
 *
 * @example <caption>Compare behaviour with and without async Scheduler</caption>
 * function iCallMyCallbackSynchronously(cb) {
 *   cb();
 * }
 *
 * const boundSyncFn = bindCallback(iCallMyCallbackSynchronously);
 * const boundAsyncFn = bindCallback(iCallMyCallbackSynchronously, null, Rx.Scheduler.async);
 *
 * boundSyncFn().subscribe(() => console.log('I was sync!'));
 * boundAsyncFn().subscribe(() => console.log('I was async!'));
 * console.log('This happened...');
 *
 * // Logs:
 * // I was sync!
 * // This happened...
 * // I was async!
 *
 *
 * @example <caption>Use bindCallback on an object method</caption>
 * const boundMethod = bindCallback(someObject.methodWithCallback);
 * boundMethod.call(someObject) // make sure methodWithCallback has access to someObject
 * .subscribe(subscriber);
 *
 *
 * @see {@link bindNodeCallback}
 * @see {@link from}
 * @see {@link fromPromise}
 *
 * @param {function} func A function with a callback as the last parameter.
 * @param {Scheduler} [scheduler] The scheduler on which to schedule the
 * callbacks.
 * @return {function(...params: *): Observable} A function which returns the
 * Observable that delivers the same values the callback would deliver.
 * @name bindCallback
 */
function bindCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            // DEPRECATED PATH
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var context = this;
        var subject;
        var params = {
            context: context,
            subject: subject,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
        };
        return new Observable_1.Observable(function (subscriber) {
            if (!scheduler) {
                if (!subject) {
                    subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        subject.error(err);
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                var state = {
                    args: args, subscriber: subscriber, params: params,
                };
                return scheduler.schedule(dispatch, 0, state);
            }
        });
    };
}
exports.bindCallback = bindCallback;
function dispatch(state) {
    var _this = this;
    var args = state.args, subscriber = state.subscriber, params = state.params;
    var callbackFunc = params.callbackFunc, context = params.context, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
            _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            subject.error(err);
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(state) {
    var value = state.value, subject = state.subject;
    subject.next(value);
    subject.complete();
}


});

unwrapExports(bindCallback_1);

var bindNodeCallback_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });





/**
 * Converts a Node.js-style callback API to a function that returns an
 * Observable.
 *
 * <span class="informal">It's just like {@link bindCallback}, but the
 * callback is expected to be of type `callback(error, result)`.</span>
 *
 * `bindNodeCallback` is not an operator because its input and output are not
 * Observables. The input is a function `func` with some parameters, but the
 * last parameter must be a callback function that `func` calls when it is
 * done. The callback function is expected to follow Node.js conventions,
 * where the first argument to the callback is an error object, signaling
 * whether call was successful. If that object is passed to callback, it means
 * something went wrong.
 *
 * The output of `bindNodeCallback` is a function that takes the same
 * parameters as `func`, except the last one (the callback). When the output
 * function is called with arguments, it will return an Observable.
 * If `func` calls its callback with error parameter present, Observable will
 * error with that value as well. If error parameter is not passed, Observable will emit
 * second parameter. If there are more parameters (third and so on),
 * Observable will emit an array with all arguments, except first error argument.
 *
 * Note that `func` will not be called at the same time output function is,
 * but rather whenever resulting Observable is subscribed. By default call to
 * `func` will happen synchronously after subscription, but that can be changed
 * with proper {@link Scheduler} provided as optional third parameter. Scheduler
 * can also control when values from callback will be emitted by Observable.
 * To find out more, check out documentation for {@link bindCallback}, where
 * Scheduler works exactly the same.
 *
 * As in {@link bindCallback}, context (`this` property) of input function will be set to context
 * of returned function, when it is called.
 *
 * After Observable emits value, it will complete immediately. This means
 * even if `func` calls callback again, values from second and consecutive
 * calls will never appear on the stream. If you need to handle functions
 * that call callbacks multiple times, check out {@link fromEvent} or
 * {@link fromEventPattern} instead.
 *
 * Note that `bindNodeCallback` can be used in non-Node.js environments as well.
 * "Node.js-style" callbacks are just a convention, so if you write for
 * browsers or any other environment and API you use implements that callback style,
 * `bindNodeCallback` can be safely used on that API functions as well.
 *
 * Remember that Error object passed to callback does not have to be an instance
 * of JavaScript built-in `Error` object. In fact, it does not even have to an object.
 * Error parameter of callback function is interpreted as "present", when value
 * of that parameter is truthy. It could be, for example, non-zero number, non-empty
 * string or boolean `true`. In all of these cases resulting Observable would error
 * with that value. This means usually regular style callbacks will fail very often when
 * `bindNodeCallback` is used. If your Observable errors much more often then you
 * would expect, check if callback really is called in Node.js-style and, if not,
 * switch to {@link bindCallback} instead.
 *
 * Note that even if error parameter is technically present in callback, but its value
 * is falsy, it still won't appear in array emitted by Observable.
 *
 *
 * @example <caption>Read a file from the filesystem and get the data as an Observable</caption>
 * import * as fs from 'fs';
 * var readFileAsObservable = bindNodeCallback(fs.readFile);
 * var result = readFileAsObservable('./roadNames.txt', 'utf8');
 * result.subscribe(x => console.log(x), e => console.error(e));
 *
 *
 * @example <caption>Use on function calling callback with multiple arguments</caption>
 * someFunction((err, a, b) => {
 *   console.log(err); // null
 *   console.log(a); // 5
 *   console.log(b); // "some string"
 * });
 * var boundSomeFunction = bindNodeCallback(someFunction);
 * boundSomeFunction()
 * .subscribe(value => {
 *   console.log(value); // [5, "some string"]
 * });
 *
 * @example <caption>Use on function calling callback in regular style</caption>
 * someFunction(a => {
 *   console.log(a); // 5
 * });
 * var boundSomeFunction = bindNodeCallback(someFunction);
 * boundSomeFunction()
 * .subscribe(
 *   value => {}             // never gets called
 *   err => console.log(err) // 5
 * );
 *
 *
 * @see {@link bindCallback}
 * @see {@link from}
 * @see {@link fromPromise}
 *
 * @param {function} func Function with a Node.js-style callback as the last parameter.
 * @param {Scheduler} [scheduler] The scheduler on which to schedule the
 * callbacks.
 * @return {function(...params: *): Observable} A function which returns the
 * Observable that delivers the same values the Node.js callback would
 * deliver.
 * @name bindNodeCallback
 */
function bindNodeCallback(callbackFunc, resultSelector, scheduler) {
    if (resultSelector) {
        if (isScheduler_1.isScheduler(resultSelector)) {
            scheduler = resultSelector;
        }
        else {
            // DEPRECATED PATH
            return function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                return bindNodeCallback(callbackFunc, scheduler).apply(void 0, args).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
            };
        }
    }
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var params = {
            subject: undefined,
            args: args,
            callbackFunc: callbackFunc,
            scheduler: scheduler,
            context: this,
        };
        return new Observable_1.Observable(function (subscriber) {
            var context = params.context;
            var subject = params.subject;
            if (!scheduler) {
                if (!subject) {
                    subject = params.subject = new AsyncSubject_1.AsyncSubject();
                    var handler = function () {
                        var innerArgs = [];
                        for (var _i = 0; _i < arguments.length; _i++) {
                            innerArgs[_i] = arguments[_i];
                        }
                        var err = innerArgs.shift();
                        if (err) {
                            subject.error(err);
                            return;
                        }
                        subject.next(innerArgs.length <= 1 ? innerArgs[0] : innerArgs);
                        subject.complete();
                    };
                    try {
                        callbackFunc.apply(context, args.concat([handler]));
                    }
                    catch (err) {
                        subject.error(err);
                    }
                }
                return subject.subscribe(subscriber);
            }
            else {
                return scheduler.schedule(dispatch, 0, { params: params, subscriber: subscriber, context: context });
            }
        });
    };
}
exports.bindNodeCallback = bindNodeCallback;
function dispatch(state) {
    var _this = this;
    var params = state.params, subscriber = state.subscriber, context = state.context;
    var callbackFunc = params.callbackFunc, args = params.args, scheduler = params.scheduler;
    var subject = params.subject;
    if (!subject) {
        subject = params.subject = new AsyncSubject_1.AsyncSubject();
        var handler = function () {
            var innerArgs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                innerArgs[_i] = arguments[_i];
            }
            var err = innerArgs.shift();
            if (err) {
                _this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
            }
            else {
                var value = innerArgs.length <= 1 ? innerArgs[0] : innerArgs;
                _this.add(scheduler.schedule(dispatchNext, 0, { value: value, subject: subject }));
            }
        };
        try {
            callbackFunc.apply(context, args.concat([handler]));
        }
        catch (err) {
            this.add(scheduler.schedule(dispatchError, 0, { err: err, subject: subject }));
        }
    }
    this.add(subject.subscribe(subscriber));
}
function dispatchNext(arg) {
    var value = arg.value, subject = arg.subject;
    subject.next(value);
    subject.complete();
}
function dispatchError(arg) {
    var err = arg.err, subject = arg.subject;
    subject.error(err);
}

});

unwrapExports(bindNodeCallback_1);

var OuterSubscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var OuterSubscriber = /** @class */ (function (_super) {
    __extends(OuterSubscriber, _super);
    function OuterSubscriber() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    OuterSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    OuterSubscriber.prototype.notifyError = function (error, innerSub) {
        this.destination.error(error);
    };
    OuterSubscriber.prototype.notifyComplete = function (innerSub) {
        this.destination.complete();
    };
    return OuterSubscriber;
}(Subscriber_1.Subscriber));
exports.OuterSubscriber = OuterSubscriber;

});

unwrapExports(OuterSubscriber_1);

var InnerSubscriber_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var InnerSubscriber = /** @class */ (function (_super) {
    __extends(InnerSubscriber, _super);
    function InnerSubscriber(parent, outerValue, outerIndex) {
        var _this = _super.call(this) || this;
        _this.parent = parent;
        _this.outerValue = outerValue;
        _this.outerIndex = outerIndex;
        _this.index = 0;
        return _this;
    }
    InnerSubscriber.prototype._next = function (value) {
        this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this);
    };
    InnerSubscriber.prototype._error = function (error) {
        this.parent.notifyError(error, this);
        this.unsubscribe();
    };
    InnerSubscriber.prototype._complete = function () {
        this.parent.notifyComplete(this);
        this.unsubscribe();
    };
    return InnerSubscriber;
}(Subscriber_1.Subscriber));
exports.InnerSubscriber = InnerSubscriber;

});

unwrapExports(InnerSubscriber_1);

var subscribeToPromise$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.subscribeToPromise = function (promise) { return function (subscriber) {
    promise.then(function (value) {
        if (!subscriber.closed) {
            subscriber.next(value);
            subscriber.complete();
        }
    }, function (err) { return subscriber.error(err); })
        .then(null, hostReportError_1.hostReportError);
    return subscriber;
}; };

});

unwrapExports(subscribeToPromise$1);

var iterator$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function getSymbolIterator() {
    if (typeof Symbol !== 'function' || !Symbol.iterator) {
        return '@@iterator';
    }
    return Symbol.iterator;
}
exports.getSymbolIterator = getSymbolIterator;
exports.iterator = getSymbolIterator();
/**
 * @deprecated use {@link iterator} instead
 */
exports.$$iterator = exports.iterator;

});

unwrapExports(iterator$1);

var subscribeToIterable$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

exports.subscribeToIterable = function (iterable) { return function (subscriber) {
    var iterator = iterable[iterator$1.iterator]();
    do {
        var item = iterator.next();
        if (item.done) {
            subscriber.complete();
            break;
        }
        subscriber.next(item.value);
        if (subscriber.closed) {
            break;
        }
    } while (true);
    // Finalize the iterator if it happens to be a Generator
    if (typeof iterator.return === 'function') {
        subscriber.add(function () {
            if (iterator.return) {
                iterator.return();
            }
        });
    }
    return subscriber;
}; };

});

unwrapExports(subscribeToIterable$1);

var subscribeToObservable$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Subscribes to an object that implements Symbol.observable with the given
 * Subscriber.
 * @param obj An object that implements Symbol.observable
 */
exports.subscribeToObservable = function (obj) { return function (subscriber) {
    var obs = obj[observable$1.observable]();
    if (typeof obs.subscribe !== 'function') {
        // Should be caught by observable subscribe function error handling.
        throw new TypeError('Provided object does not correctly implement Symbol.observable');
    }
    else {
        return obs.subscribe(subscriber);
    }
}; };

});

unwrapExports(subscribeToObservable$1);

var isArrayLike$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isArrayLike = (function (x) { return x && typeof x.length === 'number' && typeof x !== 'function'; });

});

unwrapExports(isArrayLike$1);

var isPromise_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function isPromise(value) {
    return value && typeof value.subscribe !== 'function' && typeof value.then === 'function';
}
exports.isPromise = isPromise;

});

unwrapExports(isPromise_1);

var subscribeTo$1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });










exports.subscribeTo = function (result) {
    if (result instanceof Observable_1.Observable) {
        return function (subscriber) {
            if (result._isScalar) {
                subscriber.next(result.value);
                subscriber.complete();
                return undefined;
            }
            else {
                return result.subscribe(subscriber);
            }
        };
    }
    else if (isArrayLike$1.isArrayLike(result)) {
        return subscribeToArray$1.subscribeToArray(result);
    }
    else if (isPromise_1.isPromise(result)) {
        return subscribeToPromise$1.subscribeToPromise(result);
    }
    else if (result && typeof result[iterator$1.iterator] === 'function') {
        return subscribeToIterable$1.subscribeToIterable(result);
    }
    else if (result && typeof result[observable$1.observable] === 'function') {
        return subscribeToObservable$1.subscribeToObservable(result);
    }
    else {
        var value = isObject_1.isObject(result) ? 'an invalid object' : "'" + result + "'";
        var msg = "You provided " + value + " where a stream was expected."
            + ' You can provide an Observable, Promise, Array, or Iterable.';
        throw new TypeError(msg);
    }
};

});

unwrapExports(subscribeTo$1);

var subscribeToResult_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


function subscribeToResult(outerSubscriber, result, outerValue, outerIndex) {
    var destination = new InnerSubscriber_1.InnerSubscriber(outerSubscriber, outerValue, outerIndex);
    return subscribeTo$1.subscribeTo(result)(destination);
}
exports.subscribeToResult = subscribeToResult;

});

unwrapExports(subscribeToResult_1);

var combineLatest_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });





var NONE = {};
/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are
 * calculated from the latest values of each of its input Observables.
 *
 * <span class="informal">Whenever any input Observable emits a value, it
 * computes a formula using the latest values from all the inputs, then emits
 * the output of that formula.</span>
 *
 * <img src="./img/combineLatest.png" width="100%">
 *
 * `combineLatest` combines the values from all the Observables passed as
 * arguments. This is done by subscribing to each Observable in order and,
 * whenever any Observable emits, collecting an array of the most recent
 * values from each Observable. So if you pass `n` Observables to operator,
 * returned Observable will always emit an array of `n` values, in order
 * corresponding to order of passed Observables (value from the first Observable
 * on the first place and so on).
 *
 * Static version of `combineLatest` accepts either an array of Observables
 * or each Observable can be put directly as an argument. Note that array of
 * Observables is good choice, if you don't know beforehand how many Observables
 * you will combine. Passing empty array will result in Observable that
 * completes immediately.
 *
 * To ensure output array has always the same length, `combineLatest` will
 * actually wait for all input Observables to emit at least once,
 * before it starts emitting results. This means if some Observable emits
 * values before other Observables started emitting, all that values but last
 * will be lost. On the other hand, is some Observable does not emit value but
 * completes, resulting Observable will complete at the same moment without
 * emitting anything, since it will be now impossible to include value from
 * completed Observable in resulting array. Also, if some input Observable does
 * not emit any value and never completes, `combineLatest` will also never emit
 * and never complete, since, again, it will wait for all streams to emit some
 * value.
 *
 * If at least one Observable was passed to `combineLatest` and all passed Observables
 * emitted something, resulting Observable will complete when all combined
 * streams complete. So even if some Observable completes, result of
 * `combineLatest` will still emit values when other Observables do. In case
 * of completed Observable, its value from now on will always be the last
 * emitted value. On the other hand, if any Observable errors, `combineLatest`
 * will error immediately as well, and all other Observables will be unsubscribed.
 *
 * `combineLatest` accepts as optional parameter `project` function, which takes
 * as arguments all values that would normally be emitted by resulting Observable.
 * `project` can return any kind of value, which will be then emitted by Observable
 * instead of default array. Note that `project` does not take as argument that array
 * of values, but values themselves. That means default `project` can be imagined
 * as function that takes all its arguments and puts them into an array.
 *
 *
 * @example <caption>Combine two timer Observables</caption>
 * const firstTimer = Rx.Observable.timer(0, 1000); // emit 0, 1, 2... after every second, starting from now
 * const secondTimer = Rx.Observable.timer(500, 1000); // emit 0, 1, 2... after every second, starting 0,5s from now
 * const combinedTimers = Rx.Observable.combineLatest(firstTimer, secondTimer);
 * combinedTimers.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0] after 0.5s
 * // [1, 0] after 1s
 * // [1, 1] after 1.5s
 * // [2, 1] after 2s
 *
 *
 * @example <caption>Combine an array of Observables</caption>
 * const observables = [1, 5, 10].map(
 *   n => Rx.Observable.of(n).delay(n * 1000).startWith(0) // emit 0 and then emit n after n seconds
 * );
 * const combined = Rx.Observable.combineLatest(observables);
 * combined.subscribe(value => console.log(value));
 * // Logs
 * // [0, 0, 0] immediately
 * // [1, 0, 0] after 1s
 * // [1, 5, 0] after 5s
 * // [1, 5, 10] after 10s
 *
 *
 * @example <caption>Use project function to dynamically calculate the Body-Mass Index</caption>
 * var weight = Rx.Observable.of(70, 72, 76, 79, 75);
 * var height = Rx.Observable.of(1.76, 1.77, 1.78);
 * var bmi = Rx.Observable.combineLatest(weight, height, (w, h) => w / (h * h));
 * bmi.subscribe(x => console.log('BMI is ' + x));
 *
 * // With output to console:
 * // BMI is 24.212293388429753
 * // BMI is 23.93948099205209
 * // BMI is 23.671253629592222
 *
 *
 * @see {@link combineAll}
 * @see {@link merge}
 * @see {@link withLatestFrom}
 *
 * @param {ObservableInput} observable1 An input Observable to combine with other Observables.
 * @param {ObservableInput} observable2 An input Observable to combine with other Observables.
 * More than one input Observables may be given as arguments
 * or an array of Observables may be given as the first argument.
 * @param {function} [project] An optional function to project the values from
 * the combined latest values into a new value on the output Observable.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for subscribing to
 * each input Observable.
 * @return {Observable} An Observable of projected values from the most recent
 * values from each input Observable, or an array of the most recent values from
 * each input Observable.
 */
function combineLatest() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = null;
    var scheduler = null;
    if (isScheduler_1.isScheduler(observables[observables.length - 1])) {
        scheduler = observables.pop();
    }
    if (typeof observables[observables.length - 1] === 'function') {
        resultSelector = observables.pop();
    }
    // if the first and only other argument besides the resultSelector is an array
    // assume it's been called with `combineLatest([obs1, obs2, obs3], resultSelector)`
    if (observables.length === 1 && isArray$1.isArray(observables[0])) {
        observables = observables[0];
    }
    return fromArray_1.fromArray(observables, scheduler).lift(new CombineLatestOperator(resultSelector));
}
exports.combineLatest = combineLatest;
var CombineLatestOperator = /** @class */ (function () {
    function CombineLatestOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    CombineLatestOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new CombineLatestSubscriber(subscriber, this.resultSelector));
    };
    return CombineLatestOperator;
}());
exports.CombineLatestOperator = CombineLatestOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var CombineLatestSubscriber = /** @class */ (function (_super) {
    __extends(CombineLatestSubscriber, _super);
    function CombineLatestSubscriber(destination, resultSelector) {
        var _this = _super.call(this, destination) || this;
        _this.resultSelector = resultSelector;
        _this.active = 0;
        _this.values = [];
        _this.observables = [];
        return _this;
    }
    CombineLatestSubscriber.prototype._next = function (observable) {
        this.values.push(NONE);
        this.observables.push(observable);
    };
    CombineLatestSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            this.active = len;
            this.toRespond = len;
            for (var i = 0; i < len; i++) {
                var observable = observables[i];
                this.add(subscribeToResult_1.subscribeToResult(this, observable, observable, i));
            }
        }
    };
    CombineLatestSubscriber.prototype.notifyComplete = function (unused) {
        if ((this.active -= 1) === 0) {
            this.destination.complete();
        }
    };
    CombineLatestSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        var values = this.values;
        var oldVal = values[outerIndex];
        var toRespond = !this.toRespond
            ? 0
            : oldVal === NONE ? --this.toRespond : this.toRespond;
        values[outerIndex] = innerValue;
        if (toRespond === 0) {
            if (this.resultSelector) {
                this._tryResultSelector(values);
            }
            else {
                this.destination.next(values.slice());
            }
        }
    };
    CombineLatestSubscriber.prototype._tryResultSelector = function (values) {
        var result;
        try {
            result = this.resultSelector.apply(this, values);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return CombineLatestSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.CombineLatestSubscriber = CombineLatestSubscriber;

});

unwrapExports(combineLatest_1);

var isInteropObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/** Identifies an input as being Observable (but not necessary an Rx Observable) */
function isInteropObservable(input) {
    return input && typeof input[observable$1.observable] === 'function';
}
exports.isInteropObservable = isInteropObservable;

});

unwrapExports(isInteropObservable_1);

var isIterable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/** Identifies an input as being an Iterable */
function isIterable(input) {
    return input && typeof input[iterator$1.iterator] === 'function';
}
exports.isIterable = isIterable;

});

unwrapExports(isIterable_1);

var fromPromise_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function fromPromise(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToPromise$1.subscribeToPromise(input));
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            sub.add(scheduler.schedule(function () { return input.then(function (value) {
                sub.add(scheduler.schedule(function () {
                    subscriber.next(value);
                    sub.add(scheduler.schedule(function () { return subscriber.complete(); }));
                }));
            }, function (err) {
                sub.add(scheduler.schedule(function () { return subscriber.error(err); }));
            }); }));
            return sub;
        });
    }
}
exports.fromPromise = fromPromise;

});

unwrapExports(fromPromise_1);

var fromIterable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function fromIterable(input, scheduler) {
    if (!input) {
        throw new Error('Iterable cannot be null');
    }
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToIterable$1.subscribeToIterable(input));
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            var iterator;
            sub.add(function () {
                // Finalize generators
                if (iterator && typeof iterator.return === 'function') {
                    iterator.return();
                }
            });
            sub.add(scheduler.schedule(function () {
                iterator = input[iterator$1.iterator]();
                sub.add(scheduler.schedule(function () {
                    if (subscriber.closed) {
                        return;
                    }
                    var value;
                    var done;
                    try {
                        var result = iterator.next();
                        value = result.value;
                        done = result.done;
                    }
                    catch (err) {
                        subscriber.error(err);
                        return;
                    }
                    if (done) {
                        subscriber.complete();
                    }
                    else {
                        subscriber.next(value);
                        this.schedule();
                    }
                }));
            }));
            return sub;
        });
    }
}
exports.fromIterable = fromIterable;

});

unwrapExports(fromIterable_1);

var fromObservable_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function fromObservable(input, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(subscribeToObservable$1.subscribeToObservable(input));
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var sub = new Subscription_1.Subscription();
            sub.add(scheduler.schedule(function () {
                var observable = input[observable$1.observable]();
                sub.add(observable.subscribe({
                    next: function (value) { sub.add(scheduler.schedule(function () { return subscriber.next(value); })); },
                    error: function (err) { sub.add(scheduler.schedule(function () { return subscriber.error(err); })); },
                    complete: function () { sub.add(scheduler.schedule(function () { return subscriber.complete(); })); },
                }));
            }));
            return sub;
        });
    }
}
exports.fromObservable = fromObservable;

});

unwrapExports(fromObservable_1);

var from_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });










function from(input, scheduler) {
    if (!scheduler) {
        if (input instanceof Observable_1.Observable) {
            return input;
        }
        return new Observable_1.Observable(subscribeTo$1.subscribeTo(input));
    }
    if (input != null) {
        if (isInteropObservable_1.isInteropObservable(input)) {
            return fromObservable_1.fromObservable(input, scheduler);
        }
        else if (isPromise_1.isPromise(input)) {
            return fromPromise_1.fromPromise(input, scheduler);
        }
        else if (isArrayLike$1.isArrayLike(input)) {
            return fromArray_1.fromArray(input, scheduler);
        }
        else if (isIterable_1.isIterable(input) || typeof input === 'string') {
            return fromIterable_1.fromIterable(input, scheduler);
        }
    }
    throw new TypeError((input !== null && typeof input || input) + ' is not observable');
}
exports.from = from;

});

unwrapExports(from_1);

var mergeMap_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });




/* tslint:enable:max-line-length */
/**
 * Projects each source value to an Observable which is merged in the output
 * Observable.
 *
 * <span class="informal">Maps each value to an Observable, then flattens all of
 * these inner Observables using {@link mergeAll}.</span>
 *
 * <img src="./img/mergeMap.png" width="100%">
 *
 * Returns an Observable that emits items based on applying a function that you
 * supply to each item emitted by the source Observable, where that function
 * returns an Observable, and then merging those resulting Observables and
 * emitting the results of this merger.
 *
 * @example <caption>Map and flatten each letter to an Observable ticking every 1 second</caption>
 * var letters = Rx.Observable.of('a', 'b', 'c');
 * var result = letters.mergeMap(x =>
 *   Rx.Observable.interval(1000).map(i => x+i)
 * );
 * result.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // a0
 * // b0
 * // c0
 * // a1
 * // b1
 * // c1
 * // continues to list a,b,c with respective ascending integers
 *
 * @see {@link concatMap}
 * @see {@link exhaustMap}
 * @see {@link merge}
 * @see {@link mergeAll}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switchMap}
 *
 * @param {function(value: T, ?index: number): ObservableInput} project A function
 * that, when applied to an item emitted by the source Observable, returns an
 * Observable.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits the result of applying the
 * projection function (and the optional `resultSelector`) to each item emitted
 * by the source Observable and merging the results of the Observables obtained
 * from this transformation.
 * @method mergeMap
 * @owner Observable
 */
function mergeMap(project, resultSelector, concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    if (typeof resultSelector === 'function') {
        // DEPRECATED PATH
        return function (source) { return source.pipe(mergeMap(function (a, i) { return from_1.from(project(a, i)).pipe(map_1.map(function (b, ii) { return resultSelector(a, b, i, ii); })); }, concurrent)); };
    }
    else if (typeof resultSelector === 'number') {
        concurrent = resultSelector;
    }
    return function (source) { return source.lift(new MergeMapOperator(project, concurrent)); };
}
exports.mergeMap = mergeMap;
var MergeMapOperator = /** @class */ (function () {
    function MergeMapOperator(project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        this.project = project;
        this.concurrent = concurrent;
    }
    MergeMapOperator.prototype.call = function (observer, source) {
        return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent));
    };
    return MergeMapOperator;
}());
exports.MergeMapOperator = MergeMapOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var MergeMapSubscriber = /** @class */ (function (_super) {
    __extends(MergeMapSubscriber, _super);
    function MergeMapSubscriber(destination, project, concurrent) {
        if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
        var _this = _super.call(this, destination) || this;
        _this.project = project;
        _this.concurrent = concurrent;
        _this.hasCompleted = false;
        _this.buffer = [];
        _this.active = 0;
        _this.index = 0;
        return _this;
    }
    MergeMapSubscriber.prototype._next = function (value) {
        if (this.active < this.concurrent) {
            this._tryNext(value);
        }
        else {
            this.buffer.push(value);
        }
    };
    MergeMapSubscriber.prototype._tryNext = function (value) {
        var result;
        var index = this.index++;
        try {
            result = this.project(value, index);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.active++;
        this._innerSub(result, value, index);
    };
    MergeMapSubscriber.prototype._innerSub = function (ish, value, index) {
        this.add(subscribeToResult_1.subscribeToResult(this, ish, value, index));
    };
    MergeMapSubscriber.prototype._complete = function () {
        this.hasCompleted = true;
        if (this.active === 0 && this.buffer.length === 0) {
            this.destination.complete();
        }
    };
    MergeMapSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.destination.next(innerValue);
    };
    MergeMapSubscriber.prototype.notifyComplete = function (innerSub) {
        var buffer = this.buffer;
        this.remove(innerSub);
        this.active--;
        if (buffer.length > 0) {
            this._next(buffer.shift());
        }
        else if (this.active === 0 && this.hasCompleted) {
            this.destination.complete();
        }
    };
    return MergeMapSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.MergeMapSubscriber = MergeMapSubscriber;

});

unwrapExports(mergeMap_1);

var mergeAll_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Converts a higher-order Observable into a first-order Observable which
 * concurrently delivers all values that are emitted on the inner Observables.
 *
 * <span class="informal">Flattens an Observable-of-Observables.</span>
 *
 * <img src="./img/mergeAll.png" width="100%">
 *
 * `mergeAll` subscribes to an Observable that emits Observables, also known as
 * a higher-order Observable. Each time it observes one of these emitted inner
 * Observables, it subscribes to that and delivers all the values from the
 * inner Observable on the output Observable. The output Observable only
 * completes once all inner Observables have completed. Any error delivered by
 * a inner Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Spawn a new interval Observable for each click event, and blend their outputs as one Observable</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000));
 * var firstOrder = higherOrder.mergeAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * @example <caption>Count from 0 to 9 every second for each click, but only allow 2 concurrent timers</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map((ev) => Rx.Observable.interval(1000).take(10));
 * var firstOrder = higherOrder.mergeAll(2);
 * firstOrder.subscribe(x => console.log(x));
 *
 * @see {@link combineAll}
 * @see {@link concatAll}
 * @see {@link exhaust}
 * @see {@link merge}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of inner
 * Observables being subscribed to concurrently.
 * @return {Observable} An Observable that emits values coming from all the
 * inner Observables emitted by the source Observable.
 * @method mergeAll
 * @owner Observable
 */
function mergeAll(concurrent) {
    if (concurrent === void 0) { concurrent = Number.POSITIVE_INFINITY; }
    return mergeMap_1.mergeMap(identity_1.identity, concurrent);
}
exports.mergeAll = mergeAll;

});

unwrapExports(mergeAll_1);

var concatAll_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Converts a higher-order Observable into a first-order Observable by
 * concatenating the inner Observables in order.
 *
 * <span class="informal">Flattens an Observable-of-Observables by putting one
 * inner Observable after the other.</span>
 *
 * <img src="./img/concatAll.png" width="100%">
 *
 * Joins every Observable emitted by the source (a higher-order Observable), in
 * a serial fashion. It subscribes to each inner Observable only after the
 * previous inner Observable has completed, and merges all of their values into
 * the returned observable.
 *
 * __Warning:__ If the source Observable emits Observables quickly and
 * endlessly, and the inner Observables it emits generally complete slower than
 * the source emits, you can run into memory issues as the incoming Observables
 * collect in an unbounded buffer.
 *
 * Note: `concatAll` is equivalent to `mergeAll` with concurrency parameter set
 * to `1`.
 *
 * @example <caption>For each click event, tick every second from 0 to 3, with no concurrency</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var higherOrder = clicks.map(ev => Rx.Observable.interval(1000).take(4));
 * var firstOrder = higherOrder.concatAll();
 * firstOrder.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // (results are not concurrent)
 * // For every click on the "document" it will emit values 0 to 3 spaced
 * // on a 1000ms interval
 * // one click = 1000ms-> 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3
 *
 * @see {@link combineAll}
 * @see {@link concat}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 * @see {@link exhaust}
 * @see {@link mergeAll}
 * @see {@link switch}
 * @see {@link zipAll}
 *
 * @return {Observable} An Observable emitting values from all the inner
 * Observables concatenated.
 * @method concatAll
 * @owner Observable
 */
function concatAll() {
    return mergeAll_1.mergeAll(1);
}
exports.concatAll = concatAll;

});

unwrapExports(concatAll_1);

var concat_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which sequentially emits all values from given
 * Observable and then moves on to the next.
 *
 * <span class="informal">Concatenates multiple Observables together by
 * sequentially emitting their values, one Observable after the other.</span>
 *
 * <img src="./img/concat.png" width="100%">
 *
 * `concat` joins multiple Observables together, by subscribing to them one at a time and
 * merging their results into the output Observable. You can pass either an array of
 * Observables, or put them directly as arguments. Passing an empty array will result
 * in Observable that completes immediately.
 *
 * `concat` will subscribe to first input Observable and emit all its values, without
 * changing or affecting them in any way. When that Observable completes, it will
 * subscribe to then next Observable passed and, again, emit its values. This will be
 * repeated, until the operator runs out of Observables. When last input Observable completes,
 * `concat` will complete as well. At any given moment only one Observable passed to operator
 * emits values. If you would like to emit values from passed Observables concurrently, check out
 * {@link merge} instead, especially with optional `concurrent` parameter. As a matter of fact,
 * `concat` is an equivalent of `merge` operator with `concurrent` parameter set to `1`.
 *
 * Note that if some input Observable never completes, `concat` will also never complete
 * and Observables following the one that did not complete will never be subscribed. On the other
 * hand, if some Observable simply completes immediately after it is subscribed, it will be
 * invisible for `concat`, which will just move on to the next Observable.
 *
 * If any Observable in chain errors, instead of passing control to the next Observable,
 * `concat` will error immediately as well. Observables that would be subscribed after
 * the one that emitted error, never will.
 *
 * If you pass to `concat` the same Observable many times, its stream of values
 * will be "replayed" on every subscription, which means you can repeat given Observable
 * as many times as you like. If passing the same Observable to `concat` 1000 times becomes tedious,
 * you can always use {@link repeat}.
 *
 * @example <caption>Concatenate a timer counting from 0 to 3 with a synchronous sequence from 1 to 10</caption>
 * var timer = Rx.Observable.interval(1000).take(4);
 * var sequence = Rx.Observable.range(1, 10);
 * var result = Rx.Observable.concat(timer, sequence);
 * result.subscribe(x => console.log(x));
 *
 * // results in:
 * // 0 -1000ms-> 1 -1000ms-> 2 -1000ms-> 3 -immediate-> 1 ... 10
 *
 *
 * @example <caption>Concatenate an array of 3 Observables</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var result = Rx.Observable.concat([timer1, timer2, timer3]); // note that array is passed
 * result.subscribe(x => console.log(x));
 *
 * // results in the following:
 * // (Prints to console sequentially)
 * // -1000ms-> 0 -1000ms-> 1 -1000ms-> ... 9
 * // -2000ms-> 0 -2000ms-> 1 -2000ms-> ... 5
 * // -500ms-> 0 -500ms-> 1 -500ms-> ... 9
 *
 *
 * @example <caption>Concatenate the same Observable to repeat it</caption>
 * const timer = Rx.Observable.interval(1000).take(2);
 *
 * Rx.Observable.concat(timer, timer) // concating the same Observable!
 * .subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('...and it is done!')
 * );
 *
 * // Logs:
 * // 0 after 1s
 * // 1 after 2s
 * // 0 after 3s
 * // 1 after 4s
 * // "...and it is done!" also after 4s
 *
 * @see {@link concatAll}
 * @see {@link concatMap}
 * @see {@link concatMapTo}
 *
 * @param {ObservableInput} input1 An input Observable to concatenate with others.
 * @param {ObservableInput} input2 An input Observable to concatenate with others.
 * More than one input Observables may be given as argument.
 * @param {Scheduler} [scheduler=null] An optional IScheduler to schedule each
 * Observable subscription on.
 * @return {Observable} All values of each passed Observable merged into a
 * single Observable, in order, in serial fashion.
 * @static true
 * @name concat
 * @owner Observable
 */
function concat() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    if (observables.length === 1 || (observables.length === 2 && isScheduler_1.isScheduler(observables[1]))) {
        return from_1.from(observables[0]);
    }
    return concatAll_1.concatAll()(of_1.of.apply(void 0, observables));
}
exports.concat = concat;

});

unwrapExports(concat_1);

var defer_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

 // lol

/**
 * Creates an Observable that, on subscribe, calls an Observable factory to
 * make an Observable for each new Observer.
 *
 * <span class="informal">Creates the Observable lazily, that is, only when it
 * is subscribed.
 * </span>
 *
 * <img src="./img/defer.png" width="100%">
 *
 * `defer` allows you to create the Observable only when the Observer
 * subscribes, and create a fresh Observable for each Observer. It waits until
 * an Observer subscribes to it, and then it generates an Observable,
 * typically with an Observable factory function. It does this afresh for each
 * subscriber, so although each subscriber may think it is subscribing to the
 * same Observable, in fact each subscriber gets its own individual
 * Observable.
 *
 * @example <caption>Subscribe to either an Observable of clicks or an Observable of interval, at random</caption>
 * var clicksOrInterval = Rx.Observable.defer(function () {
 *   if (Math.random() > 0.5) {
 *     return Rx.Observable.fromEvent(document, 'click');
 *   } else {
 *     return Rx.Observable.interval(1000);
 *   }
 * });
 * clicksOrInterval.subscribe(x => console.log(x));
 *
 * // Results in the following behavior:
 * // If the result of Math.random() is greater than 0.5 it will listen
 * // for clicks anywhere on the "document"; when document is clicked it
 * // will log a MouseEvent object to the console. If the result is less
 * // than 0.5 it will emit ascending numbers, one every second(1000ms).
 *
 * @see {@link create}
 *
 * @param {function(): SubscribableOrPromise} observableFactory The Observable
 * factory function to invoke for each Observer that subscribes to the output
 * Observable. May also return a Promise, which will be converted on the fly
 * to an Observable.
 * @return {Observable} An Observable whose Observers' subscriptions trigger
 * an invocation of the given Observable factory function.
 * @static true
 * @name defer
 * @owner Observable
 */
function defer(observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var input;
        try {
            input = observableFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = input ? from_1.from(input) : empty_1.empty();
        return source.subscribe(subscriber);
    });
}
exports.defer = defer;

});

unwrapExports(defer_1);

var forkJoin_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






/* tslint:enable:max-line-length */
/**
 * Joins last values emitted by passed Observables.
 *
 * <span class="informal">Wait for Observables to complete and then combine last values they emitted.</span>
 *
 * <img src="./img/forkJoin.png" width="100%">
 *
 * `forkJoin` is an operator that takes any number of Observables which can be passed either as an array
 * or directly as arguments. If no input Observables are provided, resulting stream will complete
 * immediately.
 *
 * `forkJoin` will wait for all passed Observables to complete and then it will emit an array with last
 * values from corresponding Observables. So if you pass `n` Observables to the operator, resulting
 * array will have `n` values, where first value is the last thing emitted by the first Observable,
 * second value is the last thing emitted by the second Observable and so on. That means `forkJoin` will
 * not emit more than once and it will complete after that. If you need to emit combined values not only
 * at the end of lifecycle of passed Observables, but also throughout it, try out {@link combineLatest}
 * or {@link zip} instead.
 *
 * In order for resulting array to have the same length as the number of input Observables, whenever any of
 * that Observables completes without emitting any value, `forkJoin` will complete at that moment as well
 * and it will not emit anything either, even if it already has some last values from other Observables.
 * Conversely, if there is an Observable that never completes, `forkJoin` will never complete as well,
 * unless at any point some other Observable completes without emitting value, which brings us back to
 * the previous case. Overall, in order for `forkJoin` to emit a value, all Observables passed as arguments
 * have to emit something at least once and complete.
 *
 * If any input Observable errors at some point, `forkJoin` will error as well and all other Observables
 * will be immediately unsubscribed.
 *
 * Optionally `forkJoin` accepts project function, that will be called with values which normally
 * would land in emitted array. Whatever is returned by project function, will appear in output
 * Observable instead. This means that default project can be thought of as a function that takes
 * all its arguments and puts them into an array. Note that project function will be called only
 * when output Observable is supposed to emit a result.
 *
 * @example <caption>Use forkJoin with operator emitting immediately</caption>
 * import { forkJoin, of } from 'rxjs';
 *
 * const observable = forkJoin(
 *   of(1, 2, 3, 4),
 *   of(5, 6, 7, 8)
 * );
 * observable.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('This is how it ends!')
 * );
 *
 * // Logs:
 * // [4, 8]
 * // "This is how it ends!"
 *
 *
 * @example <caption>Use forkJoin with operator emitting after some time</caption>
 * import { forkJoin, interval } from 'rxjs';
 * import { take } from 'rxjs/operators';
 *
 * const observable = forkJoin(
 *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete
 *   interval(500).pipe(take(4)) // emit 0, 1, 2, 3 every half a second and complete
 * );
 * observable.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('This is how it ends!')
 * );
 *
 * // Logs:
 * // [2, 3] after 3 seconds
 * // "This is how it ends!" immediately after
 *
 *
 * @example <caption>Use forkJoin with project function</caption>
 * import { jorkJoin, interval } from 'rxjs';
 * import { take } from 'rxjs/operators';
 *
 * const observable = forkJoin(
 *   interval(1000).pipe(take(3)), // emit 0, 1, 2 every second and complete
 *   interval(500).pipe(take(4)), // emit 0, 1, 2, 3 every half a second and complete
 *   (n, m) => n + m
 * );
 * observable.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('This is how it ends!')
 * );
 *
 * // Logs:
 * // 5 after 3 seconds
 * // "This is how it ends!" immediately after
 *
 * @see {@link combineLatest}
 * @see {@link zip}
 *
 * @param {...ObservableInput} sources Any number of Observables provided either as an array or as an arguments
 * passed directly to the operator.
 * @param {function} [project] Function that takes values emitted by input Observables and returns value
 * that will appear in resulting Observable instead of default array.
 * @return {Observable} Observable emitting either an array of last values emitted by passed Observables
 * or value from project function.
 */
function forkJoin() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    var resultSelector;
    if (typeof sources[sources.length - 1] === 'function') {
        // DEPRECATED PATH
        resultSelector = sources.pop();
    }
    // if the first and only other argument is an array
    // assume it's been called with `forkJoin([obs1, obs2, obs3])`
    if (sources.length === 1 && isArray$1.isArray(sources[0])) {
        sources = sources[0];
    }
    if (sources.length === 0) {
        return empty_1.EMPTY;
    }
    if (resultSelector) {
        // DEPRECATED PATH
        return forkJoin(sources).pipe(map_1.map(function (args) { return resultSelector.apply(void 0, args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        return new ForkJoinSubscriber(subscriber, sources);
    });
}
exports.forkJoin = forkJoin;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ForkJoinSubscriber = /** @class */ (function (_super) {
    __extends(ForkJoinSubscriber, _super);
    function ForkJoinSubscriber(destination, sources) {
        var _this = _super.call(this, destination) || this;
        _this.sources = sources;
        _this.completed = 0;
        _this.haveValues = 0;
        var len = sources.length;
        _this.values = new Array(len);
        for (var i = 0; i < len; i++) {
            var source = sources[i];
            var innerSubscription = subscribeToResult_1.subscribeToResult(_this, source, null, i);
            if (innerSubscription) {
                _this.add(innerSubscription);
            }
        }
        return _this;
    }
    ForkJoinSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.values[outerIndex] = innerValue;
        if (!innerSub._hasValue) {
            innerSub._hasValue = true;
            this.haveValues++;
        }
    };
    ForkJoinSubscriber.prototype.notifyComplete = function (innerSub) {
        var _a = this, destination = _a.destination, haveValues = _a.haveValues, values = _a.values;
        var len = values.length;
        if (!innerSub._hasValue) {
            destination.complete();
            return;
        }
        this.completed++;
        if (this.completed !== len) {
            return;
        }
        if (haveValues === len) {
            destination.next(values);
        }
        destination.complete();
    };
    return ForkJoinSubscriber;
}(OuterSubscriber_1.OuterSubscriber));

});

unwrapExports(forkJoin_1);

var fromEvent_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




function fromEvent(target, eventName, options, resultSelector) {
    if (isFunction_1.isFunction(options)) {
        // DEPRECATED PATH
        resultSelector = options;
        options = undefined;
    }
    if (resultSelector) {
        // DEPRECATED PATH
        return fromEvent(target, eventName, options).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        function handler(e) {
            if (arguments.length > 1) {
                subscriber.next(Array.prototype.slice.call(arguments));
            }
            else {
                subscriber.next(e);
            }
        }
        setupSubscription(target, eventName, handler, subscriber, options);
    });
}
exports.fromEvent = fromEvent;
function setupSubscription(sourceObj, eventName, handler, subscriber, options) {
    var unsubscribe;
    if (isEventTarget(sourceObj)) {
        var source_1 = sourceObj;
        sourceObj.addEventListener(eventName, handler, options);
        unsubscribe = function () { return source_1.removeEventListener(eventName, handler, options); };
    }
    else if (isJQueryStyleEventEmitter(sourceObj)) {
        var source_2 = sourceObj;
        sourceObj.on(eventName, handler);
        unsubscribe = function () { return source_2.off(eventName, handler); };
    }
    else if (isNodeStyleEventEmitter(sourceObj)) {
        var source_3 = sourceObj;
        sourceObj.addListener(eventName, handler);
        unsubscribe = function () { return source_3.removeListener(eventName, handler); };
    }
    else if (sourceObj && sourceObj.length) {
        for (var i = 0, len = sourceObj.length; i < len; i++) {
            setupSubscription(sourceObj[i], eventName, handler, subscriber, options);
        }
    }
    else {
        throw new TypeError('Invalid event target');
    }
    subscriber.add(unsubscribe);
}
function isNodeStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.addListener === 'function' && typeof sourceObj.removeListener === 'function';
}
function isJQueryStyleEventEmitter(sourceObj) {
    return sourceObj && typeof sourceObj.on === 'function' && typeof sourceObj.off === 'function';
}
function isEventTarget(sourceObj) {
    return sourceObj && typeof sourceObj.addEventListener === 'function' && typeof sourceObj.removeEventListener === 'function';
}

});

unwrapExports(fromEvent_1);

var fromEventPattern_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




/* tslint:enable:max-line-length */
/**
 * Creates an Observable from an API based on addHandler/removeHandler
 * functions.
 *
 * <span class="informal">Converts any addHandler/removeHandler API to an
 * Observable.</span>
 *
 * <img src="./img/fromEventPattern.png" width="100%">
 *
 * Creates an Observable by using the `addHandler` and `removeHandler`
 * functions to add and remove the handlers. The `addHandler` is
 * called when the output Observable is subscribed, and `removeHandler` is
 * called when the Subscription is unsubscribed.
 *
 * @example <caption>Emits clicks happening on the DOM document</caption>
 * function addClickHandler(handler) {
 *   document.addEventListener('click', handler);
 * }
 *
 * function removeClickHandler(handler) {
 *   document.removeEventListener('click', handler);
 * }
 *
 * var clicks = fromEventPattern(
 *   addClickHandler,
 *   removeClickHandler
 * );
 * clicks.subscribe(x => console.log(x));
 *
 * @see {@link from}
 * @see {@link fromEvent}
 *
 * @param {function(handler: Function): any} addHandler A function that takes
 * a `handler` function as argument and attaches it somehow to the actual
 * source of events.
 * @param {function(handler: Function, signal?: any): void} [removeHandler] An optional function that
 * takes a `handler` function as argument and removes it in case it was
 * previously attached using `addHandler`. if addHandler returns signal to teardown when remove,
 * removeHandler function will forward it.
 * @return {Observable<T>}
 * @name fromEventPattern
 */
function fromEventPattern(addHandler, removeHandler, resultSelector) {
    if (resultSelector) {
        // DEPRECATED PATH
        return fromEventPattern(addHandler, removeHandler).pipe(map_1.map(function (args) { return isArray$1.isArray(args) ? resultSelector.apply(void 0, args) : resultSelector(args); }));
    }
    return new Observable_1.Observable(function (subscriber) {
        var handler = function () {
            var e = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                e[_i] = arguments[_i];
            }
            return subscriber.next(e.length === 1 ? e[0] : e);
        };
        var retValue;
        try {
            retValue = addHandler(handler);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!isFunction_1.isFunction(removeHandler)) {
            return undefined;
        }
        return function () { return removeHandler(handler, retValue); };
    });
}
exports.fromEventPattern = fromEventPattern;

});

unwrapExports(fromEventPattern_1);

var generate_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



function generate(initialStateOrOptions, condition, iterate, resultSelectorOrObservable, scheduler) {
    var resultSelector;
    var initialState;
    if (arguments.length == 1) {
        var options = initialStateOrOptions;
        initialState = options.initialState;
        condition = options.condition;
        iterate = options.iterate;
        resultSelector = options.resultSelector || identity_1.identity;
        scheduler = options.scheduler;
    }
    else if (resultSelectorOrObservable === undefined || isScheduler_1.isScheduler(resultSelectorOrObservable)) {
        initialState = initialStateOrOptions;
        resultSelector = identity_1.identity;
        scheduler = resultSelectorOrObservable;
    }
    else {
        initialState = initialStateOrOptions;
        resultSelector = resultSelectorOrObservable;
    }
    return new Observable_1.Observable(function (subscriber) {
        var state = initialState;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                subscriber: subscriber,
                iterate: iterate,
                condition: condition,
                resultSelector: resultSelector,
                state: state
            });
        }
        do {
            if (condition) {
                var conditionResult = void 0;
                try {
                    conditionResult = condition(state);
                }
                catch (err) {
                    subscriber.error(err);
                    return undefined;
                }
                if (!conditionResult) {
                    subscriber.complete();
                    break;
                }
            }
            var value = void 0;
            try {
                value = resultSelector(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
            subscriber.next(value);
            if (subscriber.closed) {
                break;
            }
            try {
                state = iterate(state);
            }
            catch (err) {
                subscriber.error(err);
                return undefined;
            }
        } while (true);
        return undefined;
    });
}
exports.generate = generate;
function dispatch(state) {
    var subscriber = state.subscriber, condition = state.condition;
    if (subscriber.closed) {
        return undefined;
    }
    if (state.needIterate) {
        try {
            state.state = state.iterate(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
    }
    else {
        state.needIterate = true;
    }
    if (condition) {
        var conditionResult = void 0;
        try {
            conditionResult = condition(state.state);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        if (!conditionResult) {
            subscriber.complete();
            return undefined;
        }
        if (subscriber.closed) {
            return undefined;
        }
    }
    var value;
    try {
        value = state.resultSelector(state.state);
    }
    catch (err) {
        subscriber.error(err);
        return undefined;
    }
    if (subscriber.closed) {
        return undefined;
    }
    subscriber.next(value);
    if (subscriber.closed) {
        return undefined;
    }
    return this.schedule(state);
}

});

unwrapExports(generate_1);

var iif_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Decides at subscription time which Observable will actually be subscribed.
 *
 * <span class="informal">`If` statement for Observables.</span>
 *
 * `if` accepts a condition function and two Observables. When
 * an Observable returned by the operator is subscribed, condition function will be called.
 * Based on what boolean it returns at that moment, consumer will subscribe either to
 * the first Observable (if condition was true) or to the second (if condition was false). Condition
 * function may also not return anything - in that case condition will be evaluated as false and
 * second Observable will be subscribed.
 *
 * Note that Observables for both cases (true and false) are optional. If condition points to an Observable that
 * was left undefined, resulting stream will simply complete immediately. That allows you to, rather
 * then controlling which Observable will be subscribed, decide at runtime if consumer should have access
 * to given Observable or not.
 *
 * If you have more complex logic that requires decision between more than two Observables, {@link defer}
 * will probably be a better choice. Actually `if` can be easily implemented with {@link defer}
 * and exists only for convenience and readability reasons.
 *
 *
 * @example <caption>Change at runtime which Observable will be subscribed</caption>
 * let subscribeToFirst;
 * const firstOrSecond = Rx.Observable.if(
 *   () => subscribeToFirst,
 *   Rx.Observable.of('first'),
 *   Rx.Observable.of('second')
 * );
 *
 * subscribeToFirst = true;
 * firstOrSecond.subscribe(value => console.log(value));
 *
 * // Logs:
 * // "first"
 *
 * subscribeToFirst = false;
 * firstOrSecond.subscribe(value => console.log(value));
 *
 * // Logs:
 * // "second"
 *
 *
 * @example <caption>Control an access to an Observable</caption>
 * let accessGranted;
 * const observableIfYouHaveAccess = Rx.Observable.if(
 *   () => accessGranted,
 *   Rx.Observable.of('It seems you have an access...') // Note that only one Observable is passed to the operator.
 * );
 *
 * accessGranted = true;
 * observableIfYouHaveAccess.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('The end')
 * );
 *
 * // Logs:
 * // "It seems you have an access..."
 * // "The end"
 *
 * accessGranted = false;
 * observableIfYouHaveAccess.subscribe(
 *   value => console.log(value),
 *   err => {},
 *   () => console.log('The end')
 * );
 *
 * // Logs:
 * // "The end"
 *
 * @see {@link defer}
 *
 * @param {function(): boolean} condition Condition which Observable should be chosen.
 * @param {Observable} [trueObservable] An Observable that will be subscribed if condition is true.
 * @param {Observable} [falseObservable] An Observable that will be subscribed if condition is false.
 * @return {Observable} Either first or second Observable, depending on condition.
 * @static true
 * @name iif
 * @owner Observable
 */
function iif(condition, trueResult, falseResult) {
    if (trueResult === void 0) { trueResult = empty_1.EMPTY; }
    if (falseResult === void 0) { falseResult = empty_1.EMPTY; }
    return defer_1.defer(function () { return condition() ? trueResult : falseResult; });
}
exports.iif = iif;

});

unwrapExports(iif_1);

var isNumeric_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

function isNumeric(val) {
    // parseFloat NaNs numeric-cast false positives (null|true|false|"")
    // ...but misinterprets leading-number strings, particularly hex literals ("0x...")
    // subtraction forces infinities to NaN
    // adding 1 corrects loss of precision from parseFloat (#15100)
    return !isArray$1.isArray(val) && (val - parseFloat(val) + 1) >= 0;
}
exports.isNumeric = isNumeric;

});

unwrapExports(isNumeric_1);

var interval_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });



/**
 * Creates an Observable that emits sequential numbers every specified
 * interval of time, on a specified IScheduler.
 *
 * <span class="informal">Emits incremental numbers periodically in time.
 * </span>
 *
 * <img src="./img/interval.png" width="100%">
 *
 * `interval` returns an Observable that emits an infinite sequence of
 * ascending integers, with a constant interval of time of your choosing
 * between those emissions. The first emission is not sent immediately, but
 * only after the first period has passed. By default, this operator uses the
 * `async` IScheduler to provide a notion of time, but you may pass any
 * IScheduler to it.
 *
 * @example <caption>Emits ascending numbers, one every second (1000ms)</caption>
 * var numbers = Rx.Observable.interval(1000);
 * numbers.subscribe(x => console.log(x));
 *
 * @see {@link timer}
 * @see {@link delay}
 *
 * @param {number} [period=0] The interval size in milliseconds (by default)
 * or the time unit determined by the scheduler's clock.
 * @param {Scheduler} [scheduler=async] The IScheduler to use for scheduling
 * the emission of values, and providing a notion of "time".
 * @return {Observable} An Observable that emits a sequential number each time
 * interval.
 * @static true
 * @name interval
 * @owner Observable
 */
function interval(period, scheduler) {
    if (period === void 0) { period = 0; }
    if (scheduler === void 0) { scheduler = async$1.async; }
    if (!isNumeric_1.isNumeric(period) || period < 0) {
        period = 0;
    }
    if (!scheduler || typeof scheduler.schedule !== 'function') {
        scheduler = async$1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        subscriber.add(scheduler.schedule(dispatch, period, { subscriber: subscriber, counter: 0, period: period }));
        return subscriber;
    });
}
exports.interval = interval;
function dispatch(state) {
    var subscriber = state.subscriber, counter = state.counter, period = state.period;
    subscriber.next(counter);
    this.schedule({ subscriber: subscriber, counter: counter + 1, period: period }, period);
}

});

unwrapExports(interval_1);

var merge_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




/* tslint:enable:max-line-length */
/**
 * Creates an output Observable which concurrently emits all values from every
 * given input Observable.
 *
 * <span class="informal">Flattens multiple Observables together by blending
 * their values into one Observable.</span>
 *
 * <img src="./img/merge.png" width="100%">
 *
 * `merge` subscribes to each given input Observable (as arguments), and simply
 * forwards (without doing any transformation) all the values from all the input
 * Observables to the output Observable. The output Observable only completes
 * once all input Observables have completed. Any error delivered by an input
 * Observable will be immediately emitted on the output Observable.
 *
 * @example <caption>Merge together two Observables: 1s interval and clicks</caption>
 * var clicks = Rx.Observable.fromEvent(document, 'click');
 * var timer = Rx.Observable.interval(1000);
 * var clicksOrTimer = Rx.Observable.merge(clicks, timer);
 * clicksOrTimer.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // timer will emit ascending values, one every second(1000ms) to console
 * // clicks logs MouseEvents to console everytime the "document" is clicked
 * // Since the two streams are merged you see these happening
 * // as they occur.
 *
 * @example <caption>Merge together 3 Observables, but only 2 run concurrently</caption>
 * var timer1 = Rx.Observable.interval(1000).take(10);
 * var timer2 = Rx.Observable.interval(2000).take(6);
 * var timer3 = Rx.Observable.interval(500).take(10);
 * var concurrent = 2; // the argument
 * var merged = Rx.Observable.merge(timer1, timer2, timer3, concurrent);
 * merged.subscribe(x => console.log(x));
 *
 * // Results in the following:
 * // - First timer1 and timer2 will run concurrently
 * // - timer1 will emit a value every 1000ms for 10 iterations
 * // - timer2 will emit a value every 2000ms for 6 iterations
 * // - after timer1 hits it's max iteration, timer2 will
 * //   continue, and timer3 will start to run concurrently with timer2
 * // - when timer2 hits it's max iteration it terminates, and
 * //   timer3 will continue to emit a value every 500ms until it is complete
 *
 * @see {@link mergeAll}
 * @see {@link mergeMap}
 * @see {@link mergeMapTo}
 * @see {@link mergeScan}
 *
 * @param {...ObservableInput} observables Input Observables to merge together.
 * @param {number} [concurrent=Number.POSITIVE_INFINITY] Maximum number of input
 * Observables being subscribed to concurrently.
 * @param {Scheduler} [scheduler=null] The IScheduler to use for managing
 * concurrency of input Observables.
 * @return {Observable} an Observable that emits items that are the result of
 * every input Observable.
 * @static true
 * @name merge
 * @owner Observable
 */
function merge() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var concurrent = Number.POSITIVE_INFINITY;
    var scheduler = null;
    var last = observables[observables.length - 1];
    if (isScheduler_1.isScheduler(last)) {
        scheduler = observables.pop();
        if (observables.length > 1 && typeof observables[observables.length - 1] === 'number') {
            concurrent = observables.pop();
        }
    }
    else if (typeof last === 'number') {
        concurrent = observables.pop();
    }
    if (scheduler === null && observables.length === 1 && observables[0] instanceof Observable_1.Observable) {
        return observables[0];
    }
    return mergeAll_1.mergeAll(concurrent)(fromArray_1.fromArray(observables, scheduler));
}
exports.merge = merge;

});

unwrapExports(merge_1);

var never_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * An Observable that emits no items to the Observer and never completes.
 *
 * <img src="./img/never.png" width="100%">
 *
 * A simple Observable that emits neither values nor errors nor the completion
 * notification. It can be used for testing purposes or for composing with other
 * Observables. Please note that by never emitting a complete notification, this
 * Observable keeps the subscription from being disposed automatically.
 * Subscriptions need to be manually disposed.
 *
 * @example <caption>Emit the number 7, then never emit anything else (not even complete).</caption>
 * function info() {
 *   console.log('Will not be called');
 * }
 * var result = NEVER.startWith(7);
 * result.subscribe(x => console.log(x), info, info);
 *
 * @see {@link create}
 * @see {@link EMPTY}
 * @see {@link of}
 * @see {@link throwError}
 */
exports.NEVER = new Observable_1.Observable(noop_1.noop);
/**
 * @deprecated Deprecated in favor of using NEVER constant.
 */
function never() {
    return exports.NEVER;
}
exports.never = never;

});

unwrapExports(never_1);

var onErrorResumeNext_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




/* tslint:enable:max-line-length */
/**
 * When any of the provided Observable emits an complete or error notification, it immediately subscribes to the next one
 * that was passed.
 *
 * <span class="informal">Execute series of Observables no matter what, even if it means swallowing errors.</span>
 *
 * <img src="./img/onErrorResumeNext.png" width="100%">
 *
 * `onErrorResumeNext` Will subscribe to each observable source it is provided, in order.
 * If the source it's subscribed to emits an error or completes, it will move to the next source
 * without error.
 *
 * If `onErrorResumeNext` is provided no arguments, or a single, empty array, it will return {@link EMPTY}.
 *
 * `onErrorResumeNext` is basically {@link concat}, only it will continue, even if one of its
 * sources emits an error.
 *
 * Note that there is no way to handle any errors thrown by sources via the resuult of
 * `onErrorResumeNext`. If you want to handle errors thrown in any given source, you can
 * always use the {@link catchError} operator on them before passing them into `onErrorResumeNext`.
 *
 * @example <caption>Subscribe to the next Observable after map fails</caption>
 * import { onErrorResumeNext, of } from 'rxjs/create';
 * import { map } from 'rxjs/operators';
 *
 * onErrorResumeNext(
 *  of(1, 2, 3, 0).pipe(
 *    map(x => {
 *      if (x === 0) throw Error();
 *      return 10 / x;
 *    })
 *  ),
 *  of(1, 2, 3),
 * )
 * .subscribe(
 *   val => console.log(val),
 *   err => console.log(err),          // Will never be called.
 *   () => console.log('done')
 * );
 *
 * // Logs:
 * // 10
 * // 5
 * // 3.3333333333333335
 * // 1
 * // 2
 * // 3
 * // "done"
 *
 * @see {@link concat}
 * @see {@link catch}
 *
 * @param {...ObservableInput} sources Observables (or anything that *is* observable) passed either directly or as an array.
 * @return {Observable} An Observable that concatenates all sources, one after the other,
 * ignoring all errors, such that any error causes it to move on to the next source.
 */
function onErrorResumeNext() {
    var sources = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        sources[_i] = arguments[_i];
    }
    if (sources.length === 0) {
        return empty_1.EMPTY;
    }
    var first = sources[0], remainder = sources.slice(1);
    if (sources.length === 1 && isArray$1.isArray(first)) {
        return onErrorResumeNext.apply(void 0, first);
    }
    return new Observable_1.Observable(function (subscriber) {
        var subNext = function () { return subscriber.add(onErrorResumeNext.apply(void 0, remainder).subscribe(subscriber)); };
        return from_1.from(first).subscribe({
            next: function (value) { subscriber.next(value); },
            error: subNext,
            complete: subNext,
        });
    });
}
exports.onErrorResumeNext = onErrorResumeNext;

});

unwrapExports(onErrorResumeNext_1);

var pairs_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });


/**
 * Convert an object into an observable sequence of [key, value] pairs
 * using an optional IScheduler to enumerate the object.
 *
 * @example <caption>Converts a javascript object to an Observable</caption>
 * var obj = {
 *   foo: 42,
 *   bar: 56,
 *   baz: 78
 * };
 *
 * var source = Rx.Observable.pairs(obj);
 *
 * var subscription = source.subscribe(
 *   function (x) {
 *     console.log('Next: %s', x);
 *   },
 *   function (err) {
 *     console.log('Error: %s', err);
 *   },
 *   function () {
 *     console.log('Completed');
 *   });
 *
 * @param {Object} obj The object to inspect and turn into an
 * Observable sequence.
 * @param {Scheduler} [scheduler] An optional IScheduler to run the
 * enumeration of the input sequence on.
 * @returns {(Observable<[string, T]>)} An observable sequence of
 * [key, value] pairs from the object.
 */
function pairs(obj, scheduler) {
    if (!scheduler) {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length && !subscriber.closed; i++) {
                var key = keys[i];
                if (obj.hasOwnProperty(key)) {
                    subscriber.next([key, obj[key]]);
                }
            }
            subscriber.complete();
        });
    }
    else {
        return new Observable_1.Observable(function (subscriber) {
            var keys = Object.keys(obj);
            var subscription = new Subscription_1.Subscription();
            subscription.add(scheduler.schedule(dispatch, 0, { keys: keys, index: 0, subscriber: subscriber, subscription: subscription, obj: obj }));
            return subscription;
        });
    }
}
exports.pairs = pairs;
/** @internal */
function dispatch(state) {
    var keys = state.keys, index = state.index, subscriber = state.subscriber, subscription = state.subscription, obj = state.obj;
    if (!subscriber.closed) {
        if (index < keys.length) {
            var key = keys[index];
            subscriber.next([key, obj[key]]);
            subscription.add(this.schedule({ keys: keys, index: index + 1, subscriber: subscriber, subscription: subscription, obj: obj }));
        }
        else {
            subscriber.complete();
        }
    }
}
exports.dispatch = dispatch;

});

unwrapExports(pairs_1);

var race_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });




function race() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    // if the only argument is an array, it was most likely called with
    // `race([obs1, obs2, ...])`
    if (observables.length === 1) {
        if (isArray$1.isArray(observables[0])) {
            observables = observables[0];
        }
        else {
            return observables[0];
        }
    }
    return fromArray_1.fromArray(observables, undefined).lift(new RaceOperator());
}
exports.race = race;
var RaceOperator = /** @class */ (function () {
    function RaceOperator() {
    }
    RaceOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new RaceSubscriber(subscriber));
    };
    return RaceOperator;
}());
exports.RaceOperator = RaceOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var RaceSubscriber = /** @class */ (function (_super) {
    __extends(RaceSubscriber, _super);
    function RaceSubscriber(destination) {
        var _this = _super.call(this, destination) || this;
        _this.hasFirst = false;
        _this.observables = [];
        _this.subscriptions = [];
        return _this;
    }
    RaceSubscriber.prototype._next = function (observable) {
        this.observables.push(observable);
    };
    RaceSubscriber.prototype._complete = function () {
        var observables = this.observables;
        var len = observables.length;
        if (len === 0) {
            this.destination.complete();
        }
        else {
            for (var i = 0; i < len && !this.hasFirst; i++) {
                var observable = observables[i];
                var subscription = subscribeToResult_1.subscribeToResult(this, observable, observable, i);
                if (this.subscriptions) {
                    this.subscriptions.push(subscription);
                }
                this.add(subscription);
            }
            this.observables = null;
        }
    };
    RaceSubscriber.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        if (!this.hasFirst) {
            this.hasFirst = true;
            for (var i = 0; i < this.subscriptions.length; i++) {
                if (i !== outerIndex) {
                    var subscription = this.subscriptions[i];
                    subscription.unsubscribe();
                    this.remove(subscription);
                }
            }
            this.subscriptions = null;
        }
        this.destination.next(innerValue);
    };
    return RaceSubscriber;
}(OuterSubscriber_1.OuterSubscriber));
exports.RaceSubscriber = RaceSubscriber;

});

unwrapExports(race_1);

var range_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

/**
 * Creates an Observable that emits a sequence of numbers within a specified
 * range.
 *
 * <span class="informal">Emits a sequence of numbers in a range.</span>
 *
 * <img src="./img/range.png" width="100%">
 *
 * `range` operator emits a range of sequential integers, in order, where you
 * select the `start` of the range and its `length`. By default, uses no
 * IScheduler and just delivers the notifications synchronously, but may use
 * an optional IScheduler to regulate those deliveries.
 *
 * @example <caption>Emits the numbers 1 to 10</caption>
 * var numbers = Rx.Observable.range(1, 10);
 * numbers.subscribe(x => console.log(x));
 *
 * @see {@link timer}
 * @see {@link interval}
 *
 * @param {number} [start=0] The value of the first integer in the sequence.
 * @param {number} [count=0] The number of sequential integers to generate.
 * @param {Scheduler} [scheduler] A {@link IScheduler} to use for scheduling
 * the emissions of the notifications.
 * @return {Observable} An Observable of numbers that emits a finite range of
 * sequential integers.
 * @static true
 * @name range
 * @owner Observable
 */
function range(start, count, scheduler) {
    if (start === void 0) { start = 0; }
    if (count === void 0) { count = 0; }
    return new Observable_1.Observable(function (subscriber) {
        var index = 0;
        var current = start;
        if (scheduler) {
            return scheduler.schedule(dispatch, 0, {
                index: index, count: count, start: start, subscriber: subscriber
            });
        }
        else {
            do {
                if (index++ >= count) {
                    subscriber.complete();
                    break;
                }
                subscriber.next(current++);
                if (subscriber.closed) {
                    break;
                }
            } while (true);
        }
        return undefined;
    });
}
exports.range = range;
/** @internal */
function dispatch(state) {
    var start = state.start, index = state.index, count = state.count, subscriber = state.subscriber;
    if (index >= count) {
        subscriber.complete();
        return;
    }
    subscriber.next(start);
    if (subscriber.closed) {
        return;
    }
    state.index = index + 1;
    state.start = start + 1;
    this.schedule(state);
}
exports.dispatch = dispatch;

});

unwrapExports(range_1);

var timer_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });




/**
 * Creates an Observable that starts emitting after an `initialDelay` and
 * emits ever increasing numbers after each `period` of time thereafter.
 *
 * <span class="informal">Its like {@link interval}, but you can specify when
 * should the emissions start.</span>
 *
 * <img src="./img/timer.png" width="100%">
 *
 * `timer` returns an Observable that emits an infinite sequence of ascending
 * integers, with a constant interval of time, `period` of your choosing
 * between those emissions. The first emission happens after the specified
 * `initialDelay`. The initial delay may be a {@link Date}. By default, this
 * operator uses the `async` IScheduler to provide a notion of time, but you
 * may pass any IScheduler to it. If `period` is not specified, the output
 * Observable emits only one value, `0`. Otherwise, it emits an infinite
 * sequence.
 *
 * @example <caption>Emits ascending numbers, one every second (1000ms), starting after 3 seconds</caption>
 * var numbers = Rx.Observable.timer(3000, 1000);
 * numbers.subscribe(x => console.log(x));
 *
 * @example <caption>Emits one number after five seconds</caption>
 * var numbers = Rx.Observable.timer(5000);
 * numbers.subscribe(x => console.log(x));
 *
 * @see {@link interval}
 * @see {@link delay}
 *
 * @param {number|Date} [dueTime] The initial delay time to wait before
 * emitting the first value of `0`.
 * @param {number|SchedulerLike} [periodOrScheduler] The period of time between emissions of the
 * subsequent numbers.
 * @param {SchedulerLike} [scheduler=async] The IScheduler to use for scheduling
 * the emission of values, and providing a notion of "time".
 * @return {Observable} An Observable that emits a `0` after the
 * `initialDelay` and ever increasing numbers after each `period` of time
 * thereafter.
 * @static true
 * @name timer
 * @owner Observable
 */
function timer(dueTime, periodOrScheduler, scheduler) {
    if (dueTime === void 0) { dueTime = 0; }
    var period = -1;
    if (isNumeric_1.isNumeric(periodOrScheduler)) {
        period = Number(periodOrScheduler) < 1 && 1 || Number(periodOrScheduler);
    }
    else if (isScheduler_1.isScheduler(periodOrScheduler)) {
        scheduler = periodOrScheduler;
    }
    if (!isScheduler_1.isScheduler(scheduler)) {
        scheduler = async$1.async;
    }
    return new Observable_1.Observable(function (subscriber) {
        var due = isNumeric_1.isNumeric(dueTime)
            ? dueTime
            : (+dueTime - scheduler.now());
        return scheduler.schedule(dispatch, due, {
            index: 0, period: period, subscriber: subscriber
        });
    });
}
exports.timer = timer;
function dispatch(state) {
    var index = state.index, period = state.period, subscriber = state.subscriber;
    subscriber.next(index);
    if (subscriber.closed) {
        return;
    }
    else if (period === -1) {
        return subscriber.complete();
    }
    state.index = index + 1;
    this.schedule(state, period);
}

});

unwrapExports(timer_1);

var using_1 = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });

 // from from from! LAWL

/**
 * Creates an Observable that uses a resource which will be disposed at the same time as the Observable.
 *
 * <span class="informal">Use it when you catch yourself cleaning up after an Observable.</span>
 *
 * `using` is a factory operator, which accepts two functions. First function returns a disposable resource.
 * It can be an arbitrary object that implements `unsubscribe` method. Second function will be injected with
 * that object and should return an Observable. That Observable can use resource object during its execution.
 * Both functions passed to `using` will be called every time someone subscribes - neither an Observable nor
 * resource object will be shared in any way between subscriptions.
 *
 * When Observable returned by `using` is subscribed, Observable returned from the second function will be subscribed
 * as well. All its notifications (nexted values, completion and error events) will be emitted unchanged by the output
 * Observable. If however someone unsubscribes from the Observable or source Observable completes or errors by itself,
 * the `unsubscribe` method on resource object will be called. This can be used to do any necessary clean up, which
 * otherwise would have to be handled by hand. Note that complete or error notifications are not emitted when someone
 * cancels subscription to an Observable via `unsubscribe`, so `using` can be used as a hook, allowing you to make
 * sure that all resources which need to exist during an Observable execution will be disposed at appropriate time.
 *
 * @see {@link defer}
 *
 * @param {function(): ISubscription} resourceFactory A function which creates any resource object
 * that implements `unsubscribe` method.
 * @param {function(resource: ISubscription): Observable<T>} observableFactory A function which
 * creates an Observable, that can use injected resource object.
 * @return {Observable<T>} An Observable that behaves the same as Observable returned by `observableFactory`, but
 * which - when completed, errored or unsubscribed - will also call `unsubscribe` on created resource object.
 */
function using(resourceFactory, observableFactory) {
    return new Observable_1.Observable(function (subscriber) {
        var resource;
        try {
            resource = resourceFactory();
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var result;
        try {
            result = observableFactory(resource);
        }
        catch (err) {
            subscriber.error(err);
            return undefined;
        }
        var source = result ? from_1.from(result) : empty_1.EMPTY;
        var subscription = source.subscribe(subscriber);
        return function () {
            subscription.unsubscribe();
            if (resource) {
                resource.unsubscribe();
            }
        };
    });
}
exports.using = using;

});

unwrapExports(using_1);

var zip_1 = createCommonjsModule(function (module, exports) {
"use strict";
var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });






/* tslint:enable:max-line-length */
/**
 * Combines multiple Observables to create an Observable whose values are calculated from the values, in order, of each
 * of its input Observables.
 *
 * If the latest parameter is a function, this function is used to compute the created value from the input values.
 * Otherwise, an array of the input values is returned.
 *
 * @example <caption>Combine age and name from different sources</caption>
 *
 * let age$ = Observable.of<number>(27, 25, 29);
 * let name$ = Observable.of<string>('Foo', 'Bar', 'Beer');
 * let isDev$ = Observable.of<boolean>(true, true, false);
 *
 * Observable
 *     .zip(age$,
 *          name$,
 *          isDev$,
 *          (age: number, name: string, isDev: boolean) => ({ age, name, isDev }))
 *     .subscribe(x => console.log(x));
 *
 * // outputs
 * // { age: 27, name: 'Foo', isDev: true }
 * // { age: 25, name: 'Bar', isDev: true }
 * // { age: 29, name: 'Beer', isDev: false }
 *
 * @param observables
 * @return {Observable<R>}
 * @static true
 * @name zip
 * @owner Observable
 */
function zip() {
    var observables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        observables[_i] = arguments[_i];
    }
    var resultSelector = observables[observables.length - 1];
    if (typeof resultSelector === 'function') {
        observables.pop();
    }
    return fromArray_1.fromArray(observables, undefined).lift(new ZipOperator(resultSelector));
}
exports.zip = zip;
var ZipOperator = /** @class */ (function () {
    function ZipOperator(resultSelector) {
        this.resultSelector = resultSelector;
    }
    ZipOperator.prototype.call = function (subscriber, source) {
        return source.subscribe(new ZipSubscriber(subscriber, this.resultSelector));
    };
    return ZipOperator;
}());
exports.ZipOperator = ZipOperator;
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipSubscriber = /** @class */ (function (_super) {
    __extends(ZipSubscriber, _super);
    function ZipSubscriber(destination, resultSelector, values) {
        if (values === void 0) { values = Object.create(null); }
        var _this = _super.call(this, destination) || this;
        _this.iterators = [];
        _this.active = 0;
        _this.resultSelector = (typeof resultSelector === 'function') ? resultSelector : null;
        _this.values = values;
        return _this;
    }
    ZipSubscriber.prototype._next = function (value) {
        var iterators = this.iterators;
        if (isArray$1.isArray(value)) {
            iterators.push(new StaticArrayIterator(value));
        }
        else if (typeof value[iterator$1.iterator] === 'function') {
            iterators.push(new StaticIterator(value[iterator$1.iterator]()));
        }
        else {
            iterators.push(new ZipBufferIterator(this.destination, this, value));
        }
    };
    ZipSubscriber.prototype._complete = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        if (len === 0) {
            this.destination.complete();
            return;
        }
        this.active = len;
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (iterator.stillUnsubscribed) {
                this.add(iterator.subscribe(iterator, i));
            }
            else {
                this.active--; // not an observable
            }
        }
    };
    ZipSubscriber.prototype.notifyInactive = function () {
        this.active--;
        if (this.active === 0) {
            this.destination.complete();
        }
    };
    ZipSubscriber.prototype.checkIterators = function () {
        var iterators = this.iterators;
        var len = iterators.length;
        var destination = this.destination;
        // abort if not all of them have values
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            if (typeof iterator.hasValue === 'function' && !iterator.hasValue()) {
                return;
            }
        }
        var shouldComplete = false;
        var args = [];
        for (var i = 0; i < len; i++) {
            var iterator = iterators[i];
            var result = iterator.next();
            // check to see if it's completed now that you've gotten
            // the next value.
            if (iterator.hasCompleted()) {
                shouldComplete = true;
            }
            if (result.done) {
                destination.complete();
                return;
            }
            args.push(result.value);
        }
        if (this.resultSelector) {
            this._tryresultSelector(args);
        }
        else {
            destination.next(args);
        }
        if (shouldComplete) {
            destination.complete();
        }
    };
    ZipSubscriber.prototype._tryresultSelector = function (args) {
        var result;
        try {
            result = this.resultSelector.apply(this, args);
        }
        catch (err) {
            this.destination.error(err);
            return;
        }
        this.destination.next(result);
    };
    return ZipSubscriber;
}(Subscriber_1.Subscriber));
exports.ZipSubscriber = ZipSubscriber;
var StaticIterator = /** @class */ (function () {
    function StaticIterator(iterator) {
        this.iterator = iterator;
        this.nextResult = iterator.next();
    }
    StaticIterator.prototype.hasValue = function () {
        return true;
    };
    StaticIterator.prototype.next = function () {
        var result = this.nextResult;
        this.nextResult = this.iterator.next();
        return result;
    };
    StaticIterator.prototype.hasCompleted = function () {
        var nextResult = this.nextResult;
        return nextResult && nextResult.done;
    };
    return StaticIterator;
}());
var StaticArrayIterator = /** @class */ (function () {
    function StaticArrayIterator(array) {
        this.array = array;
        this.index = 0;
        this.length = 0;
        this.length = array.length;
    }
    StaticArrayIterator.prototype[iterator$1.iterator] = function () {
        return this;
    };
    StaticArrayIterator.prototype.next = function (value) {
        var i = this.index++;
        var array = this.array;
        return i < this.length ? { value: array[i], done: false } : { value: null, done: true };
    };
    StaticArrayIterator.prototype.hasValue = function () {
        return this.array.length > this.index;
    };
    StaticArrayIterator.prototype.hasCompleted = function () {
        return this.array.length === this.index;
    };
    return StaticArrayIterator;
}());
/**
 * We need this JSDoc comment for affecting ESDoc.
 * @ignore
 * @extends {Ignored}
 */
var ZipBufferIterator = /** @class */ (function (_super) {
    __extends(ZipBufferIterator, _super);
    function ZipBufferIterator(destination, parent, observable) {
        var _this = _super.call(this, destination) || this;
        _this.parent = parent;
        _this.observable = observable;
        _this.stillUnsubscribed = true;
        _this.buffer = [];
        _this.isComplete = false;
        return _this;
    }
    ZipBufferIterator.prototype[iterator$1.iterator] = function () {
        return this;
    };
    // NOTE: there is actually a name collision here with Subscriber.next and Iterator.next
    //    this is legit because `next()` will never be called by a subscription in this case.
    ZipBufferIterator.prototype.next = function () {
        var buffer = this.buffer;
        if (buffer.length === 0 && this.isComplete) {
            return { value: null, done: true };
        }
        else {
            return { value: buffer.shift(), done: false };
        }
    };
    ZipBufferIterator.prototype.hasValue = function () {
        return this.buffer.length > 0;
    };
    ZipBufferIterator.prototype.hasCompleted = function () {
        return this.buffer.length === 0 && this.isComplete;
    };
    ZipBufferIterator.prototype.notifyComplete = function () {
        if (this.buffer.length > 0) {
            this.isComplete = true;
            this.parent.notifyInactive();
        }
        else {
            this.destination.complete();
        }
    };
    ZipBufferIterator.prototype.notifyNext = function (outerValue, innerValue, outerIndex, innerIndex, innerSub) {
        this.buffer.push(innerValue);
        this.parent.checkIterators();
    };
    ZipBufferIterator.prototype.subscribe = function (value, index) {
        return subscribeToResult_1.subscribeToResult(this, this.observable, this, index);
    };
    return ZipBufferIterator;
}(OuterSubscriber_1.OuterSubscriber));

});

unwrapExports(zip_1);

var rxjs = createCommonjsModule(function (module, exports) {
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* Observable */

exports.Observable = Observable_1.Observable;

exports.ConnectableObservable = ConnectableObservable_1.ConnectableObservable;

exports.GroupedObservable = groupBy_1.GroupedObservable;

exports.observable = observable$1.observable;
/* Subjects */

exports.Subject = Subject_1.Subject;

exports.BehaviorSubject = BehaviorSubject_1.BehaviorSubject;

exports.ReplaySubject = ReplaySubject_1.ReplaySubject;

exports.AsyncSubject = AsyncSubject_1.AsyncSubject;
/* Schedulers */

exports.asapScheduler = asap$1.asap;

exports.asyncScheduler = async$1.async;

exports.queueScheduler = queue$1.queue;

exports.animationFrameScheduler = animationFrame$1.animationFrame;

exports.VirtualTimeScheduler = VirtualTimeScheduler_1.VirtualTimeScheduler;
exports.VirtualAction = VirtualTimeScheduler_1.VirtualAction;

exports.Scheduler = Scheduler_1.Scheduler;
/* Subscription */

exports.Subscription = Subscription_1.Subscription;

exports.Subscriber = Subscriber_1.Subscriber;
/* Notification */

exports.Notification = Notification_1.Notification;
/* Utils */

exports.pipe = pipe_1.pipe;

exports.noop = noop_1.noop;

exports.identity = identity_1.identity;

exports.isObservable = isObservable_1.isObservable;
/* Error types */

exports.ArgumentOutOfRangeError = ArgumentOutOfRangeError_1.ArgumentOutOfRangeError;

exports.EmptyError = EmptyError_1.EmptyError;

exports.ObjectUnsubscribedError = ObjectUnsubscribedError_1.ObjectUnsubscribedError;

exports.UnsubscriptionError = UnsubscriptionError_1.UnsubscriptionError;

exports.TimeoutError = TimeoutError_1.TimeoutError;
/* Static observable creation exports */

exports.bindCallback = bindCallback_1.bindCallback;

exports.bindNodeCallback = bindNodeCallback_1.bindNodeCallback;

exports.combineLatest = combineLatest_1.combineLatest;

exports.concat = concat_1.concat;

exports.defer = defer_1.defer;

exports.empty = empty_1.empty;

exports.forkJoin = forkJoin_1.forkJoin;

exports.from = from_1.from;

exports.fromEvent = fromEvent_1.fromEvent;

exports.fromEventPattern = fromEventPattern_1.fromEventPattern;

exports.generate = generate_1.generate;

exports.iif = iif_1.iif;

exports.interval = interval_1.interval;

exports.merge = merge_1.merge;

exports.never = never_1.never;

exports.of = of_1.of;

exports.onErrorResumeNext = onErrorResumeNext_1.onErrorResumeNext;

exports.pairs = pairs_1.pairs;

exports.race = race_1.race;

exports.range = range_1.range;

exports.throwError = throwError_1.throwError;

exports.timer = timer_1.timer;

exports.using = using_1.using;

exports.zip = zip_1.zip;
/* Constants */
var empty_2 = empty_1;
exports.EMPTY = empty_2.EMPTY;
var never_2 = never_1;
exports.NEVER = never_2.NEVER;
/* Config */

exports.config = config$1.config;

});

unwrapExports(rxjs);
var rxjs_1 = rxjs.Observable;
var rxjs_5 = rxjs.Subject;
var rxjs_6 = rxjs.BehaviorSubject;

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by pratik on 18/12/17.
 */
var AmexioHeaderComponent = /** @class */ (function () {
    function AmexioHeaderComponent() {
        this.className = 'modal-window-header';
        this.jstyfy = 'space-between';
        this.background = '';
        this.color = '';
        this.closeable = false;
        this.maximize = false;
        this.isFullWindow = false;
        this.closeableBehaiour = new rxjs_6(false);
        this.maximizeBehaiour = new rxjs_6(false);
    }
    /**
     * @return {?}
     */
    AmexioHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} maximize
     * @param {?} isFullWindow
     * @return {?}
     */
    AmexioHeaderComponent.prototype.setMaximizeData = /**
     * @param {?} maximize
     * @param {?} isFullWindow
     * @return {?}
     */
    function (maximize, isFullWindow) {
        this.maximize = maximize;
        this.isFullWindow = isFullWindow;
        this.maximizeBehaiour.next(this.isFullWindow);
    };
    /**
     * @param {?} materialDesign
     * @return {?}
     */
    AmexioHeaderComponent.prototype.setMaterialDesignStatus = /**
     * @param {?} materialDesign
     * @return {?}
     */
    function (materialDesign) {
        if (materialDesign) {
            this.background = 'white';
            this.color = 'black';
        }
    };
    /**
     * @return {?}
     */
    AmexioHeaderComponent.prototype.sizeChange = /**
     * @return {?}
     */
    function () {
        this.isFullWindow = !this.isFullWindow;
        this.maximizeBehaiour.next(this.isFullWindow);
    };
    /**
     * @return {?}
     */
    AmexioHeaderComponent.prototype.onCloseClick = /**
     * @return {?}
     */
    function () {
        this.closeableBehaiour.next(false);
    };
    AmexioHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-header', template: "\n  <ng-content></ng-content>\n  <span>\n  <amexio-c-icon class=\"cursor-style\" *ngIf=\"(isFullWindow && maximize )\"\n  [key]=\"'window_maximize'\" (onClick)=\"sizeChange()\"></amexio-c-icon>\n  <amexio-c-icon class=\"cursor-style\" *ngIf=\"(!isFullWindow && maximize )\"\n  [key]=\"'window_restore'\" (click)=\"sizeChange()\"></amexio-c-icon>\n  <amexio-c-icon class=\"cursor-style\"\n  style = \"padding-left: 10px\"\n  *ngIf=\"closeable\" [key]=\"'window_close'\" (onClick)=\"onCloseClick()\"></amexio-c-icon>\n  </span>\n  ",
                    styles: [
                        "\n  .cursor-style {\n  cursor:pointer;\n  }\n  ",
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioHeaderComponent.ctorParameters = function () { return []; };
    AmexioHeaderComponent.propDecorators = {
        className: [{ type: i0.HostBinding, args: ['attr.class',] }],
        jstyfy: [{ type: i0.HostBinding, args: ['style.justify-content',] }],
        background: [{ type: i0.HostBinding, args: ['style.background',] }],
        color: [{ type: i0.HostBinding, args: ['style.color',] }],
        padding: [{ type: i0.Input }]
    };
    return AmexioHeaderComponent;
}());

var __extends$2 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*Created by pratik on 14/12/17.
*/
var AmexioPanelComponent = /** @class */ (function (_super) {
    __extends$2(AmexioPanelComponent, _super);
    function AmexioPanelComponent(renderer) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        /*
        Properties
        name : collapsible
        datatype :  boolean
        version : 4.0 onwards
        default : false
        description : Pane will expand or collapse based on the boolean.
        */
        _this.collapsible = true;
        _this.contentAlign = 'left';
        _this.onClick = new i0.EventEmitter();
        _this.nodeRightClick = new i0.EventEmitter();
        _this.rightClick = new i0.EventEmitter();
        _this.mouseLocation = { left: 0, top: 0 };
        _this.faFaIconUPCss = 'fa fa-caret-up';
        _this.faFaIconDownCss = 'fa fa-caret-down';
        _this.panelstyle = { visibility: 'visible' };
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioPanelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = Math.random() * 1000 + 'panel';
        if (!this.collapsible) {
            this.expanded = true;
        }
        this.iconclassKey = this.expanded ? this.faFaIconUPCss : this.faFaIconDownCss;
        if (this.height) {
            return this.height;
        }
        this.updatestyle();
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @return {?}
     */
    AmexioPanelComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
    };
    /**
     * @param {?} btn
     * @return {?}
     */
    AmexioPanelComponent.prototype.onTabClick = /**
     * @param {?} btn
     * @return {?}
     */
    function (btn) {
        btn.classList.toggle('active-accordion');
        if (this.iconclassKey === this.faFaIconDownCss) {
            this.iconclassKey = this.faFaIconUPCss;
        }
        else if (this.iconclassKey === this.faFaIconUPCss) {
            this.iconclassKey = this.faFaIconDownCss;
        }
        this.expanded = !this.expanded;
        this.updatestyle();
        this.onClick.emit();
    };
    /**
     * @param {?} Data
     * @return {?}
     */
    AmexioPanelComponent.prototype.rightClickDataEmit = /**
     * @param {?} Data
     * @return {?}
     */
    function (Data) {
        this.rightClick.emit(Data);
    };
    /**
     * @return {?}
     */
    AmexioPanelComponent.prototype.updatestyle = /**
     * @return {?}
     */
    function () {
        if (this.fit && this.expanded) {
            this.panelstyle = { visibility: 'visible', state: 'visible' };
        }
        else if (this.fit && !this.expanded) {
            this.panelstyle = { visibility: 'hidden', state: 'hidden' };
        }
        else if (!this.fit && this.expanded) {
            this.panelstyle = { display: 'block', state: 'block' };
        }
        else if (!this.fit && !this.expanded) {
            this.panelstyle = { display: 'none', state: 'none' };
        }
        else {
            this.panelstyle = { visibility: 'visible', state: 'visible' };
        }
    };
    // getcontextmenu
    /**
     * @return {?}
     */
    AmexioPanelComponent.prototype.getContextMenu = /**
     * @return {?}
     */
    function () {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioPanelComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    AmexioPanelComponent.prototype.loadContextMenu = /**
     * @param {?} rightClickData
     * @return {?}
     */
    function (rightClickData) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.mouseLocation.left = rightClickData.event.clientX;
            this.mouseLocation.top = rightClickData.event.clientY;
            this.getContextMenu();
            this.posixUp = this.getListPosition(rightClickData.ref);
            rightClickData.event.preventDefault();
            rightClickData.event.stopPropagation();
            this.rightClickNodeData = rightClickData.data;
            this.nodeRightClick.emit(rightClickData);
        }
    };
    /**
     * @return {?}
     */
    AmexioPanelComponent.prototype.addListner = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.globalClickListenFunc = this.renderer.listen('document', 'click', function (e) {
            _this.flag = false;
            if (!_this.flag) {
                _this.removeListner();
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioPanelComponent.prototype.removeListner = /**
     * @return {?}
     */
    function () {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    };
    /**
     * @return {?}
     */
    AmexioPanelComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        this.removeListner();
    };
    AmexioPanelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-panel',
                    template: "\n\n\n\n    <div    #id style=\"width: 100%\" (contextmenu)=\"loadContextMenu({event:$event,ref:id})\"  >\n        <ng-container *ngIf=\"collapsible; else elseBlock\"> \n            <div id=\"{{componentId}}\" [ngStyle]=\"{'background': bgColor, 'color': color}\"\n            *ngIf=\"header\" class=\"panel-accordion\" \n            (click)=\"onTabClick(btn1)\"    >\n                <amexio-toolbar\n                tabindex=\"0\" \n                role=\"heading\"\n                [attr.aria-expanded]=\"expanded\"\n                (keyup.enter)=\"onTabClick(btn1)\"\n                (keyup.space)=\"onTabClick(btn1)\"\n\n            \n                >\n                    <amexio-toolbar-item position-left  attr.aria-label=\"{{title}}\">\n                        <amexio-label  attr.aria-labelledby=\"{{componentId}}\" size=\"small\">\n                            {{title}}\n                        </amexio-label>\n                    </amexio-toolbar-item>\n                    <amexio-toolbar-item position-right>\n                        <ng-content select=\"amexio-panel-header\"></ng-content>\n                    </amexio-toolbar-item>\n                    <amexio-toolbar-item style=\"margin:auto\" position-right>\n                        <i [class]=\"iconclassKey\" aria-hidden=\"true\" #btn1></i>\n                    </amexio-toolbar-item>\n                </amexio-toolbar>\n            </div>\n        </ng-container>\n\n        <ng-template #elseBlock> {{expanded}}\n            <div    id=\"{{componentId}}\"   *ngIf=\"header\" class=\"panel-accordion\" (click)=\"onTabClick(btn1)\">\n                <amexio-toolbar\n                tabindex=\"0\" \n                [attr.aria-expanded]=\"expanded\"\n                (keyup.enter)=\"onTabClick(btn1)\"\n                (keyup.space)=\"onTabClick(btn1)\"\n            \n                >\n                    <amexio-toolbar-item position-left tabindex=\"0\" [attr.aria-expanded]=\"expanded\"  attr.aria-label=\"{{title}}\">\n                        <amexio-label  size=\"small\"   attr.aria-labelledby=\"{{componentId}}\" >\n                            {{title}}\n                        </amexio-label>\n                    </amexio-toolbar-item>\n                    <amexio-toolbar-item position-right>\n                        <ng-content select=\"amexio-panel-header\"></ng-content>\n                    </amexio-toolbar-item>\n                </amexio-toolbar>\n            </div>\n        </ng-template>\n    \n        <div tabindex=\"0\"  id=\"panelpanelId\" class=\"panel-panel\" [ngStyle]=\"{'border-color': border && bgColor}\" [ngClass]=\"{'panel-box-border':border}\" [style.textAlign]=\"contentAlign\" [style.height.px]=\"height\"\n            [@panelState]=\"panelstyle.state\">\n            <ng-content aria-labelledby=\"panelpanelId\" ></ng-content>\n        </div>\n\n        <ng-container *ngIf=\"flag && (this.contextmenu && this.contextmenu.length > 0)\">\n            <base-contextmenu tabindex=\"0\" [base-context-menu]=\"contextmenu\" [mouse-location-top]=\"mouseLocation.top\"\n                [mouse-location-left]=\"mouseLocation.left\" [is-FlagShow]=\"flag\" [right-click-data]=\"nodeRightClick\"\n                (onRightClick)=\"rightClickDataEmit($event)\" [position-up]=\"posixUp\">\n            </base-contextmenu>\n        </ng-container>\n    </div>\n  ",
                    animations: [
                        trigger('panelState', [
                            state('hidden', style({
                                visibility: 'hidden',
                                height: '0px',
                            })),
                            state('visible', style({
                                visibility: 'visible',
                                height: '*',
                            })),
                            state('block', style({
                                display: 'block',
                                height: '*',
                            })),
                            state('none', style({
                                display: 'none',
                                height: '0px',
                            })),
                            transition('*=>*', animate('200ms')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioPanelComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };
    AmexioPanelComponent.propDecorators = {
        title: [{ type: i0.Input }],
        header: [{ type: i0.Input }],
        expanded: [{ type: i0.Input }],
        border: [{ type: i0.Input }],
        collapsible: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        contextmenu: [{ type: i0.Input, args: ['context-menu',] }],
        color: [{ type: i0.Input }],
        bgColor: [{ type: i0.Input, args: ['background',] }],
        contentAlign: [{ type: i0.Input, args: ['content-align',] }],
        parentRef: [{ type: i0.Input }],
        fit: [{ type: i0.Input, args: ['fit',] }],
        onClick: [{ type: i0.Output }],
        nodeRightClick: [{ type: i0.Output }],
        rightClick: [{ type: i0.Output }]
    };
    return AmexioPanelComponent;
}(LifeCycleBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioPanelHeaderComponent = /** @class */ (function () {
    function AmexioPanelHeaderComponent() {
        this.role = 'amexio-panel-header';
    }
    /**
     * @return {?}
     */
    AmexioPanelHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioPanelHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-panel-header', template: "\n    <ng-content></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioPanelHeaderComponent.ctorParameters = function () { return []; };
    AmexioPanelHeaderComponent.propDecorators = {
        role: [{ type: i0.HostBinding, args: ['attr.class',] }],
        padding: [{ type: i0.Input }]
    };
    return AmexioPanelHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var StepBlockComponent = /** @class */ (function () {
    function StepBlockComponent() {
    }
    /**
     * @return {?}
     */
    StepBlockComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    StepBlockComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-step-block', template: "\n  ",
                },] },
    ];
    /** @nocollapse */
    StepBlockComponent.ctorParameters = function () { return []; };
    StepBlockComponent.propDecorators = {
        active: [{ type: i0.Input }],
        label: [{ type: i0.Input }],
        icon: [{ type: i0.Input }]
    };
    return StepBlockComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by pratik on 15/12/17.
*/
var AmexioStepsComponent = /** @class */ (function () {
    function AmexioStepsComponent() {
        /*
        Events
        name : onClick
        datatype : none
        version : none
        default : none
        description :Event emitted on block click.
        */
        this.onClick = new i0.EventEmitter();
        /*
        Events
        name : getStepBlockData
        datatype : none
        version : none
        default : none
        description :Gives stepblock information .
        */
        this.getStepBlockData = new i0.EventEmitter();
    }
    Object.defineProperty(AmexioStepsComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} clickData
     * @param {?} ev
     * @return {?}
     */
    AmexioStepsComponent.prototype.onStepClick = /**
     * @param {?} clickData
     * @param {?} ev
     * @return {?}
     */
    function (clickData, ev) {
        this.getStepBlockData.emit({ event: ev, data: clickData });
        this.onClick.emit(clickData);
    };
    /**
     * @return {?}
     */
    AmexioStepsComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.data && this.data.length > 0) {
            this.stepPreviewData = JSON.parse(JSON.stringify(this.data));
            this.stepBlockArray = this.data;
        }
        else {
            this.stepBlockArray = this.stepBlocks.toArray();
        }
        this.componentLoaded = true;
    };
    /**
     * @return {?}
     */
    AmexioStepsComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (JSON.stringify(this.stepPreviewData) !== JSON.stringify(this.data)) {
            this.stepPreviewData = JSON.parse(JSON.stringify(this.data));
            this.stepBlockArray = this.data;
        }
    };
    AmexioStepsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-steps', template: "\n    <div class=\"stepwizard\" *ngIf=\"(index && !block && !icon)\">\n        <div class=\"stepwizard-row setup-panel\">\n            <div *ngFor=\"let stepBlock of stepBlockArray; let i = index\" class=\"stepwizard-step\">\n                <button type=\"button\" [disabled]=\"!stepBlock.active\" [ngClass]=\"{'disabled index-step-inactive':!stepBlock.active,\n            'active':stepBlock.active}\" class=\"btn-circle button button-primary\" (click)=\"onStepClick(stepBlock,$event)\">{{i + 1}}\n                </button>\n                <ng-container *ngIf=\"stepBlock.label && !stepBlock.active\">\n                    <p>{{stepBlock.label}}</p>\n                </ng-container>\n                <ng-container *ngIf=\"stepBlock.label && stepBlock.active\">\n                    <p><strong class=\"step-label-highlight\">{{stepBlock.label}}</strong></p>\n                </ng-container>\n            </div>\n        </div>\n    </div>\n\n    <!--this code use when user give icon true bydefault it is false-->\n    <div class=\"stepwizard\" *ngIf=\"(icon && !index && !block)\">\n        <div class=\"stepwizard-row setup-panel\">\n            <div *ngFor=\"let stepBlock of stepBlockArray; let i = index\" class=\"stepwizard-step\">\n                <ng-container *ngIf=\"stepBlock.icon && stepBlock.active\">\n                    <span [ngClass]=\"{'step-box-icon-active':stepBlock.active}\" (onClick)=\"onStepClick(stepBlock,$event)\">\n                        <amexio-c-icon [customclass]=\"stepBlock.icon\"></amexio-c-icon>\n                    </span>\n                </ng-container>\n                <ng-container *ngIf=\"stepBlock.icon && !stepBlock.active\">\n                    <span [ngClass]=\"{'step-block-icon-disable':!stepBlock.active}\">\n                        <amexio-c-icon [customclass]=\"stepBlock.icon\" (onClick)=\"onStepClick(stepBlock,$event)\"></amexio-c-icon>\n                    </span>\n                </ng-container>\n                <ng-container *ngIf=\"stepBlock.icon=='' || !stepBlock.icon\">\n                    <br>\n                </ng-container>\n                <ng-container *ngIf=\"stepBlock.label && !stepBlock.active\">\n                    <p style=\"cursor:not-allowed;\" (onClick)=\"onStepClick(stepBlock,$event)\">{{stepBlock.label}}</p>\n                </ng-container>\n                <ng-container *ngIf=\"stepBlock.label && stepBlock.active\">\n                    <p style=\"cursor:pointer;\"><strong class=\"step-label-highlight\" [ngClass]=\"{'step-box-label-active':stepBlock.active}\">{{stepBlock.label}}</strong></p>\n                </ng-container>\n            </div>\n        </div>\n    </div>\n\n    <!--This code use for steps of boxes-->\n    <div *ngIf=\"block\">\n        <div *ngIf=\"block\" role=\"tablist\" class=\"step-box-sqaure\">\n            <div class=\"step-box-table\">\n                <ng-container *ngFor=\"let stepBlock of stepBlockArray; let i = index\">\n                    <div role=\"link\" class=\"step-box-table-item\" [tabindex]=\"stepBlock.active ? 0 : -1\" [attr.aria-labelleby]=\"stepBlock.label\" (click)=\"onStepClick(stepBlock,$event)\" style=\"padding-top: 10px;\" [ngClass]=\"{'disabled step-box-table-item-hover ':!stepBlock.active,'active':stepBlock.active}\">\n                        <a>\n                            <ng-container *ngIf=\"index\">\n                                {{i + 1}}<br>\n                            </ng-container>\n                            <ng-container *ngIf=\"icon && stepBlock.icon\">\n                                <amexio-c-icon [customclass]=\"stepBlock.icon\"></amexio-c-icon>\n                            </ng-container>\n                            <ng-container *ngIf=\"stepBlock.label && !stepBlock.active\">\n                                <p style=\"word-wrap: break-word;\">{{stepBlock.label}}</p>\n                            </ng-container>\n                            <ng-container *ngIf=\"stepBlock.label && stepBlock.active\">\n                                <p style=\"word-wrap: break-word;\"><strong>{{stepBlock.label}}</strong></p>\n                            </ng-container>\n                        </a>\n                    </div>\n                </ng-container>\n\n            </div>\n        </div>\n\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioStepsComponent.ctorParameters = function () { return []; };
    AmexioStepsComponent.propDecorators = {
        index: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        block: [{ type: i0.Input }],
        onClick: [{ type: i0.Output }],
        getStepBlockData: [{ type: i0.Output }],
        stepBlocks: [{ type: i0.ContentChildren, args: [StepBlockComponent,] }],
        data: [{ type: i0.Input, args: ['data',] }]
    };
    return AmexioStepsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 8/12/17.
*/
var AmexioTabPillComponent = /** @class */ (function () {
    function AmexioTabPillComponent() {
        /*
        Properties
        name : disabled
        datatype : boolean
        version : 4.1.4 onwards
        default : false
        description : Disable property for tab
        */
        this.disabled = false;
        /*
        Properties
        name : active
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : Set true for specific tab open as default tab..
        */
        this.active = false;
        /*
         Properties
         name : closable
         datatype : boolean
         version : 4.2 onwards
         default : false
         description : Font color of label
         */
        this.closable = null;
        this.tabId = Math.floor(Math.random() * 90000) + 10000;
    }
    /**
     * @return {?}
     */
    AmexioTabPillComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioTabPillComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-tab', template: "\n    <div style = \"outline: none\" role=\"tabpanel\" tabindex=\"1\" class=\"tab-pane active\" attr.aria-labelledby=\"{{tablk}}\" [attr.id]=\"tabId\" [hidden]=\"!active\">\n      <ng-content></ng-content>\n      <ng-template #target></ng-template>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioTabPillComponent.ctorParameters = function () { return []; };
    AmexioTabPillComponent.propDecorators = {
        title: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        active: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        amexiocolor: [{ type: i0.Input, args: ['amexio-color',] }],
        closable: [{ type: i0.Input }],
        target: [{ type: i0.ViewChild, args: ['target', { read: i0.ViewContainerRef },] }]
    };
    return AmexioTabPillComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
var AmexioRightVerticalTabComponent = /** @class */ (function () {
    function AmexioRightVerticalTabComponent(render, componentFactoryResolver) {
        this.render = render;
        this.componentFactoryResolver = componentFactoryResolver;
        this.dummyArray = [];
        this.componentId = '';
        /*
        Events
        name : onClick
        datatype :none
        version : 4.0 onwards
        default : none
        description : Callback to invoke on activated tab event.
        */
        this.onClick = new i0.EventEmitter();
        this.tabPosition = 'top';
    }
    /**
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = Math.floor(Math.random() * 90000) + 10000 + '_tabc';
    };
    /**
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.tabCollection = this.queryTabs.toArray();
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.onTabClick = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        var _this = this;
        if (!tab.disabled && !tab.header) {
            for (var _i = 0, _a = this.tabCollection; _i < _a.length; _i++) {
                var i = _a[_i];
                if (i === tab) {
                    i['active'] = true;
                    this.asignTabPillClass(tab);
                    this.onClick.emit(tab);
                }
                else {
                    i['active'] = false;
                    i['tabPillClass'] = '';
                }
            }
            this.tabCollection.forEach(function (tab1) {
                _this.asignTabPillClass(tab1);
            });
        }
    };
    /**
     * @param {?} tabData
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.asignTabPillClass = /**
     * @param {?} tabData
     * @return {?}
     */
    function (tabData) {
        tabData.tabPillClass = '';
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && tabData.active && (this.tabPosition === 'top')) {
            tabData.tabPillClass = 'activetab';
        }
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'bottomActivetab';
        }
        if (tabData.disabled) {
            tabData.tabPillClass = 'disabled-tab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'top') && tabData.active) {
            tabData.tabPillClass = 'activecolortab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'activebottomcolortab';
        }
    };
    /**
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.findTabStyleClass = /**
     * @return {?}
     */
    function () {
        if (this.tabPosition === 'top') {
            return 'tabposition-right-top';
        }
        if (this.tabPosition === 'bottom') {
            return 'tabposition-right-bottom';
        }
    };
    /**
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.closeAllTabs = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.tabCollection.forEach(function (tabs) {
            if (tabs.closable === true || _this.closable === true) {
                _this.closeTab(tabs);
            }
        });
    };
    /**
     * @param {?} title
     * @param {?} amexiocolor
     * @param {?} closable
     * @param {?} component
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.addDynamicTab = /**
     * @param {?} title
     * @param {?} amexiocolor
     * @param {?} closable
     * @param {?} component
     * @return {?}
     */
    function (title, amexiocolor, closable, component) {
        // get a component factory for our TabComponent
        var /** @type {?} */ tpCF = this.componentFactoryResolver.resolveComponentFactory(AmexioTabPillComponent);
        var /** @type {?} */ tp = this.target.createComponent(tpCF);
        // set the according properties on our component instance
        var /** @type {?} */ instance = /** @type {?} */ (tp.instance);
        instance.title = title;
        instance.active = true;
        instance.closable = closable;
        instance['tabpillinstance'] = this.target;
        if (instance.amexiocolor === '') {
            instance.amexiocolor = 'amexio-top-tab-black';
        }
        else {
            instance.amexiocolor = 'amexio-top-tab-' + amexiocolor;
        }
        // create dynamic component
        var /** @type {?} */ dynCF = this.componentFactoryResolver.resolveComponentFactory(component);
        var /** @type {?} */ dynCmp = tp.instance.target.createComponent(dynCF);
        // Push new tab and select it.
        this.dummyArray.push(tp);
        this.tabCollection.push(tp.instance);
        this.selectTab(tp.instance);
        return dynCmp.instance;
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.selectTab = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        var _this = this;
        // deactivate all tabs
        this.tabCollection.forEach(function (tab1) {
            tab1.active = false;
        });
        tab.active = true;
        this.tabCollection.forEach(function (tab1) {
            _this.asignTabPillClass(tab1);
        });
    };
    /**
     * @param {?} tabNode
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.closeTab = /**
     * @param {?} tabNode
     * @return {?}
     */
    function (tabNode) {
        var _this = this;
        var /** @type {?} */ newTab = [];
        var /** @type {?} */ index = 0;
        var /** @type {?} */ tabHighlightIndex = 0;
        this.tabCollection.forEach(function (tab, i) {
            tab.active = false;
            if (tab.tabId === tabNode.tabId) {
                tabHighlightIndex = index;
                if (tab.hasOwnProperty('tabpillinstance')) {
                    tab.target.remove();
                }
                else {
                    _this.tabDomRemove(tab);
                }
            }
            else if (tab.tabId !== tabNode.tabId) {
                newTab.push(tab);
            }
            index++;
        });
        if (tabHighlightIndex === newTab.length) {
            tabHighlightIndex--;
        }
        this.tabCollection = newTab;
        if (tabHighlightIndex > -1) {
            this.activateTab(newTab[tabHighlightIndex].tabId);
        }
        else {
            this.activateTab(null);
        }
        if (this.tabCollection.length === 1) {
            this.closable = false;
        }
        if (newTab.length === 1) {
            newTab[0].closable = false;
        }
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.tabDomRemove = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        var /** @type {?} */ removeNode = document.getElementById(tab.tabId).parentNode;
        var /** @type {?} */ parentRefNode = removeNode.parentNode;
        parentRefNode.removeChild(removeNode);
    };
    /**
     * @param {?} tabId
     * @return {?}
     */
    AmexioRightVerticalTabComponent.prototype.activateTab = /**
     * @param {?} tabId
     * @return {?}
     */
    function (tabId) {
        this.tabCollection.forEach(function (tab) {
            tab.active = false;
            if (tab.tabId === tabId) {
                tab.active = true;
            }
        });
    };
    AmexioRightVerticalTabComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-right-vertical-tab-view',
                    template: "\n    <div class=\"righttable\">\n        <div class=\"righttablerow\">\n            <div class=\"tablecol verticalalign-tabcontent\">\n                <div style=\"float:left\" class=\"tabcontent\" [attr.id]=\"componentId\">\n                    <ng-content></ng-content>\n                    <ng-template #target></ng-template>\n                </div>\n            </div>\n\n            <div style=\"float:right;height:580px\" class=\"righttablecol verticalalign-tabright\">\n                <div #tab class=\"verticalnavtab verticalnavtab-right\" [ngClass]=\"{'tabposition-right-top': (tabPosition==='top'),'tabposition-right-bottom':(tabPosition==='bottom')}\">\n                    <ul>\n                        <li *ngFor=\"let tabnode of tabCollection\">\n                            <div class=\"defaultnode\" [ngClass]=\"{'rightactivetab':tabnode.active,'disabled-tab':tabnode.disabled }\" (click)=\"onTabClick(tabnode)\" [ngStyle]=\"{'color': tabnode.amexiocolor}\">\n                                <span *ngIf=\"tabnode.icon\" [ngClass]=\"tabnode.icon\" aria-hidden=\"true\"></span>\n                                <span style=\"padding-left:5px\">{{tabnode.title}}</span>\n                                <span *ngIf=\"closable\" class=\"tablecol\">\n                    <amexio-c-icon key=\"tab_close\" (onClick)=\"closeTab(tabnode)\" style=\"padding-left:5px;float:right\"></amexio-c-icon>\n                  </span>\n                            </div>\n                        </li>\n                    </ul>\n                </div>\n            </div>\n\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioRightVerticalTabComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: i0.ComponentFactoryResolver }
    ]; };
    AmexioRightVerticalTabComponent.propDecorators = {
        tabs: [{ type: i0.ViewChild, args: ['tab', { read: i0.ElementRef },] }],
        queryTabs: [{ type: i0.ContentChildren, args: [AmexioTabPillComponent,] }],
        target: [{ type: i0.ViewChild, args: ['target', { read: i0.ViewContainerRef },] }],
        closable: [{ type: i0.Input }],
        tabPosition: [{ type: i0.Input }],
        onClick: [{ type: i0.Output }]
    };
    return AmexioRightVerticalTabComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var noop$3 = function () {
};
/**
 * @abstract
 * @template T
 */
var ValueAccessorBase = /** @class */ (function () {
    function ValueAccessorBase() {
        this.onTouchedCallback = noop$3;
        this.onChangeCallback = noop$3;
    }
    Object.defineProperty(ValueAccessorBase.prototype, "value", {
        // get accessor
        get: /**
         * @return {?}
         */
        function () {
            return this.innerValue;
        },
        // set accessor including call the onchange callback
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v !== this.innerValue) {
                this.innerValue = v;
                this.onChangeCallback(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    ValueAccessorBase.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    ValueAccessorBase.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    ValueAccessorBase.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    // THIS METHOD GENERATE RANDOM STRING
    /**
     * @param {?} name
     * @param {?} fieldlabel
     * @param {?} inputType
     * @return {?}
     */
    ValueAccessorBase.prototype.generateName = /**
     * @param {?} name
     * @param {?} fieldlabel
     * @param {?} inputType
     * @return {?}
     */
    function (name, fieldlabel, inputType) {
        var /** @type {?} */ newName = name;
        if (!name && fieldlabel) {
            newName = fieldlabel.replace(/\s/g, '');
        }
        else if (!name && !fieldlabel) {
            newName = inputType + '-' + this.getRandomString();
        }
        return newName;
    };
    /**
     * @return {?}
     */
    ValueAccessorBase.prototype.getRandomString = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ possibleCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
        var /** @type {?} */ randomString = '';
        for (var /** @type {?} */ i = 0; i < 6; i++) {
            randomString += possibleCharacters.charAt(Math.floor(Math.random() * possibleCharacters.length));
        }
        return randomString;
    };
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    ValueAccessorBase.prototype.createCompId = /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    function (inputType, name) {
        return inputType + '_' + name + '_' + Math.floor(Math.random() * 1000 + 999);
    };
    return ValueAccessorBase;
}());

var __extends$3 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioCheckBoxGroupComponent = /** @class */ (function (_super) {
    __extends$3(AmexioCheckBoxGroupComponent, _super);
    function AmexioCheckBoxGroupComponent(httpService) {
        var _this = _super.call(this) || this;
        _this.httpService = httpService;
        /*
          Properties
          name : disabled
          datatype : boolean
          version : 4.0 onwards
          default : false
          description :  If true will not react on any user events and show disable icon over
          */
        _this.disabled = false;
        _this.onSelection = new i0.EventEmitter();
        return _this;
    }
    Object.defineProperty(AmexioCheckBoxGroupComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._data = v;
            this.viewdata = of(this.data);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioCheckBoxGroupComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.componentId = this.createCompId('checkboxgroup', this.name);
        var /** @type {?} */ reponseData;
        if (this.httpmethod && this.httpurl) {
            this.httpService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                reponseData = response;
            }, function (error) {
            }, function () {
                _this.data = _this.getResponseData(reponseData);
            });
        }
        else if (this.data && this.datareader) {
            this.data = this.getResponseData(this.data);
        }
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioCheckBoxGroupComponent.prototype.getResponseData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioCheckBoxGroupComponent.prototype.contains = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        if (this._model instanceof Array) {
            this._model.forEach(function (obj) {
                if (obj[_this.displayfield] === value[_this.displayfield]) {
                    return true;
                }
            });
        }
        return false;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioCheckBoxGroupComponent.prototype.add = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!this.contains(value)) {
            if (this._model instanceof Array) {
                this._model.push(value);
            }
            else {
                this._model = [value];
            }
            this.onChangeCallback(this._model);
        }
        this.emitCheckboxes(this._model);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioCheckBoxGroupComponent.prototype.remove = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var /** @type {?} */ index = this._model.indexOf(value);
        if (!this._model || index < 0) {
            return;
        }
        this._model.splice(index, 1);
        this.onChangeCallback(this._model);
        this.emitCheckboxes(this._model);
    };
    // THIS METHOD EMMIT SELECTED CHECKBOXES
    /**
     * @param {?} selectedCheckBoxes
     * @return {?}
     */
    AmexioCheckBoxGroupComponent.prototype.emitCheckboxes = /**
     * @param {?} selectedCheckBoxes
     * @return {?}
     */
    function (selectedCheckBoxes) {
        var _this = this;
        this.selectedCheckBox = [];
        if (selectedCheckBoxes && selectedCheckBoxes.length > 0) {
            selectedCheckBoxes.forEach(function (obj) {
                obj.checked = true;
                _this.selectedCheckBox.push(obj);
            });
        }
        this.onSelection.emit(this.selectedCheckBox);
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioCheckBoxGroupComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return (this.required && (this._model && this._model.length > 0)) || !this.required
            ? null
            : {
                jsonParseError: {
                    valid: true,
                },
            };
    };
    AmexioCheckBoxGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-checkbox-group',
                    template: "\n    <div role=\"group\"\n         attr.aria-labelledby=\"{{componentId}}\"\n         [attr.aria-required]=\"required\" \n         tabindex=\"0\"\n         class=\"inputgroup form-group\">\n        <div *ngIf=\"fieldlabel\">\n            <legend id=\"{{componentId}}\">{{fieldlabel}}</legend>\n        </div>  \n\n        <div *ngIf=\"horizontal\" style=\"display: inline-flex; flex-direction :row;\">\n            <checkbox *ngFor=\"let data of viewdata | async\" [checked]=\"data.checked\" [value]=\"data\" [disabled]=\"data?.disabled || disabled\" [label]=\"data[displayfield]\">\n            </checkbox>    \n        </div>\n\n        <div *ngIf=\"!horizontal\" style=\"display: inline-flex;flex-direction :column;\">\n            <checkbox *ngFor=\"let data of viewdata | async\" [checked]=\"data.checked\" [value]=\"data\" [disabled]=\"data?.disabled || disabled\" [label]=\"data[displayfield]\">\n            </checkbox>\n        </div>\n    </div>\n  ",
                    providers: [
                        { provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioCheckBoxGroupComponent; }), multi: true },
                        { provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioCheckBoxGroupComponent; }), multi: true },
                    ]
                },] },
    ];
    /** @nocollapse */
    AmexioCheckBoxGroupComponent.ctorParameters = function () { return [
        { type: CommonDataService }
    ]; };
    AmexioCheckBoxGroupComponent.propDecorators = {
        horizontal: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        valuefield: [{ type: i0.Input, args: ['value-field',] }],
        required: [{ type: i0.Input, args: ['required',] }],
        name: [{ type: i0.Input, args: ['name',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        onSelection: [{ type: i0.Output }]
    };
    return AmexioCheckBoxGroupComponent;
}(ValueAccessorBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioFormValidator = /** @class */ (function () {
    function AmexioFormValidator() {
    }
    // @ViewChild(NgModel) model: NgModel;
    // public validate(c: FormControl) {
    //     return (this.model.valid ) ? null : {
    //         jsonParseError: {
    //             valid: true,
    //         },
    //     };
    // }
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    AmexioFormValidator.prototype.createCompId = /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    function (inputType, name) {
        return inputType + '_' + name + '_' + Math.floor(Math.random() * 1000 + 999);
    };
    return AmexioFormValidator;
}());

var __extends$4 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 11/21/17.
*/
var noop$4 = function () {
};
var AmexioCheckBoxComponent = /** @class */ (function (_super) {
    __extends$4(AmexioCheckBoxComponent, _super);
    function AmexioCheckBoxComponent() {
        var _this = _super.call(this) || this;
        _this.innerValue = '';
        _this.onTouchedCallback = noop$4;
        _this.onChangeCallback = noop$4;
        /*
          Properties
          name : required
          datatype : boolean
          version : 4.0 onwards
          default : false
          description :  property to set if manditory
          */
        _this.required = false;
        /*
          Events
          name : onSelection
          datatype : any
          version : none
          default : none
          description : Event fired on checkbox click.
          */
        _this.onSelection = new i0.EventEmitter();
        /*
          Events
          name : input
          datatype : any
          version : none
          default : none
          description : On input event field.
          */
        _this.input = new i0.EventEmitter();
        _this.tabFocus = false;
        _this.isComponentValid = new i0.EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.createCompId('checkbox', this.name);
        this.generateName();
        this.isValid = !this.required;
        this.isComponentValid.emit(!this.required);
    };
    /**
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.onInput = /**
     * @return {?}
     */
    function () {
        this.isValid = this.value;
        this.isComponentValid.emit(this.value);
        this.input.emit(this.value);
    };
    /**
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.value = !this.value;
        this.isValid = this.value;
        this.isComponentValid.emit(this.value);
        this.onSelection.emit(this.value);
    };
    Object.defineProperty(AmexioCheckBoxComponent.prototype, "value", {
        // get accessor
        get: /**
         * @return {?}
         */
        function () {
            if (this.required) {
                this.isValid = this.innerValue;
            }
            else {
                this.isValid = true;
            }
            return this.innerValue;
        },
        // set accessor including call the onchange callback
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v !== this.innerValue) {
                this.innerValue = v;
                this.onChangeCallback(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    // Set touched on blur
    /**
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.tabFocus = false;
        this.onTouchedCallback();
    };
    /**
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.tabFocus = true;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
            this.value = this.innerValue;
        }
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.checkValidity = /**
     * @return {?}
     */
    function () {
        return this.isValid;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return ((this.required && this.value) || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    // THIS METHOD GENERATE RANDOM STRING
    /**
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.generateName = /**
     * @return {?}
     */
    function () {
        if (!this.name && this.fieldlabel) {
            this.name = this.fieldlabel.replace(/\s/g, '');
        }
        else if (!this.name && !this.fieldlabel) {
            this.name = 'textinput-' + this.getRandomString();
        }
    };
    /**
     * @return {?}
     */
    AmexioCheckBoxComponent.prototype.getRandomString = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ possibleCharacters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';
        var /** @type {?} */ randomString = '';
        for (var /** @type {?} */ i = 0; i < 6; i++) {
            randomString += possibleCharacters.charAt(Math.floor(Math.random() * possibleCharacters.length));
        }
        return randomString;
    };
    AmexioCheckBoxComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-checkbox',
                    template: "\n    <div [attr.aria-checked]=\"value\" class=\"inputgroup form-group\" [ngClass]=\"{'checkbox-disable' : disabled}\">\n        <label for=\"{{componentId}}\" class=\"input-box-container\">\n            <input\n            id=\"{{componentId}}\" type=\"checkbox\" style=\"top:0; left:0\"\n            [attr.checked]=\"value ? true: null\"\n             tabindex=\"1\"\n            (input)=\"onInput()\" \n            (click)=\"onClick()\"\n            (focus)=\"onFocus()\"\n            (blur)=\"onBlur()\"\n            [attr.disabled] = \"disabled ? true: null\"\n            [attr.aria-disabled]=\"disabled\"\n            [attr.aria-required]=\"required\"\n            [required]=\"required\" >\n            {{fieldlabel}}\n            <span class=\"input-box-checkbox-label\" [ngClass]=\"{'focusOnCheckbox':tabFocus}\">\n            </span>\n          </label>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioCheckBoxComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioCheckBoxComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioCheckBoxComponent.ctorParameters = function () { return []; };
    AmexioCheckBoxComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        disabled: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        onSelection: [{ type: i0.Output }],
        input: [{ type: i0.Output }],
        name: [{ type: i0.Input, args: ['name',] }],
        isComponentValid: [{ type: i0.Output }]
    };
    return AmexioCheckBoxComponent;
}(AmexioFormValidator));

var __extends$6 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
 * @template T
 */
var EventBaseComponent = /** @class */ (function (_super) {
    __extends$6(EventBaseComponent, _super);
    function EventBaseComponent(renderer, element, cd) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        _this.element = element;
        _this.cd = cd;
        _this.self = false;
        _this.itemClick = false;
        _this.hide();
        return _this;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    EventBaseComponent.prototype.onBaseFocusEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'visible' };
        this.bindDocumentClickListener();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    EventBaseComponent.prototype.onBaseBlurEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onBaseItemClicked();
        return false;
    };
    /**
     * @return {?}
     */
    EventBaseComponent.prototype.onBaseItemClicked = /**
     * @return {?}
     */
    function () {
        this.itemClick = true;
        this.hide();
        this.unbindDocumentClickListener();
        this.clearClicks();
    };
    /**
     * @return {?}
     */
    EventBaseComponent.prototype.bindDocumentClickListener = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer
                .listen('document', 'click', function (event) { return _this.handleDocumentListener(event); });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    EventBaseComponent.prototype.handleDocumentListener = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.self && !this.itemClick) {
            this.hide();
            this.unbindDocumentClickListener();
        }
        this.clearClicks();
        this.cd.markForCheck();
    };
    /**
     * @return {?}
     */
    EventBaseComponent.prototype.clearClicks = /**
     * @return {?}
     */
    function () {
        this.self = false;
        this.itemClick = false;
    };
    /**
     * @return {?}
     */
    EventBaseComponent.prototype.unbindDocumentClickListener = /**
     * @return {?}
     */
    function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    /**
     * @return {?}
     */
    EventBaseComponent.prototype.hide = /**
     * @return {?}
     */
    function () {
        this.dropdownstyle = { visibility: 'hidden' };
    };
    return EventBaseComponent;
}(ValueAccessorBase));

var __extends$5 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 1/12/17.
 */
var AmexioDropDownComponent = /** @class */ (function (_super) {
    __extends$5(AmexioDropDownComponent, _super);
    function AmexioDropDownComponent(dataService, displayFieldService, element, renderer, _cd) {
        var _this = _super.call(this, renderer, element, _cd) || this;
        _this.dataService = dataService;
        _this.displayFieldService = displayFieldService;
        _this.element = element;
        _this.renderer = renderer;
        _this.displayValue = '';
        _this.filteredOptions = [];
        /*
          Events
          name : onBlur
          datatype : any
          version : 4.0 onwards
          default :
          description : 	On blur event
          */
        _this.onBlur = new i0.EventEmitter();
        /*
        Events
        name : input
        datatype : any
        version : none
        default :
        description : 	On input event field.
        */
        _this.input = new i0.EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On field focus event
        */
        _this.focus = new i0.EventEmitter();
        /*
        Events
        name : onSingleSelect
        datatype : any
        version : none
        default :
        description : Fire when drop down item selected.
        */
        _this.onSingleSelect = new i0.EventEmitter();
        /*
        Events
        name : onMultiSelect
        datatype : any
        version :none
        default :
        description : Fire when multiple record select in drop down.this event is only
        applied when multi-select=true
        */
        _this.onMultiSelect = new i0.EventEmitter();
        /*
        Events
        name : onClick
        datatype : any
        version :none
        default :
        description : On record select event.this event is only for normal dropdown.
        */
        _this.onClick = new i0.EventEmitter();
        /*
        Properties
        name : place-holder
        datatype : string
        version : 4.0 onwards
        default :
        description : Show place-holder inside dropdown component*/
        _this.placeholder = '';
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : flag to set label
        */
        _this.haslabel = true;
        _this.enablesort = false;
        _this.sort = '';
        _this.selectedindex = -1;
        _this.multiselectValues = [];
        _this.maskloader = true;
        _this.activedescendant = 'aria-activedescendant';
        // The internal dataviews model
        _this.isComponentValid = new i0.EventEmitter();
        return _this;
    }
    Object.defineProperty(AmexioDropDownComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.setData(this._data);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioDropDownComponent.prototype, "errormsg", {
        get: /**
         * @return {?}
         */
        function () {
            return this._errormsg;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.helpInfoMsg = value + '<br/>';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioDropDownComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.name = this.generateName(this.name, this.fieldlabel, 'dropdowninput');
        this.componentId = this.createCompId('dropdown', this.displayfield);
        this.isValid = this.allowblank;
        this.isComponentValid.emit(this.allowblank);
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioDropDownComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        // Check if key is added?
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            this.multiselectValues = [];
            var /** @type {?} */ dr = this.datareader.split('.');
            if (dr) {
                for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                    var ir = dr_1[_i];
                    responsedata = responsedata[ir];
                }
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.setResponseData(responsedata);
        this.multiSelection();
        this.setUserSelection();
        this.maskloader = false;
    };
    /**
     * @param {?} responsedata
     * @return {?}
     */
    AmexioDropDownComponent.prototype.setResponseData = /**
     * @param {?} responsedata
     * @return {?}
     */
    function (responsedata) {
        if (responsedata) {
            if (this.enablesort === true && (this.sort === '' || this.sort.toLowerCase() === 'asc')) {
                this.sortDataAscending(responsedata);
            }
            else if (this.enablesort === true && this.sort.toLowerCase() === 'desc') {
                this.sortDataDescending(responsedata);
            }
            else if (this.enablesort === false) {
                this.viewData = responsedata;
                this.filteredOptions = this.viewData;
                this.generateIndex(this.filteredOptions);
            }
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioDropDownComponent.prototype.sortDataAscending = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        this.viewData = data.sort(function (a, b) { return _this.displayFieldService.findValue(_this.displayfield, a).toLowerCase()
            !== _this.displayFieldService.findValue(_this.displayfield, b).toLowerCase() ?
            _this.displayFieldService.findValue(_this.displayfield, a).toLowerCase() <
                _this.displayFieldService.findValue(_this.displayfield, b).toLowerCase() ? -1 : 1 : 0; });
        this.filteredOptions = this.viewData;
        this.generateIndex(this.filteredOptions);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioDropDownComponent.prototype.sortDataDescending = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        this.viewData = data.sort(function (a, b) { return _this.displayFieldService.findValue(_this.displayfield, a).toLowerCase()
            !== _this.displayFieldService.findValue(_this.displayfield, b).toLowerCase() ?
            _this.displayFieldService.findValue(_this.displayfield, a).toLowerCase() >
                _this.displayFieldService.findValue(_this.displayfield, b).toLowerCase() ? -1 : 1 : 0; });
        this.filteredOptions = this.viewData;
        this.generateIndex(this.filteredOptions);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioDropDownComponent.prototype.generateIndex = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        data.forEach(function (element, index) {
            element['index'] = _this.componentId + 'listitem' + index;
        });
    };
    /**
     * @return {?}
     */
    AmexioDropDownComponent.prototype.multiSelection = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.multiselect && this.viewData) {
            var /** @type {?} */ preSelectedMultiValues_1 = '';
            var /** @type {?} */ optionsChecked_1 = [];
            this.viewData.forEach(function (row) {
                if (row.hasOwnProperty('checked')) {
                    if (row.checked) {
                        optionsChecked_1.push(row[_this.valuefield]);
                        _this.multiselectValues.push(row);
                        preSelectedMultiValues_1 === '' ? preSelectedMultiValues_1 +=
                            _this.displayFieldService.findValue(_this.displayfield, row) : preSelectedMultiValues_1 += ', ' +
                            _this.displayFieldService.findValue(_this.displayfield, row);
                    }
                }
                else {
                    row['checked'] = false;
                }
            });
            this.displayValue = this.setMultiSelect();
            this.onMultiSelect.emit(this.multiselectValues);
        }
    };
    /**
     * @return {?}
     */
    AmexioDropDownComponent.prototype.setUserSelection = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // Set user selection
        if (this.innerValue != null) {
            var /** @type {?} */ valueKey_1 = this.valuefield;
            var /** @type {?} */ displayKey_1 = this.displayfield;
            var /** @type {?} */ val_1 = this.innerValue;
            if (this.viewData.length > 0) {
                this.viewData.forEach(function (item) {
                    if (item[valueKey_1] === val_1) {
                        _this.isValid = true;
                        _this.isComponentValid.emit(true);
                        _this.displayValue = item[displayKey_1];
                        _this.onSingleSelect.emit(item);
                    }
                });
            }
        }
    };
    /**
     * @param {?} selectedItem
     * @return {?}
     */
    AmexioDropDownComponent.prototype.onItemSelect = /**
     * @param {?} selectedItem
     * @return {?}
     */
    function (selectedItem) {
        var _this = this;
        if (this.multiselect) {
            var /** @type {?} */ optionsChecked_2 = [];
            this.multiselectValues = [];
            if (selectedItem.hasOwnProperty('checked')) {
                selectedItem.checked = !selectedItem.checked;
                this.filteredOptions.forEach(function (row) {
                    if (row.checked) {
                        optionsChecked_2.push(row[_this.valuefield]);
                        _this.multiselectValues.push(row);
                    }
                });
                this.innerValue = optionsChecked_2;
                this.displayValue = this.setMultiSelect();
                this.onMultiSelect.emit(this.multiselectValues);
            }
        }
        else {
            this.value = selectedItem[this.valuefield]; // Issue here?
            this.displayValue = this.displayFieldService.findValue(this.displayfield, selectedItem);
            this.multiselect ? this.showToolTip = true : this.showToolTip = false;
            this.onSingleSelect.emit(selectedItem);
        }
        this.isValid = true;
        this.isComponentValid.emit(true);
    };
    /**
     * @return {?}
     */
    AmexioDropDownComponent.prototype.setMultiSelectData = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.multiselectValues = [];
        if (this.innerValue && this.innerValue.length > 0) {
            var /** @type {?} */ modelValue_1 = this.innerValue;
            this.filteredOptions.forEach(function (test) {
                modelValue_1.forEach(function (mdValue) {
                    if (test[_this.valuefield] === mdValue) {
                        if (test.hasOwnProperty('checked')) {
                            test.checked = true;
                        }
                        _this.multiselectValues.push(test);
                    }
                });
            });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownComponent.prototype.navigateKey = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
    };
    /**
     * @return {?}
     */
    AmexioDropDownComponent.prototype.getDisplayText = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.innerValue != null || this.innerValue !== '') {
            if (this.multiselect) {
                this.displayValue = this.setMultiSelect();
            }
            else {
                this.displayValue = '';
                this.filteredOptions.forEach(function (test) {
                    if (test[_this.valuefield] === _this.innerValue) {
                        _this.displayValue = _this.displayFieldService.findValue(_this.displayfield, test);
                    }
                });
                this.displayValue = this.displayValue === undefined ? '' : this.displayValue;
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioDropDownComponent.prototype.setMultiSelect = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.setMultiSelectData();
        var /** @type {?} */ multiselectDisplayString = '';
        this.multiselectValues.forEach(function (row) {
            multiselectDisplayString === '' ? multiselectDisplayString +=
                _this.displayFieldService.findValue(_this.displayfield, row) : multiselectDisplayString += ', '
                + _this.displayFieldService.findValue(_this.displayfield, row);
        });
        if (this.multiselectValues.length > 0) {
            return multiselectDisplayString;
        }
        else {
            return '';
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownComponent.prototype.onDropDownClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onBaseFocusEvent(event);
        this.showToolTip = true;
        this.onClick.emit(event);
        if (!this.multiselect && this.selectedindex > -1) {
            this.filteredOptions[this.selectedindex].selected = false;
            this.selectedindex = -1;
            this.selectedindex = this.selectedindex + 1;
            this.filteredOptions[this.selectedindex].selected = true;
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.selectedindex].index);
            this.generateScroll(this.selectedindex);
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    AmexioDropDownComponent.prototype.generateScroll = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        var /** @type {?} */ listitems = this.element.nativeElement.getElementsByClassName('list-items')[index];
        if (listitems) {
            listitems.scrollIntoView({ behavior: 'smooth' });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownComponent.prototype.focusToLast = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.selectedindex > -1) {
            this.filteredOptions[this.selectedindex].selected = false;
            this.selectedindex = this.filteredOptions.length - 1;
            this.filteredOptions[this.filteredOptions.length - 1].selected = true;
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.filteredOptions.length - 1].index);
            this.generateScroll(this.selectedindex);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownComponent.prototype.closeOnEScape = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.showToolTip = false;
        this.hide();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownComponent.prototype.onChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.innerValue = event;
        this.isValid = true;
        this.getDisplayText();
        this.isComponentValid.emit(true);
    };
    /**
     * @param {?} input
     * @return {?}
     */
    AmexioDropDownComponent.prototype.onInput = /**
     * @param {?} input
     * @return {?}
     */
    function (input) {
        this.input.emit();
        this.isValid = input.valid;
        this.isComponentValid.emit(input.valid);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownComponent.prototype.onDropDownSearchKeyUp = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (this.search && this.viewData) {
            var /** @type {?} */ keyword = event.target.value;
            if (keyword != null && keyword !== '' && keyword !== ' ') {
                this.filteredOptions = [];
                var /** @type {?} */ search_Term_1 = keyword.toLowerCase();
                this.viewData.forEach(function (row) {
                    if (_this.displayFieldService.findValue(_this.displayfield, row).toLowerCase().startsWith(search_Term_1)) {
                        _this.filteredOptions.push(row);
                    }
                });
            }
            if (keyword === '') {
                this.filteredOptions = this.viewData;
            }
        }
        if (event.keyCode === 8) {
            this.innerValue = '';
        }
        if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            this.navigateUsingKey(event);
        }
        this.onBaseFocusEvent({});
    };
    // navigate using keys
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownComponent.prototype.navigateUsingKey = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.showToolTip) {
            this.showToolTip = true;
        }
        if (this.selectedindex > this.filteredOptions.length) {
            this.selectedindex = 0;
        }
        if (event.keyCode === 40 || event.keyCode === 38 && this.selectedindex <
            this.filteredOptions.length) {
            var /** @type {?} */ prevselectedindex = -1;
            prevselectedindex = this.selectedindex;
            if (event.keyCode === 40) {
                this.selectedindex++;
            }
            else if (event.keyCode === 38) {
                this.selectedindex--;
            }
            this.navigateFilterOptions(prevselectedindex);
        }
        if (event.keyCode === 13 && this.filteredOptions[this.selectedindex]) {
            this.onItemSelect(this.filteredOptions[this.selectedindex]);
        }
    };
    // for highlight  navigated options
    /**
     * @param {?} previndex
     * @return {?}
     */
    AmexioDropDownComponent.prototype.navigateFilterOptions = /**
     * @param {?} previndex
     * @return {?}
     */
    function (previndex) {
        if (this.filteredOptions[this.selectedindex]) {
            this.filteredOptions[this.selectedindex].selected = true;
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.selectedindex].index);
        }
        if (this.filteredOptions[previndex]) {
            this.filteredOptions[previndex].selected = false;
            this.toNavigateFirstAndLastOption();
        }
        this.generateScroll(this.selectedindex);
    };
    // to navigate first and last option
    /**
     * @return {?}
     */
    AmexioDropDownComponent.prototype.toNavigateFirstAndLastOption = /**
     * @return {?}
     */
    function () {
        if (this.selectedindex === -1) {
            this.selectedindex = this.filteredOptions.length - 1;
            this.filteredOptions[this.filteredOptions.length - 1].selected = true;
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.filteredOptions.length - 1].index);
        }
        else if (this.selectedindex === this.filteredOptions.length) {
            this.selectedindex = 0;
            this.filteredOptions[this.selectedindex].selected = true;
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute(this.activedescendant, this.filteredOptions[this.selectedindex].index);
        }
    };
    Object.defineProperty(AmexioDropDownComponent.prototype, "value", {
        // get accessor
        get: /**
         * @return {?}
         */
        function () {
            return this.innerValue;
        },
        // set accessor including call the onchange callback
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v != null && v !== this.innerValue) {
                this.innerValue = v;
                this.onChangeCallback(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    // Set touched on blur
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownComponent.prototype.onblur = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.target && event.target.value && this.filteredOptions &&
            this.filteredOptions.length === 1) {
            var /** @type {?} */ fvalue = event.target.value;
            var /** @type {?} */ row = this.filteredOptions[0];
            var /** @type {?} */ rvalue = this.displayFieldService.findValue(this.displayfield, row);
            if (fvalue && rvalue && (fvalue.toLowerCase() === rvalue.toLowerCase())) {
                this.onItemSelect(row);
            }
        }
        this.onTouchedCallback();
        this.onBaseBlurEvent(event);
        this.onBlur.emit();
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioDropDownComponent.prototype.onFocus = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        this.onBaseFocusEvent(elem);
        this.showToolTip = true;
        this.posixUp = this.getListPosition(elem);
        this.focus.emit();
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioDropDownComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ dropdownHeight = 325; // must be same in dropdown.scss
        if (window.screen.height - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
            return true;
        }
        else {
            return false;
        }
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioDropDownComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value != null) {
            this.writeChangedValue(value);
        }
        else {
            this.innerValue = '';
            if (this.allowblank) {
                this.isValid = true;
            }
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioDropDownComponent.prototype.writeChangedValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var _this = this;
        if (value !== this.innerValue) {
            var /** @type {?} */ status_1 = false;
            if (this.viewData && this.viewData.length > 0) {
                this.viewData.forEach(function (item) {
                    if (item[_this.valuefield] === value) {
                        _this.isValid = true;
                        _this.displayValue = _this.displayFieldService.findValue(_this.displayfield, item);
                        status_1 = true;
                        return;
                    }
                });
            }
            if (!status_1) {
                this.displayValue = '';
            }
            this.value = value;
        }
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioDropDownComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioDropDownComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @return {?}
     */
    AmexioDropDownComponent.prototype.onIconClick = /**
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            var /** @type {?} */ showflag = this.showToolTip;
            if (!this.showToolTip) {
                this.onBaseFocusEvent({});
            }
            else {
                this.onBaseBlurEvent({});
            }
            this.showToolTip = !showflag;
        }
    };
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    AmexioDropDownComponent.prototype.checkValidity = /**
     * @return {?}
     */
    function () {
        return this.isValid;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioDropDownComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return ((!this.allowblank && (this.value || this.value === 0)) || this.allowblank) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    AmexioDropDownComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-dropdown',
                    template: "\n    <div class=\"inputgroup\" #rootDiv (keyup.esc)=\"closeOnEScape($event)\">\n\n        <label id=\"fieldlabel\" for=\"input\" *ngIf=\"haslabel\" [style.font-style]=\"fontstyle\" [style.font-family]=\"fontfamily\" [style.font-size]=\"fontsize\">\n        {{fieldlabel}}\n      </label>\n\n        <input type=\"hidden\" [ngModel]=\"value\" (ngModelChange)=\"onChange($event)\" #inp=\"ngModel\" />\n        <input id=\"{{componentId}}\" tabindex=\"1\" aria-autocomplete=\"list\" role=\"combobox\" [attr.aria-expanded]=\"showToolTip\" [attr.aria-activedescendant]=\"\" type=\"text\" class=\"input-control\" [value]=\"displayValue\" [ngClass]=\"{'input-control-error' : inp.invalid && !displayValue && (inp.dirty || inp.touched),\n             'input-control-success' : inp.valid && displayValue && (inp.dirty || inp.touched)}\" (input)=\"onInput(inp)\" (blur)=\"onblur($event)\" (focus)=\"onFocus(rootDiv)\" (click)=\" onDropDownClick($event)\" [attr.placeholder]=\"placeholder\" [readonly]=\"readonly ? true : null\"\n            [attr.disabled]=\"disabled ? true: null\" [required]=\"!allowblank\" (keyup.end)=\"focusToLast($event)\" (keyup)=\"onDropDownSearchKeyUp($event)\" (keyup.enter)=\"closeOnEScape($event)\" (keydown)=\"navigateKey($event)\" />\n\n        <span class=\"drodown-caret-down\" role=\"listbox\" [attr.aria-expanded]=\"showToolTip\" (click)=\"onIconClick()\">\n        <amexio-c-icon key=\"dropdown_caret\" *ngIf=\"!maskloader\"></amexio-c-icon>\n        <em class=\"fa fa-spinner fa-spin\" *ngIf=\"maskloader\"></em>\n      </span>\n\n        <span #dropdownitems class=\"dropdown\" [ngClass]=\"{'dropdown-up' : posixUp}\" [ngStyle]=\"dropdownstyle\">\n        <ul aria-labelledby=\"fieldlabel\" aria-haspopup=\"listbox\" class=\"dropdown-list\">\n\n          <li role=\"option\" tabindex=\"1\" class=\"list-items\" [ngClass]=\"{'list-items-selected':item.selected}\" *ngFor=\"let item of filteredOptions\"\n            id=\"{{item.index}}\" (mousedown)=\"onItemSelect(item)\" (click)=\"onItemSelect(item)\">\n            <ng-container *ngIf=\"bodyTemplate\">\n              <ng-template [ngTemplateOutlet]=\"bodyTemplate\" [ngTemplateOutletContext]=\"{ $implicit: { text : row }, row: item }\">\n              </ng-template>\n            </ng-container>\n            <ng-container *ngIf=\"!bodyTemplate\">\n              <span>\n                <amexio-display-field [data]=\"item\" [data-index]=\"displayfield\"></amexio-display-field>\n              </span>\n\n        </ng-container>\n        <span style=\"float : right\">{{item?.checked ? '&#10004;': ''}}</span>\n        </li>\n    \n        <ng-template *ngIf=\"filteredOptions && (filteredOptions.length < 1)\">\n            <li class=\"list-items\">No Options</li>\n        </ng-template>\n        </ul>\n        <ng-content></ng-content>\n        </span>\n        <span class=\"inputfieldbar\"></span>\n    </div>\n    <span *ngIf=\"showToolTip && enablepopover\" class=\"tooltiptext\">\n      <div [innerHTML]=\"helpInfoMsg\"></div>\n    </span>\n\n    <span *ngIf=\"iconfeedback && (inp.invalid && (inp.dirty || inp.touched) || inp.valid)\" class=\"input-control-feedback\">\n      <span *ngIf=\"inp.invalid && (inp.dirty || inp.touched)\">&#9888;</span>\n    <span *ngIf=\"inp.valid && (inp.dirty || inp.touched)\"> &#10004;</span>\n\n    </span>\n  ",
                    animations: [
                        trigger('changeState', [
                            state('visible', style({
                                'max-height': '200px',
                            })),
                            state('hidden', style({
                                'max-height': '0px',
                            })),
                            transition('*=>*', animate('200ms')),
                        ]),
                    ],
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioDropDownComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioDropDownComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioDropDownComponent.ctorParameters = function () { return [
        { type: CommonDataService },
        { type: DisplayFieldService },
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: i0.ChangeDetectorRef }
    ]; };
    AmexioDropDownComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        allowblank: [{ type: i0.Input, args: ['allow-blank',] }],
        data: [{ type: i0.Input, args: ['data',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        valuefield: [{ type: i0.Input, args: ['value-field',] }],
        search: [{ type: i0.Input }],
        readonly: [{ type: i0.Input }],
        multiselect: [{ type: i0.Input, args: ['multi-select',] }],
        dropdownitems: [{ type: i0.ViewChild, args: ['dropdownitems', { read: i0.ElementRef },] }],
        onBlur: [{ type: i0.Output }],
        input: [{ type: i0.Output }],
        focus: [{ type: i0.Output }],
        onSingleSelect: [{ type: i0.Output }],
        onMultiSelect: [{ type: i0.Output }],
        onClick: [{ type: i0.Output }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        disabled: [{ type: i0.Input }],
        iconfeedback: [{ type: i0.Input, args: ['icon-feedback',] }],
        fontstyle: [{ type: i0.Input, args: ['font-style',] }],
        fontfamily: [{ type: i0.Input, args: ['font-family',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        haslabel: [{ type: i0.Input, args: ['has-label',] }],
        enablepopover: [{ type: i0.Input, args: ['enable-popover',] }],
        enablesort: [{ type: i0.Input, args: ['enable-sort',] }],
        sort: [{ type: i0.Input, args: ['sort',] }],
        errormsg: [{ type: i0.Input, args: ['error-msg',] }],
        bodyTemplate: [{ type: i0.ContentChild, args: ['amexioBodyTmpl',] }],
        isComponentValid: [{ type: i0.Output }],
        name: [{ type: i0.Input, args: ['name',] }]
    };
    return AmexioDropDownComponent;
}(EventBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by  Pratik on 7/2/18.
*/
var AmexioLabelComponent = /** @class */ (function () {
    function AmexioLabelComponent() {
        this.enableclick = false;
        // For internal use
        this.blackLabel = false;
        this.onClick = new i0.EventEmitter();
        this.tempStyleArray = ['large', 'medium', 'small', 'bold', 'large-bold', 'medium-bold', 'small-bold',
            'large-44', 'large-24', 'large-50', 'large-54', 'large-56', 'large-60', 'large-64', 'large-68', 'large-78', 'large-9vw',
            'large-44-bold', 'large-50-bold', 'large-24-bold', 'large-4vw', 'large-4vw-bold',
            'large-54-bold', 'large-56-bold', 'large-60-bold', 'large-64-bold', 'large-68-bold', 'large-78-bold', 'large-9vw-bold'];
    }
    /**
     * @return {?}
     */
    AmexioLabelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.styleClass == null) {
            this.styleClass = 'small';
        }
        else {
            this.styleClass = this.tempStyleArray.find(function (x) { return x === _this.styleClass; });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioLabelComponent.prototype.onLabel = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.enableclick) {
            this.onClick.emit(event);
        }
    };
    AmexioLabelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-label',
                    template: "\n  <label [ngClass]=\"{'labelFontClass': blackLabel}\" style=\"outline: none\"\n  role=\"text\" tabindex=\"1\" class=\"label-content {{styleClass}}\" (click)=\"onLabel($event)\"\n    [ngStyle]=\"{'color' : fontColor,'cursor': enableclick ? 'pointer': 'text'}\">\n    <ng-content></ng-content>\n    <span class=\"label-badge\" *ngIf=\"badge\">{{badge}}</span>\n  </label>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioLabelComponent.ctorParameters = function () { return []; };
    AmexioLabelComponent.propDecorators = {
        badge: [{ type: i0.Input, args: ['badge',] }],
        styleClass: [{ type: i0.Input, args: ['size',] }],
        fontColor: [{ type: i0.Input, args: ['font-color',] }],
        enableclick: [{ type: i0.Input, args: ['enable-click',] }],
        blackLabel: [{ type: i0.Input }],
        onClick: [{ type: i0.Output }]
    };
    return AmexioLabelComponent;
}());

var __extends$7 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioNumberInputComponent = /** @class */ (function (_super) {
    __extends$7(AmexioNumberInputComponent, _super);
    function AmexioNumberInputComponent() {
        var _this = _super.call(this) || this;
        _this.isValid = false;
        /*
          Events
          name : onBlur
          datatype : any
          version : 4.0 onwards
          default :
          description : On blur event
          */
        _this.onBlur = new i0.EventEmitter();
        /*
         Events
         name : input
         datatype : any
         version : none
         default :
         description : 	On input event field.
         */
        _this.input = new i0.EventEmitter();
        /*
         Events
         name : focus
         datatype : any
         version : none
         default :
         description : On focus event field.
         */
        _this.focus = new i0.EventEmitter();
        /*
         Events
         name : change
         datatype : any
         version : none
         default :
         description : On field value change event
         */
        _this.change = new i0.EventEmitter();
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : true
        description : Flag to set label
        */
        _this.haslabel = true;
        _this.showToolTip = false;
        return _this;
    }
    Object.defineProperty(AmexioNumberInputComponent.prototype, "pattern", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pattern;
        },
        /*
      Properties
      name : pattern
      datatype : string
      version : 4.0 onwards
      default :
      description : Apply Reg-ex to the field
      */
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value != null) {
                this.regEx = new RegExp(this.pattern);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioNumberInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.createCompId('numberinput', this.name);
        this.name = this.generateName(this.name, this.fieldlabel, 'numberinput');
    };
    // THIS METHOD USED FOR BLUR EVENT.
    /**
     * @return {?}
     */
    AmexioNumberInputComponent.prototype.onBlurEvent = /**
     * @return {?}
     */
    function () {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    };
    // THIS METHOD USED FOR FOCUS EVENT .
    /**
     * @return {?}
     */
    AmexioNumberInputComponent.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.showToolTip = true;
        this.focus.emit(this.value);
    };
    // THIS METHOD USED FOR  INPUT EVENT .
    /**
     * @return {?}
     */
    AmexioNumberInputComponent.prototype.onInput = /**
     * @return {?}
     */
    function () {
        this.isValid = this.isFieldValidate();
        this.input.emit(this.value);
    };
    // THIS METHOD USED FOR CHANGE EVENT  .
    /**
     * @return {?}
     */
    AmexioNumberInputComponent.prototype.onChangeEv = /**
     * @return {?}
     */
    function () {
        this.change.emit(this.value);
    };
    // THIS METHOD FOR KEYBORAD KEY HOME PRESS.
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNumberInputComponent.prototype.onKeyUpHome = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.value = this.minvalue;
    };
    // THIS METHOD FOR KEYBORAD KEY END PRESS.
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNumberInputComponent.prototype.onKeyUpEnd = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.value = this.maxvalue;
    };
    /**
     * @return {?}
     */
    AmexioNumberInputComponent.prototype.isFieldValidate = /**
     * @return {?}
     */
    function () {
        if (this.minvalue && !this.maxvalue) {
            return this.innerValue && (this.innerValue >= this.minvalue);
        }
        else if (!this.minvalue && this.maxvalue) {
            return this.innerValue && (this.innerValue <= this.maxvalue);
        }
        else if (!this.minvalue && !this.maxvalue && this.innerValue) {
            return true;
        }
        else {
            return this.innerValue && (this.innerValue >= this.minvalue && this.innerValue <= this.maxvalue);
        }
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioNumberInputComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        var /** @type {?} */ isValid = (!this.allowblank && this.isFieldValidate()) || this.allowblank;
        return isValid ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    AmexioNumberInputComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-number-input',
                    template: "\n\n\n\n    <div class=\"inputgroup\">\n\n      <label *ngIf=\"haslabel\" role=\"number\"  id=\"{{componentId}}\"  [style.font-style]=\"fontstyle\" [style.font-family]=\"fontfamily\" [style.font-size]=\"fontsize\">\n          {{fieldlabel}}\n      </label>\n\n      <input type=\"number\" \n\n\n            role=\"number\"\n            tabindex=\"1\"\n       \n            aria-describedby=\"numberDes\"\n            attr.aria-labelledby=\"{{componentId}}\"\n            [attr.aria-required]=\"!allowblank\"\n            [attr.aria-invalid]=\"!isValid \"\n            (keyup.home)=\"onKeyUpHome($event)\"\n            (keyup.end)=\"onKeyUpEnd($event)\"\n\n\n\n             class=\"input-control\"\n             [ngClass]=\"model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''\"\n             [(ngModel)]=\"value\"\n             (blur)=\"onBlurEvent()\" \n             (focus)=\"onFocus()\" \n             (input)=\"onInput()\" \n             (change)=\"onChangeEv()\"\n             [name]=\"name\" \n             [pattern]=\"regEx\"\n             [attr.placeholder]=\"placeholder\" \n             [attr.max]=\"maxvalue\" \n             [attr.min]=\"minvalue\" \n             [attr.disabled]=\"disabled ? true: null\"\n             [required]=\"!allowblank\" />\n\n\n      <ng-container *ngIf=\"iconfeedback\">\n          <span class=\"input-control-feedback\">\n              <span *ngIf=\"!isValid && model.touched\"><em class=\"fa fa-times\"></em></span>\n              <span *ngIf=\"isValid && model.touched\"><em class=\"fa fa-check\"></em></span>\n          </span>\n      </ng-container>\n\n      <input-help *ngIf=\"showToolTip && enablepopover\"\n\n      id=\"numberDes\"\n      role=\"tooltip\"\n\n      [error-msg]=\"errormsg\" \n      [max-error-msg]=\"maxerrormsg\"\n      [min-error-msg]=\"minerrormsg\"\n      [min-value]=\"minvalue\"\n      [max-value]=\"maxvalue\"\n      [min-msg]=\"minmsg\" \n      [max-msg]=\"maxmsg\"\n      [is-number]=\"true\"\n      >\n      </input-help>\n  \n      <span class=\"inputfieldbar\"></span>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioNumberInputComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioNumberInputComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioNumberInputComponent.ctorParameters = function () { return []; };
    AmexioNumberInputComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        allowblank: [{ type: i0.Input, args: ['allow-blank',] }],
        minvalue: [{ type: i0.Input, args: ['min-value',] }],
        maxvalue: [{ type: i0.Input, args: ['max-value',] }],
        minerrormsg: [{ type: i0.Input, args: ['min-error-msg',] }],
        maxerrormsg: [{ type: i0.Input, args: ['max-error-msg',] }],
        errormsg: [{ type: i0.Input, args: ['error-msg',] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        disabled: [{ type: i0.Input }],
        onBlur: [{ type: i0.Output }],
        input: [{ type: i0.Output }],
        focus: [{ type: i0.Output }],
        change: [{ type: i0.Output }],
        iconfeedback: [{ type: i0.Input, args: ['icon-feedback',] }],
        fontstyle: [{ type: i0.Input, args: ['font-style',] }],
        fontfamily: [{ type: i0.Input, args: ['font-family',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        haslabel: [{ type: i0.Input, args: ['has-label',] }],
        name: [{ type: i0.Input, args: ['name',] }],
        pattern: [{ type: i0.Input, args: ['pattern',] }],
        enablepopover: [{ type: i0.Input, args: ['enable-popover',] }],
        model: [{ type: i0.ViewChild, args: [forms.NgModel,] }]
    };
    return AmexioNumberInputComponent;
}(ValueAccessorBase));

var __extends$8 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by  Pratik on 27/11/17.
*/
var AmexioRadioGroupComponent = /** @class */ (function (_super) {
    __extends$8(AmexioRadioGroupComponent, _super);
    // The internal dataviews model
    // private innerValue: any = '';
    function AmexioRadioGroupComponent(amxHttp, cd) {
        var _this = _super.call(this) || this;
        _this.amxHttp = amxHttp;
        _this.cd = cd;
        /*
           Properties
           name : default-value
           datatype : string
           version : 4.0 onwards
           default :
           description : Default Value to be checked
           */
        _this.defaultSelectedValue = '';
        /*
           Properties
           name : data
           datatype : any
           version : 4.0 onwards
           default :
           description : 	Local data for radio group.
           */
        _this.data = [];
        /*
           Events
           name : onSelection
           datatype : any
           version : 4.0 onwards
           default :
           description : Fires selection event
           */
        _this.onSelection = new i0.EventEmitter();
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        // private onTouchedCallback: () => void = noop;
        // private onChangeCallback: (_: any) => void = noop;
        _this.isComponentValid = new i0.EventEmitter();
        _this.tabFocus = false;
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.componentId = this.createCompId('radiogroup', this.name);
        this.name = this.generateName(this.name, this.fieldlabel, 'radiogroup');
        if (this.defaultSelectedValue) {
            this.value = this.defaultSelectedValue;
        }
        this.isValid = this.allowblank;
        this.isComponentValid.emit(this.allowblank);
        if (this.httpmethod && this.httpurl) {
            this.amxHttp.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.data = _this.getResponseData(response);
            });
        }
        else if (this.data != null) {
            this.data = this.getResponseData(this.data);
        }
    };
    /**
     * @param {?} viewData
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.checkDefaultValidation = /**
     * @param {?} viewData
     * @return {?}
     */
    function (viewData) {
        var _this = this;
        viewData.forEach(function (opt) {
            opt['tabindex'] = '-1';
            opt['radioId'] = 'radio' + '_' + opt[_this.valuefield] + '_' + _this.getRandomString();
            if (opt[_this.valuefield] === _this.innerValue || (opt.hasOwnProperty('selected') && opt.selected)) {
                _this.isValid = true;
                opt['selected'] = true;
                opt['tabindex'] = '0';
                _this.isComponentValid.emit(true);
                return;
            }
            else {
                opt['selected'] = false;
                var /** @type {?} */ tempArray_1 = [];
                viewData.forEach(function (option) {
                    if (option.selected === false) {
                        tempArray_1.push('0');
                        if (tempArray_1.length === viewData.length) {
                            viewData[0].tabindex = '0';
                        }
                    }
                });
            }
        });
    };
    /**
     * @param {?} viewData
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.checkSelectedFlag = /**
     * @param {?} viewData
     * @return {?}
     */
    function (viewData) {
        var _this = this;
        viewData.forEach(function (opt) {
            if (_this.innerValue === '' && (opt.hasOwnProperty('selected') && opt.selected)) {
                _this.value = opt[_this.valuefield];
                opt.tabindex = '0';
                return;
            }
        });
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.getResponseData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            if (dr != null) {
                for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                    var ir = dr_1[_i];
                    responsedata = responsedata[ir];
                }
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.checkSelectedFlag(responsedata);
        if (!this.allowblank) {
            this.checkDefaultValidation(responsedata);
        }
        return responsedata;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
            this.checkDefaultValidation(this.data);
        }
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    Object.defineProperty(AmexioRadioGroupComponent.prototype, "value", {
        // get accessor
        get: /**
         * @return {?}
         */
        function () {
            return this.innerValue;
        },
        // set accessor including call the onchange callback
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v !== this.innerValue) {
                this.innerValue = v;
                this.onChangeCallback(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.tabFocus = false;
        this.onTouchedCallback();
    };
    /**
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.tabFocus = true;
    };
    /**
     * @param {?} row
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.onClick = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
            var r = _a[_i];
            if (r.selected) {
                r.selected = false;
            }
        }
        for (var _b = 0, _c = this.data; _b < _c.length; _b++) {
            var r = _c[_b];
            if (r === row) {
                r.selected = true;
                this.isValid = true;
                this.value = row[this.valuefield];
                this.listCopy = Object.assign([], row);
                delete this.listCopy.tabindex;
                delete this.listCopy.radioId;
                this.onSelection.emit(this.listCopy);
                delete row.tabindex;
                this.isComponentValid.emit(true);
                this.onSelection.emit(row);
            }
            else {
                r.selected = false;
            }
        }
    };
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.checkValidity = /**
     * @return {?}
     */
    function () {
        return this.isValid;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioRadioGroupComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return ((!this.allowblank && this.value) || this.allowblank) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    AmexioRadioGroupComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-radio-group',
                    template: "\n    <div role=\"radiogroup\" [attr.name]=\"name\"  attr.aria-labelledby=\"{{componentId}}\" [attr.aria-disabled]=\"disabled\"\n      [attr.aria-required]=\"!allowblank\" class=\"inputgroup from-group\">\n      <div *ngIf=\"fieldlabel\">\n        <legend style=\"margin-bottom: .6rem; margin-top: 5px;\" id=\"{{componentId}}\">{{fieldlabel}}</legend>\n      </div>\n\n      <ng-container *ngIf=\"horizontal\">\n        <ng-container *ngFor=\"let rData of data let index=index\">\n          <label for=\"{{name+rData[displayfield]+index}}\" \n          [attr.aria-checked]=\"value\" \n          [attr.aria-disabled]=\"rData.disabled\"\n     \n            class=\"input-box-container\" style=\"padding-bottom:0px !important; margin: 5px !important\" (click)=\"onClick(rData)\"\n            [ngClass]=\"{'disable-component' : rData.disabled || disabled}\">\n            {{rData[displayfield]}}\n\n            <input [attr.tabindex]=\"disabled ? -1 : 1\"\n            style=\"top:0; left:0\" id=\"{{name+rData[displayfield]+index}}\"\n             type=\"radio\" \n\n              [required]=\"!allowblank\"\n               [attr.name]=\"name\" \n               [value]=\"rData?.selected ? rData[valuefield] : rData[valuefield] \"\n              [attr.disabled]=\"rData?.disabled ? true: null\" \n              (focus)=\"onFocus()\"\n              (blur)=\"onBlur()\"\n              [checked]=\"(value === rData[valuefield] || rData.selected)\">\n\n            <span class=\"input-box-radiobox-label\" [ngClass]=\"{'focusOnCheckbox':tabFocus}\" ></span>\n          </label>\n        </ng-container>\n      </ng-container>\n\n      <ng-container *ngIf=\"!horizontal\">\n        <ng-container *ngFor=\"let rData of data let index=index\">\n          <div>\n            <label for=\"{{name+rData[displayfield]+index}}\" [attr.aria-checked]=\"value\" [attr.aria-disabled]=\"rData.disabled\"\n              class=\"input-box-container\" style=\"padding-bottom:0px !important; margin: 5px !important\" (click)=\"onClick(rData)\"\n              [ngClass]=\"{'disable-component' : rData.disabled || disabled}\">{{rData[displayfield]}}\n              <input style=\"top:0; left:0\" id=\"{{name+rData[displayfield]+index}}\" type=\"radio\"\n              [attr.tabindex]=\"disabled ? -1 : 1\" [required]=\"!allowblank\" [attr.name]=\"name\" [value]=\"rData?.selected ? rData[valuefield] : rData[valuefield] \"\n              (focus)=\"onFocus()\"\n              (blur)=\"onBlur()\"\n              [attr.disabled]=\"rData?.disabled ? true: null\" [(ngModel)]=\"rData?.selected ? rData[valuefield] : value\"\n                [checked]=\"(value === rData[valuefield] || rData.selected)\">\n              <span class=\"input-box-radiobox-label\" [ngClass]=\"{'focusOnCheckbox':tabFocus}\"></span>\n            </label>\n          </div>\n        </ng-container>\n      </ng-container>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioRadioGroupComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: AmexioRadioGroupComponent, multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioRadioGroupComponent.ctorParameters = function () { return [
        { type: CommonDataService },
        { type: i0.ChangeDetectorRef }
    ]; };
    AmexioRadioGroupComponent.propDecorators = {
        allowblank: [{ type: i0.Input, args: ['allow-blank',] }],
        name: [{ type: i0.Input }],
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        valuefield: [{ type: i0.Input, args: ['value-field',] }],
        defaultSelectedValue: [{ type: i0.Input, args: ['default-value',] }],
        horizontal: [{ type: i0.Input }],
        data: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        onSelection: [{ type: i0.Output }],
        isComponentValid: [{ type: i0.Output }]
    };
    return AmexioRadioGroupComponent;
}(ValueAccessorBase));

var __extends$9 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioRatingComponent = /** @class */ (function (_super) {
    __extends$9(AmexioRatingComponent, _super);
    function AmexioRatingComponent() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /*
          Properties
          name : icon-class
          datatype : string
          version : 4.0 onwards
          default : star-icon
          description : Sets if custom icon class is required
          */
        _this.iconclass = 'star-icon';
        /*
          Properties
          name : full-icon
          datatype : string
          version : 4.0 onwards
          default :
          description : 	Icon for selected rating .This attribute is useful only
          when user have custom rating icons.example
          */
        _this.fullicon = '';
        /*
          Properties
          name : empty-icon
          datatype : string
          version : 4.0 onwards
          default :
          description : Icon for non-selected rating .This attribute is useful only
          when user have custom rating icons.example
          */
        _this.emptyicon = '';
        /*
          Properties
          name : titles
          datatype : string array
          version : 4.0 onwards
          default : 1,2,3..
          description : Array of titles
          */
        _this.titles = [];
        _this.ratingRangeData = [];
        // -------------------------------------------------------------------------
        // Outputs
        // -------------------------------------------------------------------------
        /*
          Events
          name : onHover
          datatype : any
          version : 4.0 onwards
          default :
          description : Fires on hovering component
          */
        _this.onHover = new i0.EventEmitter();
        /*
          Events
          name : onLeave
          datatype : any
          version : 4.0 onwards
          default :
          description : fires on leaving component and returns its value
          */
        _this.onLeave = new i0.EventEmitter();
        _this.hovered = 0;
        _this.hoveredPercent = undefined;
        _this._max = 5;
        return _this;
    }
    Object.defineProperty(AmexioRatingComponent.prototype, "max", {
        get: /**
         * @return {?}
         */
        function () {
            return this._max;
        },
        /*
        Properties
        name : max
        datatype : number
        version : 4.0 onwards
        default :
        description : Number of stars for rating component.
        */
        set: /**
         * @param {?} max
         * @return {?}
         */
        function (max) {
            this._max = max;
            this.buildRanges();
        },
        enumerable: true,
        configurable: true
    });
    // -------------------------------------------------------------------------
    // Implemented from ControlValueAccessor
    // -------------------------------------------------------------------------
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioRatingComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.model = value;
        this.setAttribute(value);
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioRatingComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioRatingComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouched = fn;
    };
    // -------------------------------------------------------------------------
    // Implemented from Va..
    // -------------------------------------------------------------------------
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioRatingComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        if (this.required && !c.value) {
            return {
                required: true,
            };
        }
        return null;
    };
    // -------------------------------------------------------------------------
    // Lifecycle callbacks
    // -------------------------------------------------------------------------
    /**
     * @return {?}
     */
    AmexioRatingComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.createCompId('rating', this.fieldlabel);
        this.starId = 'star' + Math.floor(Math.random() * 1000 + 999);
        for (var /** @type {?} */ i = 0; i < this.ratingRange.length; i++) {
            var /** @type {?} */ obj = {};
            obj['number'] = i + 1;
            obj['selected'] = false;
            obj['tabindex'] = '-1';
            this.ratingRangeData.push(obj);
        }
        this.buildRanges();
    };
    // -------------------------------------------------------------------------
    // Public Methods
    // -------------------------------------------------------------------------
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioRatingComponent.prototype.calculateWidth = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (this.hovered > 0) {
            if (this.hoveredPercent !== undefined && this.hovered === item) {
                return this.hoveredPercent;
            }
            else {
                return this.hovered >= item ? 100 : 0;
            }
        }
        else {
            return this.model >= item ? 100 : 100 - Math.round((item - this.model) * 10) * 10;
        }
    };
    /**
     * @param {?} hovered
     * @return {?}
     */
    AmexioRatingComponent.prototype.setHovered = /**
     * @param {?} hovered
     * @return {?}
     */
    function (hovered) {
        if (!this.readonly && !this.disabled) {
            this.hovered = hovered;
            this.onHover.emit(hovered);
            this.ratingMethod(hovered);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioRatingComponent.prototype.changeHovered = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.float) {
            return;
        }
        var /** @type {?} */ target = /** @type {?} */ (event.target);
        var /** @type {?} */ relativeX = event.pageX - target.offsetLeft;
        var /** @type {?} */ percent = Math.round((relativeX * 100 / target.offsetWidth) / 10) * 10;
        this.hoveredPercent = percent > 50 ? 100 : 50;
    };
    /**
     * @return {?}
     */
    AmexioRatingComponent.prototype.resetHovered = /**
     * @return {?}
     */
    function () {
        this.hovered = 0;
        this.hoveredPercent = undefined;
        this.onLeave.emit(this.hovered);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioRatingComponent.prototype.rate = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (!this.readonly && !this.disabled && value >= 0 && value <= this.ratingRange.length) {
            this.setAttribute(value);
            var /** @type {?} */ newValue = this.hoveredPercent ? (value - 1) + this.hoveredPercent / 100 : value;
            this.onChange(newValue);
            this.model = newValue;
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioRatingComponent.prototype.rate1 = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.ratingMethod(item);
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioRatingComponent.prototype.setAttribute = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.ratingRangeData.forEach(function (element) {
            element.selected = false;
            element.tabindex = '-1';
            if (value >= element.number) {
                element.selected = true;
            }
            if (value === element.number) {
                element.tabindex = 0;
            }
        });
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioRatingComponent.prototype.ratingMethod = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.ratingRangeData.forEach(function (element) {
            element.selected = false;
            if (item + 1 >= element.number) {
                element.selected = true;
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioRatingComponent.prototype.buildRanges = /**
     * @return {?}
     */
    function () {
        this.ratingRange = this.range(1, this.max);
    };
    /**
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    AmexioRatingComponent.prototype.range = /**
     * @param {?} start
     * @param {?} end
     * @return {?}
     */
    function (start, end) {
        var /** @type {?} */ foo = [];
        for (var /** @type {?} */ i = start; i <= end; i++) {
            foo.push(i);
        }
        return foo;
    };
    AmexioRatingComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-rating-input',
                    template: "\n    <div tabindex=\"1\" role=\"radiogroup\" attr.aria-labelledby=\"{{componentId}}\" class=\"inputgroup\">\n      <ng-container *ngIf=\"fieldlabel\">\n        <legend id=\"{{componentId}}\">\n          {{fieldlabel}}\n        </legend>\n      </ng-container>\n\n      <div (mouseleave)=\"resetHovered()\" class=\"rating\" [class.disabled]=\"disabled\" [class.readonly]=\"readonly\">\n        <span *ngFor=\"let item of ratingRangeData; let index = index\">\n          <input (keyup.space)=\"rate1(index)\" style=\"top:0; left:0; position: absolute;\n            opacity: 0;\n            cursor: pointer;\"\n            value=\"{{model}}\" id=\"{{starId}}{{index}}\" [attr.aria-checked]=\"item.selected\" type=\"radio\" name=\"rating\" role=\"radio\">\n\n          <label for=\"{{starId}}{{index}}\" style=\"display: inline-flex;\">\n            <em [ngStyle]=\"{'cursor': readonly ? 'not-allowed' : 'pointer'}\" role=\"tooltip\" [attr.tabindex]=\"item.tabindex\"\n              (mouseenter)=\"setHovered(item.number)\" attr.aria-label=\"Star {{index+1}}\" (click)=\"rate(item.number)\"\n              [attr.data-icon]=\"fullicon\" class=\"{{ iconclass }} half{{(item.selected? 100 : 0) }}\" [title]=\"titles[index] || item.number\">{{\n              emptyicon }}</em>\n          </label>\n\n        </span>\n      </div>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: i0.forwardRef(function () { return AmexioRatingComponent; }),
                            multi: true,
                        },
                        {
                            provide: forms.NG_VALIDATORS,
                            useExisting: i0.forwardRef(function () { return AmexioRatingComponent; }),
                            multi: true,
                        },
                    ],
                },] },
    ];
    AmexioRatingComponent.propDecorators = {
        iconclass: [{ type: i0.Input, args: ['icon-class',] }],
        fullicon: [{ type: i0.Input, args: ['full-icon',] }],
        emptyicon: [{ type: i0.Input, args: ['empty-icon',] }],
        readonly: [{ type: i0.Input, args: ['read-only',] }],
        disabled: [{ type: i0.Input }],
        required: [{ type: i0.Input }],
        float: [{ type: i0.Input }],
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        titles: [{ type: i0.Input }],
        max: [{ type: i0.Input }],
        onHover: [{ type: i0.Output }],
        onLeave: [{ type: i0.Output }]
    };
    return AmexioRatingComponent;
}(AmexioFormValidator));

var __extends$10 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioTextInputComponent = /** @class */ (function (_super) {
    __extends$10(AmexioTextInputComponent, _super);
    function AmexioTextInputComponent() {
        var _this = _super.call(this) || this;
        /*
        Properties
        name : icon-feedback
        datatype : boolean
        version : 4.0 onwards
        default :false
        description :
        */
        _this.iconfeedback = false;
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : Flag to set label
        */
        _this.haslabel = true;
        _this.isValid = false;
        /*
         Events
         name : onBlur
         datatype : any
         version : 4.0 onwards
         default :
         description : On blur event
         */
        _this.onBlur = new i0.EventEmitter();
        /*
        Events
        name : input
        datatype : any
        version : none
        default :
        description :   On input event field.
        */
        _this.input = new i0.EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On focus event field.
        */
        _this.focus = new i0.EventEmitter();
        /*
        Events
        name : change
        datatype : any
        version : none
        default :
        description : On field value change event
        */
        _this.change = new i0.EventEmitter();
        _this.showToolTip = false;
        return _this;
    }
    Object.defineProperty(AmexioTextInputComponent.prototype, "pattern", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pattern;
        },
        /*
      Properties
      name : pattern
      datatype : string
      version : 4.0 onwards
      default :
      description : Apply Reg-ex to the field
      */
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value != null) {
                this._pattern = value;
                this.regEx = new RegExp(this._pattern);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioTextInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.createCompId('textinput', this.name);
        this.name = this.generateName(this.name, this.fieldlabel, 'textinput');
    };
    // THIS METHOD USED FOR BLUR EVENT.
    /**
     * @return {?}
     */
    AmexioTextInputComponent.prototype.onBlurEvent = /**
     * @return {?}
     */
    function () {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    };
    // THIS METHOD USED FOR FOCUS EVENT .
    /**
     * @return {?}
     */
    AmexioTextInputComponent.prototype.onFocusEvent = /**
     * @return {?}
     */
    function () {
        this.showToolTip = true;
        this.focus.emit(this.value);
    };
    // THIS METHOD USED FOR  INPUT EVENT .
    /**
     * @return {?}
     */
    AmexioTextInputComponent.prototype.onInput = /**
     * @return {?}
     */
    function () {
        this.isValid = this.isFieldValid();
        this.input.emit(this.value);
    };
    // THIS METHOD USED FOR CHANGE EVENT  .
    /**
     * @return {?}
     */
    AmexioTextInputComponent.prototype.onChangeEv = /**
     * @return {?}
     */
    function () {
        this.change.emit(this.value);
    };
    /**
     * @return {?}
     */
    AmexioTextInputComponent.prototype.isFieldValid = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ valid;
        valid = (!this.allowblank && (this.value && ((this.value.length >= this.minlength) && this.value.length > 0)) ||
            (!this.minlength && this.value && this.value.length > 0)) || this.allowblank;
        return valid;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioTextInputComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    AmexioTextInputComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-text-input',
                    template: "\n    <div class=\"inputgroup\">\n\n        <label *ngIf=\"haslabel\" role=\"input\" id=\"{{componentId}}\"  for=\"{{componentId}}\" [style.font-style]=\"fontstyle\" [style.font-family]=\"fontfamily\" [style.font-size]=\"fontsize\">\n          {{fieldlabel}}\n      </label>\n        <input type=\"text\" \n\n            role=\"text\" \n            tabindex=\"1\"\n            id=\"{{componentId}}\" \n            name=\"textID\"\n            attr.aria-labelledby=\"{{componentId}}\"\n            aria-describedby=\"textDec\"\n            [attr.aria-required]=\"!allowblank\"\n            [attr.aria-invalid]=\"!isValid \"\n\n\n\n            class=\"input-control\" \n            [ngClass]=\"model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''\" \n            [(ngModel)]=\"value\"\n            (blur)=\"onBlurEvent()\" \n            (focus)=\"onFocusEvent()\" \n            (input)=\"onInput()\"\n            (change)=\"onChangeEv()\"\n            [name]=\"name\" \n            [pattern]=\"regEx\" \n            [attr.placeholder]=\"placeholder\" \n            [maxlength]=\"maxlength\" \n            [minlength]=\"minlength\" \n            [attr.disabled]=\"disabled ? true: null\"\n            [required]=\"!allowblank\" />\n\n        <ng-container *ngIf=\"iconfeedback\">\n            <span class=\"input-control-feedback\">\n              <span *ngIf=\"!isValid && model.touched\"><em class=\"fa fa-times\"></em></span>\n            <span *ngIf=\"isValid && model.touched\"><em class=\"fa fa-check\"></em></span>\n            </span>\n        </ng-container>\n\n          <input-help *ngIf=\"showToolTip && enablepopover\" \n\n          id=\"textDec\"\n          role=\"tooltip\"\n\n          [error-msg]=\"errormsg\" \n          [min-msg]=\"minmsg\" \n          [max-error-msg]=\"maxerrormsg\"\n          [min-error-msg]=\"minerrormsg\"\n          [min-length]=\"minlength\"\n          [max-length]=\"maxlength\"\n          [max-msg]=\"maxmsg\">\n          </input-help>\n   \n        <span class=\"inputfieldbar\"></span>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioTextInputComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioTextInputComponent; }), multi: true,
                        }],
                    encapsulation: i0.ViewEncapsulation.None,
                },] },
    ];
    /** @nocollapse */
    AmexioTextInputComponent.ctorParameters = function () { return []; };
    AmexioTextInputComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        minlength: [{ type: i0.Input, args: ['min-length',] }],
        maxlength: [{ type: i0.Input, args: ['max-length',] }],
        allowblank: [{ type: i0.Input, args: ['allow-blank',] }],
        minerrormsg: [{ type: i0.Input, args: ['min-error-msg',] }],
        maxerrormsg: [{ type: i0.Input, args: ['max-error-msg',] }],
        errormsg: [{ type: i0.Input, args: ['error-msg',] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        disabled: [{ type: i0.Input }],
        iconfeedback: [{ type: i0.Input, args: ['icon-feedback',] }],
        fontstyle: [{ type: i0.Input, args: ['font-style',] }],
        fontfamily: [{ type: i0.Input, args: ['font-family',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        haslabel: [{ type: i0.Input, args: ['has-label',] }],
        pattern: [{ type: i0.Input, args: ['pattern',] }],
        enablepopover: [{ type: i0.Input, args: ['enable-popover',] }],
        model: [{ type: i0.ViewChild, args: [forms.NgModel,] }],
        name: [{ type: i0.Input, args: ['name',] }],
        onBlur: [{ type: i0.Output }],
        input: [{ type: i0.Output }],
        focus: [{ type: i0.Output }],
        change: [{ type: i0.Output }]
    };
    return AmexioTextInputComponent;
}(ValueAccessorBase));

var __extends$11 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var noop$6 = function () {
};
var AmexioToggleComponent = /** @class */ (function (_super) {
    __extends$11(AmexioToggleComponent, _super);
    function AmexioToggleComponent() {
        var _this = _super.call(this) || this;
        _this.onChange = new i0.EventEmitter();
        _this.isComponentValid = new i0.EventEmitter();
        _this.innerValue = '';
        _this.onTouchedCallback = noop$6;
        _this.onChangeCallback = noop$6;
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioToggleComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.createCompId('togglebtn', this.fieldlabel);
        this.toggleId = this.createCompId('toggleId', this.fieldlabel);
        if (this.shape === '' || this.shape == null) {
            this.shape = 'round';
        }
        this.isValid = !this.required;
        this.isComponentValid.emit(false);
    };
    /**
     * @return {?}
     */
    AmexioToggleComponent.prototype.onToggle = /**
     * @return {?}
     */
    function () {
        this.checked = !this.checked;
        this.value = this.checked;
        this.isValid = this.value;
        this.isComponentValid.emit(this.value);
        this.onChange.emit(this.value);
    };
    Object.defineProperty(AmexioToggleComponent.prototype, "value", {
        // get accessor
        get: /**
         * @return {?}
         */
        function () {
            return this.innerValue;
        },
        // set accessor including call the onchange callback
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v !== this.innerValue) {
                this.innerValue = v;
                this.onChangeCallback(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    // Set touched on blur
    /**
     * @return {?}
     */
    AmexioToggleComponent.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.onTouchedCallback();
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioToggleComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value && value !== this.innerValue) {
            this.isValid = value;
        }
        if (!value && value !== this.innerValue) {
            this.isValid = value;
        }
        this.innerValue = value;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioToggleComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioToggleComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    AmexioToggleComponent.prototype.checkValidity = /**
     * @return {?}
     */
    function () {
        return this.isValid;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioToggleComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return ((this.required && this.value) || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioToggleComponent.prototype.onEventFilter = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onToggle();
    };
    AmexioToggleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-toggle',
                    template: "\n    <div id=\"{{componentId}}\" class=\"inputgroup\">\n      {{fieldlabel}}\n\n\n      <label role=\"switch\" attr.aria-labelledby=\"{{componentId}}\" [attr.aria-checked]=\"checked\" tabindex=\"1\" for=\"{{toggleId}}\"\n        [ngClass]=\"{smallToggle:(size == 'small' && type != 2),\n        smallType2Toggle:(size == 'small' && type == 2),\n\n        mediumToggle:(size == 'medium' && type != 2),\n        mediumType2Toggle:(size == 'medium' && type == 2),\n\n        largeToggle:(size == 'large' && type != 2),\n        largeType2Toggle:(size == 'large' && type == 2)\n\n    }\"\n        (keyup.space)=\"onEventFilter($event)\">\n\n        <input id=\"{{toggleId}}\" type=\"checkbox\" style=\"top:0; left:0;display: none;\" [attr.checked]=\"checked\" data-check-switch=\"\"\n          [attr.aria-required]=\"required\" #rangeHndl [(ngModel)]=\"value\" (blur)=\"onBlur()\" [attr.aria-checked]=\"checked\"\n          (change)=\"onToggle()\">\n        <span class=\"toggle-slider {{shape}}\" [ngClass]=\"\n        {\n          smallToggleSlider :(size == 'small' && type != 2),\n          smallType2ToggleSlider :(size == 'small' && type == 2),\n\n         mediumToggleSlider : (size == 'medium' && type !=2),\n         mediumType2ToggleSlider : (size == 'medium' && type ==2),\n\n         largeToggleSlider : (size == 'large' && type !=2),\n         largeType2ToggleSlider : (size == 'large' && type ==2)\n      }\">\n\n        </span>\n      </label>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioToggleComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioToggleComponent; }), multi: true,
                        }],
                    encapsulation: i0.ViewEncapsulation.None,
                },] },
    ];
    /** @nocollapse */
    AmexioToggleComponent.ctorParameters = function () { return []; };
    AmexioToggleComponent.propDecorators = {
        shape: [{ type: i0.Input }],
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        required: [{ type: i0.Input }],
        size: [{ type: i0.Input, args: ['size',] }],
        type: [{ type: i0.Input, args: ['type',] }],
        onChange: [{ type: i0.Output }],
        isComponentValid: [{ type: i0.Output }]
    };
    return AmexioToggleComponent;
}(AmexioFormValidator));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 18/12/17.
*/
var AmexioImageComponent = /** @class */ (function () {
    function AmexioImageComponent() {
        /*
        Properties
        name : c-class
        datatype :  string
        version : 4.0 onwards
        default :
        description : Used for custom style classes
        */
        this.cclass = '';
        /*
        Events
        name : onClick
        datatype :  none
        version : none
        default : none
        description : Get image / icon click event.
        */
        this.onClick = new i0.EventEmitter();
        /*
        Properties
        name :absolute
        datatype :  string
        version : 4.1.9 onwards
        default :
        description :sets absolute attribute  to image
        */
        this.absolute = false;
        /*
        Properties
        name :relative
        datatype :  string
        version : 4.1.9 onwards
        default :
        description :sets relative attribute  to image
        */
        this.relative = false;
        this.overlay = false;
        this.absoluteposition = false;
        this.imageCss = ' image-';
        this.overlayTextCss = 'overlay-text overlay-';
        this.textCss = '-text';
        this.imgFluidCss = ' img-fluid';
        this.overlayOverlayCss = 'overlay overlay-';
        this.imageTitleCss = 'image-title image-';
        this.imageTitleBottomCss = 'image-title image-bottom-right';
    }
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioImageComponent.prototype.onImageClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onClick.emit(event);
    };
    /**
     * @return {?}
     */
    AmexioImageComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!(this.width || this.height)) {
            this.cclass = this.cclass + this.imgFluidCss;
        }
        if (this.filter) {
            this.cclass = this.cclass + this.imageCss + this.filter;
        }
        if (this.overlayEffect) {
            this.overlay = true;
            if (!this.overlayText) {
                this.overlayText = '';
            }
            if (this.overlayText) {
                this.overlayTextClass = this.overlayTextCss + this.overlayEffect + this.textCss;
            }
            this.overlayEffect = this.overlayOverlayCss + this.overlayEffect;
        }
        if (this.position && !this.imgTitle) {
            this.imgTitle = '';
        }
        if (this.imgTitle) {
            if (this.position) {
                this.position = this.imageTitleCss + this.position;
            }
            else {
                this.position = this.imageTitleBottomCss;
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioImageComponent.prototype.addimageCSSClass = /**
     * @return {?}
     */
    function () {
        if (this.top || this.bottom || this.right || this.left) {
            this.absoluteposition = true;
        }
        this.imagepositionclass = '';
        if (this.relative && !this.absolute) {
            this.imagepositionclass = ' img-relative ';
            this.top = '';
            this.left = '';
            this.right = '';
            this.bottom = '';
        }
        else if (this.absolute) {
            this.imagepositionclass = 'img-absolute ';
        }
        return this.imagepositionclass;
    };
    AmexioImageComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-image', template: "\n    <!--Normal image-->\n    <ng-container *ngIf=\"iconclass && (!path && !mda) && overlay || overlayText || titlePara || imgTitle \">\n    <div class=\"img-container\" [ngClass]=\"addimageCSSClass()\"  [ngStyle]=\"{'top':top,'bottom':bottom,'left':left,'right':right} \">\n      <ng-container *ngIf=\"path || (path && iconclass)\">\n        <ng-container *ngIf=\"!(width || height)\">\n          <img alt=\"title\" [src]=\"path\" [attr.class]=\"cclass\" (click)=\"onImageClick($event)\" [attr.title]=\"tooltip\">\n          <div *ngIf=\"overlay\" [ngClass]=\"overlayEffect\">\n            <div *ngIf=\"overlayText\" [ngClass]=\"overlayTextClass\">{{overlayText}}\n              <p *ngIf=\"titlePara\">{{titlePara}}</p>\n            </div>\n          </div>\n          <div *ngIf=\"imgTitle\" [ngClass]=\"position\">{{imgTitle}}</div>\n        </ng-container>\n        <ng-container *ngIf=\"width || height\">\n          <img alt=\"title\" [ngStyle]=\"{'width':width,'height':height}\" [attr.class]=\"cclass\" [src]=\"path\" (click)=\"onImageClick($event)\" [attr.title]=\"tooltip\">\n           <div *ngIf=\"overlay\" [ngClass]=\"overlayEffect\">\n            <div *ngIf=\"overlayText\" [ngClass]=\"overlayTextClass\">{{overlayText}}\n              <p *ngIf=\"titlePara\">{{titlePara}}</p>\n            </div>\n          </div>\n          <div *ngIf=\"imgTitle\" [ngClass]=\"position\">{{imgTitle}}</div>\n        </ng-container>\n      </ng-container>\n      </div>\n    </ng-container>\n\n\n\n    <ng-container *ngIf=\"!(iconclass && (!path && !mda) && overlay || overlayText || titlePara || imgTitle )\">\n        <ng-container *ngIf=\"path || (path && iconclass)\">\n        <ng-container *ngIf=\"!(width || height)\">\n        <img alt=\"title\" [src]=\"path\" [attr.class]=\"cclass\" (click)=\"onImageClick($event)\" [attr.title]=\"tooltip\">\n        </ng-container>\n        <ng-container *ngIf=\"width || height\">\n        <img alt=\"title\" [ngStyle]=\"{'width':width,'height':height}\" [attr.class]=\"cclass\" [src]=\"path\" (click)=\"onImageClick($event)\" [attr.title]=\"tooltip\">\n        </ng-container>\n        </ng-container>\n        </ng-container>\n    \n    <!--this is for fontawesome-->\n    <ng-container *ngIf=\"iconclass && (!path && !mda)\">\n      <em [attr.class]=\"iconclass\" [attr.title]=\"tooltip\" (click)=\"onImageClick($event)\"></em>\n      <label class=\"image-title\" *ngIf=\"title\" (click)=\"onImageClick($event)\" style=\"cursor: pointer\">{{title}}</label>\n    </ng-container>\n\n    <!--Material icon-->\n    <ng-container *ngIf=\"(iconclass && mda) && !path\">\n      <em [attr.class]=\"iconclass\" [attr.title]=\"tooltip\" (click)=\"onImageClick($event)\">{{mda}}</em>\n    </ng-container>\n\n    <ng-container *ngIf=\" title && !iconclass\">\n      <span style=\"font-size: medium\">{{title}}</span>\n    </ng-container>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioImageComponent.ctorParameters = function () { return []; };
    AmexioImageComponent.propDecorators = {
        tooltip: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        path: [{ type: i0.Input }],
        iconclass: [{ type: i0.Input, args: ['icon-class',] }],
        cclass: [{ type: i0.Input, args: ['c-class',] }],
        mda: [{ type: i0.Input }],
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        onClick: [{ type: i0.Output }],
        filter: [{ type: i0.Input, args: ['filter',] }],
        overlayEffect: [{ type: i0.Input, args: ['overlay-effect',] }],
        overlayText: [{ type: i0.Input, args: ['overlay-text',] }],
        imgTitle: [{ type: i0.Input, args: ['image-title',] }],
        position: [{ type: i0.Input, args: ['title-position',] }],
        titlePara: [{ type: i0.Input, args: ['para',] }],
        top: [{ type: i0.Input, args: ['position-top',] }],
        bottom: [{ type: i0.Input, args: ['position-bottom',] }],
        left: [{ type: i0.Input, args: ['position-left',] }],
        right: [{ type: i0.Input, args: ['position-right',] }],
        absolute: [{ type: i0.Input, args: ['absolute',] }],
        relative: [{ type: i0.Input, args: ['relative',] }]
    };
    return AmexioImageComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioTabActionComponent = /** @class */ (function () {
    function AmexioTabActionComponent() {
        this.showContent = false;
        this.actionComponent = '';
    }
    /**
     * @return {?}
     */
    AmexioTabActionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioTabActionComponent.prototype.checkActionComponent = /**
     * @return {?}
     */
    function () {
        this.textinput = this.queryTextinput.toArray();
        if (this.textinput.length > 0) {
            this.actionComponent = 'text';
            this.textinput[0].haslabel = false;
            this.textinput[0].iconfeedback = false;
        }
        this.checkbox = this.queryCheckbox.toArray();
        if (this.checkbox.length > 0) {
            this.actionComponent = 'checkbox';
            this.checkbox[0].fieldlabel = '';
        }
        this.radioGroup = this.queryRadioGroup.toArray();
        if (this.radioGroup.length > 0) {
            this.actionComponent = 'radiogroup';
            this.radioGroup[0].fieldlabel = '';
            this.radioGroup[0].horizontal = true;
        }
        this.label = this.queryLabel.toArray();
        if (this.label.length > 0) {
            this.actionComponent = 'label';
        }
        this.number = this.queryNumber.toArray();
        if (this.number.length > 0) {
            this.actionComponent = 'number';
            this.number[0].fieldlabel = '';
        }
        this.rating = this.queryRating.toArray();
        if (this.rating.length > 0) {
            this.actionComponent = 'rating';
            this.rating[0].fieldlabel = '';
        }
        this.toggle = this.queryToggle.toArray();
        if (this.toggle.length > 0) {
            this.actionComponent = 'toggle';
            this.toggle[0].fieldlabel = '';
        }
        this.button = this.queryButton.toArray();
        if (this.button.length > 0) {
            this.actionComponent = 'button';
        }
        this.image = this.queryImage.toArray();
        if (this.image.length > 0) {
            this.actionComponent = 'image';
        }
        this.dropdown = this.queryDropDown.toArray();
        if (this.dropdown.length > 0) {
            this.actionComponent = 'dropdown';
            this.dropdown[0].fieldlabel = '';
        }
        this.checkboxgroup = this.queryCheckBoxGroup.toArray();
        if (this.checkboxgroup.length > 0) {
            this.actionComponent = 'checkboxgroup';
            this.checkboxgroup[0].fieldlabel = '';
            this.checkboxgroup[0].horizontal = true;
        }
    };
    AmexioTabActionComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-tab-action',
                    template: "\n   <ng-content></ng-content>\n   ",
                },] },
    ];
    /** @nocollapse */
    AmexioTabActionComponent.ctorParameters = function () { return []; };
    AmexioTabActionComponent.propDecorators = {
        queryTextinput: [{ type: i0.ContentChildren, args: [AmexioTextInputComponent, { descendants: true },] }],
        queryCheckbox: [{ type: i0.ContentChildren, args: [AmexioCheckBoxComponent, { descendants: true },] }],
        queryRadioGroup: [{ type: i0.ContentChildren, args: [AmexioRadioGroupComponent, { descendants: true },] }],
        queryLabel: [{ type: i0.ContentChildren, args: [AmexioLabelComponent, { descendants: true },] }],
        queryNumber: [{ type: i0.ContentChildren, args: [AmexioNumberInputComponent, { descendants: true },] }],
        queryRating: [{ type: i0.ContentChildren, args: [AmexioRatingComponent, { descendants: true },] }],
        queryToggle: [{ type: i0.ContentChildren, args: [AmexioToggleComponent, { descendants: true },] }],
        queryButton: [{ type: i0.ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
        queryImage: [{ type: i0.ContentChildren, args: [AmexioImageComponent, { descendants: true },] }],
        queryDropDown: [{ type: i0.ContentChildren, args: [AmexioDropDownComponent, { descendants: true },] }],
        queryCheckBoxGroup: [{ type: i0.ContentChildren, args: [AmexioCheckBoxGroupComponent, { descendants: true },] }]
    };
    return AmexioTabActionComponent;
}());

var __extends$12 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
var TOP_COMPONENT_CLASS_MAP = {
    red: 'amexio-top-tab-red',
    green: 'amexio-top-tab-green',
    purple: 'amexio-top-tab-purple',
    blue: 'amexio-top-tab-blue',
    brown: 'amexio-top-tab-brown',
    yellow: 'amexio-top-tab-yellow',
    black: 'amexio-top-tab-black',
    pink: 'amexio-top-tab-pink',
    orange: 'amexio-top-tab-orange',
};
var BOTTOM_COMPONENT_CLASS_MAP = {
    red: 'amexio-bottom-tab-red',
    green: 'amexio-bottom-tab-green',
    purple: 'amexio-bottom-tab-purple',
    blue: 'amexio-bottom-tab-blue',
    brown: 'amexio-bottom-tab-brown',
    yellow: 'amexio-bottom-tab-yellow',
    black: 'amexio-bottom-tab-black',
    pink: 'amexio-bottom-tab-pink',
    orange: 'amexio-bottom-tab-orange',
};
var AmexioTabComponent = /** @class */ (function (_super) {
    __extends$12(AmexioTabComponent, _super);
    function AmexioTabComponent(render, componentFactoryResolver, renderer) {
        var _this = _super.call(this) || this;
        _this.render = render;
        _this.componentFactoryResolver = componentFactoryResolver;
        _this.renderer = renderer;
        /*
           Properties
           name :  context-menu
           datatype : string
           version : 5.0.1 onwards
           default :
           description : Context Menu provides the list of menus on right click.
           */
        _this.contextmenu = [];
        /*
           Events
           name : rightClick
           datatype : none
           version : 5.0.1
           default : none
           description : It will gives you row clicked data.
           */
        _this.rightClick = new i0.EventEmitter();
        /*
           Events
           name : onClick
           datatype : none
           version : none
           default : none
           description : Callback to invoke on activated tab event.
           */
        _this.onClick = new i0.EventEmitter();
        _this.showprev = false;
        _this.shownext = false;
        _this.mouseLocation = { left: 0, top: 0 };
        _this.closeOthersConst = 'Close Others';
        _this.dummyArray = [];
        _this.tabPositionClass = '';
        _this.componentId = '';
        _this.map = new Map();
        _this.prevtabindex = -1;
        _this.currtabindex = -1;
        _this.headeralign = 'left';
        _this.typeActionAlign = 'left';
        _this.tabPosition = 'top';
        _this.fullPageTabs = false;
        _this.action = false;
        return _this;
    }
    Object.defineProperty(AmexioTabComponent.prototype, "tabLocalData", {
        get: /**
         * @return {?}
         */
        function () {
            return this._tabLocalData;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._tabLocalData = value;
            if (this.componentLoaded) {
                this.updateTabComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentLoaded = true;
        this.componentId = Math.floor(Math.random() * 90000) + 10000 + '_tabc';
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.updateTabComponent = /**
     * @return {?}
     */
    function () {
        if (this.tabs.nativeElement.scrollWidth > this.tabs.nativeElement.clientWidth) {
            this.headeralign = 'left';
        }
        this.adjustWidth();
        if (this.tabs && this.tabs.nativeElement
            && this.headerWidth && this.headerWidth.nativeElement
            && this.tabAction && this.tabAction.nativeElement
            && this.tabWidth1 !== this.tabs.nativeElement.offsetWidth) {
            this.headWidth = (this.tabAction.nativeElement.scrollWidth + this.headerWidth.nativeElement.scrollWidth);
            this.widthTabs = this.tabs.nativeElement.offsetWidth - this.headWidth;
        }
        if (JSON.stringify(this.tabPreviewData) !== JSON.stringify(this.tabLocalData)) {
            this.tabPreviewData = JSON.parse(JSON.stringify(this.tabLocalData));
            this.tabCollection = this.tabLocalData;
        }
        this.tabPositionClass = this.findTabStyleClass();
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // set time out
        setTimeout(function () {
            _this.tabWidth1 = _this.tabs.nativeElement.offsetWidth;
            _this.totalTabs = _this.tabCollection.length;
            _this.updateTabComponent();
            _this.tabCollection.forEach(function (element, index) {
                element['tablk'] = Math.floor(Math.random() * 90000) + 10000 + '_tablk';
                _super.prototype.ngAfterViewInit.call(_this);
            });
        }, 500);
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.adjustWidth = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ tWidth = this.tabs.nativeElement.clientWidth;
        var /** @type {?} */ tlistWidth = this.tabslist.nativeElement.scrollWidth;
        var /** @type {?} */ hWidth = 0;
        var /** @type {?} */ totalElWidth = tlistWidth + hWidth;
        if (totalElWidth > tWidth) {
            this.shownext = true;
        }
        else {
            this.shownext = false;
        }
        if (this.fullPageTabs === true) {
            if (totalElWidth > tWidth && this.fullPageTabs) {
                this.shownext = true;
            }
            else {
                this.singleTabWidth = totalElWidth / this.totalTabs;
            }
        }
        this.onAdjustHeight();
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.tabLocalData && this.tabLocalData.length > 0) {
            this.tabPreviewData = JSON.parse(JSON.stringify(this.tabLocalData));
            this.tabCollection = this.tabLocalData;
        }
        else {
            this.tabCollection = [];
            this.tabCollection = this.queryTabs.toArray();
        }
        this.tabNodeProperties();
        // To add action in tab
        this.actionComp = this.queryAction.toArray();
        if (this.actionComp.length > 0) {
            this.actionComp[0].checkActionComponent();
        }
        this.tabPositionClass = this.findTabStyleClass();
    };
    /**
     * @param {?} title
     * @param {?} amexiocolor
     * @param {?} closable
     * @param {?} component
     * @return {?}
     */
    AmexioTabComponent.prototype.addDynamicTab = /**
     * @param {?} title
     * @param {?} amexiocolor
     * @param {?} closable
     * @param {?} component
     * @return {?}
     */
    function (title, amexiocolor, closable, component) {
        // get a component factory for our TabComponent
        var /** @type {?} */ tpCF = this.componentFactoryResolver.resolveComponentFactory(AmexioTabPillComponent);
        var /** @type {?} */ tp = this.target.createComponent(tpCF);
        // set the according properties on our component instance
        var /** @type {?} */ instance = /** @type {?} */ (tp.instance);
        instance.title = title;
        instance.active = true;
        instance.closable = closable;
        instance['tabpillinstance'] = this.target;
        if (instance.amexiocolor === '') {
            instance.amexiocolor = 'amexio-top-tab-black';
        }
        else {
            instance.amexiocolor = 'amexio-top-tab-' + amexiocolor;
        }
        // create dynamic component
        var /** @type {?} */ dynCF = this.componentFactoryResolver.resolveComponentFactory(component);
        var /** @type {?} */ dynCmp = tp.instance.target.createComponent(dynCF);
        // Push new tab and select it.
        this.dummyArray.push(tp);
        this.tabCollection.push(tp.instance);
        this.selectTab(tp.instance);
        this.adjustWidth();
        return dynCmp.instance;
    };
    // Method to close all tab
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.closeAllTabs = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.tabCollection.forEach(function (tabs) {
            if (tabs.closable || _this.closable) {
                _this.closeTab(tabs);
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.closeAll = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.tabCollection.forEach(function (tabs) {
            _this.closeTab(tabs);
        });
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioTabComponent.prototype.closeTabs = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        var /** @type {?} */ tabList = [];
        this.tabCollection.forEach(function (tabs) {
            tabs.active = false;
            data.forEach(function (opt) {
                if (opt.toLowerCase() !== tabs.title.toLowerCase() && (tabs.closable || _this.closable)) {
                    _this.closeTab(tabs);
                }
                else {
                    tabList.push(tabs);
                    _this.asignTabPillClass(tabs);
                }
            });
        });
        tabList[tabList.length - 1].active = true;
        this.asignTabPillClass(tabList[tabList.length - 1]);
    };
    // Method to set active tab on the basis of tab sequence or tab title
    /**
     * @param {?} input
     * @return {?}
     */
    AmexioTabComponent.prototype.setActiveTab = /**
     * @param {?} input
     * @return {?}
     */
    function (input) {
        var _this = this;
        var /** @type {?} */ flag = false;
        if (typeof input === 'string') {
            this.tabCollection.forEach(function (tabs) {
                tabs.tabPillClass = '';
                if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                    tabs.active = true;
                    flag = true;
                }
                else {
                    tabs.active = false;
                }
                _this.asignTabPillClass(tabs);
            });
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach(function (tabs, index) {
                tabs.tabPillClass = '';
                if (index + 1 === input) {
                    tabs.active = true;
                    flag = true;
                }
                else {
                    tabs.active = false;
                }
                _this.asignTabPillClass(tabs);
            });
        }
        return flag;
    };
    /**
     * @param {?} disabledTabInput
     * @return {?}
     */
    AmexioTabComponent.prototype.setDisableTabs = /**
     * @param {?} disabledTabInput
     * @return {?}
     */
    function (disabledTabInput) {
        var _this = this;
        var /** @type {?} */ flag = false;
        if (disabledTabInput.length > 0) {
            disabledTabInput.forEach(function (ele) {
                if (typeof ele === 'string') {
                    _this.disableTabByString(flag, ele);
                }
                else if (typeof ele === 'number') {
                    _this.disableTabByNumber(flag, ele);
                }
            });
        }
        return flag;
    };
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    AmexioTabComponent.prototype.disableTabByString = /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    function (flag, ele) {
        var _this = this;
        this.tabCollection.forEach(function (tabs) {
            tabs.tabPillClass = '';
            if (ele.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                tabs.disabled = true;
                flag = true;
            }
            _this.asignTabPillClass(tabs);
        });
    };
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    AmexioTabComponent.prototype.disableTabByNumber = /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    function (flag, ele) {
        var _this = this;
        this.tabCollection.forEach(function (tabs, index) {
            tabs.tabPillClass = '';
            if (index + 1 === ele) {
                tabs.active = true;
                flag = true;
            }
            else {
                tabs.active = false;
            }
            _this.asignTabPillClass(tabs);
        });
    };
    /**
     * @param {?} disabledTabInput
     * @return {?}
     */
    AmexioTabComponent.prototype.setEnableTabs = /**
     * @param {?} disabledTabInput
     * @return {?}
     */
    function (disabledTabInput) {
        var _this = this;
        var /** @type {?} */ flag = false;
        if (disabledTabInput.length > 0) {
            disabledTabInput.forEach(function (ele) {
                if (typeof ele === 'string') {
                    _this.enableTabByString(flag, ele);
                }
                else if (typeof ele === 'number') {
                    _this.enableTabByNumber(flag, ele);
                }
            });
        }
        return flag;
    };
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    AmexioTabComponent.prototype.enableTabByString = /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    function (flag, ele) {
        var _this = this;
        this.tabCollection.forEach(function (tabs) {
            tabs.tabPillClass = '';
            if (ele.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                tabs.disabled = false;
                flag = true;
            }
            _this.asignTabPillClass(tabs);
        });
    };
    /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    AmexioTabComponent.prototype.enableTabByNumber = /**
     * @param {?} flag
     * @param {?} ele
     * @return {?}
     */
    function (flag, ele) {
        var _this = this;
        this.tabCollection.forEach(function (tabs, index) {
            tabs.tabPillClass = '';
            if (index + 1 === ele) {
                tabs.disabled = false;
                flag = true;
            }
            _this.asignTabPillClass(tabs);
        });
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    AmexioTabComponent.prototype.selectTab = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        var _this = this;
        // deactivate all tabs
        this.tabCollection.forEach(function (tab1) {
            tab1.active = false;
        });
        tab.active = true;
        this.tabCollection.forEach(function (tab1) {
            _this.asignTabPillClass(tab1);
        });
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.tabNodeProperties = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ tabWidth = this.tabCollection.length;
        for (var /** @type {?} */ i = 0; i < tabWidth; i++) {
            if (this.tabPosition === 'top') {
                this.tabCollection[i].amexiocolor = TOP_COMPONENT_CLASS_MAP[this.tabCollection[i].amexiocolor];
            }
            else {
                this.tabCollection[i].amexiocolor = BOTTOM_COMPONENT_CLASS_MAP[this.tabCollection[i].amexiocolor];
            }
            if (this.closable) {
                if (this.tabCollection[i].closable === null || this.tabCollection[i].closable === true) {
                    this.tabCollection[i].closable = true;
                }
                else if (this.tabCollection[i].closable === false) {
                    this.tabCollection[i].closable = false;
                }
            }
            this.asignTabPillClass(this.tabCollection[i]);
        }
    };
    /**
     * @param {?} tab
     * @param {?} index
     * @return {?}
     */
    AmexioTabComponent.prototype.onTabClick = /**
     * @param {?} tab
     * @param {?} index
     * @return {?}
     */
    function (tab, index) {
        var _this = this;
        if (!tab.disabled && !tab.header) {
            for (var _i = 0, _a = this.tabCollection; _i < _a.length; _i++) {
                var i = _a[_i];
                if (i === tab) {
                    i['active'] = true;
                    i['index'] = index;
                    this.asignTabPillClass(tab);
                    this.onClick.emit(tab);
                }
                else {
                    i['active'] = false;
                    i['tabPillClass'] = '';
                }
            }
            this.tabCollection.forEach(function (tab1) {
                _this.asignTabPillClass(tab1);
            });
        }
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.onArrowRight = /**
     * @return {?}
     */
    function () {
        if (this.prevtabindex > -1) {
            this.tabCollection[this.prevtabindex]['isSelected'] = false;
        }
        this.currtabindex++;
        this.prevtabindex = this.currtabindex;
        if (this.currtabindex >= this.tabCollection.length) {
            this.currtabindex = 0;
            this.prevtabindex = 0;
        }
        var /** @type {?} */ currentTab = this.tabCollection[this.currtabindex];
        this.commonFocus(currentTab);
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.onArrowLeft = /**
     * @return {?}
     */
    function () {
        if (this.prevtabindex > -1) {
            this.tabCollection[this.prevtabindex]['isSelected'] = false;
        }
        this.prevtabindex--;
        if (this.prevtabindex === -1) {
            this.prevtabindex = this.tabCollection.length - 1;
            this.currtabindex = -1;
        }
        this.tabCollection[this.prevtabindex]['isSelected'] = true;
        var /** @type {?} */ currentTab = this.tabCollection[this.prevtabindex];
        this.commonFocus(currentTab);
        if (this.prevtabindex === 0) {
            this.currtabindex = 0;
        }
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.onHomeClick = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ currentTab = this.tabCollection[0];
        this.commonFocus(currentTab);
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.onEndClick = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ currentTab = this.tabCollection[this.tabCollection.length - 1];
        this.commonFocus(currentTab);
    };
    /**
     * @param {?} currentTab
     * @return {?}
     */
    AmexioTabComponent.prototype.commonFocus = /**
     * @param {?} currentTab
     * @return {?}
     */
    function (currentTab) {
        currentTab['isSelected'] = true;
        var /** @type {?} */ tablk = document.getElementById(currentTab.tablk);
        tablk.focus();
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.next = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ nxt = this.tabs.nativeElement;
        nxt.scrollLeft = nxt.scrollLeft + 200;
        if ((nxt.scrollWidth - nxt.offsetWidth - nxt.scrollLeft) <= 0) {
            this.shownext = false;
        }
        this.showprev = true;
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.previous = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ prev = this.tabs.nativeElement;
        prev.scrollLeft = prev.scrollLeft - 200;
        if (prev.scrollLeft === 0) {
            this.showprev = false;
        }
        this.shownext = true;
    };
    /**
     * @param {?} tabNode
     * @return {?}
     */
    AmexioTabComponent.prototype.closeTab = /**
     * @param {?} tabNode
     * @return {?}
     */
    function (tabNode) {
        var _this = this;
        var /** @type {?} */ newTab = [];
        var /** @type {?} */ index = 0;
        var /** @type {?} */ tabHighlightIndex = 0;
        this.tabCollection.forEach(function (tab, i) {
            tab.active = false;
            if (tab.tabId === tabNode.tabId) {
                tabHighlightIndex = index;
                if (tab.hasOwnProperty('tabpillinstance')) {
                    tab.target.remove();
                }
                else {
                    _this.tabDomRemove(tab);
                }
            }
            else if (tab.tabId !== tabNode.tabId) {
                newTab.push(tab);
            }
            index++;
        });
        if (tabHighlightIndex === newTab.length) {
            tabHighlightIndex--;
        }
        this.tabCollection = newTab;
        if (tabHighlightIndex > -1) {
            this.activateTab(newTab[tabHighlightIndex].tabId);
        }
        else {
            this.activateTab(null);
        }
        if (this.tabCollection.length === 1) {
            this.closable = false;
        }
        if (newTab.length === 1) {
            newTab[0].closable = false;
        }
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    AmexioTabComponent.prototype.tabDomRemove = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        var /** @type {?} */ removeNode = document.getElementById(tab.tabId).parentNode;
        var /** @type {?} */ parentRefNode = removeNode.parentNode;
        parentRefNode.removeChild(removeNode);
    };
    /**
     * @param {?} tabId
     * @return {?}
     */
    AmexioTabComponent.prototype.activateTab = /**
     * @param {?} tabId
     * @return {?}
     */
    function (tabId) {
        var _this = this;
        if (tabId !== null) {
            this.tabCollection.forEach(function (tab) {
                tab.active = false;
                if (tab.tabId === tabId) {
                    tab.active = true;
                }
                _this.asignTabPillClass(tab);
            });
        }
    };
    /**
     * @param {?} tabData
     * @return {?}
     */
    AmexioTabComponent.prototype.asignTabPillClass = /**
     * @param {?} tabData
     * @return {?}
     */
    function (tabData) {
        tabData.tabPillClass = '';
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && tabData.active && (this.tabPosition === 'top')) {
            tabData.tabPillClass = 'activetab';
        }
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'bottomActivetab';
        }
        if (tabData.disabled) {
            tabData.tabPillClass = 'disabled-tab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'top') && tabData.active && !this.activeBGColor) {
            tabData.tabPillClass = 'activecolortab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'top') && tabData.active && this.activeBGColor) {
            tabData.tabPillClass = 'activebgcolortab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'activebottomcolortab';
        }
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.findTabStyleClass = /**
     * @return {?}
     */
    function () {
        if (this.headeralign === 'right' && !this.fullPageTabs) {
            return 'tabposition-right';
        }
        if (this.headeralign === 'left' && !this.fullPageTabs) {
            return 'tabposition-left';
        }
        if (this.fullPageTabs === true) {
            return 'equally-align-tabs';
        }
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.onAdjustHeight = /**
     * @return {?}
     */
    function () {
        if (this.bodyheight) {
            var /** @type {?} */ h = (window.innerHeight / 100) * this.bodyheight;
            if (this.tabs && this.tabs.nativeElement && this.tabs.nativeElement.offsetHeight) {
                h = h - this.tabs.nativeElement.offsetHeight;
            }
            if (this.bodyheight === 100) {
                h = h - 40;
            }
            this.minHeight = h;
            this.height = h;
        }
    };
    /**
     * @param {?} event
     * @param {?} row
     * @param {?} id
     * @return {?}
     */
    AmexioTabComponent.prototype.loadContextMenu = /**
     * @param {?} event
     * @param {?} row
     * @param {?} id
     * @return {?}
     */
    function (event, row, id) {
        this.tempSelectedFlag(this.tabCollection);
        this.mouseLocation.left = event.clientX;
        this.mouseLocation.top = event.clientY;
        row.active = true;
        this.getContextMenu();
        this.posixUp = this.getListPosition(id);
        if (this.contextmenu && this.contextmenu.length > 0) {
            event.preventDefault();
            event.stopPropagation();
        }
        this.rightClickRowData = row;
    };
    /**
     * @param {?} tabs
     * @return {?}
     */
    AmexioTabComponent.prototype.tempSelectedFlag = /**
     * @param {?} tabs
     * @return {?}
     */
    function (tabs) {
        tabs.forEach(function (tab) {
            if (tab.active) {
                tab.active = false;
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.getContextMenu = /**
     * @return {?}
     */
    function () {
        if (this.defaultContextMenu) {
            var /** @type {?} */ obj = { text: 'Close All', icon: 'fa fa-close', disable: false };
            var /** @type {?} */ obj2 = { text: this.closeOthersConst, icon: 'fa fa-close', seperator: false, disabled: false };
            var /** @type {?} */ tmpflag = true;
            for (var _i = 0, _a = this.contextmenu; _i < _a.length; _i++) {
                var i = _a[_i];
                if (i.text === 'Close All' || i.text === this.closeOthersConst) {
                    tmpflag = false;
                }
            }
            if (tmpflag) {
                this.contextmenu.push(obj, obj2);
            }
            this.contextMenuFlag = true;
            this.addListner();
        }
        else if (this.contextmenu && this.contextmenu.length > 0) {
            this.contextMenuFlag = true;
            this.addListner();
        }
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioTabComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} Data
     * @return {?}
     */
    AmexioTabComponent.prototype.rightClickDataEmit = /**
     * @param {?} Data
     * @return {?}
     */
    function (Data) {
        var /** @type {?} */ temptab;
        this.tabCollection.forEach(function (obj) {
            if (obj.active) {
                temptab = obj;
            }
        });
        if (Data.nodeData.active) {
            temptab = Data;
        }
        if (Data.menuData.text === 'Close All') {
            this.closeAllTabs();
        }
        if (Data.menuData.text === this.closeOthersConst) {
            this.closeOtherTabs(temptab);
        }
        this.rightClick.emit(Data);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioTabComponent.prototype.closeOtherTabs = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        this.tabCollection.forEach(function (tabs) {
            if (data.nodeData.title.toLowerCase() !== tabs.title.toLowerCase() && (tabs.closable || _this.closable)) {
                _this.closeTab(tabs);
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.addListner = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.globalClickListenFunc = this.renderer.listen('document', 'click', function (e) {
            _this.contextMenuFlag = false;
            if (!_this.contextMenuFlag) {
                _this.removeListner();
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.removeListner = /**
     * @return {?}
     */
    function () {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeListner();
        _super.prototype.ngOnDestroy.call(this);
    };
    /**
     * @param {?} input
     * @return {?}
     */
    AmexioTabComponent.prototype.showTab = /**
     * @param {?} input
     * @return {?}
     */
    function (input) {
        var _this = this;
        if (typeof input === 'string') {
            this.tabCollection.forEach(function (tabs) {
                if (input.trim().toLowerCase() !== tabs.title.trim().toLowerCase()) {
                    tabs.hide = true;
                    tabs['showflag'] = true;
                    tabs.active = false;
                }
                else {
                    tabs.hide = false;
                    tabs['showflag'] = false;
                    tabs.active = true;
                }
                _this.asignTabPillClass(tabs);
            });
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach(function (tabs, index) {
                if (index !== input) {
                    tabs.hide = true;
                    tabs['showflag'] = true;
                    tabs.active = false;
                }
                else {
                    tabs.hide = false;
                    tabs['showflag'] = false;
                    tabs.active = true;
                }
            });
        }
    };
    // Method to hide tab
    /**
     * @param {?} input
     * @return {?}
     */
    AmexioTabComponent.prototype.hideTab = /**
     * @param {?} input
     * @return {?}
     */
    function (input) {
        var _this = this;
        if (typeof input === 'string') {
            this.tabCollection.forEach(function (tabs, index) {
                if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase() && tabs.active) {
                    var /** @type {?} */ i = index + 1;
                    tabs.hide = false;
                    _this.tabCollection[i].active = true;
                    var /** @type {?} */ newTab = _this.tabCollection[i];
                    tabs.active = false;
                    tabs['showflag'] = true;
                    _this.asignTabPillClass(newTab);
                }
                else if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase() && !tabs.active) {
                    tabs.hide = true;
                    tabs['showflag'] = true;
                }
            });
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach(function (tabs, index) {
                if (index !== input) {
                    tabs.hide = true;
                    tabs['showflag'] = false;
                }
                else {
                    tabs.hide = false;
                    tabs['showflag'] = true;
                }
            });
        }
    };
    /**
     * @param {?} input
     * @param {?} flag
     * @return {?}
     */
    AmexioTabComponent.prototype.disableTab = /**
     * @param {?} input
     * @param {?} flag
     * @return {?}
     */
    function (input, flag) {
        var _this = this;
        if (typeof input === 'string') {
            this.tabCollection.forEach(function (tabs) {
                if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                    tabs.disabled = true;
                    flag = true;
                }
                _this.asignTabPillClass(tabs);
            });
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach(function (tabs, index) {
                if (index === input) {
                    tabs.disabled = true;
                    flag = true;
                }
                _this.asignTabPillClass(tabs);
            });
        }
        else if (typeof input === 'object') {
            this.disabledsplitmethod(input, flag);
        }
    };
    /**
     * @param {?} input
     * @param {?} flag
     * @return {?}
     */
    AmexioTabComponent.prototype.disabledsplitmethod = /**
     * @param {?} input
     * @param {?} flag
     * @return {?}
     */
    function (input, flag) {
        var _this = this;
        input.forEach(function (element) {
            if (typeof element === 'string') {
                _this.tabCollection.forEach(function (tabs) {
                    if (element.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                        tabs.disabled = true;
                        flag = true;
                    }
                    _this.asignTabPillClass(tabs);
                });
            }
            else if (typeof element === 'number') {
                _this.tabCollection.forEach(function (tabs, index) {
                    if (index === element) {
                        tabs.disabled = true;
                        flag = true;
                    }
                    _this.asignTabPillClass(tabs);
                });
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioTabComponent.prototype.getCurrentTab = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ currentindex;
        this.tabCollection.forEach(function (tabs, index) {
            if (tabs.active === true) {
                currentindex = index;
            }
        });
        return currentindex;
    };
    /**
     * @param {?} input
     * @return {?}
     */
    AmexioTabComponent.prototype.deleteTab = /**
     * @param {?} input
     * @return {?}
     */
    function (input) {
        var _this = this;
        if (typeof input === 'string') {
            this.tabCollection.forEach(function (tabs) {
                if (input.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                    _this.closeTab(tabs);
                }
            });
        }
        else if (typeof input === 'number') {
            this.tabCollection.forEach(function (tabs, index) {
                if (index === input) {
                    _this.closeTab(tabs);
                }
            });
        }
        else if (typeof input === 'object') {
            this.deletetypeObject(input);
        }
    };
    /**
     * @param {?} input
     * @return {?}
     */
    AmexioTabComponent.prototype.deletetypeObject = /**
     * @param {?} input
     * @return {?}
     */
    function (input) {
        var _this = this;
        input.forEach(function (element) {
            if (typeof element === 'string') {
                _this.tabCollection.forEach(function (tabs) {
                    if (element.trim().toLowerCase() === tabs.title.trim().toLowerCase()) {
                        _this.closeTab(tabs);
                    }
                });
            }
            else if (typeof element === 'number') {
                _this.tabCollection.forEach(function (tabs, index) {
                    if (element === index) {
                        _this.closeTab(tabs);
                    }
                });
            }
        });
    };
    /**
     * @param {?} input
     * @param {?} replacetab
     * @return {?}
     */
    AmexioTabComponent.prototype.replaceTab = /**
     * @param {?} input
     * @param {?} replacetab
     * @return {?}
     */
    function (input, replacetab) {
        this.tabCollection.forEach(function (tabs, index) {
            if (input === index) {
                tabs.title = replacetab;
            }
        });
    };
    AmexioTabComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-tab-view',
                    template: "\n    <div class=\"tabwrapper\">\n        <div *ngIf=\"showprev\" [ngClass]=\"{'tabnavigation float-right tabnavigation-bottom-left':tabPosition=='bottom', 'tabnavigation float-left':tabPosition=='top'}\" (click)=\"previous()\">\n            <amexio-c-icon key=\"tab_previous\"></amexio-c-icon>\n        </div>\n        <div *ngIf=\"shownext\" [ngClass]=\"{'tabnavigation float-right tabnavigation-bottom-right':tabPosition=='bottom','tabnavigation float-right':tabPosition=='top'}\" (click)=\"next()\">\n            <amexio-c-icon key=\"tab_next\"></amexio-c-icon>\n        </div>\n\n        <div #tab class=\"tab\"  role=\"tablist\" aria-labelledby=\"Tablist\" [ngClass]=\"{'bottomTab':tabPosition == 'bottom'}\">\n\n            <div #tabslist class=\"tablistitems {{tabPositionClass}}\">\n                <!-- HEADER -->\n\n                <div class=\"tablink\" style=\"padding-bottom:0%\" *ngIf=\"(this.action == true || header) && (fullPageTabs == false)\">\n                    <div class=\"table\">\n                        <div class=\"tablerow\">\n                            <div class=\"tablecol\">\n                                {{header}}\n                            </div>\n                            <div class=\"tablecol\">\n                                <ng-content select=\"amexio-tab-action\"></ng-content>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n\n\n\n                <div>\n                    <div *ngFor=\"let tabnode of tabCollection, let index = index\" class=\"tablink {{tabnode.amexiocolor+ ' '+tabnode.tabPillClass}}\" \n                    [style.width.px]=\"singleTabWidth\"  (contextmenu)=\"loadContextMenu($event,tabnode, tab)\">\n                        <div class=\"table1\" id=\"{{tabnode.tablk}}\" tabindex=\"1\" attr.aria-controls=\"{{tabnode.tabId}}\" role=\"tab\" (click)=\"onTabClick(tabnode, index)\" [ngStyle]=\"{'display': tabnode.showflag ? 'none':'table-cell'}\"\n                        (keyup.arrowright)=\"onArrowRight()\" (keyup.arrowleft)=\"onArrowLeft()\" (keyup.enter)=\"onTabClick(tabnode, index)\" (keyup.home)=\"onHomeClick()\" \n                        (keyup.end)=\"onEndClick()\">\n                            <div class=\"tablerow\">\n                                <div *ngIf=\"tabnode.icon\" class=\"tablecol\">\n                                    <amexio-c-icon *ngIf=\"tabnode.icon\" [customclass]=\"tabnode.icon\"></amexio-c-icon>\n                                </div>\n                                <div class=\"tablecol\">\n                                    {{tabnode.title}}\n                                </div>\n                                <div *ngIf=\"tabnode.closable\" class=\"tablecol\">\n                                    <amexio-c-icon key=\"tab_close\" (onClick)=\"closeTab(tabnode)\"></amexio-c-icon>\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <div class=\"tabcontent\" [attr.id]=\"componentId\" [ngStyle]=\"{'height.px' : height,'overflow-y' : height!= null ? 'auto' : '','min-height.px' : minHeight}\">\n        <ng-content></ng-content>\n        <ng-template #target></ng-template>\n    </div>\n\n\n    <ng-container *ngIf=\"contextMenuFlag\">\n        <base-contextmenu [base-context-menu]=\"contextmenu\" [mouse-location-top]=\"mouseLocation.top\" [mouse-location-left]=\"mouseLocation.left\" [is-FlagShow]=\"contextMenuFlag\" [right-click-data]=\"rightClickRowData\" (onRightClick)=\"rightClickDataEmit($event)\"\n            [position-up]=\"posixUp\">\n        </base-contextmenu>\n    </ng-container>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioTabComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: i0.ComponentFactoryResolver },
        { type: i0.Renderer2 }
    ]; };
    AmexioTabComponent.propDecorators = {
        closable: [{ type: i0.Input }],
        headeralign: [{ type: i0.Input, args: ['header-align',] }],
        action: [{ type: i0.Input }],
        typeActionAlign: [{ type: i0.Input, args: ['action-type-align',] }],
        fullPageTabs: [{ type: i0.Input, args: ['divide-header-equally',] }],
        tabPosition: [{ type: i0.Input, args: ['tab-position',] }],
        header: [{ type: i0.Input }],
        bodyheight: [{ type: i0.Input, args: ['body-height',] }],
        contextmenu: [{ type: i0.Input, args: ['context-menu',] }],
        defaultContextMenu: [{ type: i0.Input, args: ['default-context-menu',] }],
        activeBGColor: [{ type: i0.Input, args: ['active-bg-color',] }],
        rightClick: [{ type: i0.Output }],
        tabs: [{ type: i0.ViewChild, args: ['tab', { read: i0.ElementRef },] }],
        tabAction: [{ type: i0.ViewChild, args: ['tabAction', { read: i0.ElementRef },] }],
        headerWidth: [{ type: i0.ViewChild, args: ['headerWidth', { read: i0.ElementRef },] }],
        headerName: [{ type: i0.ViewChild, args: ['headerName', { read: i0.ElementRef },] }],
        tabslist: [{ type: i0.ViewChild, args: ['tabslist', { read: i0.ElementRef },] }],
        actionProperty: [{ type: i0.ViewChild, args: ['actionProperty', { read: i0.ElementRef },] }],
        queryTabs: [{ type: i0.ContentChildren, args: [AmexioTabPillComponent,] }],
        target: [{ type: i0.ViewChild, args: ['target', { read: i0.ViewContainerRef },] }],
        queryAction: [{ type: i0.ContentChildren, args: [AmexioTabActionComponent, { descendants: true },] }],
        onClick: [{ type: i0.Output }],
        tabLocalData: [{ type: i0.Input, args: ['tabLocalData',] }]
    };
    return AmexioTabComponent;
}(LifeCycleBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/1/17.
*/
var AmexioVerticalTabComponent = /** @class */ (function () {
    function AmexioVerticalTabComponent(render, componentFactoryResolver) {
        this.render = render;
        this.componentFactoryResolver = componentFactoryResolver;
        /*
        Events
        name : onClick
        datatype : none
        version : 4.0 onwards
        default :none
        description : Callback to invoke on activated tab event.
        */
        this.onClick = new i0.EventEmitter();
        this.dummyArray = [];
        this.componentId = '';
        this.tabPosition = 'top';
    }
    /**
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = Math.floor(Math.random() * 90000) + 10000 + '_tabc';
    };
    /**
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.tabCollection = this.queryTabs.toArray();
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.onTabClick = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        var _this = this;
        if (!tab.disabled && !tab.header) {
            for (var _i = 0, _a = this.tabCollection; _i < _a.length; _i++) {
                var i = _a[_i];
                if (i === tab) {
                    i['active'] = true;
                    this.asignTabPillClass(tab);
                    this.onClick.emit(tab);
                }
                else {
                    i['active'] = false;
                    i['tabPillClass'] = '';
                }
            }
            this.tabCollection.forEach(function (tab1) {
                _this.asignTabPillClass(tab1);
            });
        }
    };
    // Code to be done
    /**
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.findTabStyleClass = /**
     * @return {?}
     */
    function () {
        if (this.tabPosition === 'top') {
            return 'tabposition-top';
        }
        if (this.tabPosition === 'bottom') {
            return 'tabposition-bottom';
        }
    };
    /**
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.closeAllTabs = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.tabCollection.forEach(function (tabs) {
            if (tabs.closable === true || _this.closable === true) {
                _this.closeTab(tabs);
            }
        });
    };
    /**
     * @param {?} tabNode
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.closeTab = /**
     * @param {?} tabNode
     * @return {?}
     */
    function (tabNode) {
        var _this = this;
        var /** @type {?} */ newTab = [];
        var /** @type {?} */ index = 0;
        var /** @type {?} */ tabHighlightIndex = 0;
        this.tabCollection.forEach(function (tab, i) {
            tab.active = false;
            if (tab.tabId === tabNode.tabId) {
                tabHighlightIndex = index;
                if (tab.hasOwnProperty('tabpillinstance')) {
                    tab.target.remove();
                }
                else {
                    _this.tabDomRemove(tab);
                }
            }
            else if (tab.tabId !== tabNode.tabId) {
                newTab.push(tab);
            }
            index++;
        });
        if (tabHighlightIndex === newTab.length) {
            tabHighlightIndex--;
        }
        this.tabCollection = newTab;
        if (tabHighlightIndex > -1) {
            this.activateTab(newTab[tabHighlightIndex].tabId);
        }
        else {
            this.activateTab(null);
        }
        if (this.tabCollection.length === 1) {
            this.closable = false;
        }
        if (newTab.length === 1) {
            newTab[0].closable = false;
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.closeTabs = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        var /** @type {?} */ tabList = [];
        this.tabCollection.forEach(function (tabs) {
            tabs.active = false;
            data.forEach(function (opt) {
                if (opt.toLowerCase() !== tabs.title.toLowerCase() && (tabs.closable === true || _this.closable === true)) {
                    _this.closeTab(tabs);
                }
                else {
                    tabList.push(tabs);
                    _this.asignTabPillClass(tabs);
                }
            });
        });
        tabList[tabList.length - 1].active = true;
        this.asignTabPillClass(tabList[tabList.length - 1]);
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.tabDomRemove = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        var /** @type {?} */ removeNode = document.getElementById(tab.tabId).parentNode;
        var /** @type {?} */ parentRefNode = removeNode.parentNode;
        parentRefNode.removeChild(removeNode);
    };
    /**
     * @param {?} title
     * @param {?} amexiocolor
     * @param {?} closable
     * @param {?} component
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.addDynamicTab = /**
     * @param {?} title
     * @param {?} amexiocolor
     * @param {?} closable
     * @param {?} component
     * @return {?}
     */
    function (title, amexiocolor, closable, component) {
        // get a component factory for our TabComponent
        var /** @type {?} */ tpCF = this.componentFactoryResolver.resolveComponentFactory(AmexioTabPillComponent);
        var /** @type {?} */ tp = this.target.createComponent(tpCF);
        // set the according properties on our component instance
        var /** @type {?} */ instance = /** @type {?} */ (tp.instance);
        instance.title = title;
        instance.active = true;
        instance.closable = closable;
        instance['tabpillinstance'] = this.target;
        if (instance.amexiocolor === '') {
            instance.amexiocolor = 'amexio-top-tab-black';
        }
        else {
            instance.amexiocolor = 'amexio-top-tab-' + amexiocolor;
        }
        // create dynamic component
        var /** @type {?} */ dynCF = this.componentFactoryResolver.resolveComponentFactory(component);
        var /** @type {?} */ dynCmp = tp.instance.target.createComponent(dynCF);
        // Push new tab and select it.
        this.dummyArray.push(tp);
        this.tabCollection.push(tp.instance);
        this.selectTab(tp.instance);
        return dynCmp.instance;
    };
    /**
     * @param {?} tab
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.selectTab = /**
     * @param {?} tab
     * @return {?}
     */
    function (tab) {
        var _this = this;
        // deactivate all tabs
        this.tabCollection.forEach(function (tab1) {
            tab1.active = false;
        });
        tab.active = true;
        this.tabCollection.forEach(function (tab1) {
            _this.asignTabPillClass(tab1);
        });
    };
    /**
     * @param {?} tabData
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.asignTabPillClass = /**
     * @param {?} tabData
     * @return {?}
     */
    function (tabData) {
        tabData.tabPillClass = '';
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && tabData.active && (this.tabPosition === 'top')) {
            tabData.tabPillClass = 'activetab';
        }
        if ((!tabData.amexiocolor || tabData.amexiocolor === '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'bottomActivetab';
        }
        if (tabData.disabled) {
            tabData.tabPillClass = 'disabled-tab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'top') && tabData.active) {
            tabData.tabPillClass = 'activecolortab';
        }
        if ((tabData.amexiocolor !== '') && (this.tabPosition === 'bottom') && tabData.active) {
            tabData.tabPillClass = 'activebottomcolortab';
        }
    };
    /**
     * @param {?} tabId
     * @return {?}
     */
    AmexioVerticalTabComponent.prototype.activateTab = /**
     * @param {?} tabId
     * @return {?}
     */
    function (tabId) {
        this.tabCollection.forEach(function (tab) {
            tab.active = false;
        });
    };
    AmexioVerticalTabComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-vertical-tab-view',
                    template: "\n    <div class=\"vertical-table\">\n        <div class=\"vertical-tablerow\" style=\"height:580px\">\n            <div class=\"vertical-tablecol verticalalign-tableft\" [ngClass]=\"{'tabposition-top': (tabPosition==='top'),'tabposition-bottom':(tabPosition==='bottom')}\">\n                <div #tab class=\"verticalnavtab verticalnavtab-left\">\n                    <ul>\n                        <li *ngFor=\"let tabnode of tabCollection\">\n                            <div class=\"defaultnode\" [ngClass]=\"{'leftactivetab':tabnode.active,'disabled-tab':tabnode.disabled}\" (click)=\"onTabClick(tabnode)\" [ngStyle]=\"{'color': tabnode.amexiocolor}\">\n                                <span *ngIf=\"tabnode.icon\" [ngClass]=\"tabnode.icon\" style=\"padding-right:8px\" aria-hidden=\"true\"></span>\n                                <span>{{tabnode.title}}</span>\n                                <span *ngIf=\"closable\" class=\"tablecol\">\n                    <amexio-c-icon key=\"tab_close\" (onClick)=\"closeTab(tabnode)\" style=\"padding-left:5px;float:right\"></amexio-c-icon>\n                  </span>\n                            </div>\n                        </li>\n                    </ul>\n                </div>\n            </div>\n            <div class=\"vertical-tablecol verticalalign-tabcontent\">\n                <div class=\"tabcontent\" [attr.id]=\"componentId\">\n                    <ng-content></ng-content>\n                    <ng-template #target></ng-template>\n                </div>\n            </div>\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioVerticalTabComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 },
        { type: i0.ComponentFactoryResolver }
    ]; };
    AmexioVerticalTabComponent.propDecorators = {
        tabs: [{ type: i0.ViewChild, args: ['tab', { read: i0.ElementRef },] }],
        queryTabs: [{ type: i0.ContentChildren, args: [AmexioTabPillComponent,] }],
        target: [{ type: i0.ViewChild, args: ['target', { read: i0.ViewContainerRef },] }],
        closable: [{ type: i0.Input }],
        tabPosition: [{ type: i0.Input }],
        onClick: [{ type: i0.Output }]
    };
    return AmexioVerticalTabComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexiotimelineeventComponent = /** @class */ (function () {
    function AmexiotimelineeventComponent() {
        this.timelineclass = 'timeline-item';
        /*
          Properties
          name :contentborder
          datatype :string
          version : 4.2onwards
          default : false
          description : This will specify the content border in timeline.
          */
        this.contentborder = true;
        this.alignment = 'center';
    }
    AmexiotimelineeventComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-timeline-event',
                    template: "\n    <div \n\n    tabindex=\"0\"\n    attr.aria-label=\"{{alignment}}\"\n\n    class=\"timeline-badge \"  \n    [ngClass]=\"{'timeline-badge-center': (alignment === 'center')\n      , 'timeline-badge-left': (alignment === 'right')\n      , 'timeline-badge-right': (alignment === 'left')}\"\n      >\n    <amexio-c-icon [customclass]=\"icon\"></amexio-c-icon>\n    </div>\n    <div \n    tabindex=\"1\"\n    attr.aria-label=\"{{contentalignment}}\"\n    class=\"timeline-panel\" [ngClass]=\"{'timeline-panel-border':contentborder,\n     'timeline-panel-float-right': (contentalignment == 'right'),\n     'timeline-panel-float-left': (contentalignment == 'left'),\n     'timeline-panel-center': (alignment === 'center'),\n     'timeline-panel-right': (alignment === 'right'),\n     'timeline-panel-left': (alignment === 'left')}\">\n    <div \n    tabindex=\"1\"\n    *ngIf=\"label\"><b>{{label}}</b></div>\n\n    <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexiotimelineeventComponent.ctorParameters = function () { return []; };
    AmexiotimelineeventComponent.propDecorators = {
        timelineclass: [{ type: i0.HostBinding, args: ['attr.class',] }],
        label: [{ type: i0.Input, args: ['label',] }],
        icon: [{ type: i0.Input, args: ['icon',] }],
        contentborder: [{ type: i0.Input, args: ['content-border',] }],
        contentalignment: [{ type: i0.Input, args: ['content-alignment',] }]
    };
    return AmexiotimelineeventComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioTimeLineModel = /** @class */ (function () {
    function AmexioTimeLineModel(timelineevents, contentalignment, alignment) {
        this.timelineevents = timelineevents;
        this.alignment = alignment;
        this.contentalignment = contentalignment;
    }
    return AmexioTimeLineModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexiotimelineComponent = /** @class */ (function () {
    function AmexiotimelineComponent(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.alignment = 'center';
        var /** @type {?} */ that = this;
        this.matchMediaService.OnPhone(function (mediaQueryList) {
            that.mobileOrTabletMode();
        });
        this.matchMediaService.OnTablet(function (mediaQueryList) {
            that.mobileOrTabletMode();
        });
        this.matchMediaService.OnDesktop(function (mediaQueryList) {
            that.desktopMode();
        });
    }
    /**
     * @return {?}
     */
    AmexiotimelineComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexiotimelineComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.timelineevents = this.querylist.toArray();
        this.initContentAlignment();
    };
    /**
     * @return {?}
     */
    AmexiotimelineComponent.prototype.initContentAlignment = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.contentalignment) {
            this.alignment = this.contentalignment;
        }
        var /** @type {?} */ hasContentAlignment = true;
        this.timelineevents.forEach(function (timeline) {
            if (timeline.contentalignment) {
                hasContentAlignment = false;
            }
        });
        if (hasContentAlignment) {
            this.timelineevents.forEach(function (timeline, index) {
                if (_this.contentalignment) {
                    timeline.contentalignment = _this.contentalignment;
                }
                else {
                    timeline.contentalignment = ((index % 2) === 0) ? 'right' : 'left';
                }
                timeline.alignment = _this.alignment;
            });
        }
        this.timelineModel = new AmexioTimeLineModel(JSON.parse(JSON.stringify(this.timelineevents)), this.contentalignment, this.alignment);
    };
    /**
     * @return {?}
     */
    AmexiotimelineComponent.prototype.mobileOrTabletMode = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.alignment = 'right';
        this.timelineevents.forEach(function (timeline, index) {
            timeline.contentalignment = 'right';
            timeline.alignment = _this.alignment;
        });
    };
    /**
     * @return {?}
     */
    AmexiotimelineComponent.prototype.desktopMode = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.alignment = this.timelineModel.alignment;
        this.contentalignment = this.timelineModel.contentalignment;
        this.timelineevents.forEach(function (timeline, index) {
            var /** @type {?} */ originalTimelineEvent1 = _this.timelineModel.timelineevents[index];
            timeline.contentalignment = originalTimelineEvent1.contentalignment;
            timeline.alignment = originalTimelineEvent1.alignment;
        });
    };
    AmexiotimelineComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-timeline',
                    template: "\n    <div class='timeline' [ngClass]=\"{'timelinecenter': (alignment == 'center'), \n                                    'timelineleft': (alignment == 'left'), \n                                    'timelineright': (alignment == 'right')}\">\n      <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexiotimelineComponent.ctorParameters = function () { return [
        { type: DeviceQueryService }
    ]; };
    AmexiotimelineComponent.propDecorators = {
        querylist: [{ type: i0.ContentChildren, args: [AmexiotimelineeventComponent,] }],
        contentalignment: [{ type: i0.Input, args: ['content-alignment',] }]
    };
    return AmexiotimelineComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by ketangote on 12/18/17.
 */
var AmexioWindowPaneComponent = /** @class */ (function () {
    function AmexioWindowPaneComponent(renderer) {
        this.renderer = renderer;
        /*
           Properties
           name : vertical-position
           datatype : string
           version : 4.1 onwards
           default : none
           description : Postion of window vertically: top or bottom or center.
           This attribute is ignored if user specify position explicitly
           (using position-top/position-bottom/position-left/position-right)
           */
        this.verticalposition = 'center';
        /*
           Properties
           name : close-on-escape
           datatype : string
           version : 4.2onwards
           default : false
           description : Enables And Disables the Escape button.
           */
        this.closeonescape = true;
        this.showChange = new i0.EventEmitter();
        /*
           Properties
           name : maximize
           datatype : boolean
           version : 4.0 onwards
           default :false
           description : User can maximize the window to full screen.
           */
        this.maximize = false;
        /*
           Properties
           name : closable
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : User can close the window.
           */
        this.closable = true;
        /*
           Properties
           name : header
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : it is flag that decides header visibility
           */
        this.header = true;
        this.window = ' window-';
        this.width = '90%';
        this.nodeRightClick = new i0.EventEmitter();
        this.rightClick = new i0.EventEmitter();
        this.close = new i0.EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
    }
    /**
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.onCloseClick = /**
     * @return {?}
     */
    function () {
        if (this.closable) {
            this.showWindow = false;
            this.show = false;
            this.showChange.emit(false);
            this.close.emit(this.showWindow);
        }
    };
    /**
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setVerticlePosition();
        this.setHorizontalPosition();
        if (this.maximize) {
            this.dummyWidth = this.width;
            this.isFullWindow = true;
            this.maximumWindowStyle = this.setMaximizeClass(this.isFullWindow);
        }
        if (this.showWindow) {
            this.show = this.showWindow;
        }
    };
    /**
     * @param {?} isFullWindow
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.setMaximizeClass = /**
     * @param {?} isFullWindow
     * @return {?}
     */
    function (isFullWindow) {
        this.isFullWindow = isFullWindow;
        if (isFullWindow) {
            this.width = '100%';
            return {
                'margin-top': '0', 'height': '100%',
            };
        }
        else {
            this.width = this.dummyWidth;
            return {
                'margin-top': '1%', 'height': '96%',
            };
        }
    };
    /**
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.setVerticlePosition = /**
     * @return {?}
     */
    function () {
        switch (this.verticalposition) {
            case 'top': {
                this.verticalposition = 'flex-start';
                break;
            }
            case 'center': {
                this.verticalposition = 'center';
                break;
            }
            case 'bottom': {
                this.verticalposition = 'flex-end';
                break;
            }
            default: {
                this.verticalposition = 'center';
                break;
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.setHorizontalPosition = /**
     * @return {?}
     */
    function () {
        switch (this.horizontalposition) {
            case 'left': {
                this.horizontalposition = 'flex-start';
                break;
            }
            case 'center': {
                this.horizontalposition = 'center';
                break;
            }
            case 'right': {
                this.horizontalposition = 'flex-end';
                break;
            }
            default: {
                this.horizontalposition = 'center';
                break;
            }
        }
    };
    /* ASSIGN PROPERTIES TO FOOTER AND HEADER*/
    /**
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.amexioFooter && this.footer) {
            this.amexioFooter.toArray().forEach(function (footer) {
                footer.footer = _this.footer;
                footer.setFooterAlignment(_this.footeralign);
            });
        }
        if (this.amexioHeader && this.header) {
            this.amexioHeader.toArray()[0].closeable = this.closable;
            if (this.maximize) {
                this.amexioHeader.toArray()[0].setMaximizeData(this.maximize, this.isFullWindow);
                this.amexioHeader.toArray()[0].maximizeBehaiour.subscribe(function (max) {
                    _this.maximumWindowStyle = _this.setMaximizeClass(max);
                });
            }
            this.amexioHeader.toArray()[0].setMaterialDesignStatus(this.materialDesign);
            this.amexioHeader.toArray()[0].closeableBehaiour.subscribe(function (close) {
                _this.onCloseClick();
            });
        }
        if (this.amexioBody && this.bodyHeight) {
            this.amexioBody.toArray()[0].height = this.bodyHeight + '%';
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['show']) {
            this.setShowFlag(changes["show"].currentValue);
        }
        if (changes['showWindow']) {
            this.setShowFlag(changes["showWindow"].currentValue);
        }
    };
    /**
     * @param {?} changedValue
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.setShowFlag = /**
     * @param {?} changedValue
     * @return {?}
     */
    function (changedValue) {
        var _this = this;
        this.show = changedValue;
        if (this.show && this.closeonescape) {
            this.globalListenFunc = this.renderer.listen('document', 'keyup.esc', function (e) {
                _this.showWindow = false;
                _this.show = false;
                _this.showChange.emit(false);
                _this.close.emit(_this.showWindow);
            });
        }
        else if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    };
    // context menu code below
    /**
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.getContextMenu = /**
     * @return {?}
     */
    function () {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.loadContextMenu = /**
     * @param {?} rightClickData
     * @return {?}
     */
    function (rightClickData) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.mouseLocation.left = rightClickData.event.clientX;
            this.mouseLocation.top = rightClickData.event.clientY;
            this.getContextMenu();
            this.posixUp = this.getListPosition(rightClickData.ref);
            rightClickData.event.preventDefault();
            rightClickData.event.stopPropagation();
            this.rightClickNodeData = rightClickData.data;
            this.nodeRightClick.emit(rightClickData);
        }
    };
    /**
     * @param {?} Data
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.rightClickDataEmit = /**
     * @param {?} Data
     * @return {?}
     */
    function (Data) {
        this.rightClick.emit(Data);
    };
    /**
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.addListner = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.globalClickListenFunc = this.renderer.listen('document', 'click', function (e) {
            _this.flag = false;
            if (!_this.flag) {
                _this.removeListner();
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.removeListner = /**
     * @return {?}
     */
    function () {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    };
    /**
     * @return {?}
     */
    AmexioWindowPaneComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeListner();
        if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    };
    AmexioWindowPaneComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-window',
                    template: "\n\n    <div #id *ngIf=\"show\" class=\"amexio-root-window\"  [style.justify-content]=\"horizontalposition\">\n      <div class=\"amexio-root-window-content\"\n           (contextmenu)=\"loadContextMenu({event:$event,ref:id})\"\n           [style.justify-content]=\"verticalposition\"\n           [ngStyle]=\"maximumWindowStyle\"\n           [ngClass]=\"{'content-max-height': (maximize && isFullWindow)}\"\n           [@animation]=\"{value: 'visible', params: {transitionParams: transitionOptions}}\"\n           [style.width]=\"width\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n\n    <ng-container *ngIf=\"flag\">\n      <base-contextmenu style=\" z-index: 5; position: absolute;\" [base-context-menu]=\"contextmenu\" [mouse-location-top]=\"mouseLocation.top\"\n                        [mouse-location-left]=\"mouseLocation.left\" [is-FlagShow]=\"flag\" [right-click-data]=\"nodeRightClick\"\n                        (onRightClick)=\"rightClickDataEmit($event)\" [position-up]=\"posixUp\">\n      </base-contextmenu>\n    </ng-container>\n  ",
                    animations: [
                        trigger('animation', [
                            state('void', style({
                                transform: 'translate3d(0, 25%, 0) scale(0.9)',
                                opacity: 0,
                            })),
                            state('visible', style({
                                transform: 'none',
                                opacity: 1,
                            })),
                            transition('* => *', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioWindowPaneComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };
    AmexioWindowPaneComponent.propDecorators = {
        verticalposition: [{ type: i0.Input, args: ['vertical-position',] }],
        horizontalposition: [{ type: i0.Input, args: ['horizontal-position',] }],
        closeonescape: [{ type: i0.Input, args: ['close-on-escape',] }],
        top: [{ type: i0.Input, args: ['position-top',] }],
        footeralign: [{ type: i0.Input, args: ['footer-align',] }],
        showWindow: [{ type: i0.Input, args: ['show-window',] }],
        materialDesign: [{ type: i0.Input, args: ['material-design',] }],
        show: [{ type: i0.Input }],
        windowHeader: [{ type: i0.ViewChild, args: ['windowHeader', { read: i0.ElementRef },] }],
        showChange: [{ type: i0.Output }],
        bodyHeight: [{ type: i0.Input, args: ['body-height',] }],
        maximize: [{ type: i0.Input }],
        closable: [{ type: i0.Input }],
        header: [{ type: i0.Input }],
        footer: [{ type: i0.Input }],
        contextmenu: [{ type: i0.Input, args: ['context-menu',] }],
        width: [{ type: i0.Input, args: ['width',] }],
        nodeRightClick: [{ type: i0.Output }],
        rightClick: [{ type: i0.Output }],
        amexioHeader: [{ type: i0.ContentChildren, args: [AmexioHeaderComponent,] }],
        amexioFooter: [{ type: i0.ContentChildren, args: [AmexioFooterComponent,] }],
        amexioBody: [{ type: i0.ContentChildren, args: [AmexioBodyComponent,] }],
        close: [{ type: i0.Output }]
    };
    return AmexioWindowPaneComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioWindowHeaderComponent = /** @class */ (function () {
    function AmexioWindowHeaderComponent() {
    }
    /**
     * @return {?}
     */
    AmexioWindowHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioWindowHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-window-header', template: "\n    <ng-content></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioWindowHeaderComponent.ctorParameters = function () { return []; };
    AmexioWindowHeaderComponent.propDecorators = {
        padding: [{ type: i0.Input }]
    };
    return AmexioWindowHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by manisha on 7/6/18.
*/
var AmexioSearchAdvanceComponent = /** @class */ (function () {
    function AmexioSearchAdvanceComponent() {
        this.title = 'Advance Search';
        this.formwidth = 0;
        this.advanceSearchFlag = false;
    }
    /**
     * @return {?}
     */
    AmexioSearchAdvanceComponent.prototype.closeSearchForm = /**
     * @return {?}
     */
    function () {
        this.advanceSearchFlag = false;
    };
    /**
     * @return {?}
     */
    AmexioSearchAdvanceComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioSearchAdvanceComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-searchbox-options',
                    template: "\n  <form [attr.aria-expanded]=\"advanceSearchFlag\" class=\"advancesearchform\"\n  *ngIf=\"advanceSearchFlag\"  [style.width]=\"formwidth+'px'\">\n    <label tabindex = \"0\" class=\"search-form-label\" [attr.aria-labellledby]=\"title\">\n        {{title}}\n    </label>\n    <span tabindex = \"0\"  aria-label=\"close form button\"\n     class=\"fa fa-window-close fa-1x close-icon\"\n     (keyup.esc)=\"closeSearchForm()\"\n     (keyup.enter)=\"closeSearchForm()\" (click)=\"closeSearchForm()\"></span>\n    <hr class=\"hrclass\">\n             <ng-content></ng-content>\n</form>\n",
                },] },
    ];
    /** @nocollapse */
    AmexioSearchAdvanceComponent.ctorParameters = function () { return []; };
    AmexioSearchAdvanceComponent.propDecorators = {
        title: [{ type: i0.Input }],
        formwidth: [{ type: i0.Input, args: ['form-width',] }]
    };
    return AmexioSearchAdvanceComponent;
}());

var __extends$14 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
 * @template T
 */
var BaseFormValidator = /** @class */ (function (_super) {
    __extends$14(BaseFormValidator, _super);
    // @ViewChild(NgModel) model: NgModel;
    // public validate(c: FormControl) {
    //     return (this.model.valid ) ? null : {
    //         jsonParseError: {
    //             valid: true,
    //         },
    //     };
    // }
    function BaseFormValidator(renderer, element, _cd) {
        var _this = _super.call(this, renderer, element, _cd) || this;
        _this.renderer = renderer;
        _this.element = element;
        _this._cd = _cd;
        return _this;
    }
    return BaseFormValidator;
}(EventBaseComponent));

var __extends$13 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var SearchboxtoolComponent = /** @class */ (function (_super) {
    __extends$13(SearchboxtoolComponent, _super);
    function SearchboxtoolComponent(element, dataService, renderer, _cd) {
        var _this = _super.call(this, renderer, element, _cd) || this;
        _this.element = element;
        _this.dataService = dataService;
        _this.renderer = renderer;
        /*
           Properties
           name : title
           datatype : string
           version : 4.2 onwards
           default : none
           description : sets title to advance search form
           */
        _this.title = 'Advance Search';
        /*
           Properties
           name : width
           datatype : number
           version : 4.2 onwards
           default : none
           description : Sets width to auto recommendation list.
           */
        _this.width = 500;
        /*
           Events
           name : keyup
           description : Fires when keyup event occurs
           */
        _this.keyup = new i0.EventEmitter();
        /*
           Events
           name : onSearchItemClick
           description : Fires when search item is selected
           */
        _this.onSearchItemClick = new i0.EventEmitter();
        /*
           Events
           name : onSearchClick
           description : Fires when search button is clicked
           */
        _this.onSearchClick = new i0.EventEmitter();
        _this.searchformString = '';
        _this.caretFlag = false;
        _this.isListFlag = false;
        _this.searchFlag = false;
        _this.searchTextBox = false;
        _this.selectedValue = '';
        _this.advanceSearchFlag = false;
        _this.selectedindex = -1;
        _this.scrollposition = 30;
        _this.enableAdvanceSearch = false;
        _this.keystrokeflag = false;
        _this.isadvsearchbtnpressed = false;
        return _this;
    }
    Object.defineProperty(SearchboxtoolComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.advanceSearchRef.formwidth = this.width;
        this.enableAdvnSearch = this.advanceSearchRef.advanceSearchFlag;
        this.enableAdvanceSearch = true;
        if (this.advanceSearchRef) {
            this.enableAdvanceSearch = true;
            if (this.advanceSearchRef.title) {
                this.advanceButtonLabel = this.advanceSearchRef.title;
            }
            else if (!this.advanceSearchRef.title || this.advanceSearchRef.title === '') {
                this.advanceButtonLabel = 'Advance Search';
            }
        }
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.componentId = this.displayfield + Math.floor(Math.random() * 1000 + 999);
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (JSON.stringify(this.previousData) !== JSON.stringify(this.data)) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.onSelectClick = /**
     * @return {?}
     */
    function () {
        this.advanceSearchFlag = false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchboxtoolComponent.prototype.onInputClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.searchFlag = true;
        this.onBaseFocusEvent({});
        var /** @type {?} */ keyword = event.target.value;
        this.viewData = [];
        this.isListFlag = false;
        if (keyword != null && keyword !== ' ') {
            var /** @type {?} */ search_term_1 = keyword.toLowerCase();
            this.localData.forEach(function (item) {
                _this.tempOnInputClick(item, search_term_1);
            });
            this.keyup.emit(event);
        }
        // logic for arrow keys and enter key press
        // 40=down-arrow and 38=up-arrow and 13=enter
        if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            // if key pressed is up down or enter then process accordingly
            // call function for process
            this.navigateKeys(event);
        }
        if (!this.selectedValue || this.selectedValue === '') {
            this.viewData = [];
            this.isListFlag = false;
        }
    };
    /**
     * @param {?} item
     * @param {?} search_term
     * @return {?}
     */
    SearchboxtoolComponent.prototype.tempOnInputClick = /**
     * @param {?} item
     * @param {?} search_term
     * @return {?}
     */
    function (item, search_term) {
        for (var _i = 0, _a = Object.entries(item); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            var /** @type {?} */ val = void 0;
            val = value;
            this.a = key;
            // For New Input enable-filter
            if (item && (this.enablefilter) && (val.startsWith(search_term))
                && item !== null && item[this.displayfield]) {
                this.isListFlag = true;
                this.viewData.push(item);
            }
            else {
                if ((!this.enablefilter) && item !== null && val.startsWith(search_term)
                    && item[this.displayfield].toLowerCase().startsWith(search_term)) {
                    this.isListFlag = true;
                    this.viewData.push(item);
                }
            }
        }
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.selectedValue.length > 0) {
            var /** @type {?} */ keyword = this.selectedValue;
            this.viewData = [];
            this.isListFlag = false;
            if (keyword != null && keyword !== ' ') {
                var /** @type {?} */ search_term_2 = keyword.toLowerCase();
                this.localData.forEach(function (item1) {
                    _this.tempOnInputClick(item1, search_term_2);
                });
                this.searchFlag = true;
                this.onBaseFocusEvent({});
                this.keyup.emit(event);
            }
            this.selectedValueOnFocus();
        }
    };
    // If Selected Value is blank, then view data will be reset
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.selectedValueOnFocus = /**
     * @return {?}
     */
    function () {
        if (!this.selectedValue || this.selectedValue === '') {
            this.viewData = [];
            this.isListFlag = false;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchboxtoolComponent.prototype.navigateKeys = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.selectedindex > this.viewData.length) {
            this.selectedindex = 0;
        }
        if (event.keyCode === 40 ||
            event.keyCode === 38
                && this.selectedindex < this.viewData.length) {
            this.navigateKeysCondition(event);
        }
        if (event.keyCode === 13 && this.viewData[this.selectedindex]) {
            this.onItemSelect(this.viewData[this.selectedindex]);
        }
    };
    // Method will be called when keycode will be 40 or 38
    /**
     * @param {?} event
     * @return {?}
     */
    SearchboxtoolComponent.prototype.navigateKeysCondition = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ prevselectedindex = -1;
        if (this.selectedindex === -1) {
            this.selectedindex = 0;
        }
        else {
            prevselectedindex = this.selectedindex;
            if (event.keyCode === 40) {
                // mtd 1 start
                if (this.selectedindex >= this.viewData.length - 1) {
                    this.selectedindex = 0;
                }
                else {
                    this.selectedindex++;
                }
                // mtd 1 ends
                if ((this.selectedindex > 5)) {
                    this.dropdownitems.nativeElement.scroll(0, this.scrollposition);
                    this.scrollposition = this.scrollposition + 30;
                }
            }
            else if (event.keyCode === 38) {
                this.eventKeyCodeCondition();
            }
        }
        if (this.viewData[this.selectedindex]) {
            this.viewData[this.selectedindex].selected = true;
            this.setAriaActiveDescendant(this.selectedindex);
        }
        if (this.viewData[prevselectedindex]) {
            this.viewData[prevselectedindex].selected = false;
        }
    };
    // If keycode is 38
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.eventKeyCodeCondition = /**
     * @return {?}
     */
    function () {
        this.selectedindex--;
        if (this.selectedindex === -1) {
            this.selectedindex = this.viewData.length - 1;
            this.setAriaActiveDescendant(this.selectedindex);
        }
        if (this.scrollposition >= 0 && this.selectedindex > 1) {
            this.dropdownitems.nativeElement.scroll(1, this.scrollposition);
            this.scrollposition = this.scrollposition - 30;
        }
        if (this.selectedindex === 1) {
            this.scrollposition = 30;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    SearchboxtoolComponent.prototype.onSearchButtonClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onSearchClick.emit(event);
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.selectCssClass = /**
     * @return {?}
     */
    function () {
        if (this.viewData.length > 5) {
            return 'dropdown-list scroll';
        }
        else {
            return 'dropdown-list';
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    SearchboxtoolComponent.prototype.onItemSelect = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.value = item[this.valuefield];
        this.selectedValue = item[this.displayfield];
        this.searchFlag = this.onBaseBlurEvent({});
        this.onSearchItemClick.emit(item);
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.advanceSearch = /**
     * @return {?}
     */
    function () {
        this.isadvsearchbtnpressed = !this.isadvsearchbtnpressed;
        this.searchformString = 'advance search form opened';
        this.advanceSearchRef.advanceSearchFlag = true;
        this.advanceSearchFlag = true;
        this.searchFlag = this.onBaseBlurEvent({});
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.closeSearchForm = /**
     * @return {?}
     */
    function () {
        this.advanceSearchFlag = false;
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    SearchboxtoolComponent.prototype.getResponseData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            if (dr != null) {
                for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                    var ir = dr_1[_i];
                    responsedata = responsedata[dr[ir]];
                }
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    SearchboxtoolComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        // Check if key is added?
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_2 = dr; _i < dr_2.length; _i++) {
                var ir = dr_2[_i];
                responsedata = responsedata[dr[ir]];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewData = responsedata;
        this.generateIndex();
        this.localData = JSON.parse(JSON.stringify(this.viewData));
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.closeOnEscape = /**
     * @return {?}
     */
    function () {
        this.viewData = [];
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.closeFormOnEscape = /**
     * @return {?}
     */
    function () {
        this.advanceSearchRef.closeSearchForm();
        this.viewData = [];
        this.advanceSearchFlag = false;
        this.selectedindex = -1;
    };
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.generateIndex = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.viewData.forEach(function (element, index) {
            element['index'] = _this.componentId + 'listitem' + index;
        });
    };
    /**
     * @param {?} rowindex
     * @return {?}
     */
    SearchboxtoolComponent.prototype.setAriaActiveDescendant = /**
     * @param {?} rowindex
     * @return {?}
     */
    function (rowindex) {
        if (this.viewData.length > 0) {
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', this.viewData[rowindex].index);
        }
        else if (this.displayValue.length < 1) {
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', 'listitem');
        }
    };
    // will be fired on end key press
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.focustolast = /**
     * @return {?}
     */
    function () {
        if (this.viewData.length > 0) {
            this.viewData[this.selectedindex].selected = false;
            this.selectedindex = this.viewData.length - 1;
            this.viewData[this.selectedindex].selected = true;
            this.setAriaActiveDescendant(this.selectedindex);
        }
    };
    // will be fired on home key press
    /**
     * @return {?}
     */
    SearchboxtoolComponent.prototype.focustofirst = /**
     * @return {?}
     */
    function () {
        if (this.viewData.length > 0) {
            this.viewData[this.selectedindex].selected = false;
            this.selectedindex = 0;
            this.viewData[this.selectedindex].selected = true;
            this.setAriaActiveDescendant(this.selectedindex);
        }
    };
    SearchboxtoolComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-searchbox',
                    template: "\n    <div (keyup.esc)=\"closeOnEscape()\">\n      <div \n      tabindex=\"1\"\n      (keyup.end)=\"focustolast()\" (keyup.home)=\"focustofirst()\" \n      class=\"input-group\">\n        <!-- input div -->\n        <div class=\"input-group-prepend\" >\n          <input id=\"{{componentId}}\" type=\"text\" \n          aria-haspopup=\"true\" aria-label=\"Search input box\" [attr.aria-expanded]=\"isListFlag\" \n          class=\"form-control\"\n            (keyup)=\"onInputClick($event)\" #inp [(ngModel)]=\"selectedValue\" [attr.placeholder]=\"placeholder\" \n            (click)=\"onSelectClick()\"\n            (focus)=\"onFocus()\"  >\n        </div>\n        <!-- search btn -->\n        <div   aria-label=\"search button\" class=\"input-group-text-search \" (click)=\"onSearchButtonClick($event)\">\n          <em class=\"fa fa-search iconColor\">\n          </em>\n        </div>\n      </div>\n      <!-- first div ends here -->\n\n      <!-- dropdown list and advance search btn -->\n      <form [ngStyle]=\"dropdownstyle\" class=\"dropdownposition\">\n        <ng-container *ngIf=\"!advanceSearchFlag\">\n          <ul role =\"menu\" tabindex=\"1\" #dropdownitems [style.width]=\"width+'px'\" \n          class=\"search-dropdown-list\" [ngClass]=\"selectCssClass()\">\n\n            <li role = \"menuitem\" tabindex=\"1\" role=\"menuitem\" class=\"search-list-items \" \n            [ngClass]=\"{'search-list-items-selected':item.selected}\" *ngFor=\"let item of viewData\"\n              id=\"{{item.index}}\"\n            (click)=\"onItemSelect(item)\">\n              <div style=\"white-space: nowrap;display: inline;\">{{item[displayfield]}}</div>\n            </li>\n          </ul>\n          <!-- adv button ng-container -->\n          <ng-container *ngIf=\"viewData.length > 0\">\n              <!-- <ng-container *ngIf=\"viewData.length > 0\"> -->\n            <div [style.width]=\"width+'px'\" class=\"advancesearchbuttondiv\">\n              <button role=\"button\" class=\"fa fa-search btncolor\" [style.width]=\"width+'px'\" class=\"advancesearchbtn fa fa-search\" \n              (click)=\"advanceSearch()\" (keyup.enter) = \"advanceSearch()\" >\n                {{advanceButtonLabel}}\n              </button>\n            </div>\n            <!-- {{isadvsearchbtnpressed}} -->\n          </ng-container>\n\n        </ng-container>\n      </form>\n      <!-- advance search form with ng content -->\n      <div (keyup.esc)=\"closeFormOnEscape()\" [ngStyle]=\"{'block': advanceSearchRef.advanceSearchFlag ? 'block' : 'none'}\">\n        <ng-content></ng-content>\n      </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    SearchboxtoolComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: CommonDataService },
        { type: i0.Renderer2 },
        { type: i0.ChangeDetectorRef }
    ]; };
    SearchboxtoolComponent.propDecorators = {
        data: [{ type: i0.Input, args: ['data',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        title: [{ type: i0.Input }],
        valuefield: [{ type: i0.Input, args: ['value-field',] }],
        width: [{ type: i0.Input }],
        enablefilter: [{ type: i0.Input, args: ['enable-global-filter',] }],
        keyup: [{ type: i0.Output }],
        onSearchItemClick: [{ type: i0.Output }],
        onSearchClick: [{ type: i0.Output }],
        advanceSearchRef: [{ type: i0.ContentChild, args: [AmexioSearchAdvanceComponent,] }],
        dropdownitems: [{ type: i0.ViewChild, args: ['dropdownitems', { read: i0.ElementRef },] }],
        inp: [{ type: i0.ViewChild, args: ['inp', { read: i0.ElementRef },] }]
    };
    return SearchboxtoolComponent;
}(BaseFormValidator));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 13/12/17.
*/
var AmexioButtonDropDownItemComponent = /** @class */ (function () {
    function AmexioButtonDropDownItemComponent() {
        /*
        Events
        name : onItemClick
        datatype : none
        version : none
        default : none
        description : Fire when button-dropdown item button/link click
        */
        this.onItemClick = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    AmexioButtonDropDownItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioButtonDropDownItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-btn-dropdown-item', template: '',
                },] },
    ];
    /** @nocollapse */
    AmexioButtonDropDownItemComponent.ctorParameters = function () { return []; };
    AmexioButtonDropDownItemComponent.propDecorators = {
        label: [{ type: i0.Input }],
        badge: [{ type: i0.Input, args: ['badge',] }],
        disabled: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        onClickRoute: [{ type: i0.Input }],
        onItemClick: [{ type: i0.Output }]
    };
    return AmexioButtonDropDownItemComponent;
}());

var __extends$15 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 13/12/17.
*/
var AmexioButtonDropdownComponent = /** @class */ (function (_super) {
    __extends$15(AmexioButtonDropdownComponent, _super);
    function AmexioButtonDropdownComponent(element, renderer, _cd) {
        var _this = _super.call(this, renderer, element, _cd) || this;
        _this.element = element;
        _this.dropdownItemData = [];
        /*
          Events
          name : click
          datatype :  none
          version : none
          default : none
          description : Fire when button-dropdown item button/link click
          */
        _this.click = new i0.EventEmitter();
        /*
        Events
        name : getLinkData
        datatype :  none
        version : none
        default : none
        description : Fire when button-dropdown item button/link click
        */
        _this.getLinkData = new i0.EventEmitter();
        _this.ispressed = false;
        _this.selected = false;
        _this.flag = false;
        _this.activedescendant = 'aria-activedescendant';
        return _this;
    }
    Object.defineProperty(AmexioButtonDropdownComponent.prototype, "data", {
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._buttonGroupLocalData = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioButtonDropdownComponent.prototype, "buttonGroupLocalData", {
        get: /**
         * @return {?}
         */
        function () {
            return this._buttonGroupLocalData;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.label + Math.floor(Math.random() * 1000 + 999);
    };
    /**
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (JSON.stringify(this.buttonGroupPreviewData) !== JSON.stringify(this.buttonGroupLocalData)) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.dropdownItemData = this.buttonGroupLocalData;
        }
    };
    /**
     * @param {?} array
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.generateIndex = /**
     * @param {?} array
     * @return {?}
     */
    function (array) {
        var _this = this;
        this.dropdownItemData.forEach(function (element, index) {
            element['index'] = _this.componentId + 'listitem' + index;
        });
    };
    /**
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.buttonGroupPreviewData = JSON.parse(JSON.stringify(this.buttonGroupLocalData));
            this.dropdownItemData = this.buttonGroupLocalData;
            this.createDropdownItemConfig(this.dropdownItemData);
        }
        else {
            this.createDropdownItemConfig(this.buttons.toArray());
        }
        this.componentLoaded = true;
    };
    /**
     * @param {?} btnCollection
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.createDropdownItemConfig = /**
     * @param {?} btnCollection
     * @return {?}
     */
    function (btnCollection) {
        var /** @type {?} */ itemRefArray = btnCollection;
        for (var _i = 0, itemRefArray_1 = itemRefArray; _i < itemRefArray_1.length; _i++) {
            var itemConfig = itemRefArray_1[_i];
            var /** @type {?} */ data = {
                label: itemConfig.label,
                disabled: itemConfig.disabled,
                onItemClick: itemConfig.onItemClick,
                iconStyleClass: itemConfig.iconStyleClass,
                icon: itemConfig.icon,
                badge: itemConfig.badge,
                selected: false,
                onClickRoute: itemConfig.onClickRoute,
            };
            data.iconStyleClass = data.icon;
            this.dropdownItemData.push(data);
        }
        if (itemRefArray.length === this.dropdownItemData.length) {
            this.generateIndex(this.dropdownItemData);
        }
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onClick = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        this.ispressed = !this.ispressed;
        this.openContent = !this.openContent;
        if (this.openContent) {
            this.onBaseFocusEvent({});
        }
        else {
            this.openContent = this.onBaseBlurEvent(elem);
        }
        this.posixUp = this.getListPosition(elem);
        this.click.emit();
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onEnterClick = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        this.flag = true;
        this.dropdownItemData[0].selected = true;
        this.ispressed = !this.ispressed;
        if (this.openContent) {
            this.onBaseFocusEvent({});
        }
        else {
            this.openContent = this.onBaseBlurEvent(elem);
        }
        this.posixUp = this.getListPosition(elem);
        this.click.emit();
        var /** @type {?} */ divid = document.getElementById(this.componentId);
        divid.setAttribute(this.activedescendant, this.dropdownItemData[0].index);
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onClickEscape = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        this.openContent = false;
        this.hide();
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onSpaceClick = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        this.onEnterClick(elem);
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onHomeClick = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        if (this.flag) {
            this.buttonindex1 = this.findbuttonindex();
            if (this.buttonindex1 < (this.dropdownItemData.length - 1)) {
                this.onHomeClickSelected();
            }
            else if (this.buttonindex1 === this.dropdownItemData.length - 1) {
                this.onHomeClickSelected();
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onHomeClickSelected = /**
     * @return {?}
     */
    function () {
        this.dropdownItemData[this.buttonindex1].selected = false;
        this.dropdownItemData[0].selected = true;
        var /** @type {?} */ divid = document.getElementById(this.componentId);
        divid.setAttribute(this.activedescendant, this.dropdownItemData[0].index);
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onEndClick = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        if (this.flag) {
            this.buttonindex1 = this.findbuttonindex();
            if (this.buttonindex1 < (this.dropdownItemData.length - 1)) {
                this.onEndClickSelected();
            }
            else if (this.buttonindex1 === this.dropdownItemData.length - 1) {
                this.onEndClickSelected();
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onEndClickSelected = /**
     * @return {?}
     */
    function () {
        this.dropdownItemData[this.buttonindex1].selected = false;
        this.dropdownItemData[this.dropdownItemData.length - 1].selected = true;
        var /** @type {?} */ divid = document.getElementById(this.componentId);
        divid.setAttribute(this.activedescendant, this.dropdownItemData[this.dropdownItemData.length - 1].index);
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onclickDown = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        if (this.flag) {
            this.buttonindex1 = this.findbuttonindex();
            if (this.buttonindex1 < (this.dropdownItemData.length - 1)) {
                this.dropdownItemData[this.buttonindex1].selected = false;
                this.dropdownItemData[this.buttonindex1 + 1].selected = true;
                var /** @type {?} */ divid = document.getElementById(this.componentId);
                divid.setAttribute(this.activedescendant, this.dropdownItemData[this.buttonindex1 + 1].index);
            }
            else if (this.buttonindex1 === this.dropdownItemData.length - 1) {
                this.dropdownItemData[this.buttonindex1].selected = false;
                this.dropdownItemData[0].selected = true;
                var /** @type {?} */ divid = document.getElementById(this.componentId);
                divid.setAttribute(this.activedescendant, this.dropdownItemData[0].index);
            }
        }
        else {
            this.dropdownstyle = { visibility: 'visible' };
            this.dropdownItemData[0].selected = true;
            var /** @type {?} */ divid = document.getElementById(this.componentId);
            divid.setAttribute(this.activedescendant, this.dropdownItemData[0].index);
            this.flag = true;
        }
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onclickUp = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        if (this.flag) {
            this.buttonindex1 = this.findbuttonindex();
            if ((this.buttonindex1 < (this.dropdownItemData.length - 1)) && this.buttonindex1 !== 0) {
                this.onClickUpSelected();
            }
            else if (this.buttonindex1 === (this.dropdownItemData.length - 1)) {
                this.onClickUpSelected();
            }
            else if (this.buttonindex1 === 0) {
                this.dropdownItemData[this.dropdownItemData.length - 1].selected = true;
                this.dropdownItemData[this.buttonindex1].selected = false;
                var /** @type {?} */ divid = document.getElementById(this.componentId);
                divid.setAttribute(this.activedescendant, this.dropdownItemData[this.dropdownItemData.length - 1].index);
            }
        }
        else {
            this.dropdownstyle = { visibility: 'visible' };
            this.dropdownItemData[this.dropdownItemData.length - 1].selected = true;
            var /** @type {?} */ divid = document.getElementById(this.componentId);
            divid.setAttribute(this.activedescendant, this.dropdownItemData[this.dropdownItemData.length - 1].index);
            this.flag = true;
        }
    };
    /**
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onClickUpSelected = /**
     * @return {?}
     */
    function () {
        this.dropdownItemData[this.buttonindex1].selected = false;
        this.dropdownItemData[this.buttonindex1 - 1].selected = true;
        var /** @type {?} */ divid = document.getElementById(this.componentId);
        divid.setAttribute(this.activedescendant, this.dropdownItemData[this.buttonindex1 - 1].index);
    };
    /**
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.findbuttonindex = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ buttonindex;
        this.dropdownItemData.forEach(function (element, index) {
            if (element.selected === true) {
                buttonindex = index;
            }
        });
        return buttonindex;
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ dropdownHeight = 325; // must be same in dropdown.scss
        if (window.screen.height - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} eve
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.onblur = /**
     * @param {?} eve
     * @return {?}
     */
    function (eve) {
        this.openContent = this.onBaseBlurEvent(eve);
    };
    /**
     * @param {?} clickEvent
     * @param {?} itemData
     * @return {?}
     */
    AmexioButtonDropdownComponent.prototype.btnItemClick = /**
     * @param {?} clickEvent
     * @param {?} itemData
     * @return {?}
     */
    function (clickEvent, itemData) {
        if (this.buttonGroupLocalData && this.buttonGroupLocalData.length > 0) {
            this.getLinkData.emit({ event: clickEvent, parentRef: this, data: itemData });
        }
        else {
            if (!itemData.disabled) {
                itemData.onItemClick.emit(clickEvent);
                this.openContent = !this.openContent;
                this.onBaseBlurEvent(event);
            }
        }
    };
    AmexioButtonDropdownComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-btn-dropdown',
                    template: "\n    <div class=\"button-group\" #rootDiv>\n        <button id={{componentId}} role=\"button\" aria-haspopup=\"true\" aria-label=\"\" [attr.aria-expanded]=\"openContent\" tabindex=\"1\" aria-controls=\"menulist\" class=\"button-dropdown-main\" (blur)=\"onblur($event)\" (click)=\"onClick(rootDiv)\" (keyup.enter)=\"onEnterClick(rootDiv)\"\n            (keyup.esc)=\"onClickEscape(rootDiv)\" (keyup.end)=\"onEndClick(rootDiv)\" (keyup.home)=\"onHomeClick(rootDiv)\" (keyup.space)=\"onSpaceClick(rootDiv)\" (keyup.arrowdown)=\"onclickDown(rootDiv)\" (keyup.arrowup)=\"onclickUp(rootDiv)\" #btnRef [ngClass]=\"{'button-default': size=='default' || size ==null,\n                'button-small': size=='small',\n                'button-large' : size=='large',\n                'button-primary' : type == 'primary' || type == null || type == 'theme-color',\n                'button-success' : type == 'success' || type == 'green',\n                'button-danger' : type=='danger' || type == 'red',\n                'button-warning' : type=='warning' ||  type == 'yellow'}\">\n          <amexio-c-icon style=\"float:right;\" key=\"button_caret-down\"></amexio-c-icon>\n          <span [attr.disabled]=\"disabled ? true: null\">{{label}} &nbsp;&nbsp;</span>\n          <!--<i class=\"fa fa-caret-down\" style=\"float:right;\" ></i>-->\n        </button>\n        <div class=\"button-dropdown\" role=\"menu\" [ngClass]=\"{'button-dropdown-up' : posixUp}\" [@changeState]=\"dropdownstyle.visibility\" [ngStyle]=\"dropdownstyle\">\n            <div id=\"{{itemData.index}}\" role=\"option\" tabindex=\"1\" *ngFor=\"let itemData of dropdownItemData let index = index\">\n                <div [ngClass]=\"{'button-default': size=='default' || size ==null,'button-small': size=='small','button-large' : size=='large'}\">\n                    <div [ngStyle]=\"{'cursor': itemData.disabled ? 'not-allowed':'pointer'}\" (click)=\"btnItemClick($event,itemData)\">\n                        <amexio-c-icon style=\"padding-right: 5px;\" [customclass]=\"itemData.iconStyleClass\"></amexio-c-icon>\n                        <span [ngClass]=\"{'button-group-list-items':itemData.selected}\" [attr.disabled]=\"itemData.disabled ? true: null\">{{itemData.label}}&nbsp;&nbsp;</span>\n                        <!--<i [class]=\"itemData.iconStyleClass\" aria-hidden=\"true\" style=\"float:right;\" ></i>-->\n                        <ng-container *ngIf=\"itemData.badge\">\n                            <span class=\"btn-dropdown-badge\">{{itemData.badge}}</span>\n                        </ng-container>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n  ",
                    animations: [
                        trigger('changeState', [
                            state('visible', style({})),
                            state('hidden', style({
                                height: '0px',
                            })),
                            transition('*=>*', animate('200ms')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioButtonDropdownComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: i0.ChangeDetectorRef }
    ]; };
    AmexioButtonDropdownComponent.propDecorators = {
        btnReference: [{ type: i0.ViewChild, args: ['btnRef',] }],
        label: [{ type: i0.Input }],
        buttons: [{ type: i0.ContentChildren, args: [AmexioButtonDropDownItemComponent,] }],
        data: [{ type: i0.Input, args: ['buttonGroupLocalData',] }],
        type: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        size: [{ type: i0.Input }],
        badge: [{ type: i0.Input, args: ['badge',] }],
        click: [{ type: i0.Output }],
        getLinkData: [{ type: i0.Output }]
    };
    return AmexioButtonDropdownComponent;
}(BaseFormValidator));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 13/12/17.
*/
var AmexioSpiltButtonDropdownComponent = /** @class */ (function () {
    function AmexioSpiltButtonDropdownComponent() {
        this.dropdownItemData = [];
    }
    /**
     * @return {?}
     */
    AmexioSpiltButtonDropdownComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.createDropdownItemConfig();
    };
    /**
     * @return {?}
     */
    AmexioSpiltButtonDropdownComponent.prototype.createDropdownItemConfig = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ itemRefArray = [];
        itemRefArray = this.buttons.toArray();
        for (var _i = 0, itemRefArray_1 = itemRefArray; _i < itemRefArray_1.length; _i++) {
            var itemConfig = itemRefArray_1[_i];
            var /** @type {?} */ data = {
                label: itemConfig.label,
                disabled: itemConfig.disabled,
                onItemClick: itemConfig.onItemClick,
                iconStyleClass: itemConfig.iconStyleClass,
                icon: itemConfig.icon,
                onClickRoute: itemConfig.onClickRoute,
            };
            data.iconStyleClass = data.icon;
            this.dropdownItemData.push(data);
        }
    };
    /**
     * @return {?}
     */
    AmexioSpiltButtonDropdownComponent.prototype.onClick = /**
     * @return {?}
     */
    function () {
        this.openContent = !this.openContent;
    };
    /**
     * @param {?} event
     * @param {?} itemData
     * @return {?}
     */
    AmexioSpiltButtonDropdownComponent.prototype.itemClick = /**
     * @param {?} event
     * @param {?} itemData
     * @return {?}
     */
    function (event, itemData) {
        itemData.onItemClick.emit(event);
    };
    /**
     * @return {?}
     */
    AmexioSpiltButtonDropdownComponent.prototype.getBackgroundColor = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ colorCode;
        if (this.type === 'primary' || this.type === 'theme-color') {
            colorCode = '#0275d8';
        }
        else if (this.type === 'success' || this.type === 'green') {
            colorCode = '#5cb85c';
        }
        else if (this.type === 'danger' || this.type === 'red') {
            colorCode = '#d9534f';
        }
        else if (this.type === 'warning' || this.type === 'yellow') {
            colorCode = '#f0ad4e';
        }
        return {
            'background-color': colorCode,
        };
    };
    AmexioSpiltButtonDropdownComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-btn-split-dropdown', template: "\n    <div class=\"dropdown-button\" [ngStyle]=\"getBackgroundColor()\">\n      <button class=\"button\" [attr.disabled]=\"disabled ? true: null\"\n              [ngClass]=\"{'button-default': size=='default' || size ==null,\n              'button-small': size=='small','button-large' : size=='large',\n              'button-primary' : type == 'primary' || type == null,\n              'button-success' : type == 'success',' button-danger' : type=='danger',\n              'button-warning' : type=='warning'}\">\n        {{label}}\n      </button>\n      <button class=\"button\"\n              [ngClass]=\"{'button-default': size=='default' || size ==null,\n              'button-small': size=='small',\n              'button-large' : size=='large',\n              'button-primary' : type == 'primary' || type == null || type == 'theme-color',\n              'button-success' : type == 'success' || type == 'green',\n              'button-danger' : type=='danger' || type == 'red',\n              'button-warning' : type=='warning' ||  type == 'yellow'}\">\n              (click)=\"onClick()\"><i class=\"fa fa-chevron-down\" aria-hidden=\"true\"></i></button>\n      <div class=\"dropdown-button-content\" [ngStyle]=\"{'display' : openContent ? 'block' : 'none'}\">\n        <ul class=\"dropdown-list\">\n          <ng-container *ngFor=\"let itemData of dropdownItemData\">\n            <li class=\"list-items\" [ngClass]=\"{'disabled':itemData.disabled}\" (click)=\"itemClick($event,itemData)\">\n            <ng-container *ngIf=\"itemData.icon!=null\">\n              <!--<i [class]=\"itemData.iconStyleClass\" aria-hidden=\"true\"></i>-->\n              <amexio-c-icon style=\"padding-right: 5px;\" [customclass]=\"itemData.iconStyleClass\"></amexio-c-icon>\n            </ng-container>{{itemData.label}}\n            </li>\n          </ng-container>\n        </ul>\n      </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioSpiltButtonDropdownComponent.ctorParameters = function () { return []; };
    AmexioSpiltButtonDropdownComponent.propDecorators = {
        label: [{ type: i0.Input }],
        badge: [{ type: i0.Input, args: ['badge',] }],
        buttons: [{ type: i0.ContentChildren, args: [AmexioButtonDropDownItemComponent,] }],
        type: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        size: [{ type: i0.Input }]
    };
    return AmexioSpiltButtonDropdownComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var noop$7 = function () {
};
var CheckboxComponent = /** @class */ (function () {
    function CheckboxComponent(checkboxGroup) {
        this.checkboxGroup = checkboxGroup;
        this.onTouchedCallback = noop$7;
        this.onChangeCallback = noop$7;
        this.tabFocus = false;
    }
    /**
     * @return {?}
     */
    CheckboxComponent.prototype.toggleCheck = /**
     * @return {?}
     */
    function () {
        if (!this.checked) {
            this.checkboxGroup.add(this.value);
        }
        else {
            this.checkboxGroup.remove(this.value);
        }
        this.checked = !this.checked;
    };
    /**
     * @return {?}
     */
    CheckboxComponent.prototype.isChecked = /**
     * @return {?}
     */
    function () {
        return this.checked || this.checkboxGroup.contains(this.value);
    };
    /**
     * @return {?}
     */
    CheckboxComponent.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.tabFocus = false;
        this.onTouchedCallback();
    };
    /**
     * @return {?}
     */
    CheckboxComponent.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.tabFocus = true;
    };
    /**
     * @return {?}
     */
    CheckboxComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.componentId = this.createCompId('checkbox', this.name);
        setTimeout(function () {
            if (_this.checked) {
                _this.checkboxGroup.add(_this.value);
            }
        }, 200);
    };
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    CheckboxComponent.prototype.createCompId = /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    function (inputType, name) {
        return inputType + '_' + name + '_' + Math.floor(Math.random() * 1000 + 999);
    };
    CheckboxComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'checkbox',
                    template: "\n    <label [attr.aria-checked]=\"checked\"\n           for=\"{{componentId}}\"\n           class=\"input-box-container\" \n           [ngClass]=\"{'disable-component' : disabled || disabled}\">\n    {{label}}\n    <input type=\"checkbox\"  \n           style=\"top:0; left:0\"\n           class=\"form-control\" \n           [attr.tabindex]=\"disabled ? -1 : 0\"\n           id=\"{{componentId}}\"\n           (focus)=\"onFocus()\"\n           (blur)=\"onBlur()\"\n           [ngClass]=\"{'checkbox-disable' : disabled}\" \n           [checked]=\"checked\" \n           [attr.aria-disabled]=\"disabled\"\n           (click)=\"toggleCheck()\">\n    <span class=\"input-box-checkbox-label\"  [ngClass]=\"{'focusOnCheckbox':tabFocus}\"></span>\n    </label>\n  ",
                },] },
    ];
    /** @nocollapse */
    CheckboxComponent.ctorParameters = function () { return [
        { type: AmexioCheckBoxGroupComponent, decorators: [{ type: i0.Host }] }
    ]; };
    CheckboxComponent.propDecorators = {
        label: [{ type: i0.Input }],
        value: [{ type: i0.Input }],
        name: [{ type: i0.Input }],
        checked: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }]
    };
    return CheckboxComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioChipComponent = /** @class */ (function () {
    function AmexioChipComponent() {
        /*
        Properties
        name : icon
        datatype :
        version : 5.3.1 onwards
        default :
        description : The icon is for determining of icon.
        */
        this.icon = '';
        /*
        Properties
        name : closeable
        datatype :
        version : 5.3.1onwards
        default :
        description : The closeable is for closing particular chip.
        */
        /*
        Properties
        name : color
        datatype :
        version : 5.3.1onwards
        default :
        description : The color is for determining color of particular chip.
        */
        this.fontcolor = 'red';
        /*
            Events
            name :  closeClick
            datatype : none
            version : none
            default : none
            description : It will fire only on selection of checkbox and gives you selected record data.
            */
        this.closeClick = new i0.EventEmitter();
        /*
           Events
           name :  labelClick
           datatype : none
           version : none
           default : none
           description : It will fire only on selection of checkbox and gives you selected record data.
           */
        this.labelClick = new i0.EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioChipComponent.prototype.onCloseClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.closeClick.emit(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioChipComponent.prototype.onLabelClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.labelClick.emit(event);
    };
    /**
     * @return {?}
     */
    AmexioChipComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioChipComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chip',
                    template: "\n    <div class=\"chips\" id=\"{{index}}\" attr.aria-label=\"{{label}}\" style=\"cursor: pointer;\" [ngStyle]=\"{'background-color': color,'filter': selected ? 'contrast(70%)':''}\">\n      <amexio-c-icon [customclass]=\"icon\"></amexio-c-icon>\n      <amexio-label (click)=\"onLabelClick($event)\">\n        <ng-container *ngIf=\"!label\">\n        <span [style.color]=\"fontcolor\" style=\"cursor: pointer;\" [ngStyle]=\"{'padding-left': icon ? '10px':'0px'}\">\n          {{item[displayfield]}}\n        </span>\n      </ng-container>\n      <ng-container *ngIf=\"label\">\n        <span [style.color]=\"fontcolor\" style=\"cursor: pointer;\" [ngStyle]=\"{'padding-left': icon ? '10px':'0px'}\">\n          {{label}}\n        </span>\n      </ng-container>\n      </amexio-label>\n      <span class=\"badge\" *ngIf=\"badge\">{{badge}}</span>\n      <span *ngIf=\"closable\">\n        <i class=\"fa fa-times\" style=\"cursor: pointer; margin-left:10px\" (click)=\"onCloseClick($event)\"></i>\n      </span>\n    </div>\n  ",
                    styles: ["\n\n  "],
                },] },
    ];
    /** @nocollapse */
    AmexioChipComponent.ctorParameters = function () { return []; };
    AmexioChipComponent.propDecorators = {
        icon: [{ type: i0.Input, args: ['icon',] }],
        label: [{ type: i0.Input, args: ['label',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        badge: [{ type: i0.Input, args: ['badge',] }],
        fontcolor: [{ type: i0.Input, args: ['font-color',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        item: [{ type: i0.Input, args: ['item',] }],
        closable: [{ type: i0.Input, args: ['closable',] }],
        closeClick: [{ type: i0.Output }],
        labelClick: [{ type: i0.Output }],
        index: [{ type: i0.Input, args: ['index',] }],
        selected: [{ type: i0.Input, args: ['selected',] }]
    };
    return AmexioChipComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioChipsComponent = /** @class */ (function () {
    function AmexioChipsComponent(renderer) {
        this.renderer = renderer;
        /*
            Events
            name : selectedRowData
            datatype : none
            version : none
            default : none
            description : It will fire only on selection of checkbox and gives you selected record data.
            */
        this.selectedchipsData = new i0.EventEmitter();
        this.closeClick = new i0.EventEmitter();
        this.chipindex = -1;
        this.prevchipindex = -1;
        this.obj = {};
        this.componentId = 'chips' + Math.floor(Math.random() * 1000 + 999);
    }
    /**
     * @return {?}
     */
    AmexioChipsComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chipCollection = this.queryChips.toArray();
        if (this.chipCollection.length > 0) {
            this.data = this.chipCollection;
        }
        this.generateIndex();
        this.listenChipOutClick();
    };
    /**
     * @return {?}
     */
    AmexioChipsComponent.prototype.listenChipOutClick = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.documentClickListener = this.renderer
            .listen('document', 'click', function (event) {
            if (_this.data.length > 0) {
                _this.data.forEach(function (element, index) {
                    if (_this.data[index]['selected'] === true) {
                        _this.data[index]['selected'] = false;
                        _this.chipindex = -1;
                        _this.prevchipindex = -1;
                    }
                });
            }
        });
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioChipsComponent.prototype.onCloseChipsClick = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var _this = this;
        if (this.chipindex > -1) {
            this.data[this.chipindex]['selected'] = false;
        }
        if (this.data.length > 0) {
            this.data.forEach(function (element, index) {
                if (element.label === item.label) {
                    _this.data.splice(index, 1);
                }
            });
            this.emitCloseData(item);
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioChipsComponent.prototype.emitCloseData = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ cloneNode = JSON.parse(JSON.stringify(item));
        delete cloneNode['index'];
        if (this.chipCollection.length > 0) {
            this.obj['icon'] = item.icon;
            this.obj['label'] = item.label;
            this.obj['badge'] = item.badge;
            this.obj['closable'] = item.closable;
            this.obj['color'] = item.color;
            this.closeClick.emit(this.obj);
        }
        else {
            this.closeClick.emit(cloneNode);
        }
    };
    /**
     * @param {?} item
     * @param {?} chipdata
     * @return {?}
     */
    AmexioChipsComponent.prototype.closeFocusedChip = /**
     * @param {?} item
     * @param {?} chipdata
     * @return {?}
     */
    function (item, chipdata) {
        var _this = this;
        var /** @type {?} */ closeindex;
        var /** @type {?} */ emitdata;
        this.obj = {};
        if (this.data.length > 0) {
            chipdata.forEach(function (element, index) {
                if (chipdata[index]['selected'] === true) {
                    emitdata = element;
                    _this.chiplabel = chipdata[index]['label'] + 'closed';
                    _this.data.splice(index, 1);
                    closeindex = index;
                }
            });
            this.obj['icon'] = emitdata.icon;
            this.obj['label'] = emitdata.label;
            this.obj['badge'] = emitdata.badge;
            this.obj['closable'] = emitdata.closable;
            this.obj['color'] = emitdata.color;
            this.closeChip(closeindex);
            this.emitSelectedLabel(chipdata);
        }
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioChipsComponent.prototype.emitSelectedLabel = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ cloneNode = JSON.parse(JSON.stringify(item));
        delete cloneNode['index'];
        if (this.chipCollection.length > 0) {
            this.obj['icon'] = item.icon;
            this.obj['label'] = item.label;
            this.obj['badge'] = item.badge;
            this.obj['closable'] = item.closable;
            this.obj['color'] = item.color;
            this.selectedchipsData.emit(this.obj);
        }
        else {
            this.selectedchipsData.emit(cloneNode);
        }
    };
    /**
     * @return {?}
     */
    AmexioChipsComponent.prototype.generateIndex = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.data.forEach(function (element, index) {
            element['index'] = _this.componentId + 'chip' + index;
            element['selected'] = false;
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioChipsComponent.prototype.onchipsKeyup = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.data.length > 0) {
            this.navigateChips(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioChipsComponent.prototype.navigateChips = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.keyCode === 37) {
            this.leftArrowKeyNavigation(event);
        }
        else if (event.keyCode === 39) {
            this.rightArrowKeyNavigation(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioChipsComponent.prototype.leftArrowKeyNavigation = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.prevchipindex > -1) {
            this.data[this.prevchipindex]['selected'] = false;
        }
        this.prevchipindex--;
        if (this.prevchipindex === -1) {
            this.prevchipindex = this.data.length - 1;
            this.chipindex = -1;
        }
        this.setAriaActiveDescendant(this.prevchipindex);
        if (this.prevchipindex === 0) {
            this.chipindex = 0;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioChipsComponent.prototype.rightArrowKeyNavigation = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.prevchipindex > -1) {
            this.data[this.prevchipindex]['selected'] = false;
        }
        this.chipindex++;
        this.prevchipindex = this.chipindex;
        if (this.chipindex >= this.data.length) {
            this.chipindex = 0;
            this.prevchipindex = 0;
        }
        this.setAriaActiveDescendant(this.chipindex);
    };
    /**
     * @param {?} rowindex
     * @return {?}
     */
    AmexioChipsComponent.prototype.setAriaActiveDescendant = /**
     * @param {?} rowindex
     * @return {?}
     */
    function (rowindex) {
        this.data[rowindex]['selected'] = true;
        var /** @type {?} */ inputid = document.getElementById(this.componentId);
        inputid.setAttribute('aria-activedescendant', this.data[rowindex]['index']);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioChipsComponent.prototype.focusToLastChip = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.prevchipindex > -1) {
            this.data[this.prevchipindex]['selected'] = false;
        }
        this.prevchipindex = this.data.length - 1;
        this.chipindex = -1;
        this.setAriaActiveDescendant(this.prevchipindex);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioChipsComponent.prototype.focusToFirstChip = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.prevchipindex > -1) {
            this.data[this.prevchipindex]['selected'] = false;
        }
        this.chipindex = 0;
        this.prevchipindex = 0;
        this.setAriaActiveDescendant(this.chipindex);
    };
    /**
     * @param {?} closeindex
     * @return {?}
     */
    AmexioChipsComponent.prototype.closeChip = /**
     * @param {?} closeindex
     * @return {?}
     */
    function (closeindex) {
        if (closeindex !== 0) {
            this.chipindex = closeindex - 1;
            this.prevchipindex = closeindex - 1;
            this.setAriaActiveDescendant(closeindex - 1);
        }
        else {
            this.chipindex = closeindex;
            this.prevchipindex = closeindex;
            this.setAriaActiveDescendant(closeindex);
        }
    };
    AmexioChipsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chips',
                    template: "\n    <span id=\"{{componentId}}\" tabindex=\"0\" role=\"listbox\" (keyup.end)=\"focusToLastChip($event)\" (keyup.home)=\"focusToFirstChip($event)\"\n        (keyup)=\"onchipsKeyup($event)\" (keydown.control.x)=\"closeFocusedChip($event, data)\">\n        <span role=\"option\" tabindex=\"0\" *ngFor=\"let item of data\" id=\"{{item.index}}\" attr.aria-label=\"{{item.label}}\">\n            <amexio-chip [item]=\"item\" [index]=\"item.index\" [selected]=\"item.selected\" [display-field]=\"displayfield\"\n                [icon]=\"item.icon\" [label]=\"item.label\" [badge]=\"item.badge\" [closable]=\"item.closable\" [font-color]=\"item.fontcolor\"\n                [color]=\"item.color\" (closeClick)=\"onCloseChipsClick(item)\" (labelClick)=\"emitSelectedLabel(item)\">\n            </amexio-chip>\n        </span>\n    </span>\n  ",
                    styles: ["\n\n  "],
                },] },
    ];
    /** @nocollapse */
    AmexioChipsComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };
    AmexioChipsComponent.propDecorators = {
        queryChips: [{ type: i0.ContentChildren, args: [AmexioChipComponent,] }],
        data: [{ type: i0.Input, args: ['data',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        selectedchipsData: [{ type: i0.Output }],
        closeClick: [{ type: i0.Output }]
    };
    return AmexioChipsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCreditCardModel = /** @class */ (function () {
    function AmexioCreditCardModel() {
        this.owner = '';
        this.cvv = null;
        this.cardnumber = null;
        this.expMonth = 1;
        this.expYear = 2018;
    }
    return AmexioCreditCardModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Ankita
*/
var noop$8 = function () {
};
var AmexioCreditcardComponent = /** @class */ (function () {
    function AmexioCreditcardComponent() {
        /*
          Properties
          name : yearcount
          datatype : string
          version : 5.2.3onwards
          default :
          description : the minexp will set the dropdown to user defined dropdown.
          */
        this.yearcount = 12;
        /*
         Properties
         name : showlabel
         datatype : boolean
         version : 5.2.3onwards
         default :
         description : the showlabel will set the label of creditcard.
         */
        this.showlabel = 'false';
        this.isNameValid = false;
        this.isCvvValid = false;
        this.visaEagerReg = /^4/;
        this.visaReg = /^4\d{12}(\d{3}|\d{6})?$/;
        this.mastropattern = /^(?:5[06789]\d\d|(?!6011[0234])(?!60117[4789])(?!60118[6789])(?!60119)(?!64[456789])(?!65)6\d{3})\d{8,15}$/;
        this.masttroeagerPattern = /^(5(018|0[23]|[68])|6[37]|60111|60115|60117([56]|7[56])|60118[0-5]|64[0-3]|66)/;
        this.masterpattern = /^5[1-5]\d{14}$/;
        this.mastereagerPattern = /^5[1-5]/;
        this.isFullCardValid = false;
        this.cvvRegex = /^[0-9]{3,4}$/;
        this.year = new Date();
        this.yearList = [];
        this.eagarValue = '';
        this.fullPatternValue = '';
        this.onTouchedCallback = noop$8;
        this.onChangeCallback = noop$8;
        if (this.template === 'single-column') {
            this.templateFlag = true;
        }
        else if (this.template === 'double-column') {
            this.templateFlag = false;
        }
        this.creditCardModel = new AmexioCreditCardModel();
        this.dummyMonth = '0' + this.creditCardModel.expMonth;
        this.dateData = [
            {
                month: '01',
            },
            {
                month: '02',
            },
            {
                month: '03',
            },
            {
                month: '04',
            },
            {
                month: '05',
            },
            {
                month: '06',
            },
            {
                month: '07',
            },
            {
                month: '08',
            },
            {
                month: '09',
            },
            {
                month: '10',
            },
            {
                month: '11',
            },
            {
                month: '12',
            },
        ];
        this.cardGroupData = [
            {
                iconName: 'fa fa-cc-visa',
                key: 'eagerflagvisa',
                color: 'black',
            },
            {
                iconName: 'fa fa-cc-mastercard',
                key: 'mastereagerPattern',
                color: 'black',
            },
            {
                iconName: 'fa fa-credit-card',
                key: 'masttroeagerPattern',
                color: 'black',
            },
        ];
    }
    // From ControlValueAccessor Interface
    /**
     * @param {?} modelValue
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.writeValue = /**
     * @param {?} modelValue
     * @return {?}
     */
    function (modelValue) {
        var _this = this;
        if (modelValue) {
            this.creditCardModel = modelValue;
            this.onChangeCardNumber(this.creditCardModel.cardnumber);
            this.onChangeMonth('0' + this.creditCardModel.expMonth);
            this.isCvvValid = this.cvvRegex.test(this.creditCardModel.cvv);
            this.cardRegexMap.forEach(function (value, key) {
                var /** @type {?} */ isEagarValid = value.test(_this.dummyCreditCardNumber);
                if (isEagarValid) {
                    _this.eagarflag = isEagarValid;
                    _this.eagarValue = key;
                }
            });
            this.validEagerCard = this.eagarValue;
            this.switchCaseMethod();
            this.onCheckValidation();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.onChangeCardNumber = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.dummyCreditCardNumber = this.creditCardNumberSpaceRemove(event);
        var /** @type {?} */ concatCardNumber = this.replaceSpace(this.dummyCreditCardNumber);
        this.cardPatternMap.forEach(function (value, key) {
            // Condition for Full String Regex
            // Condition for Full String Regex
            _this.isValidFullString = value.test(concatCardNumber);
            if (_this.isValidFullString) {
                _this.fullPatternflag = _this.isValidFullString;
                _this.fullPatternValue = key;
            }
        });
        this.validPatternCard = this.fullPatternValue;
        this.creditCardModel.cardnumber = +concatCardNumber;
    };
    // From ControlValueAccessor Interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor Interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    // method to check owners length
    /**
     * @param {?} inp
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.onNameClick = /**
     * @param {?} inp
     * @return {?}
     */
    function (inp) {
        if (inp.model.length > 0) {
            this.isNameValid = true;
        }
        else {
            this.isNameValid = false;
        }
    };
    // method to check Cvv Number
    /**
     * @param {?} inpcvv
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.onClick = /**
     * @param {?} inpcvv
     * @return {?}
     */
    function (inpcvv) {
        this.isCvvValid = this.cvvRegex.test(inpcvv.model);
    };
    // method to check Card Number
    /**
     * @param {?} inp
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.onInput = /**
     * @param {?} inp
     * @return {?}
     */
    function (inp) {
        // Condition for null check
        if (inp.model !== '') {
            var /** @type {?} */ isValidFullString_1;
            var /** @type {?} */ fullPatternValue_1 = '';
            var /** @type {?} */ concatValue_1 = this.replaceSpace(inp.model);
            this.cardPatternMap.forEach(function (value, key) {
                // Condition for Full String Regex
                // Condition for Full String Regex
                isValidFullString_1 = value.test(concatValue_1);
                if (isValidFullString_1) {
                    fullPatternValue_1 = key;
                }
            });
            this.validPatternCard = fullPatternValue_1;
            var /** @type {?} */ eagarValue_1 = '';
            this.cardRegexMap.forEach(function (value, key) {
                var /** @type {?} */ isEagarValid = value.test(concatValue_1);
                if (isEagarValid) {
                    eagarValue_1 = key;
                }
            });
            this.validEagerCard = eagarValue_1;
        }
        else {
            this.validEagerCard = '';
        }
        this.switchCaseMethod();
        this.onCheckValidation();
        if (inp.model !== '') {
            this.cardNumberValue = this.creditCardNumberSpaceRemove(inp.model);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.replaceSpace = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        var /** @type {?} */ newString = '';
        if (value) {
            var /** @type {?} */ stringArray = value.split(' ');
            if (stringArray) {
                stringArray.forEach(function (element) {
                    newString = newString.concat(element);
                });
            }
        }
        return newString;
    };
    // Map Implementation for key value pair
    /**
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.cardRegexMap = new Map();
        this.cardPatternMap = new Map();
        this.cardRegexMap.set('eagerflagvisa', this.visaEagerReg);
        this.cardRegexMap.set('mastereagerPattern', this.mastereagerPattern);
        this.cardRegexMap.set('masttroeagerPattern', this.masttroeagerPattern);
        this.cardPatternMap.set('visaReg', this.visaReg);
        this.cardPatternMap.set('masterpattern', this.masterpattern);
        this.cardPatternMap.set('mastropattern', this.mastropattern);
        this.cardName = '';
        this.currentYear = this.year.getFullYear();
        if (this.template === 'single-column') {
            this.templateFlag = true;
        }
        else if (this.template === 'double-column') {
            this.templateFlag = false;
        }
        for (var /** @type {?} */ i = 0; i < this.yearcount; i++) {
            this.yearList.push(this.currentYear + i);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.creditCardNumberSpaceRemove = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value) {
            value = value.toString();
            var /** @type {?} */ v = value.replace(/\s+/g, '').replace(/[^0-9]/gi, '');
            var /** @type {?} */ matches = v.match(/\d{4,16}/g);
            var /** @type {?} */ match = matches && matches[0] || '';
            var /** @type {?} */ parts = [];
            var /** @type {?} */ len = void 0;
            var /** @type {?} */ i = void 0;
            for (i = 0, len = match.length; i < len; i += 4) {
                parts.push(match.substring(i, i + 4));
            }
            if (parts.length) {
                return parts.join(' ');
            }
            else {
                return value;
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.switchCaseMethod = /**
     * @return {?}
     */
    function () {
        switch (this.validEagerCard) {
            case 'eagerflagvisa':
                this.cardName = 'fa fa-cc-visa';
                break;
            case 'mastereagerPattern':
                this.cardName = 'fa fa-cc-mastercard';
                break;
            case 'masttroeagerPattern':
                this.cardName = 'fa fa-credit-card';
                break;
            case '':
                this.cardName = '';
                break;
            default:
                this.cardName = '';
                break;
        }
    };
    /**
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.onCheckValidation = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.cardGroupData.forEach(function (element) {
            if (element.key === _this.validEagerCard) {
                element.color = 'blue';
            }
            else {
                element.color = 'black';
            }
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCreditcardComponent.prototype.onChangeMonth = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.dummyMonth = event;
        this.creditCardModel.expMonth = +this.dummyMonth;
    };
    AmexioCreditcardComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-creditcard',
                    template: "\n    <!-- <pre><code>{{creditCardModel|json}}</code></pre> -->\n    <ng-container *ngIf=\"templateFlag\">\n\n            <div class=\"creditCardFormSglCol\">\n                <div class=\"imageSglCol\">\n                    <i *ngFor=\"let cardimage of cardGroupData\" [style.color]=\"cardimage.color\" [attr.class]=\"cardimage.iconName\" style=\"font-size:50px\">\n                    </i>\n                </div>\n                <div class=\"ownerdetailsSglCol\">\n                    <label *ngIf=\"showlabel\">CARD HOLDER NAME</label>\n                    <div class=\"ownerSglCol\">\n                        <input [ngClass]=\"{'input-control-success':isNameValid,'input-control-failure':(!isNameValid && inpowner.touched)}\" type=\"text\" placeholder=\"CARD HOLDER NAME\"\n                            #inpowner=\"ngModel\" class=\"input-control\" [(ngModel)]=\"creditCardModel.owner\" (keyup)=\"onNameClick(inpowner)\">\n                    </div>\n                </div>\n        \n                <div class=\"cardNumberSglCol\">\n                    <label *ngIf=\"showlabel\">CARD NUMBER</label>\n                    <input type=\"text\" placeholder=\"CARD NUMBER\" maxlength=\"19\" class=\"input-control\" [ngModel]=\"dummyCreditCardNumber\" (ngModelChange)=\"onChangeCardNumber($event)\"\n                    [value]=\"cardNumberValue\" #inp=\"ngModel\" [ngClass]=\"{'input-control-success':validPatternCard,'input-control-failure':(!validPatternCard && (inp.dirty || inp.touched))}\" (keyup)=\"onInput(inp)\"\n                    />\n                </div>\n                <label *ngIf=\"showlabel\">EXP DATE</label>\n                <div class=\"expiration-dateSglCol\">\n                    <div class=\"monthSglCol\">\n                        <select [ngModel]=\"dummyMonth\" (ngModelChange)=\"onChangeMonth($event)\" placeholder=\"MM\" style=\"padding:10px\">\n                            <option *ngFor=\"let months of dateData\">{{months.month}}</option>\n                        </select>\n                    </div>\n                    <div class=\"dateSglCol\">\n                        <select [(ngModel)]=\"creditCardModel.expYear\" yearControl=\"yearControl\" style=\"padding:10px\" placeholder=\"YY\">\n                            <option *ngFor=\"let year of yearList\">{{year}}</option>\n                        </select>\n                    </div>\n                </div>\n                <div class=\"cvvSglCol\">\n                    <label *ngIf=\"showlabel\">CVV</label>\n                    <input #inpcvv=\"ngModel\" [ngClass]=\"{'input-control-success':isCvvValid,'input-control-failure':(!isCvvValid && inpcvv.touched)}\"\n                        type=\"password\" placeholder=\"CVV\" maxlength=\"3\" class=\"input-control\" [(ngModel)]=\"creditCardModel.cvv\" (keyup)=\"onClick(inpcvv)\">\n                </div>\n            </div>\n            </ng-container>\n            <br>\n            <ng-container *ngIf=\"!templateFlag\">\n            <div class=\"creditCardForm\">\n                <div class=\"owner\">\n                    <label *ngIf=\"showlabel\">CARD HOLDER NAME</label>\n                    <input [ngClass]=\"{'input-control-success':isNameValid,'input-control-failure':(!isNameValid && inpowner.touched)}\" type=\"text\" placeholder=\"CARD HOLDER NAME\"\n                       #inpowner=\"ngModel\" class=\"input-control\" [(ngModel)]=\"creditCardModel.owner\" (keyup)=\"onNameClick(inpowner)\">\n                </div>\n                <div [ngClass]=\"{'image-label':showlabel==true,'image':showlabel==false}\">\n                    <i *ngFor=\"let cardimage of cardGroupData\" [style.color]=\"cardimage.color\" [attr.class]=\"cardimage.iconName\" style=\"font-size:40px\"></i>\n                </div>\n        \n        \n                <div class=\"cardNumber\">\n                    <label *ngIf=\"showlabel\">CARD NUMBER</label>\n                    <input type=\"text\" placeholder=\"CARD NUMBER\" maxlength=\"19\" class=\"input-control\" [ngModel]=\"dummyCreditCardNumber\" (ngModelChange)=\"onChangeCardNumber($event)\"\n                    [value]=\"cardNumberValue\"   #inp=\"ngModel\" [ngClass]=\"{'input-control-success':validPatternCard,'input-control-failure':(!validPatternCard && (inp.dirty || inp.touched))}\" (keyup)=\"onInput(inp)\" />\n                </div>\n        \n                <div [ngClass]=\"{'expiration-date-label':showlabel==true,'expiration-date':showlabel==false}\" >\n                    <label *ngIf=\"showlabel\">EXP DATE</label>\n                    <div class=\"exp-month-date-label\">\n                        <div class=\"month\">\n                            <select [ngModel]=\"dummyMonth\" (ngModelChange)=\"onChangeMonth($event)\" style=\"padding:10px\" placeholder=\"MM\">\n                                <option *ngFor=\"let months of dateData\">{{months.month}}</option>\n                            </select>\n                        </div>\n                        <div class=\"date\">\n                            <select [(ngModel)]=\"creditCardModel.expYear\" yearControl=\"yearControl\" style=\"padding:10px\" placeholder=\"YY\">\n                                <option *ngFor=\"let year of yearList\">{{year}}</option>\n                            </select>\n                        </div>\n                    </div>\n        \n                </div>\n        \n                <div class=\"cvv\">\n                    <label *ngIf=\"showlabel\">CVV</label>\n                    <input #inpcvv=\"ngModel\" [ngClass]=\"{'input-control-success':isCvvValid,'input-control-failure':(!isCvvValid && (inpcvv.dirty ||inpcvv.touched))}\"\n                        type=\"password\" placeholder=\"CVV\" maxlength=\"3\" class=\"input-control\" [(ngModel)]=\"creditCardModel.cvv\" (keyup)=\"onClick(inpcvv)\">\n                </div>\n            </div>\n            </ng-container>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioCreditcardComponent; }), multi: true,
                        }],
                    styles: ["\n\n  "],
                },] },
    ];
    /** @nocollapse */
    AmexioCreditcardComponent.ctorParameters = function () { return []; };
    AmexioCreditcardComponent.propDecorators = {
        yearcount: [{ type: i0.Input, args: ['year-count',] }],
        showlabel: [{ type: i0.Input, args: ['show-label',] }],
        template: [{ type: i0.Input, args: ['template',] }]
    };
    return AmexioCreditcardComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DarkmodeComponent = /** @class */ (function () {
    function DarkmodeComponent() {
        this.size = 'medium';
        this.themesdata = [];
        this.themeStyles = [];
        this.themesdata = [
            {
                varName: '--appBackground',
                darkValue: '#121212',
                themeValue: '#f5f5f5',
            },
            {
                varName: '--appForegroundColor',
                darkValue: '#f5f5f5',
                themeValue: '#121212',
            },
            {
                varName: '--componentBGColor',
                darkValue: '#121212',
                themeValue: '#ffffff',
            },
            {
                varName: '--componentFontColor',
                darkValue: '#ffffff',
                themeValue: '#121212',
            },
        ];
    }
    /**
     * @return {?}
     */
    DarkmodeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DarkmodeComponent.prototype.onToggleClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.themeStyles = [];
        this.themesdata.forEach(function (obj) {
            var /** @type {?} */ varObj = {
                name: '',
                value: '',
            };
            if (event) {
                varObj.name = obj.varName;
                varObj.value = obj.darkValue;
            }
            else {
                varObj.name = obj.varName;
                varObj.value = obj.themeValue;
            }
            _this.themeStyles.push(varObj);
        });
        this.themeStyles.forEach(function (style) {
            document.documentElement.style.setProperty(style.name, style.value);
        });
    };
    DarkmodeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-darkmode',
                    template: "\n      <amexio-toggle\n      [field-label]=\"fieldLabel\" [size]=\"size\" [type]=\"type\" [shape]=\"shape\" (onChange)=\"onToggleClick($event)\">\n      </amexio-toggle>\n    ",
                },] },
    ];
    /** @nocollapse */
    DarkmodeComponent.ctorParameters = function () { return []; };
    DarkmodeComponent.propDecorators = {
        fieldLabel: [{ type: i0.Input, args: ['field-label',] }],
        shape: [{ type: i0.Input, args: ['shape',] }],
        type: [{ type: i0.Input, args: ['type',] }],
        size: [{ type: i0.Input, args: ['size',] }]
    };
    return DarkmodeComponent;
}());

var __extends$17 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
 * @template T
 */
var ListBaseDatepickerComponent = /** @class */ (function (_super) {
    __extends$17(ListBaseDatepickerComponent, _super);
    function ListBaseDatepickerComponent(renderer, element, cd) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        _this.element = element;
        _this.cd = cd;
        _this.self = false;
        _this.itemClick = false;
        _this.hide();
        return _this;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    ListBaseDatepickerComponent.prototype.focus = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'visible' };
        this.bindDocumentClickListener();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ListBaseDatepickerComponent.prototype.blur = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.itemClicked();
    };
    /**
     * @return {?}
     */
    ListBaseDatepickerComponent.prototype.itemClicked = /**
     * @return {?}
     */
    function () {
        this.itemClick = true;
        this.hide();
        this.unbindDocumentClickListener();
        this.clearClicks();
    };
    /**
     * @return {?}
     */
    ListBaseDatepickerComponent.prototype.bindDocumentClickListener = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer
                .listen('document', 'click', function (event) { return _this.handleDocumentListener(event); });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ListBaseDatepickerComponent.prototype.handleDocumentListener = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.self && !this.itemClick) {
            this.hide();
            this.unbindDocumentClickListener();
        }
        this.clearClicks();
        this.cd.markForCheck();
    };
    /**
     * @return {?}
     */
    ListBaseDatepickerComponent.prototype.clearClicks = /**
     * @return {?}
     */
    function () {
        this.self = false;
        this.itemClick = false;
    };
    /**
     * @return {?}
     */
    ListBaseDatepickerComponent.prototype.unbindDocumentClickListener = /**
     * @return {?}
     */
    function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    /**
     * @return {?}
     */
    ListBaseDatepickerComponent.prototype.hide = /**
     * @return {?}
     */
    function () {
        this.dropdownstyle = { visibility: 'hidden' };
    };
    return ListBaseDatepickerComponent;
}(AmexioFormValidator));

var __extends$16 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var noop$9 = function () {
};
var AmexioDateTimePickerComponent = /** @class */ (function (_super) {
    __extends$16(AmexioDateTimePickerComponent, _super);
    function AmexioDateTimePickerComponent(element, cdf, renderer) {
        var _this = _super.call(this, renderer, element, cdf) || this;
        _this.element = element;
        _this.cdf = cdf;
        /*
          Properties
          name : field-label
          datatype : string
          version : 5.5.5 onwards
          default :
          description :The label of this field
          */
        _this.placeholder = '';
        /*
           Properties
           name : disabled
           datatype : boolean
           version : 4.1.5 onwards
           default : false
           description : Disable Date/Time Picker field
           */
        _this.disabled = false;
        /*
           Properties
           name : diabled-date
           datatype :  any
           version : 4.2 onwards
           default : none
           description : sets disabled dates range
           */
        _this.diabledDate = [];
        /*
           Properties
           name : inline-datepicker
           datatype :  boolean
           version : 4.2 onwards
           default : none
           description : sets inline calender
           */
        _this.inlineDatepicker = false;
        /*
           Properties
           name : dropdown-datepicker
           datatype :  boolean
           version : 4.2 onwards
           default : none
           description : sets dropdown datepicker
           */
        _this.dropdownDatepicker = false;
        /*
           Properties
           name : required
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : Flag to allow blank field or not
           */
        _this.required = false;
        /*
           Events
           name : blur
           description : On blur event
           */
        // @Output() blur: EventEmitter<any> = new EventEmitter<any>();
        /*
           Properties
           name : change
           description : On field value change event
           */
        _this.change = new i0.EventEmitter();
        /*
           Properties
           name : input
           description : On input event field.
           */
        _this.input = new i0.EventEmitter();
        /*
           Properties
           name : focus
           description : On field focus event
           */
        // @Output() focus: EventEmitter<any> = new EventEmitter<any>();
        _this.inputtabindex = 0;
        _this.daystabindex = -1;
        _this.drop = false;
        _this.tempFlag = true;
        _this.hostFlag = false;
        _this.isComponentValid = new i0.EventEmitter();
        _this.backArrowFlag = false;
        _this.forwardArrowFlag = false;
        _this.okispressed = false;
        _this.cancelispressed = false;
        _this.innerValue = '';
        _this.onTouchedCallback = noop$9;
        _this.onChangeCallback = noop$9;
        _this.viewmode = '1';
        _this.yearList1 =
            [{ year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
            ];
        // generate yearlist1 ids
        // generate yearlist1 ids
        _this.yearList1.forEach(function (yearlist1element) {
            yearlist1element['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
        });
        _this.yearList2 = [{ year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }];
        // generate yearlist2 ids
        // generate yearlist2 ids
        _this.yearList2.forEach(function (yearlist2element) {
            yearlist2element['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
        });
        _this.monthList1 = [
            { name: 'Jan', flag: false, num: 4, fullname: 'January' },
            { name: 'Feb', flag: false, fullname: 'febuary' },
            { name: 'Mar', flag: false, fullname: 'march' },
            { name: 'Apr', flag: false, fullname: 'april' },
            { name: 'May', flag: false, fullname: 'may' },
            { name: 'Jun', flag: false, fullname: 'june' },
        ];
        // generate id for monthlist1
        // generate id for monthlist1
        _this.monthList1.forEach(function (monthlist1element) {
            monthlist1element['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
        });
        _this.monthList2 = [
            { name: 'Jul', flag: false, fullname: 'july' },
            { name: 'Aug', flag: false, fullname: 'august' },
            { name: 'Sep', flag: false, fullname: 'september' },
            { name: 'Oct', flag: false, fullname: 'october' },
            { name: 'Nov', flag: false, fullname: 'november' },
            { name: 'Dec', flag: false, fullname: 'december' },
        ];
        // generate id for monthlist 2
        // generate id for monthlist 2
        _this.monthList2.forEach(function (monthlist2element) {
            monthlist2element['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
        });
        _this.minDate = '';
        _this.maxDate = '';
        _this.elementId = new Date().getTime() + '';
        _this.selectedDate = new Date();
        _this.currrentDate = new Date();
        _this.curYear = _this.currrentDate.getFullYear();
        var /** @type {?} */ i = 0;
        var /** @type {?} */ j = 0;
        for (i = 4; i >= 0; i--) {
            _this.yearList1[j].year = _this.curYear - i;
            j++;
        }
        j = 0;
        for (i = 1; i <= 5; i++) {
            _this.yearList2[j].year = _this.curYear + i;
            j++;
        }
        _this.daysTitle = [];
        _this.daysArray = [];
        _this.timepicker = false;
        _this.hrs = _this.currrentDate.getHours();
        _this.min = _this.currrentDate.getMinutes();
        _this.initDaysTitle();
        _this.createDaysForCurrentMonths(_this.currrentDate);
        _this.monthList1.forEach(function (tmpElement) {
        });
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.inlineDatepicker) {
            this.showToolTip = true;
            this.dropdownstyle = { visibility: 'visible' };
        }
        this.isValid = !this.required;
        this.isComponentValid.emit(!this.required);
        if (this.dateformat != null) {
            this.dateformat = 'dd/MM/yyyy';
        }
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.minMaxDateFound();
        } // main if ends
        // logic for disabling yrs before min and after max
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            var /** @type {?} */ min_1 = new Date(this.minDate);
            var /** @type {?} */ max_1 = new Date(this.maxDate);
            this.yearList1.forEach(function (element) {
                _this.disableMinMaxYear(element, min_1, max_1);
            });
            this.yearList2.forEach(function (element) {
                _this.disableMinMaxYear(element, min_1, max_1);
            });
        }
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.initDaysTitle = /**
     * @return {?}
     */
    function () {
        this.daysTitle.push({ text: 'Mo' });
        this.daysTitle.push({ text: 'Tu' });
        this.daysTitle.push({ text: 'We' });
        this.daysTitle.push({ text: 'Th' });
        this.daysTitle.push({ text: 'Fr' });
        this.daysTitle.push({ text: 'Sa' });
        this.daysTitle.push({ text: 'Su' });
    };
    /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.createDaysForCurrentMonths = /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    function (selectedPeriod) {
        this.daysArray = [];
        var /** @type {?} */ date = new Date(selectedPeriod.getFullYear(), selectedPeriod.getMonth(), 1, 0, 0, 0, 0); // Starting at the 1st of the month
        var /** @type {?} */ extras = (date.getDay() + 6) % 7; // How many days of the last month do we need to include?
        date.setDate(date.getDate() - extras); // Skip back to the previous monday
        while (this.daysArray.length < 6) {
            var /** @type {?} */ rowDays = [];
            for (var /** @type {?} */ i = 0; i < 7; i++) {
                var /** @type {?} */ day = {
                    date: null, selected: false, isCurrentMonth: null, isDisabled: false,
                };
                day.date = new Date(date.getTime());
                day.isCurrentMonth = (date.getMonth() === selectedPeriod.getMonth());
                day['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
                day['fulldate'] = (day.date).getDate() + ' ' +
                    this.getFullMonthName(day.date) + ' ' + (day.date).getFullYear() +
                    ' ' + this.getFullDayName(day.date);
                if (this.dateModel && (date.getMonth() === this.dateModel.getMonth()) &&
                    (date.getDate() === this.dateModel.getDate())) {
                    day.selected = true;
                }
                else if ((date.getMonth() === this.currrentDate.getMonth()) &&
                    (date.getDate() === this.currrentDate.getDate())) {
                    if (this.dateModel) {
                        day.selected = false;
                        day['tabindex'] = -1;
                    }
                    else {
                        day.selected = true;
                        day['tabindex'] = 1;
                    }
                }
                rowDays.push(day);
                date.setDate(date.getDate() + 1);
            }
            this.daysArray.push(rowDays);
        }
    };
    /**
     * @param {?} recevieddate
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.getFullMonthName = /**
     * @param {?} recevieddate
     * @return {?}
     */
    function (recevieddate) {
        var /** @type {?} */ months = ['January', 'Febuary', 'March', 'April', 'May',
            'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        var /** @type {?} */ datemonth = recevieddate.getMonth();
        var /** @type {?} */ monthString = '';
        months.forEach(function (element, index) {
            if (datemonth === index) {
                monthString = element;
            }
        });
        return monthString;
    };
    /**
     * @param {?} receiveddate
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.getFullDayName = /**
     * @param {?} receiveddate
     * @return {?}
     */
    function (receiveddate) {
        var /** @type {?} */ weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
            'Thursday', 'Friday', 'Saturday'];
        var /** @type {?} */ day = receiveddate.getDay();
        var /** @type {?} */ dayname = '';
        weekdays.forEach(function (element, index) {
            if (day === index) {
                dayname = element;
            }
        });
        return dayname;
    };
    /**
     * @param {?} dateObj
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.onDateClick = /**
     * @param {?} dateObj
     * @param {?} event
     * @return {?}
     */
    function (dateObj, event) {
        if (dateObj.isDisabled === false) {
            this.change.emit(dateObj.date);
            if (this.inlineDatepicker === false) {
                _super.prototype.itemClicked.call(this);
            }
            this.hostFlag = true;
            this.selectedDate = dateObj.date;
            this.selectedDate.setHours(this.hrs);
            this.selectedDate.setMinutes(this.min);
            this.resetSelection(dateObj.date);
            this.dateModel = this.selectedDate;
            this.value = this.selectedDate;
            this.isValid = true;
            this.isComponentValid.emit(true);
            if (this.inlineDatepicker) {
                this.showToolTip = true;
            }
            else {
                this.showToolTip = !this.showToolTip;
            }
        }
        else {
            event.stopPropagation();
        }
    };
    /**
     * @param {?} dateObj
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.resetSelection = /**
     * @param {?} dateObj
     * @return {?}
     */
    function (dateObj) {
        for (var _i = 0, _a = this.daysArray; _i < _a.length; _i++) {
            var i = _a[_i];
            for (var _b = 0, i_1 = i; _b < i_1.length; _b++) {
                var j = i_1[_b];
                var /** @type {?} */ day = j;
                if (day.date.getTime() === dateObj.getTime()) {
                    day.selected = true;
                }
                else {
                    day.selected = false;
                }
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.onInput = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.target.value != null && event.target.value !== '') {
            var /** @type {?} */ timeValue = event.target.value.split(':');
            if (timeValue != null) {
                var /** @type {?} */ hrs = parseInt(timeValue[0].trim(), 10);
                var /** @type {?} */ mins = parseInt(timeValue[1].trim(), 10);
                this.selectedDate.setHours(hrs);
                this.selectedDate.setMinutes(mins);
                this.hrs = hrs;
                this.min = mins;
                this.value = this.selectedDate;
                event.stopPropagation();
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.nextMonth = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setDateData('plus', 1, event);
        this.disableddays(this.diabledDate);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.prevMonth = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setDateData('minus', 1, event);
        this.disableddays(this.diabledDate);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.nextYear = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setDateData1('plus', 12, event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.prevYear = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setDateData1('minus', 12, event);
    };
    // this function validates month
    /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.setDateData = /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    function (state1, mon, event) {
        var /** @type {?} */ d = new Date(this.currrentDate.getFullYear(), this.currrentDate.getMonth(), this.currrentDate.getDate());
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        // checks if selected date is within maximum range of month
        if (state1 === 'plus') {
            this.setPlusData(d, max, mon);
        }
        else if (state1 === 'minus') {
            this.setMinusData(d, min, mon);
        }
        this.currrentDate = d;
        this.initDate();
        event.stopPropagation();
    };
    // Set Plus Data
    /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.setPlusData = /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    function (d, max, mon) {
        if (this.maxDate.length > 0) {
            if (d.getFullYear() === max.getFullYear()) {
                this.setMaxFullYear(d, max, mon);
            }
            else {
                // logic to chk if year is valid
                if (d.getFullYear() <= max.getFullYear()) {
                    d.setMonth(d.getMonth() + mon);
                }
            }
        }
        else {
            // outer ends
            d.setMonth(d.getMonth() + mon);
        } // checks if selected date is within minimum range of month
    };
    // Set Max Full Year
    /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.setMaxFullYear = /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    function (d, max, mon) {
        if ((d.getMonth() !== max.getMonth()) && d.getFullYear() <= max.getFullYear() && d.getMonth() <= max.getMonth()) {
            d.setMonth(d.getMonth() + mon);
        }
    };
    // Set Minus Data
    /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.setMinusData = /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    function (d, min, mon) {
        if (this.minDate.length > 0) {
            if (d.getFullYear() === min.getFullYear()) {
                this.setMinFullYear(d, min, mon);
            }
            else {
                d.setMonth(d.getMonth() - mon);
            }
        }
        else {
            d.setMonth(d.getMonth() - mon);
        }
    };
    // Set Min Full year
    /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.setMinFullYear = /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    function (d, min, mon) {
        if ((d.getMonth() !== min.getMonth()) && d.getFullYear() >= min.getFullYear() && d.getMonth() >= min.getMonth()) {
            // logic to chk if year is valid
            d.setMonth(d.getMonth() - mon);
        }
    };
    // this function validates year
    /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.setDateData1 = /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    function (state1, mon, event) {
        var /** @type {?} */ d = new Date(this.currrentDate.getFullYear(), this.currrentDate.getMonth(), this.currrentDate.getDate());
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        // checks if selected date is within maximum range of year
        if (state1 === 'plus') {
            if (this.maxDate.length > 0) {
                if (d.getFullYear() <= max.getFullYear() - 1) {
                    d.setMonth(d.getMonth() + mon);
                }
            }
            else {
                d.setMonth(d.getMonth() + mon);
            } // checks if selected date is within minimum range of year
        }
        else if (state1 === 'minus') {
            if (this.minDate.length > 0) {
                if (d.getFullYear() >= min.getFullYear() + 1) {
                    d.setMonth(d.getMonth() - mon);
                }
            }
            else {
                d.setMonth(d.getMonth() - mon);
            }
        }
        this.currrentDate = d;
        this.initDate();
        event.stopPropagation();
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.setToday = /**
     * @return {?}
     */
    function () {
        this.currrentDate = new Date();
        this.initDate();
        this.showToolTip = !this.showToolTip;
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.initDate = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.currrentDate);
        this.daysArray.forEach(function (dayrow, outerindex) {
            dayrow.forEach(function (element, innerindex) {
                if (_this.currrentDate === new Date(element.date)) {
                    var /** @type {?} */ itemid = _this.daysArray[outerindex][innerindex];
                    document.getElementById(itemid['id']).focus();
                }
            });
        });
        this.selectedDate = this.currrentDate;
        this.dateModel = this.selectedDate;
        this.value = this.selectedDate;
        this.innerValue = '';
    };
    /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.plus = /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    function (type, event) {
        if (type === 'min') {
            if (this.min === 59) {
                this.min = -1;
                this.hrs++;
            }
            this.min++;
        }
        if (type === 'hrs') {
            this.hrs++;
        }
        if (this.hrs === 24) {
            this.hrs = 0;
        }
        this.selectedDate.setHours(this.hrs);
        this.selectedDate.setMinutes(this.min);
        this.value = this.selectedDate;
        this.isValid = true;
        this.isComponentValid.emit(true);
        this.change.emit(this.value);
        event.stopPropagation();
    };
    /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.minus = /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    function (type, event) {
        if (type === 'min') {
            if (this.min === 0) {
                this.min = 60;
                this.hrs--;
            }
            this.min--;
        }
        if (type === 'hrs') {
            this.hrs--;
        }
        if (this.hrs === 0) {
            this.hrs = 23;
        }
        this.selectedDate.setHours(this.hrs);
        this.selectedDate.setMinutes(this.min);
        this.value = this.selectedDate;
        this.isValid = true;
        this.isComponentValid.emit(true);
        this.change.emit(this.value);
        event.stopPropagation();
    };
    Object.defineProperty(AmexioDateTimePickerComponent.prototype, "value", {
        // get accessor
        get: /**
         * @return {?}
         */
        function () {
            return this.innerValue;
        },
        // set accessor including call the onchange callback
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v !== this.innerValue) {
                this.innerValue = v;
                this.onChangeCallback(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    // Set touched on blur
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.onTouchedCallback();
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== '') {
            if (value !== this.innerValue) {
                this.validateWriteValue(value);
            }
        }
        else {
            this.dateModel = '';
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.validateWriteValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.innerValue = value;
        if (this.innerValue instanceof Date || ('number' === typeof this.innerValue)) {
            if (('number' === typeof this.innerValue)) {
                this.innerValue = new Date(this.innerValue);
            }
            this.dateModel = this.innerValue;
            this.currrentDate = this.dateModel;
            this.selectedDate = this.currrentDate;
            this.createDaysForCurrentMonths(this.dateModel);
            if (this.required) {
                this.isValid = true;
            }
        }
        else {
            this.negateisValid();
        }
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.negateisValid = /**
     * @return {?}
     */
    function () {
        this.isValid = false;
        this.hrs = 0;
        this.min = 0;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.onFocus = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.onFocusOut = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (isNaN(Date.parse(value.value))) {
            this.isValid = false;
            value.value = '';
        }
        else {
            this.value = Date.parse(value.value);
            this.isValid = true;
        }
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.openPicker = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        this.inputtabindex = -1;
        this.daystabindex = 1;
        if (this.disabled === false) {
            _super.prototype.focus.call(this, elem);
            this.hostFlag = false;
            this.pickerele = elem;
            if (this.inlineDatepicker) {
                this.showToolTip = this.inlineDatepicker;
                this.setFocus();
            }
            else {
                this.showToolTip = true;
            }
            this.posixUp = this.getListPosition(elem);
            var /** @type {?} */ visibility = this.dropdownstyle.visibility;
            this.dropdownstyle = JSON.parse(JSON.stringify(this.positionClass));
            this.dropdownstyle.visibility = visibility;
            this.dropdownstyle.position = 'fixed';
            this.disableddays(this.diabledDate);
            this.setFocus();
        }
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.setFocus = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            // focus code starts
            // focus code starts
            _this.daysArray.forEach(function (row, index) {
                row.forEach(function (day, innerindex) {
                    if (day.selected) {
                        document.getElementById(day.id).focus();
                    }
                });
            });
        }, 0);
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ dropdownHeight = 350; // must be same in dropdown.scss
        if (window.innerHeight - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
            this.positionClass = {
                top: ((elementRef.getBoundingClientRect().top - dropdownHeight) + elementRef.getBoundingClientRect().height) + 'px',
            };
            return true;
        }
        else {
            this.positionClass = {
                top: (elementRef.getBoundingClientRect().top + elementRef.getBoundingClientRect().height) + 'px',
            };
            return false;
        }
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.onSelect = /**
     * @return {?}
     */
    function () {
        this.showToolTip = false;
    };
    /**
     * @param {?} days
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.validateDays = /**
     * @param {?} days
     * @return {?}
     */
    function (days) {
        var /** @type {?} */ max = new Date(this.maxDate);
        var /** @type {?} */ min = new Date(this.minDate);
        // check1: if min max is null return false
        if (this.maxDate.length <= 0 && this.minDate.length <= 0) {
            return false;
        }
        if ((this.maxDate.length > 0 && this.minDate.length <= 0) ||
            (this.maxDate.length > 0 && this.minDate.length > 0)) {
            this.validateMaxDate(days, max);
        }
        if ((this.maxDate.length <= 0 && this.minDate.length > 0) || (this.maxDate.length > 0 && this.minDate.length > 0)) {
            // 3
            if (days.getDate() < min.getDate() &&
                days.getMonth() === min.getMonth() && days.getFullYear() === min.getFullYear()) {
                return true;
                // 4
            }
            else if (days.getMonth() < min.getMonth() && days.getFullYear() === min.getFullYear()) {
                return true;
            }
        }
        this.disableddays(this.diabledDate);
    };
    /**
     * @param {?} days
     * @param {?} max
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.validateMaxDate = /**
     * @param {?} days
     * @param {?} max
     * @return {?}
     */
    function (days, max) {
        // check if days greater than max return
        // 1
        if (days.getDate() > max.getDate() &&
            days.getMonth() >= max.getMonth() && days.getFullYear() >= max.getFullYear()) {
            return true;
            // 2
        }
        else if (days.getMonth() > max.getMonth() && days.getFullYear() === max.getFullYear()) {
            return true;
        }
    };
    /**
     * @param {?} dates
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.disableddays = /**
     * @param {?} dates
     * @return {?}
     */
    function (dates) {
        var _this = this;
        if (dates) {
            dates.forEach(function (element) {
                var /** @type {?} */ From = new Date(element.from);
                var /** @type {?} */ To = new Date(element.to);
                _this.daysArray.forEach(function (element2) {
                    element2.forEach(function (element1) {
                        if (element1.date.getFullYear() <= To.getFullYear() && element1.date.getMonth()
                            <= To.getMonth() && element1.date.getDate() <= To.getDate() && element1.date.getFullYear() >= From.getFullYear() &&
                            element1.date.getMonth() >= From.getMonth() &&
                            element1.date.getDate() >= From.getDate()) {
                            element1.isDisabled = true;
                        }
                    });
                });
            });
        }
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.dropdownDatePicker = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.monthList1.forEach(function (element) {
            _this.elementFlagMethod(element);
        });
        this.monthList2.forEach(function (element) {
            _this.elementFlagMethod(element);
        });
        this.yearList1.forEach(function (element) {
            _this.elementFlagMethod(element);
        });
        this.yearList2.forEach(function (element) {
            _this.elementFlagMethod(element);
        });
        this.hostFlag = true;
        this.tempFlag = false;
        this.drop = true;
        _super.prototype.focus.call(this, {});
        this.okispressed = false;
        this.cancelispressed = false;
    };
    // Added method to avois recursive code
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.elementFlagMethod = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (element.flag) {
            element.flag = false;
        }
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.negateDrop = /**
     * @return {?}
     */
    function () {
        this.cancelispressed = true;
        this.hostFlag = true;
        this.drop = false;
        this.showToolTip = true;
        this.tempFlag = true;
    };
    /**
     * @param {?} month
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.getDropdownMonth = /**
     * @param {?} month
     * @return {?}
     */
    function (month) {
        var _this = this;
        this.monthList1.forEach(function (element) {
            _this.elementFlagMethod(element);
        });
        this.monthList2.forEach(function (element) {
            _this.elementFlagMethod(element);
        });
        this.monthList1.forEach(function (element) {
            _this.chkMonth(element, month);
        });
        this.monthList2.forEach(function (element) {
            _this.chkMonth(element, month);
        });
        switch (month.name) {
            case 'Jan':
                this.monthNo = 0;
                break;
            case 'Feb':
                this.monthNo = 1;
                break;
            case 'Mar':
                this.monthNo = 2;
                break;
            case 'Apr':
                this.monthNo = 3;
                break;
            case 'May':
                this.monthNo = 4;
                break;
            case 'Jun':
                this.monthNo = 5;
                break;
            case 'Jul':
                this.monthNo = 6;
                break;
            case 'Aug':
                this.monthNo = 7;
                break;
            case 'Sep':
                this.monthNo = 8;
                break;
            case 'Oct':
                this.monthNo = 9;
                break;
            case 'Nov':
                this.monthNo = 10;
                break;
            case 'Dec':
                this.monthNo = 11;
                break;
            default:
                break;
        }
        _super.prototype.focus.call(this, {});
    };
    // this function broken from chk month getDropdownMonth()
    /**
     * @param {?} element
     * @param {?} month
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.chkMonth = /**
     * @param {?} element
     * @param {?} month
     * @return {?}
     */
    function (element, month) {
        if (element.name === month.name) {
            element.flag = true;
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.yearFlagNegate = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this.elementFlagMethod(element);
    };
    // this function is broken from getDropdownYear
    /**
     * @param {?} element
     * @param {?} year
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.yearFlag = /**
     * @param {?} element
     * @param {?} year
     * @return {?}
     */
    function (element, year) {
        if (element.year === year.year) {
            element.flag = true;
        }
    };
    /**
     * @param {?} year
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.getDropdownYear = /**
     * @param {?} year
     * @return {?}
     */
    function (year) {
        var _this = this;
        this.yearList1.forEach(function (element) {
            // negate dropdown year flag
            // negate dropdown year flag
            _this.yearFlagNegate(element);
        });
        this.yearList2.forEach(function (element) {
            // negate dropdown year flag
            // negate dropdown year flag
            _this.yearFlagNegate(element);
        });
        this.yearList1.forEach(function (element) {
            _this.yearFlag(element, year);
        });
        this.yearList2.forEach(function (element) {
            _this.yearFlag(element, year);
        });
        this.yearNo = year.year;
        _super.prototype.focus.call(this, {});
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.navigateDropdown = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.okispressed = true;
        this.hostFlag = true;
        this.selectedDate = new Date();
        if (this.yearNo != null && this.monthNo != null) {
            this.selectedDate.setFullYear(this.yearNo);
            this.selectedDate.setMonth(this.monthNo);
        }
        else if (this.yearNo != null && this.monthNo === null) {
            this.selectedDate.setFullYear(this.yearNo);
        }
        else if (this.yearNo === null && this.monthNo != null) {
            this.selectedDate.setMonth(this.monthNo);
        }
        this.drop = false;
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.selectedDate);
        this.disableddays(this.diabledDate);
        this.tempFlag = true;
        this.cdf.detectChanges();
        this.yearList1.forEach(function (element) {
            _this.elementFlagMethod(element);
        });
        this.yearList2.forEach(function (element) {
            _this.elementFlagMethod(element);
        });
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.selectedDate);
        this.disableddays(this.diabledDate);
        _super.prototype.focus.call(this, {});
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.cancelDropdown = /**
     * @return {?}
     */
    function () {
        this.drop = false;
        this.showToolTip = true;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.arrowClickBack = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ i;
        // disable flag logic
        this.disableYearFlag();
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            // arrow click logic
            this.backArrow();
        }
        else {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year - 10;
                this.yearList2[i].year = this.yearList2[i].year - 10;
            } // for ends
        } // main else ends
        // disable flag logic
        this.disableYearFlag();
        // rechking arrow flags after reinitialization of yrlist1 & 2
        this.rechkYearFlag();
        event.stopPropagation();
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.backArrow = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        this.yearList1.forEach(function (element) {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear() && element.year !== min.getFullYear()) {
                _this.forwardArrowFlag = true;
                _this.backArrowFlag = false;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                _this.forwardArrowFlag = false;
                _this.backArrowFlag = false;
            }
        });
        // resets Arrow Flag
        this.resetYearFlag();
    };
    // this function is broken from resetArrowFlag()
    /**
     * @param {?} element
     * @param {?} min
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.alterBackArrow = /**
     * @param {?} element
     * @param {?} min
     * @return {?}
     */
    function (element, min) {
        if (element.year === min.getFullYear()) {
            this.backArrowFlag = true;
        }
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.resetArrowFlag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        this.yearList2.forEach(function (element) {
            _this.alterBackArrow(element, min);
            if (element.year === max.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.forwardArrowFlag = true;
            }
        });
    };
    // this fn is broken from  backArrow() and it resets Year Flag
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.resetYearFlag = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ i;
        if (!this.backArrowFlag) {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year - 10;
                this.yearList2[i].year = this.yearList2[i].year - 10;
                this.yearList1[i].disabled = false;
                this.yearList2[i].disabled = false;
            }
        } /* if ends */
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.alterBackForwardArrow = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        if (element.year === min.getFullYear()) {
            this.backArrowFlag = true;
        }
        if (element.year === max.getFullYear() ||
            (element.year === min.getFullYear() && element.year === max.getFullYear())) {
            this.forwardArrowFlag = true;
        }
    };
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.forwardArrow = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ i;
        // chk yearlist1
        this.chkYearList1();
        this.yearList2.forEach(function (element) {
            _this.alterBackForwardArrow(element);
        });
        if (!this.forwardArrowFlag) {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year + 10;
                this.yearList2[i].year = this.yearList2[i].year + 10;
                this.yearList1[i].disabled = false;
                this.yearList2[i].disabled = false;
            } // for ends
        } // if ends
    };
    // chk yearlist1 broken from forwardArrow()
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.chkYearList1 = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        this.yearList1.forEach(function (element) {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.backArrowFlag = true;
            }
            if (element.year === min.getFullYear() && element.year !== max.getFullYear()) {
                _this.forwardArrowFlag = false;
                _this.backArrowFlag = true;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                _this.forwardArrowFlag = false;
                _this.backArrowFlag = false;
            }
            if (element.year === max.getFullYear()) {
                _this.forwardArrowFlag = true;
            }
        });
    };
    // this function is obtained by breaking arrowClickBack() and arrowClickForward()
    // for rechking arrow flags after reinitialization of yrlist1 & 2
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.rechkYearFlag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.yearList1.forEach(function (element) {
            var /** @type {?} */ min = new Date(_this.minDate);
            var /** @type {?} */ max = new Date(_this.maxDate);
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear()) {
                _this.forwardArrowFlag = true;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                _this.forwardArrowFlag = false;
                _this.backArrowFlag = false;
            }
        });
        this.yearList2.forEach(function (element) {
            _this.alterBackForwardArrow(element);
        });
    };
    // this function is broken from disableYearFlag() , here year flag disable altered to true
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.yearFlagDisable = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        if (element.year < min.getFullYear() || element.year > max.getFullYear()) {
            element.disabled = true;
        } // if ends
    };
    // this function is obtained by breaking arrowClickBack() and arrowClickForward()
    // for disabling year flag
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.disableYearFlag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.yearList1.forEach(function (element) {
                _this.yearFlagDisable(element);
            }); // for ends
            this.yearList2.forEach(function (element) {
                _this.yearFlagDisable(element);
            }); // for ends
        } // outer if ends
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.arrowClickForward = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ i;
        // disable flag logic
        this.disableYearFlag();
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.forwardArrow();
        }
        else {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year + 10;
                this.yearList2[i].year = this.yearList2[i].year + 10;
            }
        }
        // disable flag logic
        this.disableYearFlag();
        // rechking arrow flags after reinitialization of yrlist1 & 2
        this.rechkYearFlag();
        event.stopPropagation();
    };
    // onInit Method: If min max date is provided
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.minMaxDateFound = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        this.yearList1.forEach(function (element) {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear()) {
                _this.forwardArrowFlag = true;
            }
        });
        this.yearList2.forEach(function (element) {
            if (element.year === min.getFullYear()) {
                _this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.forwardArrowFlag = true;
            }
        });
    };
    // Method to disable when min max year provided
    /**
     * @param {?} element
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.disableMinMaxYear = /**
     * @param {?} element
     * @param {?} min
     * @param {?} max
     * @return {?}
     */
    function (element, min, max) {
        if (element.year < min.getFullYear() || element.year > max.getFullYear()) {
            element.disabled = true;
        }
    };
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.checkValidity = /**
     * @return {?}
     */
    function () {
        return this.isValid;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return (this.value || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.arrowright = /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    function (day, month, event) {
        var _this = this;
        var /** @type {?} */ currentindex;
        var /** @type {?} */ ismonthchanged = false;
        var /** @type {?} */ drindex;
        month.forEach(function (dayrow, dayrowindex) {
            dayrow.forEach(function (element, index) {
                if (day['id'] === element['id']) {
                    if (index < dayrow.length - 1) {
                        currentindex = index + 1;
                        drindex = dayrowindex;
                    }
                    else {
                        if ((dayrowindex === (month.length - 1)) && (index === (dayrow.length - 1))) {
                            _this.nextMonth(event);
                            ismonthchanged = true;
                        }
                        else {
                            currentindex = 0;
                            drindex = dayrowindex + 1;
                        }
                    }
                }
            });
        });
        this.refactoredRightArrow(ismonthchanged, month, drindex, currentindex);
    };
    /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.refactoredRightArrow = /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    function (ismonthchanged, month, drindex, currentindex) {
        if (!ismonthchanged) {
            this.refactoredFocus(month, drindex, currentindex);
        }
        else {
            this.setFocus();
        }
    };
    /**
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.refactoredFocus = /**
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    function (month, drindex, currentindex) {
        var /** @type {?} */ itemid;
        itemid = month[drindex][currentindex];
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.arrowleft = /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    function (day, month, event) {
        var _this = this;
        var /** @type {?} */ currentindex;
        var /** @type {?} */ drindex;
        var /** @type {?} */ ismonthchanged = false;
        month.forEach(function (dayrow, dayrowindex) {
            dayrow.forEach(function (element, index) {
                if (day['id'] === element['id']) {
                    if (index > 0) {
                        currentindex = index - 1;
                        drindex = dayrowindex;
                    }
                    else {
                        if (dayrowindex === 0 && index === 0) {
                            _this.prevMonth(event);
                            ismonthchanged = true;
                        }
                        else {
                            drindex = dayrowindex - 1;
                            currentindex = 6;
                        }
                    }
                }
            });
        });
        this.refactoredarrow(ismonthchanged, month, drindex, currentindex);
    };
    /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.refactoredarrow = /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    function (ismonthchanged, month, drindex, currentindex) {
        var /** @type {?} */ itemid;
        if (!ismonthchanged) {
            itemid = month[drindex][currentindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            this.setFocus();
        }
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.arrowup = /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    function (day, month, event) {
        var _this = this;
        var /** @type {?} */ isfirstrow = false;
        var /** @type {?} */ drindex;
        var /** @type {?} */ currentindex;
        month.forEach(function (dayrow, dayrowindex) {
            dayrow.forEach(function (element, index) {
                if (day.id === element.id) {
                    if (dayrowindex === 0) {
                        isfirstrow = true;
                        _this.prevMonth(event);
                    }
                    else {
                        drindex = dayrowindex - 1;
                        currentindex = index;
                    }
                }
            });
        });
        if (!isfirstrow) {
            var /** @type {?} */ itemid = void 0;
            itemid = this.daysArray[drindex][currentindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            this.setFocus();
        }
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.arrowdown = /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    function (day, month, event) {
        var _this = this;
        var /** @type {?} */ islastrow = false;
        var /** @type {?} */ drindex;
        var /** @type {?} */ currentindex;
        month.forEach(function (dayrow, dayrowindex) {
            dayrow.forEach(function (element, index) {
                if (day.id === element.id) {
                    if (dayrowindex === (month.length - 1)) {
                        islastrow = true;
                        _this.nextMonth(event);
                    }
                    else {
                        drindex = dayrowindex + 1;
                        currentindex = index;
                    }
                }
            });
        });
        if (!islastrow) {
            var /** @type {?} */ itemid = void 0;
            itemid = this.daysArray[drindex][currentindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            this.setFocus();
        }
    };
    /**
     * @param {?} currentmonth
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.dropdownListOneArrowDown = /**
     * @param {?} currentmonth
     * @return {?}
     */
    function (currentmonth) {
        var _this = this;
        var /** @type {?} */ focusindex;
        var /** @type {?} */ islast = false;
        this.monthList1.forEach(function (element, index) {
            if (element.id === currentmonth.id) {
                if (index !== (_this.monthList1.length - 1)) {
                    focusindex = index + 1;
                }
                else {
                    islast = true;
                }
            }
        });
        var /** @type {?} */ itemid;
        if (!islast) {
            itemid = this.monthList1[focusindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            itemid = this.monthList2[0];
            document.getElementById(itemid['id']).focus();
        }
    };
    /**
     * @param {?} currentmonth
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.dropdownListOneArrowUp = /**
     * @param {?} currentmonth
     * @return {?}
     */
    function (currentmonth) {
        var /** @type {?} */ focusindex;
        var /** @type {?} */ isfirst = false;
        this.monthList1.forEach(function (elementmonthList1, index) {
            if (elementmonthList1.id === currentmonth.id) {
                if (index > 0) {
                    focusindex = index - 1;
                }
                else {
                    isfirst = true;
                }
            }
        });
        var /** @type {?} */ itemid;
        if (!isfirst) {
            itemid = this.monthList1[focusindex];
        }
        else {
            itemid = this.monthList2[this.monthList2.length - 1];
        }
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} currentmonth
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.dropdownListTwoArrowDown = /**
     * @param {?} currentmonth
     * @return {?}
     */
    function (currentmonth) {
        var _this = this;
        var /** @type {?} */ focusindex;
        var /** @type {?} */ islast = false;
        this.monthList2.forEach(function (element, index) {
            if (element.id === currentmonth.id) {
                if (index !== (_this.monthList2.length - 1)) {
                    focusindex = index + 1;
                }
                else {
                    islast = true;
                }
            }
        });
        var /** @type {?} */ itemid;
        if (!islast) {
            itemid = this.monthList2[focusindex];
        }
        else {
            itemid = this.monthList1[0];
        }
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} currentmonth
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.dropdownListTwoArrowUp = /**
     * @param {?} currentmonth
     * @return {?}
     */
    function (currentmonth) {
        var /** @type {?} */ focusindex;
        var /** @type {?} */ isfirst = false;
        this.monthList2.forEach(function (element, index) {
            if (element.id === currentmonth.id) {
                if (index > 0) {
                    focusindex = index - 1;
                }
                else {
                    isfirst = true;
                }
            }
        });
        var /** @type {?} */ itemid;
        if (!isfirst) {
            itemid = this.monthList2[focusindex];
        }
        else {
            itemid = this.monthList1[this.monthList1.length - 1];
        }
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} currentyear
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.yearList1ArrowDown = /**
     * @param {?} currentyear
     * @return {?}
     */
    function (currentyear) {
        var _this = this;
        var /** @type {?} */ focusindex;
        var /** @type {?} */ islast = false;
        this.yearList1.forEach(function (element, index) {
            if (element.id === currentyear.id) {
                if (index !== (_this.yearList1.length - 1)) {
                    focusindex = index + 1;
                }
                else {
                    islast = true;
                }
            }
        });
        var /** @type {?} */ itemid;
        if (!islast) {
            itemid = this.yearList1[focusindex];
        }
        else {
            itemid = this.yearList2[0];
        }
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} currentyear
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.yearList2ArrowDown = /**
     * @param {?} currentyear
     * @return {?}
     */
    function (currentyear) {
        var _this = this;
        var /** @type {?} */ focusindex;
        var /** @type {?} */ islast = false;
        this.yearList2.forEach(function (element, index) {
            if (element.id === currentyear.id) {
                if (index !== (_this.yearList2.length - 1)) {
                    focusindex = index + 1;
                }
                else {
                    islast = true;
                }
            }
        });
        var /** @type {?} */ itemid;
        if (!islast) {
            itemid = this.yearList2[focusindex];
        }
        else {
            itemid = this.yearList1[0];
        }
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} currentyear
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.yearList1ArrowUp = /**
     * @param {?} currentyear
     * @return {?}
     */
    function (currentyear) {
        var /** @type {?} */ focusindex;
        var /** @type {?} */ isfirst = false;
        this.yearList1.forEach(function (elementyearList1, index) {
            if (elementyearList1.id === currentyear.id) {
                if (index !== 0) {
                    focusindex = index - 1;
                }
                else {
                    isfirst = true;
                }
            }
        });
        var /** @type {?} */ itemid;
        if (!isfirst) {
            itemid = this.yearList1[focusindex];
        }
        else {
            itemid = this.yearList2[this.yearList2.length - 1];
        }
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} currentyear
     * @return {?}
     */
    AmexioDateTimePickerComponent.prototype.yearList2ArrowUp = /**
     * @param {?} currentyear
     * @return {?}
     */
    function (currentyear) {
        var /** @type {?} */ focusindex;
        var /** @type {?} */ isfirst = false;
        this.yearList2.forEach(function (element, index) {
            if (element.id === currentyear.id) {
                if (index !== 0) {
                    focusindex = index - 1;
                }
                else {
                    isfirst = true;
                }
            }
        });
        var /** @type {?} */ itemid;
        if (!isfirst) {
            itemid = this.yearList2[focusindex];
        }
        else {
            itemid = this.yearList1[this.yearList1.length - 1];
        }
        document.getElementById(itemid['id']).focus();
    };
    AmexioDateTimePickerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-date-time-picker',
                    template: "\n    <div id=\"maindiv\">\n        <div   tabindex=\"{{inputtabindex}}\" (keyup.enter)=\"openPicker(rootDiv)\" aria-label=\"datetimepicker push button\" \n       class=\"inputgroup\" \n        *ngIf=\"!inlineDatepicker\"\n        #rootDiv>\n  \n            <label>\n                {{fieldlabel}}\n            </label>\n  \n            <ng-container *ngIf=\"datepicker && !timepicker\">\n                    <!-- (change)=\"change.emit()\"  -->\n                <input tabindex=\"-1\" type=\"text\" #pickerDt value=\"{{dateModel|date:dateformat}}\" \n                [attr.disabled]=\"disabled ? true: null\" [required]=\"required ? true: null\"\n                    (blur)=\"onBlur()\" (focus)=\"onFocus(rootDiv)\" \n                    (focusout)=\"onFocusOut(pickerDt)\" \n                    class=\"input-control\"\n                    [ngStyle]=\"{'cursor': readonly ? 'not-allowed':'pointer'}\" [attr.placeholder]=\"placeholder\" />\n            </ng-container>\n  \n            <ng-container *ngIf=\"timepicker\">\n                <input type=\"text\" [(ngModel)]=\"selectedDate\" value=\"{{selectedDate|date:dateformat}} {{hrs + ' : ' + min}}\" [attr.disabled]=\"disabled ? true: null\"\n                    [attr.required]=\"required ? true: null\" (blur)=\"onBlur()\" (focus)=\"onFocus(rootDiv)\" (input)=\"onInput($event)\"\n                    (change)=\"change.emit()\" class=\"input-control\" [ngStyle]=\"{'cursor': readonly ? 'not-allowed':'pointer'}\" [attr.placeholder]=\"placeholder\"\n                />\n            </ng-container>\n  \n            <div class=\"drodown-caret-down\" [ngStyle]=\"{'cursor':disabled ? 'not-allowed' : 'pointer'}\" (click)=\"openPicker(rootDiv)\">\n                <ng-container *ngIf=\"timepicker\">\n                    <span  tabindex=\"1\" (keyup.enter)=\"openPicker(rootDiv)\" aria-label=\"timepicker push button\" >\n                    <amexio-c-icon key=\"datepicker-clock-icon\"></amexio-c-icon>\n                    </span>\n                </ng-container>\n                <ng-container *ngIf=\"!timepicker\">\n                    <span>\n                             <amexio-c-icon key=\"datepicker_calendar\"></amexio-c-icon>\n                    </span>\n               \n                </ng-container>\n  \n            </div>\n  \n  \n        </div>\n   \n\n        <div  \n         [@changeState]=\"dropdownstyle.visibility\"\n         [ngStyle]=\"dropdownstyle\"  \n        [ngClass]=\"{'datetimepicker1':inlineDatepicker , 'datetimepicker':!inlineDatepicker}\">\n            <!-- datepicker starts -->\n            <span aria-label=\"datepicker window opened \">\n                <div aria-label=\"datetimepicker header\" class=\"datetimepickertopbar\" aria-label=\"datepicker header\" [ngStyle]=\"{'display': datepicker ? 'block' : 'none'}\">\n                    <ul>\n                        <li class=\"prev\">\n                            <span tabindex=\"1\" aria-label=\"previous year push button\" (keyup.enter)=\"prevYear($event)\">\n                                <amexio-c-icon key=\"datepicker_previous_fast\" (onClick)=\"prevYear($event)\"></amexio-c-icon>\n                            </span>\n                            <span tabindex=\"1\" aria-label=\"previous month push button \" (keyup.enter)=\"prevMonth($event)\">\n                                <amexio-c-icon key=\"datepicker_previous\" (onClick)=\"prevMonth($event)\"></amexio-c-icon>\n                            </span>\n                        </li>\n                        <li class=\"next\">\n                            <span tabindex=\"1\" aria-label=\"next month push button\" (keyup.enter)=\"nextMonth($event)\">\n                                <amexio-c-icon key=\"datepicker_next\" (onClick)=\"nextMonth($event)\"></amexio-c-icon>\n                            </span>\n                            <span tabindex=\"1\" aria-label=\"next year push button\" (keyup.enter)=\"nextYear($event)\">\n                                <amexio-c-icon key=\"datepicker_next_fast\" (onClick)=\"nextYear($event)\"></amexio-c-icon>\n                            </span>\n                        </li>\n                        <li>\n                            <span *ngIf=\"dropdownDatepicker\">\n                                  <span  style=\"cursor:pointer\" (click)=\"dropdownDatePicker()\">\n                                    {{selectedDate | date:'MMMM'}}\n                                    <br>\n                                    <span class=\"title\">{{selectedDate | date:'y'}}</span>\n                                </span>\n                                <span tabindex=\"1\" aria-label=\"dropdown datepicker push button\" (keyup.enter)=\"dropdownDatePicker()\" (onClick)=\" dropdownDatePicker()\" style=\"cursor:pointer\">\n                                    <amexio-c-icon key=\"dropdown_caret\" (onClick)=\"dropdownDatePicker()\"></amexio-c-icon>\n                                </span>\n                             </span>\n  \n                            <span *ngIf=\"!dropdownDatepicker\">\n                                {{selectedDate | date:'MMMM'}}\n                                <br>\n                                <span class=\"title\" style=\"cursor:auto\">{{selectedDate | date:'y'}}</span>\n                            </span>\n  \n                        </li>\n                    </ul>\n                </div>\n                <div *ngIf=\"!drop\">\n                    <ul class=\"weekdays\" [ngStyle]=\"{'display': datepicker ? 'block' : 'none'}\">\n                        <li *ngFor=\"let dayTitle of daysTitle\">{{dayTitle.text}}</li>\n                    </ul>\n  \n                    <ul id=\"{{daystabindex}}\" class=\"days\" [ngStyle]=\"{'display': datepicker ? 'block' : 'none'}\">\n  \n                        <ng-container *ngFor=\"let dayArray of daysArray\">\n                            <li  [ngStyle]=\"{'cursor': day.isDisabled ? 'not-allowed' : 'pointer'}\"\n                                *ngFor=\"let day of dayArray\" (click)=\"onDateClick(day, $event)\" [ngClass]=\"{'date1':validateDays(day.date) , 'date1':day.isDisabled , 'notclickable':isDisabled}\">\n                                <span [attr.tabindex]=\"(day.selected ? 1: -1)\" id=\"{{day.id}}\" \n                                (keyup.arrowleft)=\"arrowleft(day,daysArray,$event)\"\n                                 (keyup.arrowright)=\"arrowright(day,daysArray,$event)\"\n                                 (keyup.arrowdown)=\"arrowdown(day,daysArray,$event)\"\n                                 (keyup.arrowup) = \"arrowup(day,daysArray,$event)\"\n                                 (keyup.enter) = \"onDateClick(day, $event)\"\n                                attr.aria-label=\"{{day.fulldate}}\" (click)=\"onDateClick(day, $event)\" class=\"day\"   \n                                [ngClass]=\"{'active':day.selected, 'currentMonth':day.isCurrentMonth, 'notCurrentMonth':!day.isCurrentMonth,'invaliddays':validateDays(day.date), 'disabled':day.isDisabled}\">\n                                    {{ day.date | date:'d' }}\n                                 </span>\n                            </li>\n                        </ng-container>\n  \n  \n                        <li (keyup.enter)=\"setToday()\" class=\"date-today\">\n                            <amexio-button type=\"primary\" label=\"TODAY\" (onClick)=\"setToday()\" size=\"small\"></amexio-button>\n                        </li>\n  \n  \n                    </ul>\n                </div>\n            </span>\n            <!--datepicker ends  -->\n            <table aria-label=\"timepicker window opened\" tabindex=\"1\" class=\"table\" [ngStyle]=\"{'display': timepicker ? 'block' : 'none'}\" style=\"cursor : pointer;text-align: center;padding: 5px;\">\n                <!--if picker is true-->\n                <tr style=\"padding: 10px;\">\n                    <td colspan=\"2\"></td>\n                    <td tabindex=\"1\" aria-label=\"increment hour push button\" (keyup.enter)=\"plus('hrs', $event)\" (click)=\"plus('hrs', $event);\">&#9650;</td>\n                    <td></td>\n                    <td tabindex=\"1\" aria-label=\"increment minute push button\" (keyup.enter)=\"plus('min', $event)\" (click)=\"plus('min', $event);\">&#9650;</td>\n                    <td colspan=\"2\"></td>\n                </tr>\n                <tr tabindex=\"1\" attr.aria-label=\"{{hrs}} hours {{min}} minutes\" >\n                    <td colspan=\"2\"></td>\n                    <td>{{hrs}}</td>\n                    <td>:</td>\n                    <td>{{min}}</td>\n                    <td colspan=\"2\">\n                    </td>\n                </tr>\n                <tr>\n                    <td colspan=\"2\"></td>\n                    <td tabindex=\"1\" (keyup.enter)=\"minus('hrs', $event)\" aria-label=\"decrement hour push button\"  (click)=\"minus('hrs', $event);\">&#9660;</td>\n                    <td></td>\n                    <td tabindex=\"1\" (keyup.enter)=\"minus('min', $event)\" aria-label=\"decrement min push button\" (click)=\"minus('min', $event);\">&#9660;</td>\n                    <td colspan=\"2\">\n                    </td>\n                </tr>\n  \n            </table>\n  \n            <!--dropdown datepicker -->\n            <div [ngStyle]=\"positionClass\" class=\"datedropdown\" *ngIf=\"drop && !timepicker\">\n  \n                <div class=\"dropdiv1\">\n                   <span  tabindex=\"1\" aria-label=\"month list\" >\n               \n                    <span  class=\"dropspan1\">\n                        <ul class=\"dropul1\">\n                            <li tabindex=\"1\" \n                            id={{month.id}}\n                            class=\"li4\" (click)=\"getDropdownMonth(month)\" \n                            *ngFor=\"let month of monthList1\"\n                             attr.aria-label=\"{{month.fullname}}\"\n                            (keyup.arrowdown)=\"dropdownListOneArrowDown(month)\"\n                            (keyup.arrowup)=\"dropdownListOneArrowUp(month)\"\n                            >\n                                <span [ngClass]=\"{'change4':month.flag}\"> {{month.name}}</span>\n                            </li>\n  \n                        </ul>\n                    </span>\n  \n                    <span class=\"dropspan2\">\n                        <ul class=\"dropul2\">\n                            <li class=\"li4\" \n                            tabindex=\"1\"\n                             id={{month.id}}\n                            (click)=\"getDropdownMonth(month)\" \n                            *ngFor=\"let month of monthList2\"\n                            attr.aria-label=\"{{month.fullname}}\"\n                            (keyup.arrowdown)=\"dropdownListTwoArrowDown(month)\"\n                            (keyup.arrowup)=\"dropdownListTwoArrowUp(month)\"\n                            >\n                                <span [ngClass]=\"{'change4':month.flag}\"> {{month.name}}</span>\n                            </li>\n  \n                        </ul>\n                    </span>\n  \n                    </span>\n  \n                    <span tabindex=\"1\" aria-label=\"year list\">\n  \n                    <span class=\"dropspan1\">\n                        <ul class=\"dropul1\">\n                            <li tabindex=\"1\" (keyup.enter)=\"arrowClickBack($event)\"  id=\"prevyearbutton\" aria-label=\"previous year list push button\" [ngClass]=\"{ 'disablearrow':backArrowFlag}\" class=\"dropiconpadding\" (click)=\"arrowClickBack()\">\n                                <amexio-c-icon key=\"paginator_first\" (onClick)=\"arrowClickBack($event)\"></amexio-c-icon>\n                            </li>\n                            <li tabindex=\"1\" (keyup.arrowdown)=\"yearList1ArrowDown(year)\" \n                            (keyup.arrowup) = \"yearList1ArrowUp(year)\"\n                            id=\"{{year.id}}\"  \n                            [ngClass]=\"{ 'disablearrow':year.disabled}\" class=\"li4\" \n                            (click)=\"getDropdownYear(year)\" *ngFor=\"let year of yearList1\">\n                                <span [ngClass]=\"{'change4':year.flag && !year.disabled}\">\n                                    {{year.year}}\n                                </span>\n                            </li>\n  \n  \n                        </ul>\n                    </span>\n  \n                    <span class=\"dropspan4\">\n                        <ul class=\"dropul2\">\n  \n                            <li tabindex=\"1\" (keyup.enter)=\"arrowClickForward($event)\"  id=\"nextyearbutton\" aria-label=\"next year list push button\" [ngClass]=\"{ 'disablearrow':forwardArrowFlag}\" class=\"dropiconpadding\" (click)=\"arrowClickForward()\">\n                                <amexio-c-icon key=\"paginator_last\" (onClick)=\"arrowClickForward($event)\"></amexio-c-icon>\n                            </li>\n                            <li tabindex=\"1\" (keyup.arrowdown)=\"yearList2ArrowDown(year)\"\n                            (keyup.arrowup) = \"yearList2ArrowUp(year)\"\n                            id=\"{{year.id}}\" [ngClass]=\"{ 'disablearrow ':year.disabled}\" class=\"li4\" (click)=\"getDropdownYear(year)\" *ngFor=\"let year of yearList2\">\n                                <span [ngClass]=\"{'change4':year.flag && !year.disabled}\">\n                                    {{year.year}}\n                                </span>\n                            </li>\n  \n                        </ul>\n                    </span>\n  \n                </span>\n                </div>\n                <div class=\"btndiv1\">\n                    <span class=\"dropbtnspan\">\n                        <button tabindex=\"1\" role=\"button\" [attr.aria-pressed]=\"okispressed\"\n                        (click)=\"navigateDropdown()\" class=\"datedropbtn\">\n                            ok\n                        </button>\n                        <button tabindex=\"1\" role=\"button\" [attr.aria-pressed]=\"cancelispressed\" class=\"datedropbtn\" (click)=\"negateDrop()\">\n                            cancel\n                        </button>\n                    </span>\n                </div>\n            </div>\n        </div>\n      </div>\n  ",
                    animations: [
                        trigger('changeState', [
                            state('visible', style({
                                transform: 'scale(1)',
                            })),
                            state('hidden', style({
                                transform: 'scale(0)',
                            })),
                            transition('*=>*', animate('200ms')),
                        ]),
                    ],
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioDateTimePickerComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioDateTimePickerComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioDateTimePickerComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: i0.Renderer2 }
    ]; };
    AmexioDateTimePickerComponent.propDecorators = {
        dateformat: [{ type: i0.Input, args: ['date-format',] }],
        datepicker: [{ type: i0.Input, args: ['date-picker',] }],
        timepicker: [{ type: i0.Input, args: ['time-picker',] }],
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        disabled: [{ type: i0.Input, args: ['disabled',] }],
        readonly: [{ type: i0.Input, args: ['read-only',] }],
        minDate: [{ type: i0.Input, args: ['min-date',] }],
        maxDate: [{ type: i0.Input, args: ['max-date',] }],
        diabledDate: [{ type: i0.Input, args: ['disabled-date',] }],
        inlineDatepicker: [{ type: i0.Input, args: ['inline-datepicker',] }],
        dropdownDatepicker: [{ type: i0.Input, args: ['dropdown-datepicker',] }],
        required: [{ type: i0.Input }],
        change: [{ type: i0.Output }],
        input: [{ type: i0.Output }],
        isComponentValid: [{ type: i0.Output }]
    };
    return AmexioDateTimePickerComponent;
}(ListBaseDatepickerComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 Component Name : Amexio  Dropdown Menu
 Component Selector : <amexio-drop-down-menu-items>
 Component Description : Amexio Dropdown component with various modes and configurations .
 */
var AmexioDropDownitemsComponent = /** @class */ (function () {
    function AmexioDropDownitemsComponent() {
        /*
           Properties
           name : add-seperator
           datatype :  boolean
           version : 4.2 onwards
           default : false
           description : add divider to the dropdown menu list
           */
        this.onClick = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    AmexioDropDownitemsComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.iconalign && this.labelalign
            && this.iconalign.toLowerCase() === this.labelalign.toLowerCase()) {
            this.iconalign = null;
            this.labelalign = null;
        }
        else if (this.iconalign && this.iconalign === 'left') {
            this.labelalign = 'right';
            this.iconalign = null;
        }
        else if (this.iconalign && this.iconalign === 'right') {
            this.labelalign = null;
        }
    };
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    AmexioDropDownitemsComponent.prototype.onItemClick = /**
     * @param {?} clickEvent
     * @return {?}
     */
    function (clickEvent) {
        this.toggle = false;
        var /** @type {?} */ e = {
            event: clickEvent,
            this: this,
        };
        this.onClick.emit(e);
    };
    AmexioDropDownitemsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-drop-down-menu-item',
                    template: "\n    <div *ngIf=\"!(icon && label)\"  class=\"dropdowndivider\" style=\"padding-bottom: 5px;\">\n      <ng-content></ng-content>\n    </div>\n    <a  *ngIf=\" (icon || label)\"   (click)=\"onItemClick($event)\" id={{index}}  [ngStyle]=\"{'background': selected ? '#ffcccc':''}\"  [ngClass]=\"{'dropdowndivider':separator}\">\n\n      <ng-container *ngIf=\"icon\">\n        <em [style.float]=\"iconalign\" [ngClass]=\"icon\"></em>\n      </ng-container>\n\n      <ng-container *ngIf=\"label\">\n        <span [style.float]=\"labelalign\" style=\"padding: 5px;\">\n          {{label}}\n        </span>\n      </ng-container>\n    </a>\n  ",
                },] },
    ];
    AmexioDropDownitemsComponent.propDecorators = {
        label: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        labelalign: [{ type: i0.Input, args: ['label-align',] }],
        iconalign: [{ type: i0.Input, args: ['icon-align',] }],
        separator: [{ type: i0.Input, args: ['separator',] }],
        index: [{ type: i0.Input, args: ['index',] }],
        selected: [{ type: i0.Input, args: ['selected',] }],
        onClick: [{ type: i0.Output }]
    };
    return AmexioDropDownitemsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioDropDownMenuComponent = /** @class */ (function () {
    function AmexioDropDownMenuComponent(element, matchMediaService) {
        this.element = element;
        this.matchMediaService = matchMediaService;
        this.xposition = false;
        /*
           Properties
           name : menu icon
           datatype : string
           version : 4.2 onwards
           default :
           description : icon on menu
           */
        this.downArrowIcon = true;
        /*
           Properties
           name : transparent
           datatype : string
           version : 4.2 onwards
           default :
           description : transparent style for menu
           */
        this.transparent = false;
        this.dropdownmenuindex = -1;
        this.prevdropdownmenuindex = -1;
        this.onClick = new i0.EventEmitter();
        this.optionsCollection = [];
        this.iconalign = 'left';
        this.padding = '5px 10px';
        this.componentId = 'dropdownmenu' + Math.floor(Math.random() * 1000 + 999);
    }
    /**
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.data) {
            this.data.forEach(function (node) {
                if (!node.iconalign && _this.iconalign) {
                    node.iconalign = _this.iconalign;
                }
                if (!node.labelalign) {
                    node.labelalign = 'left';
                }
            });
            this.generateIndex(this.data);
        }
    };
    /**
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.optionsCollection = this.dropdowns.toArray();
        this.optionsCollection.forEach(function (node) { return node.onClick.subscribe(function (eventdata) {
            _this.toggle = false;
        }); });
    };
    /**
     * @param {?} targetElement
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.onElementOutClick = /**
     * @param {?} targetElement
     * @return {?}
     */
    function (targetElement) {
        var /** @type {?} */ parentFound = false;
        while (targetElement !== null && !parentFound) {
            if (targetElement === this.element.nativeElement) {
                parentFound = true;
            }
            targetElement = targetElement.parentElement;
        }
        if (!parentFound) {
            this.toggle = false;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.showDropDownContent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.dropdownmenuindex > -1) {
            this.data[this.dropdownmenuindex]['selected'] = false;
        }
        this.toggle = !this.toggle;
        this.top = event.target.getBoundingClientRect().top + 25;
        if ((this.matchMediaService.browserWindow().innerWidth - event.clientX) < 200) {
            this.xposition = true;
        }
        else {
            this.xposition = false;
        }
        var /** @type {?} */ inputid = document.getElementById(this.componentId);
        inputid.setAttribute('aria-activedescendant', 'dropdownitem');
        this.dropdownmenuindex = -1;
        this.prevdropdownmenuindex = -1;
    };
    /**
     * @param {?} childposition
     * @param {?} parentIconPosition
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.getIconPosition = /**
     * @param {?} childposition
     * @param {?} parentIconPosition
     * @return {?}
     */
    function (childposition, parentIconPosition) {
        if (childposition.hasOwnProperty('iconalign') && childposition.iconalign !== '') {
            if (childposition.iconalign === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (parentIconPosition === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.onDropDownMenuClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.toggle = false;
        this.onClick.emit(event);
    };
    /**
     * @param {?} childPosition
     * @param {?} parentLabelPosition
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.getLabelPosition = /**
     * @param {?} childPosition
     * @param {?} parentLabelPosition
     * @return {?}
     */
    function (childPosition, parentLabelPosition) {
        if (childPosition.hasOwnProperty('labelalign') && childPosition.labelalign !== '') {
            if (childPosition.labelalign === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
        else {
            if (parentLabelPosition === 'right') {
                return true;
            }
            else {
                return false;
            }
        }
    };
    // Aria Logic Starts
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.generateIndex = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        data.forEach(function (element, index) {
            element['index'] = _this.componentId + 'dropdownmenuitem' + index;
            element['selected'] = false;
        });
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.navigateOptions = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        if (item.keyCode === 38) {
            this.upArrowKeyNavigation(item);
        }
        else if (item.keyCode === 40) {
            this.downArrowKeyNavigation(item);
        }
        else if (item.keyCode === 13 && this.dropdownmenuindex > -1) {
            var /** @type {?} */ emitdata = this.createEmitObject(this.data[this.dropdownmenuindex]);
            var /** @type {?} */ e = {
                event: item,
                this: emitdata,
            };
            this.onClick.emit(e);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.upArrowKeyNavigation = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.prevdropdownmenuindex > -1) {
            this.data[this.prevdropdownmenuindex]['selected'] = false;
        }
        this.prevdropdownmenuindex--;
        if (this.prevdropdownmenuindex === -1) {
            this.prevdropdownmenuindex = this.data.length - 1;
            this.dropdownmenuindex = -1;
        }
        this.setAriaActiveDescendant(this.prevdropdownmenuindex);
        if (this.prevdropdownmenuindex === 0) {
            this.dropdownmenuindex = 0;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.downArrowKeyNavigation = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.prevdropdownmenuindex > -1) {
            this.data[this.prevdropdownmenuindex]['selected'] = false;
        }
        this.dropdownmenuindex++;
        this.prevdropdownmenuindex = this.dropdownmenuindex;
        if (this.dropdownmenuindex >= this.data.length) {
            this.dropdownmenuindex = 0;
            this.prevdropdownmenuindex = 0;
        }
        this.setAriaActiveDescendant(this.dropdownmenuindex);
    };
    /**
     * @param {?} object
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.createEmitObject = /**
     * @param {?} object
     * @return {?}
     */
    function (object) {
        var /** @type {?} */ obj = {};
        if (object['icon']) {
            obj['icon'] = object['icon'];
        }
        if (object['label']) {
            obj['label'] = object['label'];
        }
        if (object['labelalign']) {
            obj['labelalign'] = object['labelalign'];
        }
        if (object['iconalign']) {
            obj['iconalign'] = object['iconalign'];
        }
        if (object['separator']) {
            obj['separator'] = object['separator'];
        }
        return obj;
    };
    /**
     * @param {?} rowindex
     * @return {?}
     */
    AmexioDropDownMenuComponent.prototype.setAriaActiveDescendant = /**
     * @param {?} rowindex
     * @return {?}
     */
    function (rowindex) {
        this.data[rowindex]['selected'] = true;
        var /** @type {?} */ inputid = document.getElementById(this.componentId);
        inputid.setAttribute('aria-activedescendant', this.data[rowindex]['index']);
    };
    AmexioDropDownMenuComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-drop-down-menu',
                    template: "\n\n    <div  tabindex=\"1\" id=\"{{componentId}}\" \n    [attr.aria-expanded]=\"toggle\"\n    [attr.aria-label]=\"title\"\n     role=\"menu\"\n    (keyup)=\"navigateOptions($event)\"\n    (keyup.enter) =\"showDropDownContent($event)\"\n    (click)=\"showDropDownContent($event)\" class=\"dropdown-menu\" \n    [style.padding]=\"padding\"\n    [ngStyle]=\"{'background-color':(transparent)?'unset':'null'}\">\n    <span >\n    <em *ngIf=\"icon\" style=\"padding-right: 5px;\" [ngClass]=\"icon\">&nbsp;</em>{{title}}&nbsp;</span>\n    <ng-container *ngIf=\"downArrowIcon\">\n    <em *ngIf=\"!toggle\"  class=\"fa fa-angle-down \"></em>\n    <em *ngIf=\"toggle\"  class=\"fa fa-angle-up \"></em>\n    </ng-container>\n\n    </div>\n    <div  *ngIf=\"toggle\" class=\"dropdown-menu-content\"\n    [style.height]=\"height\"   [ngClass]=\"{'menu-right':xposition}\">\n\n    <ng-content></ng-content>\n    <div  >\n    <span  role=\"option\" tabindex=\"1\"  *ngFor=\"let node of data\"   id=\"{{node.index}}\"  >\n    <amexio-drop-down-menu-item   \n                              (onClick)=\"onDropDownMenuClick($event)\"  \n                              [icon-align]=\"node.iconalign\"\n                              [label-align]=\"node.labelalign\"\n                              [label]=\"node.label\"\n                              [separator]=\"node.separator\"\n                              [icon]=\"node.icon\"\n                              [index]=\"node.index\" \n                              [selected]=\"node.selected\">\n    </amexio-drop-down-menu-item>\n    </span>\n    </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioDropDownMenuComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: DeviceQueryService }
    ]; };
    AmexioDropDownMenuComponent.propDecorators = {
        dropDownMenuLocalData: [{ type: i0.Input }],
        data: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        iconalign: [{ type: i0.Input, args: ['icon-align',] }],
        padding: [{ type: i0.Input }],
        downArrowIcon: [{ type: i0.Input, args: ['down-arrow-icon',] }],
        transparent: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        onClick: [{ type: i0.Output }],
        dropdowns: [{ type: i0.ContentChildren, args: [AmexioDropDownitemsComponent,] }],
        onElementOutClick: [{ type: i0.HostListener, args: ['document:click', ['$event.target'],] }, { type: i0.HostListener, args: ['document: touchstart', ['$event.target'],] }]
    };
    return AmexioDropDownMenuComponent;
}());

var __extends$18 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioEmailInputComponent = /** @class */ (function (_super) {
    __extends$18(AmexioEmailInputComponent, _super);
    function AmexioEmailInputComponent() {
        var _this = _super.call(this) || this;
        /*
           Properties
           name : has-label
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : Flag to set label
           */
        _this.hasLabel = true;
        /*
           Properties
           name : pattern
           datatype : string
           version : 4.0 onwards
           default :
           description : Apply Reg-ex to the field
           */
        _this.emailpattern = /\S+@\S+\.\S+/;
        /*
           Events
           name : onBlur
           datatype : any
           version : 4.0 onwards
           default :
           description : On blur event
           */
        _this.onBlur = new i0.EventEmitter();
        /*
           Events
           name : input
           datatype : any
           version : none
           default :
           description : 	On input event field.
           */
        _this.input = new i0.EventEmitter();
        /*
           Events
           name : focus
           datatype : any
           version : none
           default :
           description : On focus event field.
           */
        _this.focus = new i0.EventEmitter();
        /*
           Events
           name : change
           datatype : any
           version : none
           default :
           description : On field value change event
           */
        _this.change = new i0.EventEmitter();
        _this.showToolTip = false;
        return _this;
    }
    Object.defineProperty(AmexioEmailInputComponent.prototype, "pattern", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pattern;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value != null) {
                this._pattern = value;
                this.regEx = new RegExp(this._pattern);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioEmailInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.createCompId('emailinput', this.name);
        this.name = this.generateName(this.name, this.fieldlabel, 'emailinput');
    };
    // THIS METHOD USED FOR BLUR EVENT.
    /**
     * @return {?}
     */
    AmexioEmailInputComponent.prototype.onblur = /**
     * @return {?}
     */
    function () {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    };
    // THIS METHOD USED FOR FOCUS EVENT .
    /**
     * @return {?}
     */
    AmexioEmailInputComponent.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.showToolTip = true;
        this.focus.emit(this.value);
    };
    // THIS METHOD USED FOR  INPUT EVENT .
    /**
     * @return {?}
     */
    AmexioEmailInputComponent.prototype.onInput = /**
     * @return {?}
     */
    function () {
        this.isValid = this.isFieldValid();
        this.input.emit(this.value);
    };
    // THIS METHOD USED FOR CHANGE EVENT  .
    /**
     * @return {?}
     */
    AmexioEmailInputComponent.prototype.onChangeEv = /**
     * @return {?}
     */
    function () {
        this.change.emit(this.value);
    };
    // THIS METHOD IS USED FOR VALIDATION
    /**
     * @return {?}
     */
    AmexioEmailInputComponent.prototype.isFieldValid = /**
     * @return {?}
     */
    function () {
        return (!this.allowblank && this.emailpattern.test(this.value)) || this.allowblank;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioEmailInputComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    AmexioEmailInputComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-email-input',
                    template: "\n\n    <div class=\"inputgroup\">\n\n      <label *ngIf=\"hasLabel\"  role=\"email\" for=\"{{componentId}}\" id=\"{{componentId}}\" [style.font-style]=\"fontstyle\" [style.font-family]=\"fontfamily\" [style.font-size]=\"fontsize\">\n        {{fieldlabel}}\n      </label> \n\n      <input type=\"email\" \n\n            role=\"email\" \n            tabindex=\"1\"\n            id=\"{{componentId}}\" \n            name=\"emailText\"\n            attr.aria-labelledby=\"{{componentId}}\"\n            aria-describedby=\"emailDes\"\n            [attr.aria-disabled]=\"disabled ? true: null\"\n            [attr.aria-required]=\"!allowblank\"\n            [attr.aria-invalid]=\"!isValid \"\n\n\n\n        \n             class=\"input-control\"\n             [ngClass]=\"model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''\"\n             [(ngModel)]=\"value\"\n             (blur)=\"onblur()\"\n             (focus)=\"onFocus()\"\n             (input)=\"onInput()\"\n             (change)=\"onChangeEv()\"\n             [name]=\"name\"\n             [pattern]=\"regEx\"\n             [attr.placeholder]=\"placeholder\"\n             [attr.disabled] = \"disabled ? true: null\"\n             [required]=\"!allowblank\"/>\n\n             <ng-container *ngIf=\"iconfeedback\">\n              <span class=\"input-control-feedback\">\n                  <span *ngIf=\"!isValid && model.touched\"><em class=\"fa fa-times\"></em></span>\n                  <span *ngIf=\"isValid && model.touched\"><em class=\"fa fa-check\"></em></span>\n              </span>\n          </ng-container>\n    \n          <input-help *ngIf=\"showToolTip && enablepopover\"\n          id=\"emailDes\" \n          role=\"tooltip\"\n          [error-msg]=\"errormsg\" \n          [min-msg]=\"minmsg\" \n          [max-msg]=\"maxmsg\"\n          >\n          </input-help>\n     \n          <span class=\"inputfieldbar\"></span>\n        </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioEmailInputComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioEmailInputComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioEmailInputComponent.ctorParameters = function () { return []; };
    AmexioEmailInputComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        hasLabel: [{ type: i0.Input, args: ['has-label',] }],
        allowblank: [{ type: i0.Input, args: ['allow-blank',] }],
        model: [{ type: i0.ViewChild, args: [forms.NgModel,] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        disabled: [{ type: i0.Input }],
        iconfeedback: [{ type: i0.Input, args: ['icon-feedback',] }],
        fontstyle: [{ type: i0.Input, args: ['font-style',] }],
        fontfamily: [{ type: i0.Input, args: ['font-family',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        errormsg: [{ type: i0.Input, args: ['error-msg',] }],
        pattern: [{ type: i0.Input, args: ['pattern',] }],
        enablepopover: [{ type: i0.Input, args: ['enable-popover',] }],
        onBlur: [{ type: i0.Output }],
        input: [{ type: i0.Output }],
        focus: [{ type: i0.Output }],
        change: [{ type: i0.Output }],
        name: [{ type: i0.Input, args: ['name',] }]
    };
    return AmexioEmailInputComponent;
}(ValueAccessorBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioFileUploadComponent = /** @class */ (function () {
    function AmexioFileUploadComponent(dataService) {
        this.dataService = dataService;
        /*
           Events
           name : onRemove
           datatype : any
           version : none
           default :
           description : On remove click event
           */
        this.onRemove = new i0.EventEmitter();
        this.onFileUpload = new i0.EventEmitter();
        this.success = new i0.EventEmitter();
        this.error = new i0.EventEmitter();
        this.uploadedFiles = [];
    }
    /**
     * @return {?}
     */
    AmexioFileUploadComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    /**
     * @return {?}
     */
    AmexioFileUploadComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () { };
    /**
     * @param {?} bytes
     * @param {?} decimals
     * @return {?}
     */
    AmexioFileUploadComponent.prototype.formatBytes = /**
     * @param {?} bytes
     * @param {?} decimals
     * @return {?}
     */
    function (bytes, decimals) {
        if (bytes === 0) {
            return '0 Bytes';
        }
        var /** @type {?} */ k = 1024;
        var /** @type {?} */ dm = decimals || 2;
        // tslint:disable-next-line:one-variable-per-declaration
        var /** @type {?} */ sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
        var /** @type {?} */ i = Math.floor(Math.log(bytes) / Math.log(k));
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioFileUploadComponent.prototype.onFileDrop = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.dropClass = '';
        var /** @type {?} */ dt = event.dataTransfer;
        if (dt.items) {
            // Use DataTransferItemList interface to access the file(s)
            // tslint:disable-next-line:prefer-for-of
            for (var /** @type {?} */ i = 0; i < dt.items.length; i++) {
                if (dt.items[i].kind === 'file') {
                    var /** @type {?} */ f = dt.items[i].getAsFile();
                    this.uploadFile(f, true);
                }
            }
        }
        else {
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioFileUploadComponent.prototype.onDragOver = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.preventDefault();
        this.dropClass = 'drop';
    };
    /**
     * @param {?} filedata
     * @param {?} index
     * @return {?}
     */
    AmexioFileUploadComponent.prototype.closeFile = /**
     * @param {?} filedata
     * @param {?} index
     * @return {?}
     */
    function (filedata, index) {
        this.onRemove.emit({ fileData: filedata });
        this.uploadedFiles.splice(index, 1);
    };
    //  For Uploading files
    /**
     * @param {?} event
     * @param {?} singleFile
     * @return {?}
     */
    AmexioFileUploadComponent.prototype.uploadFile = /**
     * @param {?} event
     * @param {?} singleFile
     * @return {?}
     */
    function (event, singleFile) {
        var _this = this;
        if (singleFile) {
            var /** @type {?} */ formData = new FormData();
            formData.append(this.paramname, event);
            if (this.httpmethod && this.httpurl) {
                this.dataService
                    .uploadFile(this.httpurl, this.httpmethod, formData)
                    .subscribe(function (response) {
                    _this.responseData = response;
                }, function (error) {
                    _this.error.emit(error);
                }, function () {
                    _this.success.emit(_this.responseData);
                });
            }
            this.uploadedFiles.push({
                name: event.name,
                size: this.formatBytes(event.size, 2),
            });
        }
        else {
            this.serviceCall(event);
        }
        this.onFileUpload.emit(this.uploadedFiles);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioFileUploadComponent.prototype.serviceCall = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ fileList = event.target.files != null ? event.target.files : event;
        var /** @type {?} */ formData = new FormData();
        if (fileList) {
            // tslint:disable-next-line:prefer-for-of
            for (var /** @type {?} */ i = 0; i < fileList.length; i++) {
                if (!this.paramname) {
                    this.paramname = 'file';
                }
                formData.append(this.paramname, fileList[i]);
            }
            this.uploadService(formData);
            if (fileList.length === 1) {
                var /** @type {?} */ fsize = this.formatBytes(fileList[0].size, 2);
                this.uploadedFiles.push({ name: fileList[0].name, size: fsize });
            }
            else if (fileList.length > 1) {
                // tslint:disable-next-line:prefer-for-of
                for (var /** @type {?} */ i = 0; i < fileList.length; i++) {
                    var /** @type {?} */ fsize = this.formatBytes(fileList[i].size, 2);
                    this.uploadedFiles.push({ name: fileList[i].name, size: fsize });
                }
            }
        }
    };
    /**
     * @param {?} formData
     * @return {?}
     */
    AmexioFileUploadComponent.prototype.uploadService = /**
     * @param {?} formData
     * @return {?}
     */
    function (formData) {
        var _this = this;
        this.dataService.uploadFile(this.httpurl, this.httpmethod, formData)
            .subscribe(function (response) {
            _this.responseData = response;
        }, function (error) { }, function () {
        });
    };
    AmexioFileUploadComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-fileupload',
                    template: "\n    <div class='input-group' *ngIf='!droppable'>\n        <ng-container *ngIf='fieldlabel'>\n            <label for=\"fileName\">{{fieldlabel}}</label>\n        </ng-container>\n        <ng-container *ngIf='!fieldlabel'>\n            <label for=\"fileName\">Choose File</label>\n        </ng-container>\n        <input type='file' aria-controls=\"fileUpload\" id=\"fileName\" class='input-control' [attr.accept]='filetype' (change)='uploadFile($event,false)' [attr.multiple]='multiplefile' #inp>\n    </div>\n    <ng-container *ngIf='droppable'>\n        <ng-container *ngIf='fieldlabel'>\n            <label for=\"dragFileName\">{{fieldlabel}}</label>\n        </ng-container>\n        <ng-container *ngIf='!fieldlabel'>\n            <label for=\"dragFileName\">Drag and Drop Files below</label>\n        </ng-container>\n        <div class='upload-drop-zone {{dropClass}}' aria-controls=\"dragFileUpload\" id=\"dragFileName\" (drop)='onFileDrop($event)' (dragover)='onDragOver($event)' (dragleave)='dropClass = \"\";' #drpZone>\n            Just drag and drop files here\n        </div>\n    </ng-container>\n\n    <div class='file-upload-box' style='width: 100%'>\n        <li *ngFor='let file of uploadedFiles ; let index = index' class='file-upload-info'>\n            <span class='uploaded-file-name'>({{file.name}} &nbsp; &nbsp; ({{file.size}}) )</span>\n            <amexio-c-icon key='tab_close' class='close-icon' (onClick)='closeFile(file,index)'>\n            </amexio-c-icon>\n        </li>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioFileUploadComponent.ctorParameters = function () { return [
        { type: CommonDataService }
    ]; };
    AmexioFileUploadComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        filetype: [{ type: i0.Input, args: ['file-type',] }],
        multiplefile: [{ type: i0.Input, args: ['multiple-file',] }],
        paramname: [{ type: i0.Input, args: ['param-name',] }],
        droppable: [{ type: i0.Input }],
        onRemove: [{ type: i0.Output }],
        onFileUpload: [{ type: i0.Output }],
        success: [{ type: i0.Output }],
        error: [{ type: i0.Output }]
    };
    return AmexioFileUploadComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 26/2/2018.
*/
var AmexioFloatingButtonComponent = /** @class */ (function () {
    function AmexioFloatingButtonComponent() {
        /*
          Properties
          name : block
          datatype : none
          version : 4.1 onwards
          default : none
          description : Display button as round or square
          */
        this.block = 'circle';
        /*
          Properties
          name : color
          datatype : string
          version : 5.5.4 onwards
          default : white color
          description : sets icon color.
          */
        this.iconcolor = 'white';
        /*
           Properties
           name : bg-color
           datatype : string
           version : 5.5.4 onwards
           default : none
           description : sets background color of floating button.
           */
        this.bgcolor = '';
        /*
          Properties
          name : relative
          datatype : boolean
          version : 4.1 onwards
          default : none
          description : Place floating button at relative position
          */
        this.relative = false;
        /*
          Events
          name : onClick
          datatype : any
          version : none
          default : none
          description : Event is fired when button is click
          */
        this.onClick = new i0.EventEmitter();
        /*
           Properties
           name : absolute
           datatype : boolean
           version : 5.5.5 onwards
           default : none
           description : Place floating button at absolute position
           */
        this.absolute = false;
        this.absoluteposition = false;
        this.ispressed = false;
        this.bgcolorflag = false;
        this.floatingButtonCss = ' floatingbutton-';
    }
    /**
     * @return {?}
     */
    AmexioFloatingButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.createCompId('floatingBtn');
        this.addCSSClasses();
    };
    // THIS METHOD IS USED FOR SETTING CSS CLASSSES
    /**
     * @return {?}
     */
    AmexioFloatingButtonComponent.prototype.addCSSClasses = /**
     * @return {?}
     */
    function () {
        if (this.top || this.bottom || this.right || this.left) {
            this.absoluteposition = true;
        }
        this.positionclass = '';
        if (this.relative && !this.absolute) {
            this.positionclass = ' floatingbutton-relative ';
            this.top = '';
            this.left = '';
            this.right = '';
            this.bottom = '';
        }
        else if (this.absolute) {
            this.positionclass = 'floatingbutton-absolute ';
        }
        else {
            this.positionclass = ' floatingbutton-fixed ';
        }
        if (!this.absoluteposition && !this.relative) {
            this.btnPositionCss();
        }
        if (this.block === 'circle') {
            this.setCricle();
        }
        else if (this.block === 'square') {
            this.positionclass = this.positionclass + ' floatingbutton-square';
        }
        if (this.bgcolor.length > 1) {
            this.bgcolorflag = true;
            this.type = 'default';
            this.getPositionClass();
        }
        else {
            this.getPositionClass();
        }
        return this.positionclass;
    };
    /**
     * @return {?}
     */
    AmexioFloatingButtonComponent.prototype.getPositionClass = /**
     * @return {?}
     */
    function () {
        this.positionclass = this.disabled ? this.positionclass + this.floatingButtonCss + this.type + '-disabled' :
            this.positionclass + this.floatingButtonCss + this.type;
    };
    /**
     * @return {?}
     */
    AmexioFloatingButtonComponent.prototype.setCricle = /**
     * @return {?}
     */
    function () {
        if (this.size && (this.size === 'large' || this.size === 'small')) {
            this.positionclass = this.positionclass + ' floatingbutton-circle-' + this.size;
        }
        else {
            this.positionclass = this.positionclass + ' floatingbutton-circle';
        }
        this.label = '';
    };
    // --------------------------------------------------------
    // Method to call css class on the basis of theme color
    // ---------------------------------------------------------------
    // Css on btn position
    /**
     * @return {?}
     */
    AmexioFloatingButtonComponent.prototype.btnPositionCss = /**
     * @return {?}
     */
    function () {
        if (this.verticalposition === null) {
            this.verticalposition = 'top';
        }
        else if (this.horizontalposition === null) {
            this.horizontalposition = 'right';
        }
        this.positionclass = this.positionclass + this.floatingButtonCss +
            this.verticalposition + this.floatingButtonCss + this.horizontalposition +
            ' floatingbutton-default';
    };
    // Method for button click
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    AmexioFloatingButtonComponent.prototype.buttonClick = /**
     * @param {?} clickEvent
     * @return {?}
     */
    function (clickEvent) {
        this.ispressed = !this.ispressed;
        if (!this.disabled) {
            this.onClick.emit({ thisObj: this, event: clickEvent });
        }
    };
    /**
     * @param {?} event1
     * @return {?}
     */
    AmexioFloatingButtonComponent.prototype.togglebtn = /**
     * @param {?} event1
     * @return {?}
     */
    function (event1) {
        this.ispressed = !this.ispressed;
        if (!this.disabled) {
            this.onClick.emit({ thisObj: this, event: event1 });
        }
    };
    /**
     * @param {?} inputType
     * @return {?}
     */
    AmexioFloatingButtonComponent.prototype.createCompId = /**
     * @param {?} inputType
     * @return {?}
     */
    function (inputType) {
        return inputType + '_' + Math.floor(Math.random() * 1000 + 999);
    };
    AmexioFloatingButtonComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-floating-button',
                    template: "\n    <div [ngClass]=\"{floatingbtntooltip: tooltip}\">\n        <div class=\"floatingbutton\" title=\"\" role=\"button\" tabindex=\"1\" [attr.aria-pressed]=\"ispressed\" attr.aria-describedby=\"{{componentId}}\" (keyup.enter)=\"togglebtn($event)\" (keyup.space)=\"togglebtn($event)\" [ngClass]=\"addCSSClasses()\" [ngStyle]=\"{'top':top,'bottom':bottom,'left':left,'right':right, 'background-color': bgcolorflag ? bgcolor : ''}\"\n            (click)=\"buttonClick($event)\">\n            <!-- attr.color=\"iconcolor\" -->\n            <amexio-c-icon *ngIf=\"icon\" [customclass]=\"icon\" [color]=\"iconcolor\">\n            </amexio-c-icon>\n            {{label}}\n\n        </div>\n        <span id=\"{{componentId}}\" role=\"tooltip\" *ngIf=\"tooltip\" class=\"floatingbtntooltiptext\">{{tooltip}}</span>\n\n    </div>\n  ",
                    changeDetection: i0.ChangeDetectionStrategy.OnPush,
                },] },
    ];
    /** @nocollapse */
    AmexioFloatingButtonComponent.ctorParameters = function () { return []; };
    AmexioFloatingButtonComponent.propDecorators = {
        verticalposition: [{ type: i0.Input, args: ['vertical-position',] }],
        horizontalposition: [{ type: i0.Input, args: ['horizontal-position',] }],
        top: [{ type: i0.Input, args: ['position-top',] }],
        bottom: [{ type: i0.Input, args: ['position-bottom',] }],
        left: [{ type: i0.Input, args: ['position-left',] }],
        right: [{ type: i0.Input, args: ['position-right',] }],
        label: [{ type: i0.Input, args: ['label',] }],
        block: [{ type: i0.Input, args: ['block',] }],
        icon: [{ type: i0.Input, args: ['icon',] }],
        iconcolor: [{ type: i0.Input, args: ['color',] }],
        bgcolor: [{ type: i0.Input, args: ['bg-color',] }],
        type: [{ type: i0.Input, args: ['type',] }],
        disabled: [{ type: i0.Input, args: ['disabled',] }],
        relative: [{ type: i0.Input, args: ['relative',] }],
        onClick: [{ type: i0.Output }],
        size: [{ type: i0.Input, args: ['size',] }],
        tooltip: [{ type: i0.Input, args: ['tool-tip',] }],
        absolute: [{ type: i0.Input, args: ['absolute',] }]
    };
    return AmexioFloatingButtonComponent;
}());

var __extends$19 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 26/2/2018.
*/
var AmexioFloatingGroupButtonComponent = /** @class */ (function (_super) {
    __extends$19(AmexioFloatingGroupButtonComponent, _super);
    function AmexioFloatingGroupButtonComponent(elementref, cdf, renderer) {
        var _this = _super.call(this, renderer, elementref, cdf) || this;
        _this.elementref = elementref;
        _this.cdf = cdf;
        /*
          Properties
          name : relative
          datatype : boolean
          version : 4.1 onwards
          default : none
          description : Place floating buttong at relative position
          */
        _this.relative = false;
        /*
          Events
          name : onClick
          datatype : any
          version : none
          default : none
          description : Event is fired when button is click
          */
        _this.onClick = new i0.EventEmitter();
        _this.togglefloatinggroup = false;
        _this.ispressed = false;
        _this.color = 'red-color';
        _this.datacount = 0;
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioFloatingGroupButtonComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dropdownstyle = { visibility: 'hidden' };
        if (this.data && this.data.length > 0) {
            this.datacount = this.data.length;
            this.data.forEach(function (node, index) {
                if (!node['type']) {
                    node['type'] = _this.type;
                    node['index'] = index;
                    node['typeclass'] = 'floatingbutton-' + _this.type;
                }
                else {
                    node['index'] = index;
                    node['typeclass'] = 'floatingbutton-' + node['type'];
                }
                _this.addCssToBtnGroup();
            });
        }
    };
    /**
     * @return {?}
     */
    AmexioFloatingGroupButtonComponent.prototype.addCssToBtnGroup = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.data && this.data.length > 0) {
            this.data.forEach(function (node) {
                if (_this.size && (_this.size === 'large')) {
                    node['typeclass'] = node['typeclass'] + ' floatingbutton-circle-' + _this.size;
                }
                if (_this.size && (_this.size === 'small')) {
                    node['typeclass'] = node['typeclass'] + ' floatingbutton-circle-' + _this.size;
                }
                if ((_this.size !== 'large') && (_this.size !== 'small')) {
                    node['typeclass'] = node['typeclass'] + ' floatingbutton-circle';
                }
            });
        }
    };
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    AmexioFloatingGroupButtonComponent.prototype.buttonClick = /**
     * @param {?} clickEvent
     * @return {?}
     */
    function (clickEvent) {
        this.ispressed = !this.ispressed;
        var /** @type {?} */ x = clickEvent.currentTarget.getBoundingClientRect().left;
        var /** @type {?} */ y = clickEvent.currentTarget.getBoundingClientRect().top;
        if (!this.disabled) {
            if (this.size === 'small' && this.floatinggroupposition === 'bottom') {
                this.floatinggroupxposition = (x) + 'px';
                this.floatinggroupyposition = (y + 34) + 'px';
            }
            if (this.size === 'large' && this.floatinggroupposition === 'bottom') {
                this.floatinggroupxposition = (x) + 'px';
                this.floatinggroupyposition = (y + 108) + 'px';
            }
            if (((this.size !== 'large') && (this.size !== 'small')) && this.floatinggroupposition === 'bottom') {
                this.floatinggroupxposition = (x) + 'px';
                this.floatinggroupyposition = (y + 70) + 'px';
            }
            this.floatingBtnGroupTopPostion(event);
            this.toggleVisibility();
            this.togglefloatinggroup = !this.togglefloatinggroup;
            this.onClick.emit({ thisObj: this, event: clickEvent });
        }
    };
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    AmexioFloatingGroupButtonComponent.prototype.floatingBtnGroupTopPostion = /**
     * @param {?} clickEvent
     * @return {?}
     */
    function (clickEvent) {
        var /** @type {?} */ x = clickEvent.currentTarget.getBoundingClientRect().left;
        var /** @type {?} */ y = clickEvent.currentTarget.getBoundingClientRect().top;
        if (this.size === 'small' && this.floatinggroupposition === 'top') {
            this.floatinggroupxposition = (x) + 'px';
            this.floatinggroupyposition = (y - (38 * this.datacount)) + 'px';
        }
        if (this.size === 'large' && this.floatinggroupposition === 'top') {
            this.floatinggroupxposition = (x) + 'px';
            this.floatinggroupyposition = (y - (108 * this.datacount)) + 'px';
        }
        if (((this.size !== 'large') && (this.size !== 'small')) && this.floatinggroupposition === 'top') {
            this.floatinggroupxposition = (x) + 'px';
            this.floatinggroupyposition = (y - (80 * this.datacount)) + 'px';
        }
    };
    /**
     * @return {?}
     */
    AmexioFloatingGroupButtonComponent.prototype.toggleVisibility = /**
     * @return {?}
     */
    function () {
        if (this.dropdownstyle.visibility === 'visible') {
            _super.prototype.itemClicked.call(this);
        }
        else {
            var /** @type {?} */ event_1 = '';
            _super.prototype.focus.call(this, event_1);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioFloatingGroupButtonComponent.prototype.onFloatingButtonClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.buttonClick(event.event);
    };
    /**
     * @param {?} node
     * @param {?} clickEvent
     * @return {?}
     */
    AmexioFloatingGroupButtonComponent.prototype.onButtonClick = /**
     * @param {?} node
     * @param {?} clickEvent
     * @return {?}
     */
    function (node, clickEvent) {
        this.toggleVisibility();
        this.togglefloatinggroup = !this.togglefloatinggroup;
        this.onClick.emit({ this: node, parent: this, event: clickEvent });
    };
    /**
     * @param {?} ref
     * @return {?}
     */
    AmexioFloatingGroupButtonComponent.prototype.arrowDown = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ trefid;
        var /** @type {?} */ refId = (parseInt(ref.id, 10));
        if (refId === (this.data.length - 1)) {
            trefid = 0;
        }
        else {
            trefid = refId + 1;
        }
        document.getElementById((trefid).toString()).focus();
    };
    /**
     * @param {?} ref
     * @return {?}
     */
    AmexioFloatingGroupButtonComponent.prototype.arrowUp = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ trefid;
        var /** @type {?} */ refId = (parseInt(ref.id, 10));
        if (refId === 0) {
            trefid = this.data.length - 1;
        }
        else {
            trefid = refId - 1;
        }
        document.getElementById((trefid).toString()).focus();
    };
    AmexioFloatingGroupButtonComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-floating-group-button',
                    template: "\n \n \n \n \n     <div id=\"parentdiv\" role=\"menu\" [attr.aria-expanded]=\"togglefloatinggroup\"\n     tabindex=\"-1\" [attr.aria-pressed]=\"ispressed\">\n       <amexio-floating-button \n           (onClick)=\"onFloatingButtonClick($event)\"\n           [vertical-position]=\"verticalposition\" \n           [horizontal-position]=\"horizontalposition\"\n           [icon]=\"icon\" \n           [type]=\"type\" \n           [disabled]=\"disabled\"\n           [size]=\"size\"\n           [relative]=\"relative\"\n           [position-top]=\"top\"\n           [position-bottom]=\"bottom\"\n           [position-left]=\"left\" \n           [position-right]=\"right\">\n       </amexio-floating-button>\n    </div>\n\n\n    <div \n\n       class=\"floatinggroup\" \n       *ngIf=\"togglefloatinggroup\"\n       tabindex=\"-1\"\n       [ngStyle]=\"{'top':floatinggroupyposition, 'left':floatinggroupxposition}\">\n\n       <div #ref attr.id=\"{{node.index}}\" role=\"button\" attr.aria-label=\"{{node.label}}\" role=\"options\"\n        class=\"floatinggroupitems\" style= \"text-align:center;\"\n\n           tabindex=\"1\" *ngFor=\"let node of data\" (keyup.enter)=\"onButtonClick(node,$event)\" (keyup.arrowdown)=\"arrowDown(ref,node)\"\n           (keyup.arrowup)=\"arrowUp(ref,node)\">\n           <div *ngIf=\"node.icon\" role=\"tooltip\"  [ngClass]=\"node.typeclass\" (click)=\"onButtonClick(node,$event)\">\n               <amexio-c-icon [customclass]=\"node.icon\">\n               </amexio-c-icon>\n           </div>\n       </div>\n    </div> \n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioFloatingGroupButtonComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: i0.Renderer2 }
    ]; };
    AmexioFloatingGroupButtonComponent.propDecorators = {
        verticalposition: [{ type: i0.Input, args: ['vertical-position',] }],
        horizontalposition: [{ type: i0.Input, args: ['horizontal-position',] }],
        top: [{ type: i0.Input, args: ['position-top',] }],
        size: [{ type: i0.Input, args: ['size',] }],
        bottom: [{ type: i0.Input, args: ['position-bottom',] }],
        left: [{ type: i0.Input, args: ['position-left',] }],
        right: [{ type: i0.Input, args: ['position-right',] }],
        icon: [{ type: i0.Input, args: ['icon',] }],
        type: [{ type: i0.Input, args: ['type',] }],
        disabled: [{ type: i0.Input, args: ['disabled',] }],
        relative: [{ type: i0.Input, args: ['relative',] }],
        floatinggroupposition: [{ type: i0.Input, args: ['floating-group-position',] }],
        data: [{ type: i0.Input, args: ['data',] }],
        onClick: [{ type: i0.Output }]
    };
    return AmexioFloatingGroupButtonComponent;
}(ListBaseDatepickerComponent));

var __extends$20 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var noop$10 = function () {
};
var AmexioMultipleDatePickerComponent = /** @class */ (function (_super) {
    __extends$20(AmexioMultipleDatePickerComponent, _super);
    function AmexioMultipleDatePickerComponent(element, cdf, renderer) {
        var _this = _super.call(this, renderer, element, cdf) || this;
        _this.element = element;
        _this.cdf = cdf;
        /*
           Properties
           name : date-picker
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : Enable/Disable Date Picker
           */
        _this.datepicker = true;
        /*
          Properties
          name : field-label
          datatype : string
          version : 5.5.5 onwards
          default :
          description :The label of this field
          */
        _this.placeholder = '';
        /*
           Properties
           name : disabled
           datatype : boolean
           version : 4.1.5 onwards
           default : false
           description : Disable Date/Time Picker field
           */
        _this.disabled = false;
        /*
           Properties
           name : diabled-date
           datatype :  any
           version : 4.2 onwards
           default : none
           description : sets disabled dates range
           */
        _this.diabledDate = [];
        /*
           Properties
           name : inline-datepicker
           datatype :  boolean
           version : 4.2 onwards
           default : none
           description : sets inline calender
           */
        _this.inlineDatepicker = false;
        /*
           Properties
           name : dropdown-datepicker
           datatype :  boolean
           version : 4.2 onwards
           default : none
           description : sets dropdown datepicker
           */
        _this.dropdownDatepicker = false;
        /*
           Properties
           name : required
           datatype : boolean
           version : 4.0 onwards
           default : false
           description : Flag to allow blank field or not
           */
        _this.required = false;
        _this.itterablemontharray = [];
        _this.montharray = [];
        /*
           Events
           name : blur
           description : On blur event
           */
        // @Output() blur: EventEmitter<any> = new EventEmitter<any>();
        /*
           Properties
           name : change
           description : On field value change event
           */
        _this.change = new i0.EventEmitter();
        /*
           Properties
           name : input
           description : On input event field.
           */
        _this.input = new i0.EventEmitter();
        /*
           Properties
           name : focus
           description : On field focus event
           */
        // @Output() focus: EventEmitter<any> = new EventEmitter<any>();
        _this.inputtabindex = 0;
        _this.daystabindex = -1;
        _this.drop = false;
        _this.tempFlag = true;
        _this.hostFlag = false;
        _this.count = 0;
        _this.isComponentValid = new i0.EventEmitter();
        _this.backArrowFlag = false;
        _this.forwardArrowFlag = false;
        _this.okispressed = false;
        _this.cancelispressed = false;
        _this.innerValue = '';
        _this.onTouchedCallback = noop$10;
        _this.onChangeCallback = noop$10;
        _this.viewmode = '1';
        _this.yearList1 =
            [{ year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
                { year: 0, flag: false, disabled: false },
            ];
        // generate yearlist1 ids
        // generate yearlist1 ids
        _this.yearList1.forEach(function (yearlist1element) {
            yearlist1element['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
        });
        _this.yearList2 = [{ year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }, { year: 0, flag: false, disabled: false },
            { year: 0, flag: false, disabled: false }];
        // generate yearlist2 ids
        // generate yearlist2 ids
        _this.yearList2.forEach(function (yearlist2element) {
            yearlist2element['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
        });
        _this.monthList1 = [
            { name: 'Jan', flag: false, num: 4, fullname: 'January' },
            { name: 'Feb', flag: false, fullname: 'febuary' },
            { name: 'Mar', flag: false, fullname: 'march' },
            { name: 'Apr', flag: false, fullname: 'april' },
            { name: 'May', flag: false, fullname: 'may' },
            { name: 'Jun', flag: false, fullname: 'june' },
        ];
        // generate id for monthlist1
        // generate id for monthlist1
        _this.monthList1.forEach(function (monthlist1element) {
            monthlist1element['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
        });
        _this.monthList2 = [
            { name: 'Jul', flag: false, fullname: 'july' },
            { name: 'Aug', flag: false, fullname: 'august' },
            { name: 'Sep', flag: false, fullname: 'september' },
            { name: 'Oct', flag: false, fullname: 'october' },
            { name: 'Nov', flag: false, fullname: 'november' },
            { name: 'Dec', flag: false, fullname: 'december' },
        ];
        // generate id for monthlist 2
        // generate id for monthlist 2
        _this.monthList2.forEach(function (monthlist2element) {
            monthlist2element['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
        });
        _this.minDate = '';
        _this.maxDate = '';
        _this.elementId = new Date().getTime() + '';
        _this.selectedDate = new Date();
        _this.currrentDate = new Date();
        _this.curYear = _this.currrentDate.getFullYear();
        var /** @type {?} */ i = 0;
        var /** @type {?} */ j = 0;
        for (i = 4; i >= 0; i--) {
            _this.yearList1[j].year = _this.curYear - i;
            j++;
        }
        j = 0;
        for (i = 1; i <= 5; i++) {
            _this.yearList2[j].year = _this.curYear + i;
            j++;
        }
        _this.daysTitle = [];
        _this.daysArray = [];
        _this.completeDaysArray = [];
        _this.timepicker = false;
        _this.hrs = _this.currrentDate.getHours();
        _this.min = _this.currrentDate.getMinutes();
        _this.initDaysTitle();
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.calculateScreenWidth();
        var /** @type {?} */ i;
        for (i = 1; i <= this.numberofmonths; i++) {
            this.itterablemontharray.push(i);
        }
        if (this.inlineDatepicker) {
            this.showToolTip = true;
            this.dropdownstyle = { visibility: 'visible' };
        }
        this.isValid = !this.required;
        this.isComponentValid.emit(!this.required);
        if (this.dateformat != null) {
            this.dateformat = 'dd/MM/yyyy';
        }
        var /** @type {?} */ d = new Date(this.currrentDate);
        for (i = 0; i < this.numberofmonths; i++) {
            var /** @type {?} */ obj = {};
            if (i === 0) {
                d.setMonth(d.getMonth());
            }
            else {
                d.setMonth(d.getMonth() + 1);
            }
            obj['date'] = new Date(d);
            this.createDaysForCurrentMonths(d);
            obj['montharray'] = this.daysArray;
            obj['month'] = this.getFullMonthName(d);
            obj['year'] = d.getFullYear();
            this.completeDaysArray.push(obj);
        }
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.initDaysTitle = /**
     * @return {?}
     */
    function () {
        this.daysTitle.push({ text: 'Mo' });
        this.daysTitle.push({ text: 'Tu' });
        this.daysTitle.push({ text: 'We' });
        this.daysTitle.push({ text: 'Th' });
        this.daysTitle.push({ text: 'Fr' });
        this.daysTitle.push({ text: 'Sa' });
        this.daysTitle.push({ text: 'Su' });
    };
    /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.createDaysForCurrentMonths = /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    function (selectedPeriod) {
        this.daysArray = [];
        var /** @type {?} */ date = new Date(selectedPeriod.getFullYear(), selectedPeriod.getMonth(), 1, 0, 0, 0, 0); // Starting at the 1st of the month
        var /** @type {?} */ extras = (date.getDay() + 6) % 7; // How many days of the last month do we need to include?
        date.setDate(date.getDate() - extras); // Skip back to the previous monday
        while (this.daysArray.length < 6) {
            var /** @type {?} */ rowDays = [];
            for (var /** @type {?} */ i = 0; i < 7; i++) {
                var /** @type {?} */ day = {
                    date: null, selected: false, isCurrentMonth: null, isDisabled: false,
                };
                day.date = new Date(date.getTime());
                day.isCurrentMonth = (date.getMonth() === selectedPeriod.getMonth());
                day['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
                day['fulldate'] = (day.date).getDate() + ' ' +
                    this.getFullMonthName(day.date) + ' ' + (day.date).getFullYear() +
                    ' ' + this.getFullDayName(day.date);
                if (this.dateModel && (date.getMonth() === this.dateModel.getMonth()) &&
                    (date.getDate() === this.dateModel.getDate())) {
                    day.selected = true;
                }
                else if ((date.getMonth() === this.currrentDate.getMonth()) &&
                    (date.getDate() === this.currrentDate.getDate())) {
                    if (this.dateModel) {
                        day.selected = false;
                        day['tabindex'] = -1;
                    }
                    else {
                        day.selected = true;
                        day['tabindex'] = 1;
                    }
                }
                rowDays.push(day);
                date.setDate(date.getDate() + 1);
            }
            this.daysArray.push(rowDays);
        }
    };
    /**
     * @param {?} recevieddate
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.getFullMonthName = /**
     * @param {?} recevieddate
     * @return {?}
     */
    function (recevieddate) {
        var /** @type {?} */ months = ['January', 'Febuary', 'March', 'April', 'May',
            'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        var /** @type {?} */ datemonth = recevieddate.getMonth();
        var /** @type {?} */ monthString = '';
        months.forEach(function (element, index) {
            if (datemonth === index) {
                monthString = element;
            }
        });
        return monthString;
    };
    /**
     * @param {?} receiveddate
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.getFullDayName = /**
     * @param {?} receiveddate
     * @return {?}
     */
    function (receiveddate) {
        var /** @type {?} */ weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
            'Thursday', 'Friday', 'Saturday'];
        var /** @type {?} */ day = receiveddate.getDay();
        var /** @type {?} */ dayname = '';
        weekdays.forEach(function (element, index) {
            if (day === index) {
                dayname = element;
            }
        });
        return dayname;
    };
    /**
     * @param {?} operation
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.updateMonthList = /**
     * @param {?} operation
     * @param {?} event
     * @return {?}
     */
    function (operation, event) {
        this.dropdownstyle = { visibility: 'visible' };
        event.stopPropagation();
        if (operation === 'plus') {
            // call plus function
            this.incrementMonthList(event);
        }
        if (operation === 'minus') {
            // call minus function
            this.decrementMonthList(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.incrementMonthList = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.completeDaysArray.forEach(function (singleDayArray) {
            // date updation
            var /** @type {?} */ d = new Date(singleDayArray.date);
            d.setMonth(d.getMonth() + _this.numberofmonths);
            _this.createDaysForCurrentMonths(d);
            singleDayArray.date = d;
            singleDayArray.montharray = _this.daysArray;
            singleDayArray.month = _this.getFullMonthName(d);
            singleDayArray.year = d.getFullYear();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.decrementMonthList = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.completeDaysArray.forEach(function (singleDayArray) {
            // date updation
            var /** @type {?} */ d = new Date(singleDayArray.date);
            d.setMonth(d.getMonth() - _this.numberofmonths);
            _this.createDaysForCurrentMonths(d);
            singleDayArray.date = d;
            singleDayArray.montharray = _this.daysArray;
            singleDayArray.month = _this.getFullMonthName(d);
            singleDayArray.year = d.getFullYear();
        });
    };
    /**
     * @param {?} dateObj
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.onDateClick = /**
     * @param {?} dateObj
     * @param {?} event
     * @return {?}
     */
    function (dateObj, event) {
        if (dateObj.isDisabled === false) {
            this.change.emit(dateObj.date);
            if (this.inlineDatepicker === false) {
                _super.prototype.itemClicked.call(this);
            }
            this.hostFlag = true;
            this.selectedDate = dateObj.date;
            this.selectedDate.setHours(this.hrs);
            this.selectedDate.setMinutes(this.min);
            this.resetSelection(dateObj.date);
            this.dateModel = this.selectedDate;
            this.value = this.selectedDate;
            this.isValid = true;
            this.isComponentValid.emit(true);
            if (this.inlineDatepicker) {
                this.showToolTip = true;
            }
            else {
                this.showToolTip = !this.showToolTip;
            }
        }
        else {
            event.stopPropagation();
        }
    };
    /**
     * @param {?} dateObj
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.resetSelection = /**
     * @param {?} dateObj
     * @return {?}
     */
    function (dateObj) {
        for (var _i = 0, _a = this.daysArray; _i < _a.length; _i++) {
            var i = _a[_i];
            for (var _b = 0, i_1 = i; _b < i_1.length; _b++) {
                var j = i_1[_b];
                var /** @type {?} */ day = j;
                if (day.date.getTime() === dateObj.getTime()) {
                    day.selected = true;
                }
                else {
                    day.selected = false;
                }
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.onInput = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.target.value != null && event.target.value !== '') {
            var /** @type {?} */ timeValue = event.target.value.split(':');
            if (timeValue != null) {
                var /** @type {?} */ hrs = parseInt(timeValue[0].trim(), 10);
                var /** @type {?} */ mins = parseInt(timeValue[1].trim(), 10);
                this.selectedDate.setHours(hrs);
                this.selectedDate.setMinutes(mins);
                this.hrs = hrs;
                this.min = mins;
                this.value = this.selectedDate;
                event.stopPropagation();
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.nextMonth = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setVisibility();
        this.setDateData('plus', 1, event);
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.setVisibility = /**
     * @return {?}
     */
    function () {
        this.dropdownstyle = { visibility: 'visible' };
        this.disableddays(this.diabledDate);
        event.stopPropagation();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.prevMonth = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setVisibility();
        this.setDateData('minus', 1, event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.nextYear = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setDateData1('plus', 12, event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.prevYear = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.setDateData1('minus', 12, event);
    };
    // this function validates month
    /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.setDateData = /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    function (state1, mon, event) {
        var /** @type {?} */ d = new Date(this.currrentDate.getFullYear(), this.currrentDate.getMonth(), this.currrentDate.getDate());
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        // checks if selected date is within maximum range of month
        if (state1 === 'plus') {
            this.setPlusData(d, max, mon);
        }
        else if (state1 === 'minus') {
            this.setMinusData(d, min, mon);
        }
        this.currrentDate = d;
        this.initDate();
        event.stopPropagation();
    };
    // Set Plus Data
    /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.setPlusData = /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    function (d, max, mon) {
        if (this.maxDate.length > 0) {
            if (d.getFullYear() === max.getFullYear()) {
                this.setMaxFullYear(d, max, mon);
            }
            else {
                // logic to chk if year is valid
                if (d.getFullYear() <= max.getFullYear()) {
                    d.setMonth(d.getMonth() + mon);
                }
            }
        }
        else {
            // outer ends
            d.setMonth(d.getMonth() + mon);
        } // checks if selected date is within minimum range of month
    };
    // Set Max Full Year
    /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.setMaxFullYear = /**
     * @param {?} d
     * @param {?} max
     * @param {?} mon
     * @return {?}
     */
    function (d, max, mon) {
        if ((d.getMonth() !== max.getMonth()) && d.getFullYear() <= max.getFullYear() && d.getMonth() <= max.getMonth()) {
            d.setMonth(d.getMonth() + mon);
        }
    };
    // Set Minus Data
    /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.setMinusData = /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    function (d, min, mon) {
        if (this.minDate.length > 0) {
            if (d.getFullYear() === min.getFullYear()) {
                this.setMinFullYear(d, min, mon);
            }
            else {
                d.setMonth(d.getMonth() - mon);
            }
        }
        else {
            d.setMonth(d.getMonth() - mon);
        }
    };
    // Set Min Full year
    /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.setMinFullYear = /**
     * @param {?} d
     * @param {?} min
     * @param {?} mon
     * @return {?}
     */
    function (d, min, mon) {
        if ((d.getMonth() !== min.getMonth()) && d.getFullYear() >= min.getFullYear() && d.getMonth() >= min.getMonth()) {
            // logic to chk if year is valid
            d.setMonth(d.getMonth() - mon);
        }
    };
    // this function validates year
    /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.setDateData1 = /**
     * @param {?} state1
     * @param {?} mon
     * @param {?} event
     * @return {?}
     */
    function (state1, mon, event) {
        var /** @type {?} */ d = new Date(this.currrentDate.getFullYear(), this.currrentDate.getMonth(), this.currrentDate.getDate());
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        // checks if selected date is within maximum range of year
        if (state1 === 'plus') {
            if (this.maxDate.length > 0) {
                if (d.getFullYear() <= max.getFullYear() - 1) {
                    d.setMonth(d.getMonth() + mon);
                }
            }
            else {
                d.setMonth(d.getMonth() + mon);
            } // checks if selected date is within minimum range of year
        }
        else if (state1 === 'minus') {
            if (this.minDate.length > 0) {
                if (d.getFullYear() >= min.getFullYear() + 1) {
                    d.setMonth(d.getMonth() - mon);
                }
            }
            else {
                d.setMonth(d.getMonth() - mon);
            }
        }
        this.currrentDate = d;
        this.initDate();
        event.stopPropagation();
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.setToday = /**
     * @return {?}
     */
    function () {
        this.currrentDate = new Date();
        this.initDate();
        this.showToolTip = !this.showToolTip;
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.initDate = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.daysArray = [];
        this.createDaysForCurrentMonths(this.currrentDate);
        this.daysArray.forEach(function (dayrow, outerindex) {
            dayrow.forEach(function (element, innerindex) {
                if (_this.currrentDate === new Date(element.date)) {
                    var /** @type {?} */ itemid = _this.daysArray[outerindex][innerindex];
                    document.getElementById(itemid['id']).focus();
                }
            });
        });
        this.selectedDate = this.currrentDate;
        this.dateModel = this.selectedDate;
        this.value = this.selectedDate;
        this.innerValue = '';
    };
    /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.plus = /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    function (type, event) {
        if (type === 'min') {
            if (this.min === 59) {
                this.min = -1;
                this.hrs++;
            }
            this.min++;
        }
        if (type === 'hrs') {
            this.hrs++;
        }
        if (this.hrs === 24) {
            this.hrs = 0;
        }
        this.selectedDate.setHours(this.hrs);
        this.selectedDate.setMinutes(this.min);
        this.value = this.selectedDate;
        this.isValid = true;
        this.isComponentValid.emit(true);
        this.change.emit(this.value);
        event.stopPropagation();
    };
    /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.minus = /**
     * @param {?} type
     * @param {?} event
     * @return {?}
     */
    function (type, event) {
        if (type === 'min') {
            if (this.min === 0) {
                this.min = 60;
                this.hrs--;
            }
            this.min--;
        }
        if (type === 'hrs') {
            this.hrs--;
        }
        if (this.hrs === 0) {
            this.hrs = 23;
        }
        this.selectedDate.setHours(this.hrs);
        this.selectedDate.setMinutes(this.min);
        this.value = this.selectedDate;
        this.isValid = true;
        this.isComponentValid.emit(true);
        this.change.emit(this.value);
        event.stopPropagation();
    };
    Object.defineProperty(AmexioMultipleDatePickerComponent.prototype, "value", {
        // get accessor
        get: /**
         * @return {?}
         */
        function () {
            return this.innerValue;
        },
        // set accessor including call the onchange callback
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v !== this.innerValue) {
                this.innerValue = v;
                this.onChangeCallback(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    // Set touched on blur
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.onBlur = /**
     * @return {?}
     */
    function () {
        this.onTouchedCallback();
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== '') {
            if (value !== this.innerValue) {
                this.validateWriteValue(value);
            }
        }
        else {
            this.dateModel = '';
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.validateWriteValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.innerValue = value;
        if (this.innerValue instanceof Date || ('number' === typeof this.innerValue)) {
            if (('number' === typeof this.innerValue)) {
                this.innerValue = new Date(this.innerValue);
            }
            this.dateModel = this.innerValue;
            this.currrentDate = this.dateModel;
            this.selectedDate = this.currrentDate;
            this.createDaysForCurrentMonths(this.dateModel);
            if (this.required) {
                this.isValid = true;
            }
        }
        else {
            this.negateisValid();
        }
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.negateisValid = /**
     * @return {?}
     */
    function () {
        this.isValid = false;
        this.hrs = 0;
        this.min = 0;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.onFocus = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.onFocusOut = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (isNaN(Date.parse(value.value))) {
            this.isValid = false;
            value.value = '';
        }
        else {
            this.value = Date.parse(value.value);
            this.isValid = true;
        }
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.openPicker = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        this.inputtabindex = -1;
        this.daystabindex = 1;
        if (this.disabled === false) {
            _super.prototype.focus.call(this, elem);
            this.hostFlag = false;
            this.pickerele = elem;
            if (this.inlineDatepicker) {
                this.showToolTip = this.inlineDatepicker;
                this.setFocus();
            }
            else {
                this.showToolTip = true;
            }
            var /** @type {?} */ visibility = this.dropdownstyle.visibility;
            this.dropdownstyle.visibility = visibility;
            this.dropdownstyle.position = 'fixed';
            this.disableddays(this.diabledDate);
            this.setFocus();
        }
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.setFocus = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            // focus code starts
            // focus code starts
            _this.daysArray.forEach(function (row, index) {
                row.forEach(function (day, innerindex) {
                    if (day.selected) {
                        document.getElementById(day.id).focus();
                    }
                });
            });
        }, 0);
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.onSelect = /**
     * @return {?}
     */
    function () {
        this.showToolTip = false;
    };
    /**
     * @param {?} days
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.validateDays = /**
     * @param {?} days
     * @return {?}
     */
    function (days) {
        // check1: if min max is null return false
        if (this.maxDate.length <= 0 && this.minDate.length <= 0) {
            return false;
        }
    };
    /**
     * @param {?} dates
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.disableddays = /**
     * @param {?} dates
     * @return {?}
     */
    function (dates) {
        var _this = this;
        if (dates) {
            dates.forEach(function (element) {
                var /** @type {?} */ From = new Date(element.from);
                var /** @type {?} */ To = new Date(element.to);
                _this.daysArray.forEach(function (element2) {
                    element2.forEach(function (element1) {
                        if (element1.date.getFullYear() <= To.getFullYear() && element1.date.getMonth()
                            <= To.getMonth() && element1.date.getDate() <= To.getDate() && element1.date.getFullYear() >= From.getFullYear() &&
                            element1.date.getMonth() >= From.getMonth() &&
                            element1.date.getDate() >= From.getDate()) {
                            element1.isDisabled = true;
                        }
                    });
                });
            });
        }
    };
    // Added method to avois recursive code
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.elementFlagMethod = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (element.flag) {
            element.flag = false;
        }
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.negateDrop = /**
     * @return {?}
     */
    function () {
        this.cancelispressed = true;
        this.hostFlag = true;
        this.drop = false;
        this.showToolTip = true;
        this.tempFlag = true;
    };
    // this function broken from chk month getDropdownMonth()
    /**
     * @param {?} element
     * @param {?} month
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.chkMonth = /**
     * @param {?} element
     * @param {?} month
     * @return {?}
     */
    function (element, month) {
        if (element.name === month.name) {
            element.flag = true;
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.yearFlagNegate = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        this.elementFlagMethod(element);
    };
    // this function is broken from getDropdownYear
    /**
     * @param {?} element
     * @param {?} year
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.yearFlag = /**
     * @param {?} element
     * @param {?} year
     * @return {?}
     */
    function (element, year) {
        if (element.year === year.year) {
            element.flag = true;
        }
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.cancelDropdown = /**
     * @return {?}
     */
    function () {
        this.drop = false;
        this.showToolTip = true;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.arrowClickBack = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ i;
        // disable flag logic
        this.disableYearFlag();
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            // arrow click logic
            this.backArrow();
        }
        else {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year - 10;
                this.yearList2[i].year = this.yearList2[i].year - 10;
            } // for ends
        } // main else ends
        // disable flag logic
        this.disableYearFlag();
        // rechking arrow flags after reinitialization of yrlist1 & 2
        this.rechkYearFlag();
        event.stopPropagation();
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.backArrow = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        this.yearList1.forEach(function (element) {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear() && element.year !== min.getFullYear()) {
                _this.forwardArrowFlag = true;
                _this.backArrowFlag = false;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                _this.forwardArrowFlag = false;
                _this.backArrowFlag = false;
            }
        });
        // resets Arrow Flag
        this.resetYearFlag();
    };
    // this function is broken from resetArrowFlag()
    /**
     * @param {?} element
     * @param {?} min
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.alterBackArrow = /**
     * @param {?} element
     * @param {?} min
     * @return {?}
     */
    function (element, min) {
        if (element.year === min.getFullYear()) {
            this.backArrowFlag = true;
        }
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.resetArrowFlag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        this.yearList2.forEach(function (element) {
            _this.alterBackArrow(element, min);
            if (element.year === max.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.forwardArrowFlag = true;
            }
        });
    };
    // this fn is broken from  backArrow() and it resets Year Flag
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.resetYearFlag = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ i;
        if (!this.backArrowFlag) {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year - 10;
                this.yearList2[i].year = this.yearList2[i].year - 10;
                this.yearList1[i].disabled = false;
                this.yearList2[i].disabled = false;
            }
        } /* if ends */
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.alterBackForwardArrow = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        if (element.year === min.getFullYear()) {
            this.backArrowFlag = true;
        }
        if (element.year === max.getFullYear() ||
            (element.year === min.getFullYear() && element.year === max.getFullYear())) {
            this.forwardArrowFlag = true;
        }
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.forwardArrow = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ i;
        // chk yearlist1
        this.chkYearList1();
        this.yearList2.forEach(function (element) {
            _this.alterBackForwardArrow(element);
        });
        if (!this.forwardArrowFlag) {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year + 10;
                this.yearList2[i].year = this.yearList2[i].year + 10;
                this.yearList1[i].disabled = false;
                this.yearList2[i].disabled = false;
            } // for ends
        } // if ends
    };
    // chk yearlist1 broken from forwardArrow()
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.chkYearList1 = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        this.yearList1.forEach(function (element) {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.backArrowFlag = true;
            }
            if (element.year === min.getFullYear() && element.year !== max.getFullYear()) {
                _this.forwardArrowFlag = false;
                _this.backArrowFlag = true;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                _this.forwardArrowFlag = false;
                _this.backArrowFlag = false;
            }
            if (element.year === max.getFullYear()) {
                _this.forwardArrowFlag = true;
            }
        });
    };
    // this function is obtained by breaking arrowClickBack() and arrowClickForward()
    // for rechking arrow flags after reinitialization of yrlist1 & 2
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.rechkYearFlag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.yearList1.forEach(function (element) {
            var /** @type {?} */ min = new Date(_this.minDate);
            var /** @type {?} */ max = new Date(_this.maxDate);
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear()) {
                _this.forwardArrowFlag = true;
            }
            if (element.year !== min.getFullYear() && element.year !== max.getFullYear()) {
                _this.forwardArrowFlag = false;
                _this.backArrowFlag = false;
            }
        });
        this.yearList2.forEach(function (element) {
            _this.alterBackForwardArrow(element);
        });
    };
    // this function is broken from disableYearFlag() , here year flag disable altered to true
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.yearFlagDisable = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        if (element.year < min.getFullYear() || element.year > max.getFullYear()) {
            element.disabled = true;
        } // if ends
    };
    // this function is obtained by breaking arrowClickBack() and arrowClickForward()
    // for disabling year flag
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.disableYearFlag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.yearList1.forEach(function (element) {
                _this.yearFlagDisable(element);
            }); // for ends
            this.yearList2.forEach(function (element) {
                _this.yearFlagDisable(element);
            }); // for ends
        } // outer if ends
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.arrowClickForward = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ i;
        // disable flag logic
        this.disableYearFlag();
        if (this.minDate.length > 0 || this.maxDate.length > 0) {
            this.forwardArrow();
        }
        else {
            for (i = 0; i < 5; i++) {
                this.yearList1[i].year = this.yearList1[i].year + 10;
                this.yearList2[i].year = this.yearList2[i].year + 10;
            }
        }
        // disable flag logic
        this.disableYearFlag();
        // rechking arrow flags after reinitialization of yrlist1 & 2
        this.rechkYearFlag();
        event.stopPropagation();
    };
    // onInit Method: If min max date is provided
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.minMaxDateFound = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ min = new Date(this.minDate);
        var /** @type {?} */ max = new Date(this.maxDate);
        this.yearList1.forEach(function (element) {
            if (element.year === min.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear()) {
                _this.forwardArrowFlag = true;
            }
        });
        this.yearList2.forEach(function (element) {
            if (element.year === min.getFullYear()) {
                _this.backArrowFlag = true;
            }
            if (element.year === max.getFullYear() ||
                (element.year === min.getFullYear() && element.year === max.getFullYear())) {
                _this.forwardArrowFlag = true;
            }
        });
    };
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.checkValidity = /**
     * @return {?}
     */
    function () {
        return this.isValid;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return (this.value || !this.required) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.arrowright = /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    function (day, month, event) {
        var _this = this;
        var /** @type {?} */ currentindex;
        var /** @type {?} */ ismonthchanged = false;
        var /** @type {?} */ drindex;
        month.forEach(function (dayrow, dayrowindex) {
            dayrow.forEach(function (element, index) {
                if (day['id'] === element['id']) {
                    if (index < dayrow.length - 1) {
                        currentindex = index + 1;
                        drindex = dayrowindex;
                    }
                    else {
                        if ((dayrowindex === (month.length - 1)) && (index === (dayrow.length - 1))) {
                            _this.nextMonth(event);
                            ismonthchanged = true;
                        }
                        else {
                            currentindex = 0;
                            drindex = dayrowindex + 1;
                        }
                    }
                }
            });
        });
        this.refactoredRightArrow(ismonthchanged, month, drindex, currentindex);
    };
    /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.refactoredRightArrow = /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    function (ismonthchanged, month, drindex, currentindex) {
        if (!ismonthchanged) {
            this.refactoredFocus(month, drindex, currentindex);
        }
        else {
            this.setFocus();
        }
    };
    /**
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.refactoredFocus = /**
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    function (month, drindex, currentindex) {
        var /** @type {?} */ itemid;
        itemid = month[drindex][currentindex];
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.arrowleft = /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    function (day, month, event) {
        var _this = this;
        var /** @type {?} */ currentindex;
        var /** @type {?} */ drindex;
        var /** @type {?} */ ismonthchanged = false;
        month.forEach(function (dayrow, dayrowindex) {
            dayrow.forEach(function (element, index) {
                if (day['id'] === element['id']) {
                    if (index > 0) {
                        currentindex = index - 1;
                        drindex = dayrowindex;
                    }
                    else {
                        if (dayrowindex === 0 && index === 0) {
                            _this.prevMonth(event);
                            ismonthchanged = true;
                        }
                        else {
                            drindex = dayrowindex - 1;
                            currentindex = 6;
                        }
                    }
                }
            });
        });
        this.refactoredarrow(ismonthchanged, month, drindex, currentindex);
    };
    /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.refactoredarrow = /**
     * @param {?} ismonthchanged
     * @param {?} month
     * @param {?} drindex
     * @param {?} currentindex
     * @return {?}
     */
    function (ismonthchanged, month, drindex, currentindex) {
        var /** @type {?} */ itemid;
        if (!ismonthchanged) {
            itemid = month[drindex][currentindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            this.setFocus();
        }
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.arrowup = /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    function (day, month, event) {
        var _this = this;
        var /** @type {?} */ isfirstrow = false;
        var /** @type {?} */ drindex;
        var /** @type {?} */ currentindex;
        month.forEach(function (dayrow, dayrowindex) {
            dayrow.forEach(function (element, index) {
                if (day.id === element.id) {
                    if (dayrowindex === 0) {
                        isfirstrow = true;
                        _this.prevMonth(event);
                    }
                    else {
                        drindex = dayrowindex - 1;
                        currentindex = index;
                    }
                }
            });
        });
        if (!isfirstrow) {
            var /** @type {?} */ itemid = void 0;
            itemid = this.daysArray[drindex][currentindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            this.setFocus();
        }
    };
    /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.arrowdown = /**
     * @param {?} day
     * @param {?} month
     * @param {?} event
     * @return {?}
     */
    function (day, month, event) {
        var _this = this;
        var /** @type {?} */ islastrow = false;
        var /** @type {?} */ drindex;
        var /** @type {?} */ currentindex;
        month.forEach(function (dayrow, dayrowindex) {
            dayrow.forEach(function (element, index) {
                if (day.id === element.id) {
                    if (dayrowindex === (month.length - 1)) {
                        islastrow = true;
                        _this.nextMonth(event);
                    }
                    else {
                        drindex = dayrowindex + 1;
                        currentindex = index;
                    }
                }
            });
        });
        if (!islastrow) {
            var /** @type {?} */ itemid = void 0;
            itemid = this.daysArray[drindex][currentindex];
            document.getElementById(itemid['id']).focus();
        }
        else {
            this.setFocus();
        }
    };
    /**
     * @return {?}
     */
    AmexioMultipleDatePickerComponent.prototype.calculateScreenWidth = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ screenwidth = window.screen.width;
        this.count = (screenwidth / 290);
    };
    AmexioMultipleDatePickerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-multiple-date-picker',
                    template: "\n    <!--this div contains fieldlabel inputbox and icon -->\n    <div tabindex=\"{{inputtabindex}}\" (keyup.enter)=\"openPicker(rootDiv)\" aria-label=\"datetimepicker push button\" class=\"inputgroup\"\n        *ngIf=\"!inlineDatepicker\" #rootDiv>\n\n        <label>\n            {{fieldlabel}}\n        </label>\n        <!-- datepicker input -->\n        <ng-container *ngIf=\"datepicker && !timepicker\">\n            <input tabindex=\"-1\" type=\"text\" #pickerDt value=\"{{dateModel|date:dateformat}}\" [attr.disabled]=\"disabled ? true: null\"\n                [required]=\"required ? true: null\" (blur)=\"onBlur()\" (focusout)=\"onFocusOut(pickerDt)\" class=\"input-control\" [ngStyle]=\"{'cursor': readonly ? 'not-allowed':'pointer'}\"\n                [attr.placeholder]=\"placeholder\" />\n        </ng-container>\n\n        <div class=\"drodown-caret-down\" [ngStyle]=\"{'cursor':disabled ? 'not-allowed' : 'pointer'}\" (click)=\"openPicker(rootDiv)\">\n            <!-- datepicker icon -->\n            <ng-container *ngIf=\"!timepicker\">\n                <span>\n                    <amexio-c-icon key=\"datepicker_calendar\"></amexio-c-icon>\n                </span>\n\n            </ng-container>\n\n        </div>\n\n\n    </div>\n\n    <div [@changeState]=\"dropdownstyle.visibility\" [ngStyle]=\"dropdownstyle\">\n\n        <table>\n\n            <tr>\n                <td style=\"display: inline-flex; flex-flow: wrap\">\n\n                    <div tabindex=\"1\" aria-label=\"previous month list\" role=\"button\" style=\"padding: 125px 0px; cursor:pointer; opacity:0.7\"\n                        class=\"float-left\" (click)=\"updateMonthList('minus',$event)\" (keyup.enter)=\"updateMonthList('minus',$event)\">\n\n                        <amexio-floating-button [size]=\"'small'\" [relative]=\"true\" [icon]=\"'fa fa-angle-left'\" [type]=\"'theme-color'\">\n                        </amexio-floating-button>\n                    </div>\n\n                    <ng-container *ngFor=\"let itemdaysArray of  completeDaysArray; index as i\">\n\n                        <span [ngStyle]=\"{'padding-left': ((i+1) > count) ? '28px':'0px'}\">\n\n                            <span style=\"position: relative;\" [ngClass]=\"{'datetimepicker':!inlineDatepicker}\">\n                                <!-- datepicker starts -->\n                                <span aria-label=\"datepicker window opened \">\n                                    <!-- datepicker header starts and contains: 4 angles drop icon and title -->\n                                    <div aria-label=\"datetimepicker header\" class=\"datetimepickertopbar\" aria-label=\"datepicker header\" [ngStyle]=\"{'display': datepicker ? 'block' : 'none'}\">\n                                        <ul>\n\n                                            <li>\n\n                                                <span *ngIf=\"!dropdownDatepicker\">\n                                                    <!-- {{itemdaysArray.month}} -->\n                                                    {{itemdaysArray.date | date:'MMMM'}}\n\n                                                    <br>\n                                                    <span class=\"title\" style=\"cursor:auto\">\n                                                        {{itemdaysArray.date | date:'y'}}\n                                                        <!-- {{itemdaysArray.year}} -->\n                                                    </span>\n                                                </span>\n\n                                            </li>\n                                        </ul>\n                                    </div>\n\n\n                                    <div *ngIf=\"!drop\">\n                                        <ul class=\"weekdays\" [ngStyle]=\"{'display': datepicker ? 'block' : 'none'}\">\n                                            <li *ngFor=\"let dayTitle of daysTitle\">{{dayTitle.text}}</li>\n                                        </ul>\n\n                                        <ul id=\"{{daystabindex}}\" class=\"days\" [ngStyle]=\"{'display': datepicker ? 'block' : 'none'}\">\n\n                                            <ng-container *ngFor=\"let dayArray of itemdaysArray.montharray\">\n                                                <li [ngStyle]=\"{'cursor': day.isDisabled ? 'not-allowed' : 'pointer'}\" *ngFor=\"let day of dayArray\" (click)=\"onDateClick(day, $event)\"\n                                                    [ngClass]=\"{'date1':validateDays(day.date) , 'date1':day.isDisabled , 'notclickable':isDisabled}\">\n                                                    <span [attr.tabindex]=\"(day.selected ? 1: -1)\" id=\"{{day.id}}\" (keyup.arrowleft)=\"arrowleft(day,daysArray,$event)\" (keyup.arrowright)=\"arrowright(day,daysArray,$event)\"\n                                                        (keyup.arrowdown)=\"arrowdown(day,daysArray,$event)\" (keyup.arrowup)=\"arrowup(day,daysArray,$event)\"\n                                                        (keyup.enter)=\"onDateClick(day, $event)\" attr.aria-label=\"{{day.fulldate}}\"\n                                                        (click)=\"onDateClick(day, $event)\" class=\"day\" [ngClass]=\"{'active':day.selected, 'currentMonth':day.isCurrentMonth, 'notCurrentMonth':!day.isCurrentMonth,'invaliddays':validateDays(day.date), 'disabled':day.isDisabled}\">\n                                                        {{ day.date | date:'d' }}\n                                                    </span>\n                                                </li>\n                                            </ng-container>\n\n\n\n                                        </ul>\n                                    </div>\n                                </span>\n                                <!--datepicker ends  -->\n\n                            </span>\n\n                        </span>\n                        <!-- </ng-container> -->\n                    </ng-container>\n\n\n                    <div tabindex=\"1\" aria-label=\"next month list\" role=\"button\" style=\"padding: 125px 0px; cursor:pointer; opacity:0.7\" class=\"float-right\"\n                        (click)=\"updateMonthList('plus',$event)\" (keyup.enter)=\"updateMonthList('plus',$event)\">\n\n                        <amexio-floating-button [size]=\"'small'\" [relative]=\"true\" [icon]=\"'fa fa-angle-right'\" [type]=\"'theme-color'\">\n                        </amexio-floating-button>\n\n                    </div>\n                </td>\n            </tr>\n        </table>\n    </div>\n  ",
                    animations: [
                        trigger('changeState', [
                            state('visible', style({
                                transform: 'scale(1)',
                            })),
                            state('hidden', style({
                                transform: 'scale(0)',
                            })),
                            transition('*=>*', animate('200ms')),
                        ]),
                    ],
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioMultipleDatePickerComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioMultipleDatePickerComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioMultipleDatePickerComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.ChangeDetectorRef },
        { type: i0.Renderer2 }
    ]; };
    AmexioMultipleDatePickerComponent.propDecorators = {
        dateformat: [{ type: i0.Input, args: ['date-format',] }],
        datepicker: [{ type: i0.Input, args: ['date-picker',] }],
        timepicker: [{ type: i0.Input, args: ['time-picker',] }],
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        disabled: [{ type: i0.Input, args: ['disabled',] }],
        readonly: [{ type: i0.Input, args: ['read-only',] }],
        minDate: [{ type: i0.Input, args: ['min-date',] }],
        maxDate: [{ type: i0.Input, args: ['max-date',] }],
        diabledDate: [{ type: i0.Input, args: ['disabled-date',] }],
        inlineDatepicker: [{ type: i0.Input, args: ['inline-datepicker',] }],
        dropdownDatepicker: [{ type: i0.Input, args: ['dropdown-datepicker',] }],
        numberofmonths: [{ type: i0.Input, args: ['number-of-months',] }],
        required: [{ type: i0.Input }],
        change: [{ type: i0.Output }],
        input: [{ type: i0.Output }],
        isComponentValid: [{ type: i0.Output }]
    };
    return AmexioMultipleDatePickerComponent;
}(ListBaseDatepickerComponent));

var __extends$21 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioPasswordComponent = /** @class */ (function (_super) {
    __extends$21(AmexioPasswordComponent, _super);
    function AmexioPasswordComponent() {
        var _this = _super.call(this) || this;
        _this.isValid = false;
        /*
          Properties
          name : has-label
          datatype : boolean
          version : 4.0 onwards
          default : false
          description : flag to set label
          */
        _this.haslabel = true;
        /*
          Events
          name : onBlur
          datatype : any
          version : 4.0 onwards
          default :
          description : On blur event
          */
        _this.onBlur = new i0.EventEmitter();
        /*
        Events
        name : input
        datatype : any
        version : none
        default :
        description : 	On input event field.
        */
        _this.input = new i0.EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On focus event field.
        */
        _this.focus = new i0.EventEmitter();
        /*
        Events
        name : change
        datatype : any
        version : none
        default :
        description : On field value change event
        */
        _this.change = new i0.EventEmitter();
        _this.showToolTip = false;
        return _this;
    }
    Object.defineProperty(AmexioPasswordComponent.prototype, "pattern", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pattern;
        },
        /*
        Properties
        name : pattern
        datatype : string
        version : 4.0 onwards
        default :
        description : Apply Reg-ex to the field
        */
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value != null) {
                this.regEx = new RegExp(this.pattern);
            }
        },
        enumerable: true,
        configurable: true
    });
    // THIS METHOD USED FOR BLUR EVENT.
    /**
     * @return {?}
     */
    AmexioPasswordComponent.prototype.onblur = /**
     * @return {?}
     */
    function () {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    };
    // THIS METHOD USED FOR FOCUS EVENT .
    /**
     * @return {?}
     */
    AmexioPasswordComponent.prototype.onFocus = /**
     * @return {?}
     */
    function () {
        this.showToolTip = true;
        this.focus.emit(this.value);
    };
    // THIS METHOD USED FOR  INPUT EVENT .
    /**
     * @return {?}
     */
    AmexioPasswordComponent.prototype.onInput = /**
     * @return {?}
     */
    function () {
        this.isValid = this.isFieldValid();
        this.input.emit(this.value);
    };
    // THIS METHOD USED FOR CHANGE EVENT  .
    /**
     * @return {?}
     */
    AmexioPasswordComponent.prototype.onChangeEv = /**
     * @return {?}
     */
    function () {
        this.change.emit(this.value);
    };
    /**
     * @return {?}
     */
    AmexioPasswordComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.createCompId('passwordinput', this.name);
        this.isValid = this.isFieldValid();
        this.name = this.generateName(this.name, this.fieldlabel, 'passwordinput');
    };
    // THIS METHOD IS USED FOR VALIDATION
    /**
     * @return {?}
     */
    AmexioPasswordComponent.prototype.isFieldValid = /**
     * @return {?}
     */
    function () {
        return (!this.allowblank && (this.value && ((this.value.length >= this.minlength) && this.value.length > 0)) ||
            (!this.minlength && this.value && this.value.length > 0)) || this.allowblank;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioPasswordComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    AmexioPasswordComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-password-input',
                    template: "\n\n\n\n    <div class=\"inputgroup\">\n\n      <label *ngIf=\"haslabel\"  role=\"password\" id=\"{{componentId}}\"  for=\"{{componentId}}\"  [style.font-style]=\"fontstyle\" [style.font-family]=\"fontfamily\" [style.font-size]=\"fontsize\">\n          {{fieldlabel}}\n      </label>\n\n      <input type=\"password\" \n\n            role=\"password\" \n            tabindex=\"1\"\n            id=\"{{componentId}}\" \n            name=\"passwordText\"\n            attr.aria-labelledby=\"{{componentId}}\"\n            aria-describedby=\"passwordDec\"\n            [attr.aria-required]=\"!allowblank\"\n            [attr.aria-invalid]=\"!isValid \"\n\n        \n             class=\"input-control\"\n             [ngClass]=\"model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''\"\n             [(ngModel)]=\"value\"\n             (blur)=\"onblur()\" \n             (focus)=\"onFocus()\" \n             (input)=\"onInput()\" \n             (change)=\"onChangeEv()\"\n             [name]=\"name\" \n             [pattern]=\"regEx\"\n             [attr.placeholder]=\"placeholder\" \n             [maxlength]=\"maxlength\" \n             [minlength]=\"minlength\"\n             [attr.disabled]=\"disabled ? true: null\"\n             [required]=\"!allowblank\" />\n\n\n      <ng-container *ngIf=\"iconfeedback\">\n          <span class=\"input-control-feedback\">\n              <span *ngIf=\"!isValid && model.touched\"><em class=\"fa fa-times\"></em></span>\n              <span *ngIf=\"isValid && model.touched\"><em class=\"fa fa-check\"></em></span>\n          </span>\n      </ng-container>\n\n      <input-help *ngIf=\"showToolTip && enablepopover\" \n\n      id = \"passwordDec\"\n      role=\"tooltip\"\n\n      [error-msg]=\"errormsg\" \n      [max-error-msg]=\"maxerrormsg\"\n      [min-error-msg]=\"minerrormsg\"\n      [min-length]=\"minlength\"\n      [max-length]=\"maxlength\"\n      [min-msg]=\"minmsg\" \n      [max-msg]=\"maxmsg\"\n      >\n      </input-help>\n\n      <span class=\"inputfieldbar\"></span>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioPasswordComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioPasswordComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioPasswordComponent.ctorParameters = function () { return []; };
    AmexioPasswordComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        minlength: [{ type: i0.Input, args: ['min-length',] }],
        maxlength: [{ type: i0.Input, args: ['max-length',] }],
        allowblank: [{ type: i0.Input, args: ['allow-blank',] }],
        minerrormsg: [{ type: i0.Input, args: ['min-error-msg',] }],
        maxerrormsg: [{ type: i0.Input, args: ['max-error-msg',] }],
        errormsg: [{ type: i0.Input, args: ['error-msg',] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        disabled: [{ type: i0.Input }],
        iconfeedback: [{ type: i0.Input, args: ['icon-feedback',] }],
        fontstyle: [{ type: i0.Input, args: ['font-style',] }],
        fontfamily: [{ type: i0.Input, args: ['font-family',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        haslabel: [{ type: i0.Input, args: ['has-label',] }],
        pattern: [{ type: i0.Input, args: ['pattern',] }],
        enablepopover: [{ type: i0.Input, args: ['enable-popover',] }],
        onBlur: [{ type: i0.Output }],
        input: [{ type: i0.Output }],
        focus: [{ type: i0.Output }],
        change: [{ type: i0.Output }],
        model: [{ type: i0.ViewChild, args: [forms.NgModel,] }],
        name: [{ type: i0.Input, args: ['name',] }]
    };
    return AmexioPasswordComponent;
}(ValueAccessorBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioRangeSliderComponent = /** @class */ (function () {
    function AmexioRangeSliderComponent(el, renderer, ngZone, cd) {
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.cd = cd;
        this.handleValues = [];
        this.dragData = false;
        this.sliderHandleClick = false;
        this.handleIndex = 0;
        this.animate = false;
        this.disabled = false;
        this.min = 0;
        this.orientation = 'horizontal';
        this.range = false;
        this.fullRange = false;
        this.onChange = new i0.EventEmitter();
        this.onSlideEnd = new i0.EventEmitter();
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
    }
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.writeValue([0, this.maxRange]);
    };
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.onMouseMove = /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    function (event, index) {
        if (this.disabled) {
            return;
        }
        this.dragData = true;
        this.updateDomData();
        this.sliderHandleClick = true;
        this.handleIndex = index;
        this.bindDragListeners();
        event.preventDefault();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.onSlideBarClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.disabled) {
            return;
        }
        if (!this.sliderHandleClick) {
            this.updateDomData();
            this.handleChange(event);
        }
        this.sliderHandleClick = false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.handleChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ handleValue = this.calculateHandleValue(event);
        this.setValueFromHandle(event, handleValue);
    };
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.bindDragListeners = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            if (!_this.dragListener) {
                _this.dragListener = _this.renderer.listen('document', 'mousemove', function (event) {
                    if (_this.dragData) {
                        _this.ngZone.run(function () {
                            _this.handleChange(event);
                        });
                    }
                });
            }
            if (!_this.mouseupListener) {
                _this.checkMouseUpListener();
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.checkMouseUpListener = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.mouseupListener = this.renderer.listen('document', 'mouseup', function (event) {
            if (_this.dragData) {
                _this.dragData = false;
                _this.ngZone.run(function () {
                    if (_this.range) {
                        _this.onSlideEnd.emit({ originalEvent: event, values: _this.values });
                    }
                    else {
                        _this.onSlideEnd.emit({ originalEvent: event, value: _this.value });
                    }
                });
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.unbindDragListeners = /**
     * @return {?}
     */
    function () {
        if (this.dragListener) {
            this.dragListener();
        }
        if (this.mouseupListener) {
            this.mouseupListener();
        }
    };
    /**
     * @param {?} event
     * @param {?} handleValue
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.setValueFromHandle = /**
     * @param {?} event
     * @param {?} handleValue
     * @return {?}
     */
    function (event, handleValue) {
        var /** @type {?} */ newValue = this.getValueFromHandle(handleValue);
        if (this.range) {
            if (this.step) {
                this.handleStepChange(newValue, this.values[this.handleIndex]);
            }
            else {
                this.handleValues[this.handleIndex] = handleValue;
                this.updateValue(newValue, event);
            }
        }
        else {
            if (this.step) {
                this.handleStepChange(newValue, this.value);
            }
            else {
                this.handleValue = handleValue;
                this.updateValue(newValue, event);
            }
        }
    };
    /**
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.handleStepChange = /**
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    function (newValue, oldValue) {
        var /** @type {?} */ diff = (newValue - oldValue);
        var /** @type {?} */ val = oldValue;
        if (diff < 0) {
            val = oldValue + Math.ceil(newValue / this.step - oldValue / this.step) * this.step;
        }
        else if (diff > 0) {
            val = oldValue + Math.floor(newValue / this.step - oldValue / this.step) * this.step;
        }
        this.updateValue(val);
        this.updateHandleValue();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        this.handleValues = [0, this.maxRange];
        if (this.range) {
            this.values = value || [0, this.maxRange];
        }
        else {
            this.value = value || 0;
        }
        this.updateHandleValue();
        this.cd.markForCheck();
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onModelChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onModelTouched = fn;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.setDisabledState = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.disabled = val;
    };
    Object.defineProperty(AmexioRangeSliderComponent.prototype, "rangeStartLeft", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.isVertical() ? 'auto' : this.handleValues[0] + '%');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioRangeSliderComponent.prototype, "rangeStartBottom", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVertical() ? this.handleValues[0] + '%' : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioRangeSliderComponent.prototype, "rangeEndLeft", {
        get: /**
         * @return {?}
         */
        function () {
            return (this.isVertical() ? 'auto' : this.handleValues[1] + '%');
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioRangeSliderComponent.prototype, "rangeEndBottom", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVertical() ? this.handleValues[1] + '%' : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.isVertical = /**
     * @return {?}
     */
    function () {
        return this.orientation === 'vertical';
    };
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.updateDomData = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ rect = this.el.nativeElement.children[0].getBoundingClientRect();
        this.initX = rect.left + this.getWindowScrollLeft();
        this.initY = rect.top + this.getWindowScrollTop();
        this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        this.barHeight = this.el.nativeElement.children[0].offsetHeight;
    };
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.getWindowScrollTop = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ doc = document.documentElement;
        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    };
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.getWindowScrollLeft = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ doc = document.documentElement;
        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.calculateHandleValue = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.orientation === 'horizontal') {
            return ((event.pageX - this.initX) * 100) / (this.barWidth);
        }
        else {
            return (((this.initY + this.barHeight) - event.pageY) * 100) / (this.barHeight);
        }
    };
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.updateHandleValue = /**
     * @return {?}
     */
    function () {
        this.max = this.maxRange;
        if (this.range) {
            this.handleValues[0] = (this.values[0] < this.min ? 0 : this.values[0] - this.min) * 100 / (this.max - this.min);
            this.handleValues[1] = (this.values[1] > this.max ? this.maxRange : this.values[1] - this.min) * 100 / (this.max - this.min);
        }
        else {
            if (this.value < this.min) {
                this.handleValue = 0;
            }
            else if (this.value > this.max) {
                this.handleValue = this.maxRange;
            }
            else {
                this.handleValue = (this.value - this.min) * this.maxRange / (this.max - this.min);
            }
        }
    };
    /**
     * @param {?} val
     * @param {?=} event
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.updateValue = /**
     * @param {?} val
     * @param {?=} event
     * @return {?}
     */
    function (val, event) {
        if (this.range) {
            this.updateValueMethodDivided(val, event);
        }
        else {
            if (val < this.min) {
                val = this.min;
                this.handleValue = 0;
            }
            else if (val > this.max) {
                val = this.max;
                this.handleValue = 100;
            }
            this.value = this.getNormalizedValue(val);
            this.onChange.emit({ event1: event, value2: this.value });
        }
        this.onModelChange(this.values);
    };
    /**
     * @param {?} val
     * @param {?=} event
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.updateValueMethodDivided = /**
     * @param {?} val
     * @param {?=} event
     * @return {?}
     */
    function (val, event) {
        var /** @type {?} */ value = val;
        if (this.handleIndex === 0) {
            if (value < this.min) {
                value = this.min;
                this.handleValues[0] = 0;
            }
            else if (value > this.values[1]) {
                value = this.values[1];
                this.handleValues[0] = this.handleValues[1];
            }
        }
        else {
            if (value > this.max) {
                value = this.max;
                this.handleValues[1] = 100;
            }
            else if (value < this.values[0]) {
                value = this.values[0];
                this.handleValues[1] = this.handleValues[0];
            }
        }
        this.values[this.handleIndex] = this.getNormalizedValue(value);
        this.onChange.emit({ event1: event, values2: this.values });
    };
    /**
     * @param {?} handleValue
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.getValueFromHandle = /**
     * @param {?} handleValue
     * @return {?}
     */
    function (handleValue) {
        return (this.max - this.min) * (handleValue / 100) + this.min;
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.getDecimalsCount = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value && Math.floor(value) !== value) {
            return value.toString().split('.')[1].length || 0;
        }
    };
    /**
     * @param {?} val
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.getNormalizedValue = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        var /** @type {?} */ decimalsCount = this.getDecimalsCount(this.step);
        if (decimalsCount > 0) {
            return +val.toFixed(decimalsCount);
        }
        else {
            return Math.floor(val);
        }
    };
    /**
     * @return {?}
     */
    AmexioRangeSliderComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.unbindDragListeners();
    };
    AmexioRangeSliderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-value-range',
                    template: "\n    <div [ngStyle]=\"style\" [class]=\"styleClass\" [ngClass]=\"{'amexio-slider amexio-slider-widget amexio-slider-widget-content ui-corner-all':true,\n    'ui-state-disabled':disabled,\n    'amexio-slider-horizontal':orientation == 'horizontal',\n    'amexio-slider-vertical':orientation == 'vertical',\n    'amexio-slider-animate':animate}\"\n        (click)=\"onSlideBarClick($event)\">\n\n        <span *ngIf=\" range && orientation == 'horizontal'\" class=\"amexio-slider-range amexio-slider-widget-header ui-corner-all\"\n            [ngStyle]=\"{'left':handleValues[0] + '%',width: (handleValues[1] - handleValues[0] + '%')}\">\n        </span>\n\n        <span *ngIf=\"range && orientation == 'vertical'\" class=\"amexio-slider-range amexio-slider-widget-header ui-corner-all\"\n            [ngStyle]=\"{'bottom':handleValues[0] + '%',height: (handleValues[1] - handleValues[0] + '%')}\">\n        </span>\n\n\n\n\n        <span *ngIf=\"range\" (mousedown)=\"onMouseMove($event,0)\" [style.transition]=\"dragData ? 'none': null\" class=\"amexio-slider-handle ui-state-default ui-corner-all ui-clickable \"\n            [ngStyle]=\"{'left': rangeStartLeft, 'bottom': rangeStartBottom}\" [ngClass]=\"{'amexio-slider-handle-active':handleIndex==0,\n        'rectangle-css' :type == 'rectangle',\n        'circle-css' :type == 'circle',\n        'square-css' :type == 'square'}\">\n            {{values[0]}}\n        </span>\n\n\n        <span *ngIf=\"range\" (mousedown)=\"onMouseMove($event,1)\" [style.transition]=\"dragData ? 'none': null\" class=\"amexio-slider-handle ui-state-default ui-corner-all ui-clickable\"\n            [ngStyle]=\"{'left': rangeEndLeft, 'bottom': rangeEndBottom}\" [ngClass]=\"{'amexio-slider-handle-active':handleIndex==1, \n        'rectangle-css' :type == 'rectangle',\n        'circle-css' :type == 'circle',\n        'square-css' :type == 'square'}\">\n\n\n            <span style=\"margin-bottom: 30px;\">\n                {{values[1]}}\n            </span>\n\n        </span>\n    </div>\n  ",
                    providers: [
                        { provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioRangeSliderComponent; }), multi: true },
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioRangeSliderComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: i0.NgZone },
        { type: i0.ChangeDetectorRef }
    ]; };
    AmexioRangeSliderComponent.propDecorators = {
        animate: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        min: [{ type: i0.Input, args: ['min',] }],
        max: [{ type: i0.Input, args: ['max',] }],
        orientation: [{ type: i0.Input, args: ['orientation',] }],
        step: [{ type: i0.Input, args: ['step-value',] }],
        range: [{ type: i0.Input }],
        maxRange: [{ type: i0.Input, args: ['max-range',] }],
        style: [{ type: i0.Input }],
        type: [{ type: i0.Input, args: ['type',] }],
        styleClass: [{ type: i0.Input }],
        onChange: [{ type: i0.Output }],
        onSlideEnd: [{ type: i0.Output }]
    };
    return AmexioRangeSliderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LoadRecaptchaService = /** @class */ (function () {
    function LoadRecaptchaService() {
    }
    /**
     * @return {?}
     */
    LoadRecaptchaService.prototype.loadScript = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ script = document.createElement('script');
        script.innerHTML = '';
        script.src = 'https://www.google.com/recaptcha/api.js?render=explicit';
        script.async = true;
        script.defer = true;
        return script;
    };
    LoadRecaptchaService.decorators = [
        { type: i0.Injectable },
    ];
    /** @nocollapse */
    LoadRecaptchaService.ctorParameters = function () { return []; };
    return LoadRecaptchaService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by dattaram on 12/9/18.
*/
var RecaptchaComponent = /** @class */ (function () {
    function RecaptchaComponent(_loadRecaptchaService) {
        this._loadRecaptchaService = _loadRecaptchaService;
        this.onSuccess = new i0.EventEmitter();
        this.onFailure = new i0.EventEmitter();
        this.responseStructure = {};
    }
    /**
     * @return {?}
     */
    RecaptchaComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.componentId =
            +Math.floor(Math.random() * 90000) + 10000 + 'google';
        var /** @type {?} */ script = this._loadRecaptchaService.loadScript();
        var /** @type {?} */ body = /** @type {?} */ (document.body);
        script.onload = function () {
            grecaptcha.ready(function () {
                _this.rendercaptcha();
            });
        };
        body.appendChild(script);
    };
    /**
     * @return {?}
     */
    RecaptchaComponent.prototype.rendercaptcha = /**
     * @return {?}
     */
    function () {
        var _this = this;
        grecaptcha.render(this.componentId, {
            sitekey: this.sitekey, callback: function (response) {
                if (response && response.length > 0) {
                    _this.responseStructure['success'] = true;
                    _this.responseStructure['response'] = response;
                    _this.onSuccess.emit(_this.responseStructure);
                }
                else {
                    _this.responseStructure['success'] = false;
                    _this.responseStructure['response'] = '';
                    _this.onFailure.emit(_this.responseStructure);
                }
            },
        });
    };
    RecaptchaComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-google-recaptcha',
                    template: "\n    <div class=\"g-recaptcha\" [attr.id]=\"componentId\">\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    RecaptchaComponent.ctorParameters = function () { return [
        { type: LoadRecaptchaService }
    ]; };
    RecaptchaComponent.propDecorators = {
        sitekey: [{ type: i0.Input, args: ['site-key',] }],
        onSuccess: [{ type: i0.Output }],
        onFailure: [{ type: i0.Output }]
    };
    return RecaptchaComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 29/1/18.
*/
var DomHandler = /** @class */ (function () {
    function DomHandler() {
        this.calculatedScrollbarWidth = null;
    }
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    DomHandler.prototype.addClass = /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    function (element, className) {
        if (element.classList) {
            element.classList.add(className);
        }
        else {
            element.className += ' ' + className;
        }
    };
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    DomHandler.prototype.addMultipleClasses = /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    function (element, className) {
        if (element.classList) {
            var /** @type {?} */ styles = className.split(' ');
            for (var _i = 0, styles_1 = styles; _i < styles_1.length; _i++) {
                var i = styles_1[_i];
                element.classList.add([i]);
            }
        }
        else {
            var /** @type {?} */ styles = className.split(' ');
            for (var _a = 0, styles_2 = styles; _a < styles_2.length; _a++) {
                var i = styles_2[_a];
                element.className += ' ' + [i];
            }
        }
    };
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    DomHandler.prototype.removeClass = /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    function (element, className) {
        if (element.classList) {
            element.classList.remove(className);
        }
        else {
            element.className = element.className.replace(new RegExp('(^|\\b)' + className.split(' ').join('|') + '(\\b|$)', 'gi'), ' ');
        }
    };
    /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    DomHandler.prototype.hasClass = /**
     * @param {?} element
     * @param {?} className
     * @return {?}
     */
    function (element, className) {
        if (element.classList) {
            return element.classList.contains(className);
        }
        else {
            return new RegExp('(^| )' + className + '( |$)', 'gi').test(element.className);
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomHandler.prototype.siblings = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        return Array.prototype.filter.call(element.parentNode.children, function (child) {
            return child !== element;
        });
    };
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    DomHandler.prototype.find = /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    function (element, selector) {
        return element.querySelectorAll(selector);
    };
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    DomHandler.prototype.findSingle = /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    function (element, selector) {
        return element.querySelector(selector);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomHandler.prototype.index = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ children = element.parentNode.childNodes;
        var /** @type {?} */ num = 0;
        for (var _i = 0, children_1 = children; _i < children_1.length; _i++) {
            var i = children_1[_i];
            if (i === element) {
                return num;
            }
            if (i.nodeType === 1) {
                num++;
            }
        }
        return -1;
    };
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    DomHandler.prototype.relativePosition = /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    function (element, target) {
        var /** @type {?} */ elementDimensions = (element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight } :
            this.getHiddenElementDimensions(element));
        var /** @type {?} */ targetHeight = target.offsetHeight;
        var /** @type {?} */ targetWidth = target.offsetWidth;
        var /** @type {?} */ targetOffset = target.getBoundingClientRect();
        var /** @type {?} */ viewport = this.getViewport();
        var /** @type {?} */ top;
        var /** @type {?} */ left;
        if ((targetOffset.top + targetHeight + elementDimensions.height) > viewport.height) {
            top = -1 * (elementDimensions.height);
            if (targetOffset.top + top < 0) {
                top = 0;
            }
        }
        else {
            top = targetHeight;
        }
        if ((targetOffset.left + elementDimensions.width) > viewport.width) {
            left = targetWidth - elementDimensions.width;
        }
        else {
            left = 0;
        }
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    };
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    DomHandler.prototype.absolutePosition = /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    function (element, target) {
        var /** @type {?} */ elementDimensions = (element.offsetParent ? { width: element.offsetWidth, height: element.offsetHeight }
            : this.getHiddenElementDimensions(element));
        var /** @type {?} */ elementOuterHeight = elementDimensions.height;
        var /** @type {?} */ elementOuterWidth = elementDimensions.width;
        var /** @type {?} */ targetOuterHeight = target.offsetHeight;
        var /** @type {?} */ targetOuterWidth = target.offsetWidth;
        var /** @type {?} */ targetOffset = target.getBoundingClientRect();
        var /** @type {?} */ windowScrollTop = this.getWindowScrollTop();
        var /** @type {?} */ windowScrollLeft = this.getWindowScrollLeft();
        var /** @type {?} */ viewport = this.getViewport();
        var /** @type {?} */ top;
        var /** @type {?} */ left;
        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
            top = targetOffset.top + windowScrollTop - elementOuterHeight;
            if (top < 0) {
                top = 0 + windowScrollTop;
            }
        }
        else {
            top = targetOuterHeight + targetOffset.top + windowScrollTop;
        }
        if (targetOffset.left + targetOuterWidth + elementOuterWidth > viewport.width) {
            left = targetOffset.left + windowScrollLeft + targetOuterWidth - elementOuterWidth;
        }
        else {
            left = targetOffset.left + windowScrollLeft;
        }
        element.style.top = top + 'px';
        element.style.left = left + 'px';
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomHandler.prototype.getHiddenElementOuterHeight = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var /** @type {?} */ elementHeight = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementHeight;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomHandler.prototype.getHiddenElementOuterWidth = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        var /** @type {?} */ elementWidth = element.offsetWidth;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return elementWidth;
    };
    /**
     * @param {?} element
     * @return {?}
     */
    DomHandler.prototype.getHiddenElementDimensions = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        var /** @type {?} */ dimensions = {};
        element.style.visibility = 'hidden';
        element.style.display = 'block';
        dimensions.width = element.offsetWidth;
        dimensions.height = element.offsetHeight;
        element.style.display = 'none';
        element.style.visibility = 'visible';
        return dimensions;
    };
    /**
     * @param {?} container
     * @param {?} item
     * @return {?}
     */
    DomHandler.prototype.scrollInView = /**
     * @param {?} container
     * @param {?} item
     * @return {?}
     */
    function (container, item) {
        var /** @type {?} */ borderTopValue = getComputedStyle(container).getPropertyValue('borderTopWidth');
        var /** @type {?} */ borderTop = borderTopValue ? parseFloat(borderTopValue) : 0;
        var /** @type {?} */ paddingTopValue = getComputedStyle(container).getPropertyValue('paddingTop');
        var /** @type {?} */ paddingTop = paddingTopValue ? parseFloat(paddingTopValue) : 0;
        var /** @type {?} */ containerRect = container.getBoundingClientRect();
        var /** @type {?} */ itemRect = item.getBoundingClientRect();
        var /** @type {?} */ offset = (itemRect.top + document.body.scrollTop) - (containerRect.top + document.body.scrollTop) - borderTop - paddingTop;
        var /** @type {?} */ scroll = container.scrollTop;
        var /** @type {?} */ elementHeight = container.clientHeight;
        var /** @type {?} */ itemHeight = this.getOuterHeight(item);
        if (offset < 0) {
            container.scrollTop = scroll + offset;
        }
        else if ((offset + itemHeight) > elementHeight) {
            container.scrollTop = scroll + offset - elementHeight + itemHeight;
        }
    };
    /**
     * @param {?} element
     * @param {?} duration
     * @return {?}
     */
    DomHandler.prototype.fadeIn = /**
     * @param {?} element
     * @param {?} duration
     * @return {?}
     */
    function (element, duration) {
        element.style.opacity = 0;
        var /** @type {?} */ last = +new Date();
        var /** @type {?} */ opacity = 0;
        var /** @type {?} */ tick = function () {
            opacity = +element.style.opacity.replace(',', '.') + (new Date().getTime() - last) / duration;
            element.style.opacity = opacity;
            last = +new Date();
        };
        tick();
    };
    /**
     * @param {?} element
     * @param {?} ms
     * @return {?}
     */
    DomHandler.prototype.fadeOut = /**
     * @param {?} element
     * @param {?} ms
     * @return {?}
     */
    function (element, ms) {
        var /** @type {?} */ opacity = 1;
        var /** @type {?} */ interval = 50;
        var /** @type {?} */ duration = ms;
        var /** @type {?} */ gap = interval / duration;
        var /** @type {?} */ fading = setInterval(function () {
            opacity = opacity - gap;
            if (opacity <= 0) {
                opacity = 0;
                clearInterval(fading);
            }
            element.style.opacity = opacity;
        }, interval);
    };
    /**
     * @return {?}
     */
    DomHandler.prototype.getWindowScrollTop = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ doc = document.documentElement;
        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    };
    /**
     * @return {?}
     */
    DomHandler.prototype.getWindowScrollLeft = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ doc = document.documentElement;
        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    };
    /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    DomHandler.prototype.matches = /**
     * @param {?} element
     * @param {?} selector
     * @return {?}
     */
    function (element, selector) {
        var /** @type {?} */ p = Element.prototype;
        var /** @type {?} */ f = p['matches'] || p.webkitMatchesSelector || p['mozMatchesSelector'] || p.msMatchesSelector || function (s) {
            return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
        };
        return f.call(element, selector);
    };
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    DomHandler.prototype.getOuterWidth = /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    function (el, margin) {
        var /** @type {?} */ width = el.offsetWidth;
        if (margin) {
            var /** @type {?} */ style = getComputedStyle(el);
            width += parseFloat(style.marginLeft) + parseFloat(style.marginRight);
        }
        return width;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DomHandler.prototype.getHorizontalPadding = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        var /** @type {?} */ style = getComputedStyle(el);
        return parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DomHandler.prototype.getHorizontalMargin = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        var /** @type {?} */ style = getComputedStyle(el);
        return parseFloat(style.marginLeft) + parseFloat(style.marginRight);
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DomHandler.prototype.innerWidth = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        var /** @type {?} */ width = el.offsetWidth;
        var /** @type {?} */ style = getComputedStyle(el);
        width += parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DomHandler.prototype.width = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        var /** @type {?} */ width = el.offsetWidth;
        var /** @type {?} */ style = getComputedStyle(el);
        width -= parseFloat(style.paddingLeft) + parseFloat(style.paddingRight);
        return width;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DomHandler.prototype.getInnerHeight = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        var /** @type {?} */ height = el.offsetHeight;
        var /** @type {?} */ style = getComputedStyle(el);
        height += parseFloat(style.paddingTop) + parseFloat(style.paddingBottom);
        return height;
    };
    /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    DomHandler.prototype.getOuterHeight = /**
     * @param {?} el
     * @param {?=} margin
     * @return {?}
     */
    function (el, margin) {
        var /** @type {?} */ height = el.offsetHeight;
        if (margin) {
            var /** @type {?} */ style = getComputedStyle(el);
            height += parseFloat(style.marginTop) + parseFloat(style.marginBottom);
        }
        return height;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DomHandler.prototype.getHeight = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        var /** @type {?} */ height = el.offsetHeight;
        var /** @type {?} */ style = getComputedStyle(el);
        height -= (parseFloat(style.paddingTop) + parseFloat(style.paddingBottom)
            + parseFloat(style.borderTopWidth) + parseFloat(style.borderBottomWidth));
        return height;
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DomHandler.prototype.getWidth = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        var /** @type {?} */ width = el.offsetWidth;
        var /** @type {?} */ style = getComputedStyle(el);
        width -= (parseFloat(style.paddingLeft) + parseFloat(style.paddingRight) +
            parseFloat(style.borderLeftWidth) + parseFloat(style.borderRightWidth));
        return width;
    };
    /**
     * @return {?}
     */
    DomHandler.prototype.getViewport = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ win = window;
        var /** @type {?} */ d = document;
        var /** @type {?} */ e = d.documentElement;
        var /** @type {?} */ g = d.getElementsByTagName('body')[0];
        var /** @type {?} */ w = win.innerWidth || e.clientWidth || g.clientWidth;
        var /** @type {?} */ h = win.innerHeight || e.clientHeight || g.clientHeight;
        return { width: w, height: h };
    };
    /**
     * @param {?} el
     * @return {?}
     */
    DomHandler.prototype.getOffset = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        var /** @type {?} */ rect = el.getBoundingClientRect();
        return {
            top: rect.top + document.body.scrollTop,
            left: rect.left + document.body.scrollLeft,
        };
    };
    /**
     * @return {?}
     */
    DomHandler.prototype.getUserAgent = /**
     * @return {?}
     */
    function () {
        return navigator.userAgent;
    };
    /**
     * @return {?}
     */
    DomHandler.prototype.isIE = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ ua = window.navigator.userAgent;
        var /** @type {?} */ msie = ua.indexOf('MSIE ');
        if (msie > 0) {
            // IE 10 or older => return version number
            return true;
        }
        var /** @type {?} */ trident = ua.indexOf('Trident/');
        if (trident > 0) {
            // IE 11 => return version number
            return true;
        }
        var /** @type {?} */ edge = ua.indexOf('Edge/');
        if (edge > 0) {
            // Edge (IE 12+) => return version number
            return true;
        }
        // other browser
        return false;
    };
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    DomHandler.prototype.appendChild = /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    function (element, target) {
        if (this.isElement(target)) {
            target.appendChild(element);
        }
        else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.appendChild(element);
        }
        else {
            throw new Error('Cannot append ' + target + ' to ' + element);
        }
    };
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    DomHandler.prototype.removeChild = /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    function (element, target) {
        if (this.isElement(target)) {
            target.removeChild(element);
        }
        else if (target.el && target.el.nativeElement) {
            target.el.nativeElement.removeChild(element);
        }
        else {
            throw new Error('Cannot remove ' + element + ' from ' + target);
        }
    };
    /**
     * @param {?} obj
     * @return {?}
     */
    DomHandler.prototype.isElement = /**
     * @param {?} obj
     * @return {?}
     */
    function (obj) {
        return (typeof HTMLElement === 'object' ? obj instanceof HTMLElement :
            obj && typeof obj === 'object' && obj !== null && obj.nodeType === 1 && typeof obj.nodeName === 'string');
    };
    /**
     * @return {?}
     */
    DomHandler.prototype.calculateScrollbarWidth = /**
     * @return {?}
     */
    function () {
        if (this.calculatedScrollbarWidth !== null) {
            return this.calculatedScrollbarWidth;
        }
        var /** @type {?} */ scrollDiv = document.createElement('div');
        scrollDiv.className = 'ui-scrollbar-measure';
        document.body.appendChild(scrollDiv);
        var /** @type {?} */ scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        document.body.removeChild(scrollDiv);
        this.calculatedScrollbarWidth = scrollbarWidth;
        return scrollbarWidth;
    };
    /**
     * @param {?} element
     * @param {?} methodName
     * @param {?=} args
     * @return {?}
     */
    DomHandler.prototype.invokeElementMethod = /**
     * @param {?} element
     * @param {?} methodName
     * @param {?=} args
     * @return {?}
     */
    function (element, methodName, args) {
        (element)[methodName].apply(element, args);
    };
    /**
     * @return {?}
     */
    DomHandler.prototype.clearSelection = /**
     * @return {?}
     */
    function () {
        if (window.getSelection) {
            if (window.getSelection().empty) {
                window.getSelection().empty();
            }
            else if (window.getSelection().removeAllRanges &&
                window.getSelection().rangeCount > 0 &&
                window.getSelection().getRangeAt(0).getClientRects().length > 0) {
                window.getSelection().removeAllRanges();
            }
        }
        else if (document['selection'] && document['selection'].empty) {
            try {
                document['selection'].empty();
            }
            catch (/** @type {?} */ error) {
                // ignore IE bug
            }
        }
    };
    /**
     * @return {?}
     */
    DomHandler.prototype.getBrowser = /**
     * @return {?}
     */
    function () {
        if (!this.browser) {
            var /** @type {?} */ matched = this.resolveUserAgent();
            this.browser = {};
            if (matched.browser) {
                this.browser[matched.browser] = true;
                this.browser['version'] = matched.version;
            }
            if (this.browser['chrome']) {
                this.browser['webkit'] = true;
            }
            else if (this.browser['webkit']) {
                this.browser['safari'] = true;
            }
        }
        return this.browser;
    };
    /**
     * @return {?}
     */
    DomHandler.prototype.resolveUserAgent = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ ua = navigator.userAgent.toLowerCase();
        var /** @type {?} */ match = /(chrome)[ \/]([\w.]+)/.exec(ua) ||
            /(webkit)[ \/]([\w.]+)/.exec(ua) ||
            /(opera)(?:.*version|)[ \/]([\w.]+)/.exec(ua) ||
            /(msie) ([\w.]+)/.exec(ua) ||
            ua.indexOf('compatible') < 0 && /(mozilla)(?:.*? rv:([\w.]+)|)/.exec(ua) ||
            [];
        return {
            browser: match[1] || '',
            version: match[2] || '0',
        };
    };
    DomHandler.zindex = 1000;
    DomHandler.decorators = [
        { type: i0.Injectable },
    ];
    return DomHandler;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 29/1/18.
*/
var AmexioSliderComponent = /** @class */ (function () {
    function AmexioSliderComponent(el, domHandler, renderer, ngZone) {
        this.el = el;
        this.domHandler = domHandler;
        this.renderer = renderer;
        this.ngZone = ngZone;
        /*
        Properties
        name : min-value
        datatype : number
        version : 4.0 onwards
        default :
        description : Min slider value
        */
        this.min = 0;
        /*
        Properties
        name : max-value
        datatype : number
        version : 4.0 onwards
        default :
        description : Max slider value
        */
        this.max = 100;
        /*
        Properties
        name : orientation
        datatype : string
        version : 4.0 onwards
        default : horizontal
        description : Vertical or Horizontal Orientation of slider
        */
        this.orientation = 'horizontal';
        /*
        Events
        name : onChange
        datatype : any
        version : 4.0 onwards
        default :
        description : Triggers when slider is moved
        */
        this.onChange = new i0.EventEmitter();
        /*
        Events
        name : onSlideEnd
        datatype : any
        version : 4.0 onwards
        default :
        description : Triggers when slider reaches the end
        */
        this.onSlideEnd = new i0.EventEmitter();
        this.handleIndex = 0;
        this.handleValues = [];
        this.sliderFocus = false;
        this.onModelChange = function () { };
        this.onModelTouched = function () { };
        this.componentId = 'slider' + '_' + Math.floor(Math.random() * 1000 + 999);
    }
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    AmexioSliderComponent.prototype.onMouseDown = /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    function (event, index) {
        if (this.disabled) {
            return;
        }
        this.dragging = true;
        this.updateDomData();
        this.sliderHandleClick = true;
        this.handleIndex = index;
        this.bindDragListeners();
        event.preventDefault();
    };
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    AmexioSliderComponent.prototype.onTouchStart = /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    function (event, index) {
        var /** @type {?} */ touchobj = event.changedTouches[0];
        this.startHandleValue = (this.range) ? this.handleValues[index] : this.handleValue;
        this.dragging = true;
        this.handleIndex = index;
        if (this.orientation === 'horizontal') {
            this.startx = parseInt(touchobj.clientX, 10);
            this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        }
        else {
            this.starty = parseInt(touchobj.clientY, 10);
            this.barHeight = this.el.nativeElement.children[0].offsetHeight;
        }
        event.preventDefault();
    };
    /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    AmexioSliderComponent.prototype.onTouchMove = /**
     * @param {?} event
     * @param {?=} index
     * @return {?}
     */
    function (event, index) {
        var /** @type {?} */ touchobj = event.changedTouches[0];
        var /** @type {?} */ handleValue = 0;
        if (this.orientation === 'horizontal') {
            handleValue = Math.floor(((parseInt(touchobj.clientX, 10) - this.startx) * 100) / (this.barWidth)) + this.startHandleValue;
        }
        else {
            handleValue = Math.floor(((this.starty - parseInt(touchobj.clientY, 10)) * 100) / (this.barHeight)) + this.startHandleValue;
        }
        this.setValueFromHandle(event, handleValue);
        event.preventDefault();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.onBarClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.disabled) {
            return;
        }
        if (!this.sliderHandleClick) {
            this.updateDomData();
            this.handleChange(event);
        }
        this.sliderHandleClick = false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.handleChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ handleValue = this.calculateHandleValue(event);
        this.setValueFromHandle(event, handleValue);
    };
    /**
     * @return {?}
     */
    AmexioSliderComponent.prototype.bindDragListeners = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.ngZone.runOutsideAngular(function () {
            if (!_this.dragListener) {
                _this.dragListener = _this.renderer.listen('document', 'mousemove', function (event) {
                    if (_this.dragging) {
                        _this.ngZone.run(function () {
                            _this.handleChange(event);
                        });
                    }
                });
            }
            if (!_this.mouseupListener) {
                _this.mouseupListener = _this.renderer.listen('document', 'mouseup', function (event) {
                    _this.mouseUpListMethod();
                });
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioSliderComponent.prototype.mouseUpListMethod = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.dragging) {
            this.dragging = false;
            this.ngZone.run(function () {
                if (_this.range) {
                    _this.onSlideEnd.emit({ originalEvent: event, values: _this.values });
                }
                else {
                    _this.onSlideEnd.emit({ originalEvent: event, value: _this.value });
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AmexioSliderComponent.prototype.unbindDragListeners = /**
     * @return {?}
     */
    function () {
        if (this.dragListener) {
            this.dragListener();
        }
        if (this.mouseupListener) {
            this.mouseupListener();
        }
    };
    /**
     * @param {?} event
     * @param {?} handleValue
     * @return {?}
     */
    AmexioSliderComponent.prototype.setValueFromHandle = /**
     * @param {?} event
     * @param {?} handleValue
     * @return {?}
     */
    function (event, handleValue) {
        var /** @type {?} */ newValue = this.getValueFromHandle(handleValue);
        if (this.range) {
            if (this.step) {
                this.handleStepChange(newValue, this.values[this.handleIndex]);
            }
            else {
                this.handleValues[this.handleIndex] = handleValue;
                this.updateValue(newValue, event);
            }
        }
        else {
            if (this.step) {
                this.handleStepChange(newValue, this.value);
            }
            else {
                this.handleValue = handleValue;
                this.updateValue(newValue, event);
            }
        }
    };
    /**
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    AmexioSliderComponent.prototype.handleStepChange = /**
     * @param {?} newValue
     * @param {?} oldValue
     * @return {?}
     */
    function (newValue, oldValue) {
        var /** @type {?} */ diff = (newValue - oldValue);
        var /** @type {?} */ val = oldValue;
        if (diff < 0) {
            val = oldValue + Math.ceil((newValue - oldValue) / this.step) * this.step;
        }
        else if (diff > 0) {
            val = oldValue + Math.floor((newValue - oldValue) / this.step) * this.step;
        }
        this.updateValue(val);
        this.updateHandleValue();
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioSliderComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (this.range) {
            this.values = value || [0, 0];
        }
        else {
            this.value = value || 0;
        }
        this.updateHandleValue();
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioSliderComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onModelChange = fn;
    };
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioSliderComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onModelTouched = fn;
    };
    /**
     * @param {?} val
     * @return {?}
     */
    AmexioSliderComponent.prototype.setDisabledState = /**
     * @param {?} val
     * @return {?}
     */
    function (val) {
        this.disabled = val;
    };
    Object.defineProperty(AmexioSliderComponent.prototype, "rangeStartLeft", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVertical() ? 'auto' : this.handleValues[0] + '%';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioSliderComponent.prototype, "rangeStartBottom", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVertical() ? this.handleValues[0] + '%' : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioSliderComponent.prototype, "rangeEndLeft", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVertical() ? 'auto' : this.handleValues[1] + '%';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioSliderComponent.prototype, "rangeEndBottom", {
        get: /**
         * @return {?}
         */
        function () {
            return this.isVertical() ? this.handleValues[1] + '%' : 'auto';
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioSliderComponent.prototype.isVertical = /**
     * @return {?}
     */
    function () {
        return this.orientation === 'vertical';
    };
    /**
     * @return {?}
     */
    AmexioSliderComponent.prototype.updateDomData = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ rect = this.el.nativeElement.children[0].getBoundingClientRect();
        this.initX = rect.left + this.domHandler.getWindowScrollLeft();
        this.initY = rect.top + this.domHandler.getWindowScrollTop();
        this.barWidth = this.el.nativeElement.children[0].offsetWidth;
        this.barHeight = this.el.nativeElement.children[0].offsetHeight;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.calculateHandleValue = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.orientation === 'horizontal') {
            return ((event.pageX - this.initX) * 100) / (this.barWidth);
        }
        else {
            return (((this.initY + this.barHeight) - event.pageY) * 100) / (this.barHeight);
        }
    };
    /**
     * @return {?}
     */
    AmexioSliderComponent.prototype.updateHandleValue = /**
     * @return {?}
     */
    function () {
        if (this.range) {
            this.handleValues[0] = (this.values[0] < this.min ? 0 : this.values[0] - this.min) * 100 / (this.max - this.min);
            this.handleValues[1] = (this.values[1] > this.max ? 100 : this.values[1] - this.min) * 100 / (this.max - this.min);
        }
        else {
            if (this.value < this.min) {
                this.handleValue = 0;
            }
            else if (this.value > this.max) {
                this.handleValue = 100;
            }
            else {
                this.handleValue = (this.value - this.min) * 100 / (this.max - this.min);
            }
        }
    };
    /**
     * @param {?} val
     * @param {?=} valueEvent
     * @return {?}
     */
    AmexioSliderComponent.prototype.updateValue = /**
     * @param {?} val
     * @param {?=} valueEvent
     * @return {?}
     */
    function (val, valueEvent) {
        if (this.range) {
            var /** @type {?} */ value = val;
            if (this.handleIndex === 0) {
                if (value < this.min) {
                    value = this.min;
                    this.handleValues[0] = 0;
                }
                else if (value > this.values[1]) {
                    value = this.values[1];
                    this.handleValues[0] = this.handleValues[1];
                }
            }
            else {
                if (value > this.max) {
                    value = this.max;
                    this.handleValues[1] = 100;
                }
                else if (value < this.values[0]) {
                    value = this.values[0];
                    this.handleValues[1] = this.handleValues[0];
                }
            }
            this.values[this.handleIndex] = Math.floor(value);
            this.onModelChange(this.values);
            this.onChange.emit({ event: valueEvent, values: this.values });
        }
        else {
            this.updateValueNoRange(val, valueEvent);
        }
    };
    /**
     * @param {?} val
     * @param {?=} valueEvent
     * @return {?}
     */
    AmexioSliderComponent.prototype.updateValueNoRange = /**
     * @param {?} val
     * @param {?=} valueEvent
     * @return {?}
     */
    function (val, valueEvent) {
        if (val < this.min) {
            val = this.min;
            this.handleValue = 0;
        }
        else if (val > this.max) {
            val = this.max;
            this.handleValue = 100;
        }
        this.value = Math.floor(val);
        this.onModelChange(this.value);
        this.onChange.emit({ event: valueEvent, value: this.value });
    };
    /**
     * @param {?} handleValue
     * @return {?}
     */
    AmexioSliderComponent.prototype.getValueFromHandle = /**
     * @param {?} handleValue
     * @return {?}
     */
    function (handleValue) {
        return (this.max - this.min) * (handleValue / 100) + this.min;
    };
    /**
     * @return {?}
     */
    AmexioSliderComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.unbindDragListeners();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.onKeyLeftDown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.step) {
            this.step = 10;
            this.step = this.max / this.step;
        }
        else if (!this.max && !this.step && !this.min) {
            this.step = this.max / this.step;
        }
        this.handleValue = this.handleValue - this.step;
        this.setValueFromHandle(event, this.handleValue);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.onKeyRightUp = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.step) {
            this.step = 10;
            this.step = this.max / this.step;
        }
        else if (!this.max && !this.step && !this.min) {
            this.step = this.max / this.step;
        }
        this.handleValue = this.handleValue + this.step;
        this.setValueFromHandle(event, this.handleValue);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.onKeyHome = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.step) {
            this.step = 10;
            this.step = this.max / this.step;
        }
        else if (!this.max && !this.step && !this.min) {
            this.step = this.max / this.step;
        }
        this.handleValue = this.min;
        this.setValueFromHandle(event, this.handleValue);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.onKeyEnd = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.step) {
            this.step = 10;
            this.step = this.max / this.step;
        }
        else if (!this.max && !this.step && !this.min) {
            this.step = this.max / this.step;
        }
        this.handleValue = this.max;
        this.setValueFromHandle(event, this.handleValue);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.onKeyPageUp = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.handleValue = this.handleValue + 10;
        this.setValueFromHandle(event, this.handleValue);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.onKeyPageDown = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.handleValue = this.handleValue - 10;
        this.setValueFromHandle(event, this.handleValue);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.onFocus = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.sliderFocus = true;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSliderComponent.prototype.onBlur = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.sliderFocus = false;
    };
    AmexioSliderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-slider',
                    template: "\n    <div id=\"{{componentId}}\" [ngStyle]=\"style\" [class]=\"styleClass\" [ngClass]=\"{'ui-slider ui-widget ui-widget-content ui-corner-all':true,'disable-component':disabled,\n      'ui-slider-horizontal':orientation == 'horizontal',\n      'ui-slider-vertical':orientation == 'vertical','ui-slider-animate':animate}\"\n        (click)=\"onBarClick($event)\" (onFocus)=\"onFocus($event)\" (onBlur)=\"onBlur($event)\">\n        <div role=\"slider\" [tabindex]=\"disabled ? -1 : 0\" attr.aria-labelledby=\"{{componentId}}\" [attr.aria-valuenow]=\"handleValue\"\n            style=\"color:red\" id=\"idRedValue\" [ngClass]=\"{'focusOnSlider':sliderFocus}\" [attr.aria-valuemin]=\"min\"\n            [attr.aria-valuemax]=\"max\" (keydown.arrowdown)=\"onKeyLeftDown($event)\" (keydown.arrowup)=\"onKeyRightUp($event)\"\n            (keydown.arrowright)=\"onKeyRightUp($event)\" (keydown.arrowleft)=\"onKeyLeftDown($event)\" (keydown.home)=\"onKeyHome($event)\"\n            (keydown.end)=\"onKeyEnd($event)\" (focus)=\"onFocus($event)\" (blur)=\"onBlur($event)\" [ngClass]=\"{'focusOnSlider':sliderFocus}\"\n            (keydown.pageup)=\"onKeyPageUp($event)\" (keydown.pagedown)=\"onKeyPageDown($event)\"></div>\n        <span *ngIf=\"range && orientation == 'horizontal'\" class=\"ui-slider-range ui-widget-header ui-corner-all\" [ngStyle]=\"{'left':handleValues[0] + '%',width: (handleValues[1] - handleValues[0] + '%')}\"></span>\n        <span *ngIf=\"range && orientation == 'vertical'\" class=\"ui-slider-range ui-widget-header ui-corner-all\" [ngStyle]=\"{'bottom':handleValues[0] + '%',height:\n           (handleValues[1] - handleValues[0] + '%')}\"></span>\n        <span *ngIf=\"!range && orientation=='vertical'\" class=\"ui-slider-range ui-slider-range-min ui-widget-header ui-corner-all\"\n            [ngStyle]=\"{'height': handleValue + '%'}\"></span>\n        <span *ngIf=\"!range && orientation=='horizontal'\" class=\"ui-slider-range ui-slider-range-min ui-widget-header ui-corner-all\"\n            [ngStyle]=\"{'width': handleValue + '%'}\"></span>\n        <span *ngIf=\"!range\" class=\"ui-slider-handle ui-state-default ui-corner-all ui-clickable\" (mousedown)=\"onMouseDown($event)\"\n            (touchstart)=\"onTouchStart($event)\" (touchmove)=\"onTouchMove($event)\" (touchend)=\"dragging=false\"\n            [style.transition]=\"dragging ? 'none': null\" [ngStyle]=\"{'left': orientation == 'horizontal' ? handleValue + '%' : null,\n                  'bottom': orientation == 'vertical' ? handleValue + '%' : null}\"></span>\n        <span *ngIf=\"range\" (mousedown)=\"onMouseDown($event,0)\" (touchstart)=\"onTouchStart($event,0)\" (touchmove)=\"onTouchMove($event,0)\"\n            (touchend)=\"dragging=false\" setValueFromHandle(event,this.slidevar); [style.transition]=\"dragging ? 'none': null\"\n            class=\"ui-slider-handle ui-state-default ui-corner-all ui-clickable\" [ngStyle]=\"{'left': rangeStartLeft, 'bottom': rangeStartBottom}\"\n            [ngClass]=\"{'ui-slider-handle-active':handleIndex==0}\"></span>\n        <span *ngIf=\"range\" (mousedown)=\"onMouseDown($event,1)\" (touchstart)=\"onTouchStart($event,1)\" (touchmove)=\"onTouchMove($event,1)\"\n            (touchend)=\"dragging=false\" [style.transition]=\"dragging ? 'none': null\" class=\"ui-slider-handle ui-state-default ui-corner-all ui-clickable\"\n            [ngStyle]=\"{'left': rangeEndLeft, 'bottom': rangeEndBottom}\" [ngClass]=\"{'ui-slider-handle-active':handleIndex==1}\"></span>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioSliderComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioSliderComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: DomHandler },
        { type: i0.Renderer2 },
        { type: i0.NgZone }
    ]; };
    AmexioSliderComponent.propDecorators = {
        animate: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        min: [{ type: i0.Input, args: ['min-value',] }],
        max: [{ type: i0.Input, args: ['max-value',] }],
        orientation: [{ type: i0.Input }],
        step: [{ type: i0.Input, args: ['step-value',] }],
        range: [{ type: i0.Input }],
        style: [{ type: i0.Input }],
        styleClass: [{ type: i0.Input, args: ['style-class',] }],
        onChange: [{ type: i0.Output }],
        onSlideEnd: [{ type: i0.Output }]
    };
    return AmexioSliderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioSpinnerComponent = /** @class */ (function () {
    function AmexioSpinnerComponent(renderer) {
        this.renderer = renderer;
        /*
          Events
          name : show
          datatype : boolean
          version : none
          default : true
          description : if show  is true than and only than the spinner is enable, if false then it is disable.
          */
        this.show = true;
        this.relative = false;
        this.spinnerVertialCss = 'spinner-vertical-';
        this.spinnerHorizontalCss = ' spinner-horizontal-';
        this.spinnerRelativeCss = 'spinnerCss-relative';
        this.alpha = '0.2';
    }
    Object.defineProperty(AmexioSpinnerComponent.prototype, "color", {
        get: /**
         * @return {?}
         */
        function () {
            return this._color;
        },
        /*
         Events
         name : color
         datatype : string
         version : none
         default : none
         description : spinner want color
         */
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            var /** @type {?} */ ischanges = (this._color !== v);
            this._color = v;
            if (ischanges) {
                this.assignColor();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioSpinnerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.assignColor();
        this.positionChangeClass();
    };
    /**
     * @return {?}
     */
    AmexioSpinnerComponent.prototype.ngOnChanges = /**
     * @return {?}
     */
    function () {
        this.positionChangeClass();
    };
    /**
     * @return {?}
     */
    AmexioSpinnerComponent.prototype.positionChangeClass = /**
     * @return {?}
     */
    function () {
        if (this.relative) {
            this.positionSpinnerClass = this.spinnerRelativeCss;
        }
        else {
            if (this.verticalposition === null) {
                this.verticalposition = 'top';
            }
            else if (this.horizontalposition === null) {
                this.horizontalposition = 'right';
            }
            this.positionSpinnerClass = this.spinnerVertialCss + this.verticalposition + this.spinnerHorizontalCss + this.horizontalposition;
        }
    };
    /**
     * @return {?}
     */
    AmexioSpinnerComponent.prototype.assignColor = /**
     * @return {?}
     */
    function () {
        if (this.type === 'spinnerround' && this.color) {
            var /** @type {?} */ newColor = void 0;
            var /** @type {?} */ r = parseInt(this.color.slice(1, 3), 16);
            var /** @type {?} */ g = parseInt(this.color.slice(3, 5), 16);
            var /** @type {?} */ b = parseInt(this.color.slice(5, 7), 16);
            if (this.alpha) {
                newColor = "rgba(" + r + ", " + g + ", " + b + ", " + this.alpha + ")";
            }
            else {
                newColor = "rgba(" + r + ", " + g + ", " + b + ")";
            }
            var /** @type {?} */ inlinecss = 'margin: 60px auto;font-size: 10px;position: relative;text-indent: -9999em;border-top: 1.1em solid ' + newColor +
                '; border-right: 1.1em solid ' + newColor +
                ';border-left: 1.1em solid ;-webkit-transform: translateZ(0);-ms-transform: translateZ(0);border-bottom: 1.1em solid ' + newColor +
                ';transform: translateZ(0);  -webkit-animation: load8 1.1s infinite linear;animation: load8 1.1s infinite linear;';
            var /** @type {?} */ inlinecssafter = ' border-radius: 50%; width: 10em; height: 10em;';
            this.insertStyleSheetRule('.dynamicclass { ' + inlinecss + inlinecssafter + '}');
            this.insertStyleSheetRule('@-webkit-keyframes load8 { 0% {  -webkit-transform: rotate(0deg);  transform: rotate(0deg);} ' +
                '100%{-webkit-transform: rotate(360deg); transform: rotate(360deg);} }');
            this.renderer.addClass(this.element.nativeElement, 'dynamicclass');
        }
    };
    /**
     * @param {?} ruleText
     * @return {?}
     */
    AmexioSpinnerComponent.prototype.insertStyleSheetRule = /**
     * @param {?} ruleText
     * @return {?}
     */
    function (ruleText) {
        var /** @type {?} */ sheets = document.styleSheets;
        if (sheets.length === 0) {
            var /** @type {?} */ style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        var /** @type {?} */ sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
    };
    AmexioSpinnerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-spinner',
                    template: "\n    <div class=\"spinner-sm\" [ngClass]=\"positionSpinnerClass\">\n\n            <div #loadindicator [ngStyle]=\"{'display': show ? 'block': 'none'}\"\n             [style.color]='color' [style.font-size]='size'\n                    [ngClass]=\"{\n            'rectangle-bounces' :type == 'rectanglebounce',\n            'rings' :type == 'ring',\n            'half-circles' :type == 'halfcircle',\n            'fading-circles' :type == 'fadingcircle',\n            'ball-spins' :type == 'ballspin',\n            'fire-spins' :type == 'firespin',\n            'three-bounces' :type == 'threebounce',\n            'spinner-rounds' :type == 'spinnerround'}\n            \">\n            </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioSpinnerComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };
    AmexioSpinnerComponent.propDecorators = {
        type: [{ type: i0.Input, args: ['type',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        show: [{ type: i0.Input }],
        verticalposition: [{ type: i0.Input, args: ['vertical-position',] }],
        horizontalposition: [{ type: i0.Input, args: ['horizontal-position',] }],
        size: [{ type: i0.Input, args: ['size',] }],
        relative: [{ type: i0.Input, args: ['relative',] }],
        element: [{ type: i0.ViewChild, args: ['loadindicator',] }]
    };
    return AmexioSpinnerComponent;
}());

var __extends$22 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 20/12/17.
*/
var AmexioTagsInputComponent = /** @class */ (function (_super) {
    __extends$22(AmexioTagsInputComponent, _super);
    function AmexioTagsInputComponent(displayFieldService, dataService, element, renderer, _cd) {
        var _this = _super.call(this, renderer, element, _cd) || this;
        _this.displayFieldService = displayFieldService;
        _this.dataService = dataService;
        _this.element = element;
        _this.renderer = renderer;
        /*
         Properties
         name : has-label
         datatype : boolean
         version : 4.0 onwards
         default : false
         description : flag to set label
         */
        _this.haslabel = true;
        /*
         Events
         name : input
         datatype : any
         version : none
         default :
         description :	On input event field.
         */
        _this.input = new i0.EventEmitter();
        /*
        Events
        name : onChange
        datatype : any
        version : none
        default :
        description : on change event
        */
        _this.onChange = new i0.EventEmitter();
        /*
        Events
        name : focus
        datatype : any
        version : none
        default :
        description : On field focus event
        */
        _this.focus = new i0.EventEmitter();
        _this.onSelections = [];
        _this.activeindex = 0;
        _this.selectedindex = -1;
        _this.scrollposition = 30;
        _this.maskloader = true;
        return _this;
    }
    Object.defineProperty(AmexioTagsInputComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        } /*
         Properties
         name : data-reader
         datatype : string
         version : 4.0 onwards
         default :
         description : Key in JSON datasource for records
         */ /*
       Properties
       name : data-reader
       datatype : string
       version : 4.0 onwards
       default :
       description : Key in JSON datasource for records
       */,
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.setData(this._data);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.componentId = this.createCompId('taginput', this.displayfield);
        if (this.placeholder === '' || this.placeholder === null) {
            this.placeholder = 'Choose Option';
        }
        if (!this.triggerchar) {
            this.triggerchar = 1;
        }
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.navigateKey = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.focusToLastElement = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.filteredResult[this.selectedindex].selected = false;
        this.selectedindex = this.filteredResult.length - 1;
        this.filteredResult[this.filteredResult.length - 1].selected = true;
        this.setAriaActiveDescendant(this.selectedindex);
        this.setScrollToList(this.selectedindex);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.focusToFirstElement = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.filteredResult[this.selectedindex].selected = false;
        this.selectedindex = 0;
        this.filteredResult[0].selected = true;
        this.setAriaActiveDescendant(this.selectedindex);
        this.setScrollToList(this.selectedindex);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.closeOnEScapeList = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.showToolTip = false;
        this.hide();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.onKeyUp = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.filteredResult = [];
        this.showToolTip = false;
        var /** @type {?} */ keyword = event.target.value;
        if (keyword !== null && keyword !== ' ' && keyword.length >= this.triggerchar) {
            var /** @type {?} */ search_term_1 = keyword.toLowerCase();
            this.viewData.forEach(function (item) {
                if (item != null && _this.displayFieldService.findValue(_this.key, item).toLowerCase().startsWith(search_term_1)) {
                    _this.filteredResult.push(item);
                }
            });
            if (this.filteredResult.length > 0) {
                this.showToolTip = true;
                this.onBaseFocusEvent({});
            }
            else {
                this.showToolTip = this.onBaseBlurEvent({});
            }
        }
        if (event.keyCode === 40 || event.keyCode === 38 || event.keyCode === 13) {
            this.navigateUsingKey(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.navigateUsingKey = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.selectedindex > this.filteredResult.length) {
            this.selectedindex = 0;
        }
        if (event.keyCode === 40 || event.keyCode === 38 && this.selectedindex < this.filteredResult.length) {
            this.keyUpDownMethod(event);
        }
        if (event.keyCode === 13 && this.filteredResult[this.selectedindex]) {
            this.onItemSelect(this.filteredResult[this.selectedindex], this.selectedindex);
        }
        this.setScrollToList(this.selectedindex);
    };
    // Method when up arrow or down arrow is pressed
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.keyUpDownMethod = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.showToolTip) {
            this.showToolTip = true;
        }
        var /** @type {?} */ prevselectedindex = -1;
        prevselectedindex = this.selectedindex;
        if (event.keyCode === 40) {
            this.selectedindex++;
        }
        else if (event.keyCode === 38) {
            this.selectedindex--;
        }
        if (this.filteredResult[this.selectedindex]) {
            this.filteredResult[this.selectedindex].selected = true;
            this.setAriaActiveDescendant(this.selectedindex);
        }
        if (this.filteredResult[prevselectedindex]) {
            this.filteredResult[prevselectedindex].selected = false;
            this.toNavigateFirstAndLastOption();
        }
    };
    /**
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.toNavigateFirstAndLastOption = /**
     * @return {?}
     */
    function () {
        if (this.selectedindex === -1) {
            this.selectedindex = this.filteredResult.length - 1;
            this.filteredResult[this.filteredResult.length - 1].selected = true;
        }
        else if (this.selectedindex === this.filteredResult.length) {
            this.selectedindex = 0;
            this.filteredResult[this.selectedindex].selected = true;
        }
        this.setAriaActiveDescendant(this.selectedindex);
    };
    /**
     * @param {?} rowindex
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.setAriaActiveDescendant = /**
     * @param {?} rowindex
     * @return {?}
     */
    function (rowindex) {
        if (this.filteredResult.length > 0) {
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', this.filteredResult[rowindex].index);
        }
        else if (this.displayValue.length < 1) {
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', 'listitem');
        }
    };
    /**
     * @param {?} rowindex
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.setScrollToList = /**
     * @param {?} rowindex
     * @return {?}
     */
    function (rowindex) {
        var /** @type {?} */ listitems = this.element.nativeElement.getElementsByClassName('list-items')[rowindex];
        if (listitems) {
            listitems.scrollIntoView({ behavior: 'smooth' });
        }
    };
    /**
     * @param {?} activerow
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.showAllData = /**
     * @param {?} activerow
     * @return {?}
     */
    function (activerow) {
        var _this = this;
        var /** @type {?} */ i = 0;
        this.viewData.forEach(function (item) {
            if (item != null) {
                if (i === activerow) {
                    item.active = true;
                    _this.currentActive = item;
                }
                else {
                    item.active = false;
                }
                item.activerow = activerow;
                _this.filteredResult.push(item);
            }
            i++;
        });
        if (this.filteredResult.length > 0) {
            this.showToolTip = true;
        }
    };
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.onItemSelect = /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    function (row, index) {
        this.value = row[this.valuefield];
        this.displayFieldService.findValue(this.displayfield, row);
        this.setValue(row, {}, index);
        this.showToolTip = false;
    };
    /**
     * @param {?} input
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.onInput = /**
     * @param {?} input
     * @return {?}
     */
    function (input) {
        if (this.selectedindex > -1) {
            this.filteredResult[this.selectedindex].selected = false;
        }
        this.selectedindex = -1;
        this.input.emit();
    };
    /**
     * @param {?} elem
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.onFocus = /**
     * @param {?} elem
     * @return {?}
     */
    function (elem) {
        this.inpHandle.nativeElement.placeholder = '';
        this.onBaseFocusEvent({});
        this.posixUp = this.getListPosition(elem);
        this.focus.emit(this.value);
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ dropdownHeight = 325;
        // must be same in dropdown.scss
        if (elementRef) {
            if (window.screen.height - (elementRef.getBoundingClientRect().bottom) < dropdownHeight) {
                return true;
            }
            else {
                return false;
            }
        }
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewData = responsedata;
        this.generateIndex(this.viewData);
        this.maskloader = false;
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.generateIndex = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        data.forEach(function (element, index) {
            element['index'] = _this.componentId + 'listitem' + index;
        });
    };
    /**
     * @param {?} value
     * @param {?} ref
     * @param {?} index
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.setValue = /**
     * @param {?} value
     * @param {?} ref
     * @param {?} index
     * @return {?}
     */
    function (value, ref, index) {
        this.inpHandle.nativeElement.value = '';
        this.onSelections.push(value);
        this.onChange.emit(this.onSelections);
        if (this.onSelections.length > 0) {
            this.isValid = true;
        }
        this.hide();
        if (index) {
            this.filteredResult[index].selected = false;
        }
        this.selectedindex = -1;
        this.showToolTip = false;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.removePill = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        var /** @type {?} */ indexToRemove = null;
        this.onSelections.forEach(function (selectedVal, index) {
            if (selectedVal === item) {
                indexToRemove = index;
            }
        });
        this.onSelections.splice(indexToRemove, 1);
        if (this.onSelections.length === 0) {
            this.isValid = false;
        }
        this.onChange.emit(this.onSelections);
    };
    // THIS MEHTOD CHECK INPUT IS VALID OR NOT
    /**
     * @return {?}
     */
    AmexioTagsInputComponent.prototype.checkValidity = /**
     * @return {?}
     */
    function () {
        return this.isValid;
    };
    AmexioTagsInputComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-tag-input',
                    template: "\n    <div class=\"inputgroup\" #rootDiv (keyup.esc)=\"closeOnEScapeList($event)\">\n\n      <label *ngIf=\"haslabel\" for=\"{{componentId}}\" [style.font-style]=\"fontstyle\" [style.font-family]=\"fontfamily\" [style.font-size]=\"fontsize\">\n        {{fieldlabel}}\n      </label>\n\n      <div class=\"tag-input\" [ngClass]=\"{'loading-mask' : maskloader}\">\n        <div class=\"tag\" *ngFor=\"let item of onSelections\">\n          <amexio-display-field [data]=\"item\" [data-index]=\"key\"></amexio-display-field>\n          <span class=\"closebtn\" (click)=\"removePill(item)\">&times;</span>\n        </div>\n        <input id=\"{{componentId}}\" aria-autocomplete=\"list\" role=\"combobox\" [attr.aria-expanded]=\"showToolTip\" type=\"text\" class=\"input-control\"\n          [ngClass]=\"{'input-control-error' : inp.invalid && (inp.dirty || inp.touched),'input-control-success' : inp.valid && (inp.dirty || inp.touched)}\"\n          (focus)=\"onFocus(rootDiv)\" (input)=\"onInput(inp)\" (keyup)=\"onKeyUp($event)\" (keyup.end)=\"focusToLastElement($event)\"\n          (keyup.home)=\"focusToFirstElement($event)\" [attr.placeholder]=\"placeholder\" [attr.disabled]=\"disabled ? true: null\" [required]=\"allowblank ? true: null\"\n          #inp />\n      </div>\n\n\n      <span #dropdownitems class=\"dropdown\" [@changeState]=\"dropdownstyle.visibility\" [ngClass]=\"{'dropdown-up' : posixUp}\" [ngStyle]=\"dropdownstyle\"\n        #tagDropRef>\n        <ul role=\"list\" class=\"dropdown-list\">\n          <li tabindex=\"1\" role=\"listitem\" class=\"list-items\" [ngClass]=\"{'list-items-selected':item.selected}\" *ngFor=\"let item of filteredResult\"\n            id=\"{{item.index}}\" (click)=\"setValue(item,inp)\">\n            <div>\n              <amexio-display-field [data]=\"item\" [data-index]=\"displayfield\"></amexio-display-field>\n            </div>\n          </li>\n        </ul>\n      </span>\n    </div>\n\n\n    <span *ngIf=\"iconfeedback && (inp.invalid && (inp.dirty || inp.touched) || inp.valid)\" class=\"input-control-feedback\">\n      <span *ngIf=\"inp.invalid && (inp.dirty || inp.touched)\">&#9888;</span>\n      <span *ngIf=\"inp.valid && (inp.dirty || inp.touched)\"> &#10004;</span>\n    </span>\n  ",
                    animations: [
                        trigger('changeState', [
                            state('visible', style({
                                'max-height': '200px',
                            })),
                            state('hidden', style({
                                'max-height': '0px',
                            })),
                            transition('*=>*', animate('200ms')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioTagsInputComponent.ctorParameters = function () { return [
        { type: DisplayFieldService },
        { type: CommonDataService },
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: i0.ChangeDetectorRef }
    ]; };
    AmexioTagsInputComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        allowblank: [{ type: i0.Input, args: ['allow-blank',] }],
        data: [{ type: i0.Input, args: ['data',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        valuefield: [{ type: i0.Input, args: ['value-field',] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        disabled: [{ type: i0.Input }],
        iconfeedback: [{ type: i0.Input, args: ['icon-feedback',] }],
        fontstyle: [{ type: i0.Input, args: ['font-style',] }],
        fontfamily: [{ type: i0.Input, args: ['font-family',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        enablepopover: [{ type: i0.Input, args: ['enable-popover',] }],
        key: [{ type: i0.Input }],
        triggerchar: [{ type: i0.Input, args: ['trigger-char',] }],
        haslabel: [{ type: i0.Input, args: ['has-label',] }],
        input: [{ type: i0.Output }],
        onChange: [{ type: i0.Output }],
        focus: [{ type: i0.Output }],
        inpHandle: [{ type: i0.ViewChild, args: ['inp',] }],
        tagDropRef: [{ type: i0.ViewChild, args: ['tagDropRef',] }],
        dropdownitems: [{ type: i0.ViewChild, args: ['dropdownitems', { read: i0.ElementRef },] }]
    };
    return AmexioTagsInputComponent;
}(EventBaseComponent));

var __extends$23 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioTextAreaComponent = /** @class */ (function (_super) {
    __extends$23(AmexioTextAreaComponent, _super);
    function AmexioTextAreaComponent() {
        var _this = _super.call(this) || this;
        /*
        Events
        name : onBlur
        datatype : any
        version : 4.0 onwards
        default :
        description : On blur event
        */
        _this.onBlur = new i0.EventEmitter();
        /*
         Events
         name : input
         datatype : any
         version : none
         default :
         description : 	On input event field.
         */
        _this.input = new i0.EventEmitter();
        /*
         Events
         name : focus
         datatype : any
         version : none
         default :
         description : On focus event field.
         */
        _this.focus = new i0.EventEmitter();
        /*
         Events
         name : change
         datatype : any
         version : none
         default :
         description : On field value change event
         */
        _this.change = new i0.EventEmitter();
        /*
        Properties
        name : has-label
        datatype : boolean
        version : 4.0 onwards
        default : none
        description : flag to set label
        */
        _this.haslabel = true;
        _this.isValid = false;
        _this.showToolTip = false;
        return _this;
    }
    Object.defineProperty(AmexioTextAreaComponent.prototype, "pattern", {
        get: /**
         * @return {?}
         */
        function () {
            return this._pattern;
        },
        /*
      Properties
      name : pattern
      datatype : string
      version : 4.0 onwards
      default : none
      description : Apply Reg-ex to the field
      */
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value != null) {
                this._pattern = value;
                this.regEx = new RegExp(this._pattern);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioTextAreaComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = this.createCompId('textareainput', this.name);
        this.name = this.generateName(this.name, this.fieldlabel, 'textareainput');
    };
    // Set touched on blur
    /**
     * @return {?}
     */
    AmexioTextAreaComponent.prototype.onBlurEvent = /**
     * @return {?}
     */
    function () {
        this.showToolTip = false;
        this.onBlur.emit(this.value);
    };
    /**
     * @return {?}
     */
    AmexioTextAreaComponent.prototype.onFocusEvent = /**
     * @return {?}
     */
    function () {
        this.showToolTip = true;
        this.focus.emit(this.value);
    };
    /**
     * @return {?}
     */
    AmexioTextAreaComponent.prototype.onInputEvent = /**
     * @return {?}
     */
    function () {
        this.isValid = this.isFieldValid();
        this.input.emit(this.value);
    };
    /**
     * @return {?}
     */
    AmexioTextAreaComponent.prototype.onChangeEv = /**
     * @return {?}
     */
    function () {
        this.change.emit(this.value);
    };
    // THIS METHOD IS USED FOR VALIDATION
    /**
     * @return {?}
     */
    AmexioTextAreaComponent.prototype.isFieldValid = /**
     * @return {?}
     */
    function () {
        return (!this.allowblank && (this.value && (this.value.length > 0)) ||
            (this.value && this.value.length > 0)) || this.allowblank;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioTextAreaComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return this.isFieldValid() ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    AmexioTextAreaComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-textarea-input',
                    template: "\n\n    <div class=\"inputgroup\">\n\n      <label *ngIf=\"haslabel\" role=\"textarea\" for=\"{{componentId}}\" id=\"{{componentId}}\"  [style.font-style]=\"fontstyle\" [style.font-family]=\"fontfamily\" [style.font-size]=\"fontsize\">\n        {{fieldlabel}}\n      </label>\n \n      <textarea type=\"text\"\n\n            role=\"text\" \n            tabindex=\"1\"\n            id=\"{{componentId}}\" \n            name=\"areaText\"\n            attr.aria-labelledby=\"{{componentId}}\"\n            aria-describedby=\"textAreaDes\"\n            aria-multiline=\"true\"\n            [attr.aria-required]=\"!allowblank\"\n            [attr.aria-invalid]=\"!isValid \"\n\n         \n\n             class=\"input-control\"\n             [(ngModel)]=\"value\"\n             [ngClass]=\"model.touched ? allowblank ? '' : (isValid && model.touched) ? 'input-control-success' : 'input-control-error' :''\" \n             (blur)=\"onBlurEvent()\"\n             (focus)=\"onFocusEvent()\"\n             (input)=\"onInputEvent()\"\n             [name]=\"name\"\n             [pattern]=\"regEx\"\n             [attr.placeholder]=\"placeholder\"\n             [attr.rows]=\"rows\"\n             [attr.cols]=\"columns\"\n             [attr.disabled] = \"disabled ? true: null\"\n             [required]=\"!allowblank\">\n      </textarea>\n\n      <ng-container *ngIf=\"iconfeedback\">\n          <span class=\"input-control-feedback\">\n            <span *ngIf=\"!isValid && model.touched\"><em class=\"fa fa-times\"></em></span>\n          <span *ngIf=\"isValid && model.touched\"><em class=\"fa fa-check\"></em></span>\n          </span>\n      </ng-container>\n\n      <input-help *ngIf=\"showToolTip && enablepopover\" \n            id=\"textAreaDes\"\n            role=\"tooltip\"\n            [error-msg]=\"errormsg\" \n            [min-msg]=\"minmsg\" \n            [max-msg]=\"maxmsg\"\n            [max-error-msg]=\"maxerrormsg\"\n            [min-error-msg]=\"minerrormsg\" >\n      </input-help>\n\n      <span class=\"inputfieldbar\"></span>\n    </div>\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioTextAreaComponent; }), multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioTextAreaComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioTextAreaComponent.ctorParameters = function () { return []; };
    AmexioTextAreaComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        rows: [{ type: i0.Input }],
        columns: [{ type: i0.Input }],
        allowblank: [{ type: i0.Input, args: ['allow-blank',] }],
        onBlur: [{ type: i0.Output }],
        input: [{ type: i0.Output }],
        focus: [{ type: i0.Output }],
        change: [{ type: i0.Output }],
        minerrormsg: [{ type: i0.Input, args: ['min-error-msg',] }],
        maxerrormsg: [{ type: i0.Input, args: ['max-error-msg',] }],
        errormsg: [{ type: i0.Input, args: ['error-msg',] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        disabled: [{ type: i0.Input }],
        iconfeedback: [{ type: i0.Input, args: ['icon-feedback',] }],
        fontstyle: [{ type: i0.Input, args: ['font-style',] }],
        fontfamily: [{ type: i0.Input, args: ['font-family',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        haslabel: [{ type: i0.Input, args: ['has-label',] }],
        pattern: [{ type: i0.Input, args: ['pattern',] }],
        enablepopover: [{ type: i0.Input, args: ['enable-popover',] }],
        name: [{ type: i0.Input, args: ['name',] }],
        model: [{ type: i0.ViewChild, args: [forms.NgModel,] }]
    };
    return AmexioTextAreaComponent;
}(ValueAccessorBase));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var ToolbaroneComponent = /** @class */ (function () {
    function ToolbaroneComponent() {
    }
    /**
     * @return {?}
     */
    ToolbaroneComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    ToolbaroneComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-toolbar-item',
                    template: "\n  <div tabindex=\"1\" [ngClass]=\"{'toolbaritemseperatorright':(seperatorposition === 'right'),\n  'toolbaritemseperatorleft':(seperatorposition === 'left')}\">\n  <ng-content></ng-content>\n  </div>\n   ",
                },] },
    ];
    /** @nocollapse */
    ToolbaroneComponent.ctorParameters = function () { return []; };
    ToolbaroneComponent.propDecorators = {
        seperatorposition: [{ type: i0.Input, args: ['seperator-position',] }]
    };
    return ToolbaroneComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var ToolbarComponent = /** @class */ (function () {
    function ToolbarComponent() {
        this.className = 'toolbar-header';
        /*
          Events
          name : onClick
          datatype : none
          version : none
          default : none
          description : Callback to invoke on activated tab event.
          */
        this.onClick = new i0.EventEmitter();
        this.toolbarposition = 'top';
        this.seperator = false;
    }
    /**
     * @return {?}
     */
    ToolbarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    ToolbarComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.toolCollection = this.queryTool.toArray();
        for (var _i = 0, _a = this.toolCollection; _i < _a.length; _i++) {
            var i = _a[_i];
            [i]['position'] = this.getToolbaritemposition([i]['position']);
        }
    };
    /**
     * @param {?} position
     * @return {?}
     */
    ToolbarComponent.prototype.getToolbaritemposition = /**
     * @param {?} position
     * @return {?}
     */
    function (position) {
        if (position === 'right') {
            return 'main-right';
        }
        if (position === 'left') {
            return 'main-left';
        }
        if (position === 'center') {
            return 'main-center';
        }
        if (position === '') {
            return 'main-center';
        }
    };
    /**
     * @param {?} tool
     * @return {?}
     */
    ToolbarComponent.prototype.onToolClick = /**
     * @param {?} tool
     * @return {?}
     */
    function (tool) {
        if (!tool.disabled) {
            for (var _i = 0, _a = this.toolCollection; _i < _a.length; _i++) {
                var i = _a[_i];
                if ([i] === tool) {
                    [i]['active'] = true;
                    this.onClick.emit(tool);
                }
                else {
                    [i]['active'] = false;
                }
            }
        }
    };
    // THIS METHOD IS  FOR APPLIED SPERATOR CLASS
    /**
     * @param {?} toolnode
     * @return {?}
     */
    ToolbarComponent.prototype.getSeperatotClass = /**
     * @param {?} toolnode
     * @return {?}
     */
    function (toolnode) {
        var /** @type {?} */ cssName = '';
        if (this.seperator) {
            cssName = 'seperator-line';
        }
        cssName = cssName + toolnode.position;
        return cssName;
    };
    /**
     * @return {?}
     */
    ToolbarComponent.prototype.getToolbarPosition = /**
     * @return {?}
     */
    function () {
        if (this.toolbarposition === 'top') {
            return '';
        }
        if (this.toolbarposition === 'right') {
            return '';
        }
        if (this.toolbarposition === 'bottom') {
            return '';
        }
    };
    ToolbarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-toolbar',
                    template: "\n\n\n    <div tabindex=\"1\" class=\"toolbar\">\n        <div class=\"topnavmainbar\">\n            <div class=\"toolbar-item\">\n                <ng-content select=\"[position-left]\"></ng-content>\n                <ng-content select=\"amexio-panel-header\"></ng-content>\n                <ng-content select=\"amexio-form-header\"></ng-content>\n                <ng-content select=\"amexio-window-header\"></ng-content>\n            </div>\n            <div class=\"toolbar-item\">\n                <ng-content select=\"[position-center]\"></ng-content>\n            </div>\n            <div class=\"toolbar-item\">\n                <ng-content select=\"[position-right]\"></ng-content>\n            </div>\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    ToolbarComponent.ctorParameters = function () { return []; };
    ToolbarComponent.propDecorators = {
        className: [{ type: i0.HostBinding, args: ['attr.class',] }],
        seperator: [{ type: i0.Input, args: ['seperator',] }],
        toolbarposition: [{ type: i0.Input, args: ['toolbar-position',] }],
        onClick: [{ type: i0.Output }],
        tabLocalData: [{ type: i0.Input }],
        queryTool: [{ type: i0.ContentChildren, args: [ToolbaroneComponent,] }]
    };
    return ToolbarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ToolBarActionComponent = /** @class */ (function () {
    function ToolBarActionComponent() {
        /*
          Events
          name : navLinkClick
          datatype : any
          version : none
          default : none
          description : Fire when nav item is clicked,
          This event is fired when nav item type is defined as 'link/button/menu'
        
          */
        this.navLinkClick = new i0.EventEmitter();
        this.actionComponent = '';
    }
    /**
     * @return {?}
     */
    ToolBarActionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} clickEvent
     * @return {?}
     */
    ToolBarActionComponent.prototype.onClick = /**
     * @param {?} clickEvent
     * @return {?}
     */
    function (clickEvent) {
        var /** @type {?} */ node = {
            title: this.title,
            type: this.type,
        };
        this.navLinkClick.emit({ data: node, event: clickEvent });
    };
    /**
     * @return {?}
     */
    ToolBarActionComponent.prototype.checkActionComponent = /**
     * @return {?}
     */
    function () {
        this.dropdown = this.queryDropDown.toArray();
        if (this.dropdown.length > 0) {
            this.actionComponent = 'dropdown';
            this.dropdown[0].fieldlabel = '';
        }
        this.button = this.queryButton.toArray();
        if (this.button.length > 0) {
            this.actionComponent = 'button';
        }
    };
    ToolBarActionComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-toolbar-action',
                    template: "\n   <ng-content></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    ToolBarActionComponent.ctorParameters = function () { return []; };
    ToolBarActionComponent.propDecorators = {
        queryDropDown: [{ type: i0.ContentChildren, args: [AmexioDropDownComponent, { descendants: true },] }],
        queryButton: [{ type: i0.ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
        queryLabel: [{ type: i0.ContentChildren, args: [AmexioLabelComponent, { descendants: true },] }],
        type: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        navLinkClick: [{ type: i0.Output }]
    };
    return ToolBarActionComponent;
}());

var __extends$26 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
 * @template T
 */
var BaseInput = /** @class */ (function (_super) {
    __extends$26(BaseInput, _super);
    function BaseInput() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    BaseInput.prototype.onBaseInputFocus = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.checkValidity();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    BaseInput.prototype.onBaseInput = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.checkValidity();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    BaseInput.prototype.onBlur2 = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.checkValidity();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    BaseInput.prototype.onBaseInputChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.checkValidity();
    };
    /**
     * @return {?}
     */
    BaseInput.prototype.checkValidity = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    BaseInput.prototype.validateOnInit = /**
     * @return {?}
     */
    function () {
        return true;
    };
    /**
     * @return {?}
     */
    BaseInput.prototype.isVali1d = /**
     * @return {?}
     */
    function () {
        return true;
    };
    return BaseInput;
}(ValueAccessorBase));

var __extends$25 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
/**
 * @template T
 */
var ListBaseComponent = /** @class */ (function (_super) {
    __extends$25(ListBaseComponent, _super);
    function ListBaseComponent(renderer, element, cd) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        _this.element = element;
        _this.cd = cd;
        _this.self = false;
        _this.itemClick = false;
        _this.hide();
        return _this;
    }
    /**
     * @param {?} event
     * @return {?}
     */
    ListBaseComponent.prototype.onFocusEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'visible' };
        this.bindDocumentClickListener();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ListBaseComponent.prototype.blur = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.itemClicked();
    };
    /**
     * @return {?}
     */
    ListBaseComponent.prototype.itemClicked = /**
     * @return {?}
     */
    function () {
        this.itemClick = true;
        this.hide();
        this.unbindDocumentClickListener();
        this.clearClicks();
    };
    /**
     * @return {?}
     */
    ListBaseComponent.prototype.bindDocumentClickListener = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (!this.documentClickListener) {
            this.documentClickListener = this.renderer
                .listen('document', 'click', function (event) { return _this.handleDocumentListener(event); });
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ListBaseComponent.prototype.handleDocumentListener = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (!this.self && !this.itemClick) {
            this.hide();
            this.unbindDocumentClickListener();
        }
        this.clearClicks();
        this.cd.markForCheck();
    };
    /**
     * @return {?}
     */
    ListBaseComponent.prototype.clearClicks = /**
     * @return {?}
     */
    function () {
        this.self = false;
        this.itemClick = false;
    };
    /**
     * @return {?}
     */
    ListBaseComponent.prototype.unbindDocumentClickListener = /**
     * @return {?}
     */
    function () {
        if (this.documentClickListener) {
            this.documentClickListener();
            this.documentClickListener = null;
        }
    };
    /**
     * @return {?}
     */
    ListBaseComponent.prototype.hide = /**
     * @return {?}
     */
    function () {
        this.dropdownstyle = { visibility: 'hidden' };
    };
    return ListBaseComponent;
}(BaseInput));

var __extends$24 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 11/21/17
*/
var AmexioTypeAheadComponent = /** @class */ (function (_super) {
    __extends$24(AmexioTypeAheadComponent, _super);
    function AmexioTypeAheadComponent(displayFieldService, dataService, element, renderer, cd) {
        var _this = _super.call(this, renderer, element, cd) || this;
        _this.displayFieldService = displayFieldService;
        _this.dataService = dataService;
        _this.element = element;
        _this.displayValue = '';
        _this.onBlur = new i0.EventEmitter();
        _this.onInputOutput = new i0.EventEmitter();
        _this.onFocusOutput = new i0.EventEmitter();
        _this.change = new i0.EventEmitter();
        _this.onClick = new i0.EventEmitter();
        _this.isComponentValid = new i0.EventEmitter();
        _this.rowindex = 0;
        _this.maskloader = true;
        _this.ariaListExpand = false;
        _this.filterarray = [];
        return _this;
    }
    Object.defineProperty(AmexioTypeAheadComponent.prototype, "fieldlabel", {
        get: /**
         * @return {?}
         */
        function () {
            return this._fieldlabel;
        },
        /*
         Properties
         name : field-label
         datatype : string
         version : 4.0 onwards
         default :
         description : The label of this field
         */
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v != null && v.length > 0) {
                this._fieldlabel = v;
                this.initComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioTypeAheadComponent.prototype, "haslabel", {
        get: /**
         * @return {?}
         */
        function () {
            return this._haslabel;
        },
        /*
         Properties
         name : has-label
         datatype : boolean
         version : 4.0 onwards
         default : false
         description : Flag to set label
         */
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._haslabel = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioTypeAheadComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.setData(this._data);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioTypeAheadComponent.prototype, "key", {
        get: /**
         * @return {?}
         */
        function () {
            return this._key;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._key = v;
            this.displayfield = this._key;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dropdown = this.dropdownlist.toArray();
        setTimeout(function () {
            _this.dropdown.forEach(function (dropdown) {
                dropdown.template = _this.bodyTemplate;
            });
        }, 200);
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes["placeholder"] && !changes["placeholder"].isFirstChange()) {
            this.placeholder = changes["placeholder"].currentValue;
        }
    };
    /**
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.name = this.generateName(this.name, this.fieldlabel, 'typeaheadinput');
        this.componentId = this.createCompId('typeahead', this.displayfield);
        if (!this.valuefield) {
            this.valuefield = this.displayfield;
        }
        this.isValid = this.allowblank;
        this.isComponentValid.emit(this.allowblank);
        if (this.placeholder === '' || this.placeholder == null) {
            this.placeholder = 'Choose Option';
        }
        if (!this.triggerchar) {
            this.triggerchar = 1;
        }
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    };
    /**
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.generateIndex = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.viewdata.value.forEach(function (element, index) {
            element['index'] = _this.componentId + 'listitem' + index;
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.closeOnEScapeKey = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.ariaListExpand = false;
        this.hide();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.input = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.filterarray = [];
        var /** @type {?} */ value;
        this.displayValue = event.target.value;
        this.rowindex = 0;
        if (this.displayValue.length >= 0 && !this.self && this.displayValue.length >= this.triggerchar) {
            this.dropdownstyle = { visibility: 'visible' };
            this.ariaListExpand = true;
            this.bindDocumentClickListener();
        }
        else {
            this.dropdownstyle = { visibility: 'hidden' };
            this.ariaListExpand = false;
        }
        this.onInputOutput.emit(event);
        if (this.displayValue.length > 0) {
            if (this.displayValue === this.displayValue.toUpperCase()) {
                value = this.displayValue.toLowerCase();
            }
            else {
                value = this.displayValue;
            }
            this.viewdata.value.forEach(function (element) {
                if ((_this.displayFieldService.findValue(_this.displayfield, element).toLowerCase()).startsWith(value)) {
                    _this.filterarray.push(element);
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.focustoLast = /**
     * @return {?}
     */
    function () {
        this.rowindex = this.filterarray.length - 1;
        this.setScrollToList(this.rowindex);
        this.setAriaActiveDescendant(this.rowindex);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.focus = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.self = true;
        this.dropdownstyle = { visibility: 'hidden' };
        this.bindDocumentClickListener();
        this.onFocusOutput.emit(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.keyup = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ keycode = event.keyCode;
        if (keycode === 40) {
            this.rowindex++;
        }
        else if (keycode === 38) {
            this.rowindex--;
        }
        else if (keycode === 40 || keycode === 38) {
            this.rowindex = 0;
        }
        if (this.rowindex < 0) {
            this.rowindex = this.filterarray.length - 1;
        }
        else if (this.rowindex >= this.filterarray.length) {
            this.rowindex = 0;
        }
        this.setAriaActiveDescendant(this.rowindex);
        if (keycode === 13) {
            var /** @type {?} */ data = this.dropdown[0].selectedItem();
            this.value = data[0].attributes['valuefield'].value;
            this.displayValue = data[0].attributes['displayfield'].value;
            this.itemClicked();
            this.isComponentValid.emit(true);
        }
        else if (keycode === 40 || keycode === 38) {
            this.dropdown[0].scroll(this.rowindex);
        }
    };
    // METHOS FOR BLUR EVENT
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.blur = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        _super.prototype.blur.call(this, event);
        var /** @type {?} */ userinput = event.target.value;
        var /** @type {?} */ listitems = this.viewdata.value;
        listitems.forEach(function (item) {
            if ((_this.displayFieldService.findValue(_this.displayfield, item) + '').toLowerCase() === userinput.toLowerCase()) {
                _this.displayValue = _this.displayFieldService.findValue(_this.displayfield, item);
                _this.value = item[_this.valuefield];
                _this.isComponentValid.emit(true);
            }
        });
        this.onBlur.emit(event);
    };
    // METHOD TO DISPLAY ITEM WHEN SELECTED
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.onDropDownListItemClick = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (this.valuefield) {
            this.value = data[this.valuefield];
        }
        else {
            this.value = this.displayFieldService.findValue(this.displayfield, data);
        }
        this.displayValue = this.displayFieldService.findValue(this.displayfield, data);
        this.onClick.emit(data);
        this.ariaListExpand = false;
    };
    // METHOD TO READ CURRENT ELEMENT FOCUSED
    /**
     * @param {?} rowindex
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.setAriaActiveDescendant = /**
     * @param {?} rowindex
     * @return {?}
     */
    function (rowindex) {
        if (this.filterarray.length > 0) {
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', this.filterarray[rowindex].index);
        }
        else if (this.displayValue.length < 1) {
            var /** @type {?} */ inputid = document.getElementById(this.componentId);
            inputid.setAttribute('aria-activedescendant', 'listitem');
        }
    };
    // METHOD TO SET SCROLL BASED ON ROWINDEX
    /**
     * @param {?} rowindex
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.setScrollToList = /**
     * @param {?} rowindex
     * @return {?}
     */
    function (rowindex) {
        var /** @type {?} */ listitems = this.element.nativeElement.getElementsByClassName('list-items')[rowindex];
        if (listitems) {
            listitems.scrollIntoView({ behavior: 'smooth' });
        }
    };
    /**
     * @param {?} v
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.writeValue = /**
     * @param {?} v
     * @return {?}
     */
    function (v) {
        _super.prototype.writeValue.call(this, v);
        if (v && this.viewdata) {
            this.showValue();
        }
    };
    /**
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.showValue = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ listitems = this.viewdata.value;
        listitems.forEach(function (item) {
            if (item[_this.valuefield] === _this.value) {
                _this.displayValue = _this.displayFieldService.findValue(_this.displayfield, item);
                _this.isComponentValid.emit(true);
            }
        });
    };
    // METHOD TO INITIALIZE COMPONENT
    /**
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.initComponent = /**
     * @return {?}
     */
    function () {
        if (this.fieldlabel != null && this.fieldlabel.length > 0) {
            this.haslabel = true;
        }
    };
    // METHOD TO EMIT CHANGE EVENT
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.onChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event != null) {
            this.change.emit(event);
        }
    };
    // METHOD TO SET DATA IN DROPDOWN
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var _this = this;
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewdata = of(responsedata);
        this.generateIndex();
        // SET USER SELECTION
        if (this.value != null) {
            var /** @type {?} */ valueKey_1 = this.valuefield;
            var /** @type {?} */ displayKey_1 = this.displayfield;
            var /** @type {?} */ val_1 = this.value;
            this.viewdata.forEach(function (item) {
                if (item[valueKey_1] === val_1) {
                    _this.isValid = true;
                    _this.displayValue = item[displayKey_1];
                }
            });
        }
        this.maskloader = false;
    };
    /**
     * @param {?} c
     * @return {?}
     */
    AmexioTypeAheadComponent.prototype.validate = /**
     * @param {?} c
     * @return {?}
     */
    function (c) {
        return ((!this.allowblank && this.value) || this.allowblank) ? null : {
            jsonParseError: {
                valid: true,
            },
        };
    };
    AmexioTypeAheadComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-typeahead',
                    template: "\n\n\n    <div class=\"inputgroup form-group\" (keyup.esc) =\"closeOnEScapeKey($event)\">\n\n      <label  id=\"fieldlabel\" for=\"{{componentId}}\"  *ngIf=\"haslabel\" [style.font-style]=\"fontstyle\" [style.font-family]=\"fontfamily\" [style.font-size]=\"fontsize\">\n        {{fieldlabel}}\n      </label>\n\n      <input type=\"hidden\"  [(ngModel)]=\"value\" [name]=\"name\" #model=\"ngModel\" required (ngModelChange)=\"onChange($event)\">\n  \n      <div class=\"input-container\" >\n              <input \n                      id=\"{{componentId}}\"\n                      aria-autocomplete=\"list\"\t\n                      role=\"combobox\"\n                      [attr.aria-expanded]=\"ariaListExpand\"\n                      type=\"text\" class=\"input-control\"\n                      [ngClass]=\"{'input-control-error': ((model.dirty || model.touched || (value && value.length>0)) && !model.valid),\n                      'input-disabled' : disabled}\"\n                      [required]=\"!allowblank\" \n                      [value]=\"displayValue\"\n                      [attr.placeholder]=\"placeholder\"\n                      [attr.disabled] = \"disabled ? true: null\"\n                      (focus)=\"focus($event)\"\n                      (input)=\"input($event)\"\n                      (keyup)=\"keyup($event)\"\n                      (blur)=\"blur($event)\"\n                      (keyup.end)=\"focustoLast()\"\n                      />\n              <em *ngIf=\"(iconfeedback && (model.dirty || model.touched) && model.valid)\" class=\"fa fa-check\"></em>\n              <em *ngIf=\"(iconfeedback && (model.dirty || model.touched) && !model.valid)\" class=\"fa fa-times icon-error\"></em>\n      </div>\n  \n      <dropdown-list-item [@changeState]=\"dropdownstyle.visibility\" class=\"dropdown\" [ngStyle]=\"dropdownstyle\"  \n                          [data]=\"viewdata\" [display-field]=\"displayfield\" [value-field]=\"valuefield\" \n                          [highlight-row]=\"rowindex\" [display-value]=\"displayValue\" \n                          (itemclick)=\"onDropDownListItemClick($event)\">\n      </dropdown-list-item>\n    </div>\n  ",
                    animations: [
                        trigger('changeState', [
                            state('visible', style({
                                'max-height': '200px',
                            })),
                            state('hidden', style({
                                'max-height': '0px',
                            })),
                            transition('*=>*', animate('200ms')),
                        ]),
                    ],
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: AmexioTypeAheadComponent,
                            multi: true,
                        }, {
                            provide: forms.NG_VALIDATORS, useExisting: i0.forwardRef(function () { return AmexioTypeAheadComponent; }), multi: true,
                        }],
                },] },
    ];
    /** @nocollapse */
    AmexioTypeAheadComponent.ctorParameters = function () { return [
        { type: DisplayFieldService },
        { type: CommonDataService },
        { type: i0.ElementRef },
        { type: i0.Renderer2 },
        { type: i0.ChangeDetectorRef }
    ]; };
    AmexioTypeAheadComponent.propDecorators = {
        fieldlabel: [{ type: i0.Input, args: ['field-label',] }],
        haslabel: [{ type: i0.Input, args: ['has-label',] }],
        data: [{ type: i0.Input, args: ['data',] }],
        key: [{ type: i0.Input, args: ['key',] }],
        allowblank: [{ type: i0.Input, args: ['allow-blank',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        valuefield: [{ type: i0.Input, args: ['value-field',] }],
        placeholder: [{ type: i0.Input, args: ['place-holder',] }],
        iconfeedback: [{ type: i0.Input, args: ['icon-feedback',] }],
        fontstyle: [{ type: i0.Input, args: ['font-style',] }],
        fontfamily: [{ type: i0.Input, args: ['font-family',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        enablepopover: [{ type: i0.Input, args: ['enable-popover',] }],
        triggerchar: [{ type: i0.Input, args: ['trigger-char',] }],
        name: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }],
        onBlur: [{ type: i0.Output }],
        onInputOutput: [{ type: i0.Output, args: ['input',] }],
        onFocusOutput: [{ type: i0.Output, args: ['focus',] }],
        change: [{ type: i0.Output }],
        onClick: [{ type: i0.Output }],
        isComponentValid: [{ type: i0.Output }],
        model: [{ type: i0.ViewChild, args: [forms.NgModel,] }],
        dropdownlist: [{ type: i0.ViewChildren, args: [DropDownListComponent,] }],
        bodyTemplate: [{ type: i0.ContentChild, args: ['amexioBodyTmpl',] }]
    };
    return AmexioTypeAheadComponent;
}(ListBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*/
var AmexioInputHelperComponent = /** @class */ (function () {
    function AmexioInputHelperComponent() {
        this.isNumberComponent = false;
        this.help = [];
    }
    Object.defineProperty(AmexioInputHelperComponent.prototype, "errormsg", {
        get: /**
         * @return {?}
         */
        function () {
            return this._errormsg;
        },
        // error Msg
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._errormsg = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioInputHelperComponent.prototype, "minmsg", {
        get: /**
         * @return {?}
         */
        function () {
            return this._minmsg;
        },
        // Min Msg
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._minmsg = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioInputHelperComponent.prototype, "maxmsg", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maxmsg;
        },
        // Max Msg
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._maxmsg = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioInputHelperComponent.prototype, "minerrormsg", {
        get: /**
         * @return {?}
         */
        function () {
            return this._minerrormsg;
        },
        // mini error msg
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._minerrormsg = v;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioInputHelperComponent.prototype, "maxerrormsg", {
        get: /**
         * @return {?}
         */
        function () {
            return this._maxerrormsg;
        },
        // max error msg
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            this._maxerrormsg = v;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioInputHelperComponent.prototype.createHelpMsg = /**
     * @return {?}
     */
    function () {
        if (this.errormsg && this.errormsg.length > 0) {
            this.help.push(this.errormsg);
        }
        if (this.errormsg && this.errormsg.length > 0) {
            this.help.push(this.errormsg);
        }
        if (this.errormsg && this.errormsg.length > 0) {
            this.help.push(this.errormsg);
        }
    };
    AmexioInputHelperComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'input-help',
                    template: "\n      <div  class=\"input-helper dropdown tooltiptext\">\n          <div *ngIf=\"minmsg\">\n              {{minmsg}}\n          </div>\n          <div *ngIf=\"maxmsg\">\n              {{maxmsg}}\n          </div>\n          <div *ngIf=\"errormsg\">\n              {{errormsg}}\n          </div>\n          <div *ngIf=\"!isNumberComponent && minerrormsg\">\n              <b>Min Length:</b> {{minerrormsg}} \n          </div>\n          <div *ngIf=\"!isNumberComponent && maxerrormsg\">\n              <b>Max Length: </b> {{maxerrormsg}} \n          </div> \n          <div *ngIf=\"isNumberComponent && minvalue && minvalue >0 && minerrormsg\">\n              <b>Min Value:</b> {{minerrormsg}} \n          </div>\n          <div *ngIf=\"isNumberComponent && maxvalue && maxvalue >0 && maxerrormsg\">\n              <b>Max Value:</b> {{maxerrormsg}} \n          </div>\n  \n      </div>\n    ",
                    styles: ["\n      .input-helper{overflow:auto;position:absolute;width:100%;max-height:200px;-webkit-box-shadow:0 1px 3px 0 #ced4da;box-shadow:0 1px 3px 0 #ced4da}\n    "],
                },] },
    ];
    /** @nocollapse */
    AmexioInputHelperComponent.ctorParameters = function () { return []; };
    AmexioInputHelperComponent.propDecorators = {
        minlength: [{ type: i0.Input, args: ['min-length',] }],
        maxlength: [{ type: i0.Input, args: ['max-length',] }],
        minvalue: [{ type: i0.Input, args: ['min-value',] }],
        maxvalue: [{ type: i0.Input, args: ['max-value',] }],
        isNumberComponent: [{ type: i0.Input, args: ['is-number',] }],
        errormsg: [{ type: i0.Input, args: ['error-msg',] }],
        minmsg: [{ type: i0.Input, args: ['min-msg',] }],
        maxmsg: [{ type: i0.Input, args: ['max-msg',] }],
        minerrormsg: [{ type: i0.Input, args: ['min-error-msg',] }],
        maxerrormsg: [{ type: i0.Input, args: ['max-error-msg',] }]
    };
    return AmexioInputHelperComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioAccordionTabComponent = /** @class */ (function () {
    function AmexioAccordionTabComponent() {
        /*
          Events
          name : emittedEvent
          datatype :none
          version : none
          default : none
          description : Fires the on accordion pane click event.
          */
        this.emittedEvent = new i0.EventEmitter();
        this.expanded = false;
        this.isSelected = false;
        this.currentstate = 'hidden';
    }
    /**
     * @return {?}
     */
    AmexioAccordionTabComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = '' + Math.floor(Math.random() * 1000 + 999);
        this.emittedEvent.emit({ keydown: true, current: this });
    };
    /**
     * @return {?}
     */
    AmexioAccordionTabComponent.prototype.emitEvent = /**
     * @return {?}
     */
    function () {
        if (!this.disabled) {
            this.active = !this.active;
            this.emittedEvent.emit({ keydown: false, current: this });
        }
        if (this.active) {
            this.currentstate = 'visible';
        }
        else {
            this.currentstate = 'hidden';
        }
    };
    /**
     * @return {?}
     */
    AmexioAccordionTabComponent.prototype.onEnterClick = /**
     * @return {?}
     */
    function () {
        this.expanded = !this.expanded;
    };
    /**
     * @return {?}
     */
    AmexioAccordionTabComponent.prototype.onArrowDown = /**
     * @return {?}
     */
    function () {
        this.emittedEvent.emit({ keydown: true, current: this });
    };
    /**
     * @return {?}
     */
    AmexioAccordionTabComponent.prototype.onArrowUp = /**
     * @return {?}
     */
    function () {
        this.emittedEvent.emit({ keyup: true, current: this });
    };
    AmexioAccordionTabComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-accordion-tab',
                    template: "\n    <button #btn role=\"button\" id=\"{{componentId}}\" tabindex=\"0\" (click)=\"emitEvent()\" [attr.aria-expanded]=\"active\"\n      (keyup.enter)=\"onEnterClick()\" (keyup.arrowdown)=\"onArrowDown()\" (keyup.arrowup)=\"onArrowUp()\" class=\"{{isTransparent ? 'accordion-transparent' : 'accordion'}} {{active ? 'active-accordion' : ''}} {{disabled ? 'accordion-disable' : ''}}\"\n      (mouseover)=\"hover=true\" (mouseleave)=\"hover=false\" [ngStyle]=\"{color: hover==true ? bgColor : color, backgroundColor: hover==true  ? color : bgColor}\">\n      <div style=\"float: left;\" *ngIf=\"leftIcon\">\n        <em class=\"fa {{leftIcon}}\"></em>\n      </div>\n      <ng-container>\n        {{header}}\n        <div style=\"float: right\" role=\"img\" aria-label=\"close push button\" tabindex=\"0\">\n          <ng-content select=\"amexio-accordion-header\">&nbsp;</ng-content> &nbsp;\n          <em *ngIf=\"!angleIcon\" class=\"fa\" [ngClass]=\"{'fa-plus' : !active,'fa-minus' : active}\" aria-hidden=\"true\"></em>\n          <em *ngIf=\"angleIcon\" class=\"fa\" [ngClass]=\"{'fa-angle-down' : !active,'fa-angle-up' : active}\" aria-hidden=\"true\"></em>\n        </div>\n      </ng-container>\n    </button>\n    <div role=\"region\" attr.aria-labelledby=\"{{componentId}}\" tabindex=\"0\" [@accordionState]=\"active ? 'visible':'hidden'\"\n      class=\"panel\">\n      <ng-content></ng-content>\n    </div>\n  ",
                    animations: [
                        trigger('accordionState', [
                            state('hidden', style({
                                display: 'none',
                                height: '0px',
                            })),
                            state('visible', style({
                                display: 'block',
                                height: '*',
                            })),
                            transition('*=>hidden', animate('0ms')),
                            transition('*=>visible', animate('200ms')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioAccordionTabComponent.ctorParameters = function () { return []; };
    AmexioAccordionTabComponent.propDecorators = {
        header: [{ type: i0.Input }],
        active: [{ type: i0.Input }],
        emittedEvent: [{ type: i0.Output }],
        leftIcon: [{ type: i0.Input, args: ['left-icon',] }],
        angleIcon: [{ type: i0.Input, args: ['angle-icon',] }],
        disabled: [{ type: i0.Input, args: ['disabled',] }],
        data: [{ type: i0.Input, args: ['data',] }],
        btn: [{ type: i0.ViewChild, args: ['btn',] }]
    };
    return AmexioAccordionTabComponent;
}());

var __extends$27 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioAccordionComponent = /** @class */ (function (_super) {
    __extends$27(AmexioAccordionComponent, _super);
    function AmexioAccordionComponent() {
        var _this = _super.call(this) || this;
        _this.flag = false;
        _this.prevaccindex = -1;
        _this.accindex = -1;
        _this.flag = true;
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioAccordionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @return {?}
     */
    AmexioAccordionComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
    };
    /**
     * @return {?}
     */
    AmexioAccordionComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.accordionCollections = this.queryTabs.toArray();
        this.accordionCollections.forEach(function (node) { return node.emittedEvent.subscribe(function (eventdata) { return _this.activateAccordionPane(eventdata); }); });
        this.accordionCollections.forEach(function (node, index) {
            if (_this.expandAll) {
                node.active = true;
            }
            else if (node.active) {
                node.active = true;
            }
            else {
                node.active = false;
            }
            if (_this.isTransparent) {
                node.isTransparent = true;
            }
            if (_this.angleIcon) {
                node.angleIcon = true;
            }
            if (_this.color) {
                node.color = _this.color;
            }
            if (_this.bgColor) {
                node.bgColor = _this.bgColor;
            }
            node['index'] = node.componentId;
        });
    };
    /**
     * @param {?} nodeEvent
     * @return {?}
     */
    AmexioAccordionComponent.prototype.activateAccordionPane = /**
     * @param {?} nodeEvent
     * @return {?}
     */
    function (nodeEvent) {
        var /** @type {?} */ node = nodeEvent.current;
        if (nodeEvent.keydown) {
            this.onkeyDown();
        }
        else if (nodeEvent.keyup) {
            this.onkeyUp();
        }
        else {
            this.accordionCollections.forEach(function (tab) {
                if (tab === node) {
                    tab.active = node.active;
                }
                else {
                    tab.active = false;
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AmexioAccordionComponent.prototype.onkeyDown = /**
     * @return {?}
     */
    function () {
        this.onPreAccIndex();
        this.accindex++;
        this.prevaccindex = this.accindex;
        if (this.accindex >= this.accordionCollections.length) {
            this.accindex = 0;
            this.prevaccindex = 0;
        }
        this.setAccoordionActive(this.accindex);
    };
    /**
     * @return {?}
     */
    AmexioAccordionComponent.prototype.onkeyUp = /**
     * @return {?}
     */
    function () {
        this.onPreAccIndex();
        this.prevaccindex--;
        if (this.prevaccindex === -1) {
            this.prevaccindex = this.accordionCollections.length - 1;
            this.accindex = -1;
        }
        this.setAccoordionActive(this.prevaccindex);
        if (this.prevaccindex === 0) {
            this.accindex = 0;
        }
    };
    /**
     * @return {?}
     */
    AmexioAccordionComponent.prototype.onPreAccIndex = /**
     * @return {?}
     */
    function () {
        if (this.prevaccindex > -1) {
            this.accordionCollections[this.prevaccindex]['isSelected'] = false;
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    AmexioAccordionComponent.prototype.setAccoordionActive = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.accordionCollections[index]['isSelected'] = true;
        if (this.accordionCollections[index]['isSelected']) {
            this.accordionCollections[index].btn.nativeElement.focus();
        }
    };
    /**
     * @return {?}
     */
    AmexioAccordionComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
    };
    AmexioAccordionComponent.decorators = [
        { type: i0.Component, args: [{ selector: 'amexio-accordion', template: "\n\n  <ng-content  select=\"amexio-accordion-tab\"></ng-content>\n" },] },
    ];
    /** @nocollapse */
    AmexioAccordionComponent.ctorParameters = function () { return []; };
    AmexioAccordionComponent.propDecorators = {
        expandAll: [{ type: i0.Input, args: ['expand-all',] }],
        isTransparent: [{ type: i0.Input, args: ['transparent',] }],
        angleIcon: [{ type: i0.Input, args: ['angle-icon',] }],
        bgColor: [{ type: i0.Input, args: ['background',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        queryTabs: [{ type: i0.ContentChildren, args: [AmexioAccordionTabComponent,] }]
    };
    return AmexioAccordionComponent;
}(LifeCycleBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioAccordionHeaderComponent = /** @class */ (function () {
    function AmexioAccordionHeaderComponent() {
    }
    /**
     * @return {?}
     */
    AmexioAccordionHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioAccordionHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-accordion-header', template: "\n    <ng-content></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioAccordionHeaderComponent.ctorParameters = function () { return []; };
    AmexioAccordionHeaderComponent.propDecorators = {
        padding: [{ type: i0.Input }]
    };
    return AmexioAccordionHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LayoutConstant = {
    'start': 'flex-start',
    'end': 'flex-end',
    'center': 'center',
    'space-between': 'space-between',
    'space-around': 'space-around',
    'space-evenly': 'space-evenly',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioLayoutComponent = /** @class */ (function () {
    function AmexioLayoutComponent(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.orientation = 'horizontal';
        this.responsiveMode = false;
        this.border = true;
        this.fit = true;
        var /** @type {?} */ that = this;
        this.matchMediaService.OnDesktop(function (mediaQueryList) {
            that.handleDeviceSettings();
        });
        this.matchMediaService.OnTablet(function (mediaQueryList) {
            that.handleDeviceSettings();
        });
        this.matchMediaService.OnPhone(function (mediaQueryList) {
            that.handleDeviceSettings();
        });
    }
    /**
     * @return {?}
     */
    AmexioLayoutComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.setLayoutDefination();
        this.handleDeviceSettings();
    };
    /**
     * @return {?}
     */
    AmexioLayoutComponent.prototype.setLayoutDefination = /**
     * @return {?}
     */
    function () {
        this.setorientation();
        this.setAlignment();
        this.setBorder();
        this.setFit();
    };
    /**
     * @return {?}
     */
    AmexioLayoutComponent.prototype.setorientation = /**
     * @return {?}
     */
    function () {
        this.updateOrientation(this.orientation);
    };
    /**
     * @param {?} orientationName
     * @return {?}
     */
    AmexioLayoutComponent.prototype.updateOrientation = /**
     * @param {?} orientationName
     * @return {?}
     */
    function (orientationName) {
        if (orientationName && orientationName.toLowerCase() === 'vertical') {
            this.orientationDirection = 'column';
        }
        else {
            this.orientationDirection = 'row';
        }
    };
    /**
     * @return {?}
     */
    AmexioLayoutComponent.prototype.setAlignment = /**
     * @return {?}
     */
    function () {
        if (this.alignment && LayoutConstant[this.alignment.toLowerCase()]) {
            this.justifyContent = LayoutConstant[this.alignment.toLowerCase()];
        }
        else {
            this.justifyContent = 'start';
        }
    };
    /**
     * @return {?}
     */
    AmexioLayoutComponent.prototype.setBorder = /**
     * @return {?}
     */
    function () {
        if (this.border) {
            this.borderstyle = '1px solid #ced4da';
            this.borderboxstyle = '0 2px 2px 0 rgba(0,0,0,.14)';
        }
    };
    /**
     * @return {?}
     */
    AmexioLayoutComponent.prototype.setFit = /**
     * @return {?}
     */
    function () {
        if (this.fit) {
            this.height = '100%';
        }
    };
    /**
     * @return {?}
     */
    AmexioLayoutComponent.prototype.handleDeviceSettings = /**
     * @return {?}
     */
    function () {
        if (!this.responsiveMode) {
            if (this.matchMediaService.IsPhone()) {
                this.updateOrientation('vertical');
            }
            else {
                this.updateOrientation(this.orientation);
            }
        }
    };
    AmexioLayoutComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-layout-columns',
                    template: "\n      <ng-content></ng-content>\n    ",
                    styles: ["\n    :host {\n        display: flex;\n    }\n  "],
                },] },
    ];
    /** @nocollapse */
    AmexioLayoutComponent.ctorParameters = function () { return [
        { type: DeviceQueryService }
    ]; };
    AmexioLayoutComponent.propDecorators = {
        orientation: [{ type: i0.Input, args: ['orientation',] }],
        responsiveMode: [{ type: i0.Input, args: ['responsive-mode',] }],
        alignment: [{ type: i0.Input, args: ['alignment',] }],
        border: [{ type: i0.Input, args: ['border',] }],
        fit: [{ type: i0.Input, args: ['fit',] }],
        orientationDirection: [{ type: i0.HostBinding, args: ['style.flex-direction',] }],
        justifyContent: [{ type: i0.HostBinding, args: ['style.justify-content',] }],
        borderstyle: [{ type: i0.HostBinding, args: ['style.border',] }],
        borderboxstyle: [{ type: i0.HostBinding, args: ['style.box-shadow',] }],
        height: [{ type: i0.HostBinding, args: ['style.height',] }]
    };
    return AmexioLayoutComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioLayoutItemComponent = /** @class */ (function () {
    function AmexioLayoutItemComponent() {
    }
    /**
     * @return {?}
     */
    AmexioLayoutItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.fit) {
            this.flexgrow = 1;
        }
        if (this.padding) {
            this.lipadding = this.padding;
        }
    };
    AmexioLayoutItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-layout-item',
                    template: "\n        <ng-content></ng-content>\n    ",
                },] },
    ];
    AmexioLayoutItemComponent.propDecorators = {
        fit: [{ type: i0.Input, args: ['fit',] }],
        padding: [{ type: i0.Input, args: ['padding',] }],
        flexgrow: [{ type: i0.HostBinding, args: ['style.flex-grow',] }],
        lipadding: [{ type: i0.HostBinding, args: ['style.padding',] }]
    };
    return AmexioLayoutItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 1/4/18.
*/
var AmexioBorderLayoutItemComponent = /** @class */ (function () {
    function AmexioBorderLayoutItemComponent() {
        this.positionClass = 'borderlayout-';
        this.role = this.positionClass;
    }
    /**
     * @return {?}
     */
    AmexioBorderLayoutItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioBorderLayoutItemComponent.prototype.getClassType = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ pos = '';
        if (this.position.toLowerCase() === 'north') {
            pos = 'N';
        }
        else if (this.position.toLowerCase() === 'east') {
            pos = 'E';
        }
        else if (this.position.toLowerCase() === 'center') {
            pos = 'C';
        }
        else if (this.position.toLowerCase() === 'west') {
            pos = 'W';
        }
        else if (this.position.toLowerCase() === 'south') {
            pos = 'S';
        }
        this.positionClass = this.positionClass + pos;
        this.role = this.positionClass;
        return pos;
    };
    AmexioBorderLayoutItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-borderlayout-item',
                    template: "\n    <div tabindex=\"0\" attr.aria-label=\"borderlayoutitem{{position}}\">\n        <aside style=\"height:100%;\">\n            <ng-content></ng-content>\n        </aside>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioBorderLayoutItemComponent.ctorParameters = function () { return []; };
    AmexioBorderLayoutItemComponent.propDecorators = {
        position: [{ type: i0.Input }],
        role: [{ type: i0.HostBinding, args: ['attr.class',] }]
    };
    return AmexioBorderLayoutItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioBorderLayoutComponent = /** @class */ (function () {
    function AmexioBorderLayoutComponent() {
        this.borderclass = 'borderlayout-container';
    }
    /**
     * @return {?}
     */
    AmexioBorderLayoutComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioBorderLayoutComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.layoutitems = this.layout.toArray();
        this.layoutitems.forEach(function (item) {
            _this.borderclass = _this.borderclass + '-' + item.getClassType();
        });
    };
    AmexioBorderLayoutComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-borderlayout',
                    template: "\n    <span tabindex=\"0\" aria-label=\"borderlayout\">\n      <section [ngClass]=\"borderclass\">\n        <ng-content></ng-content>\n      </section>\n    </span>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioBorderLayoutComponent.ctorParameters = function () { return []; };
    AmexioBorderLayoutComponent.propDecorators = {
        layout: [{ type: i0.ContentChildren, args: [AmexioBorderLayoutItemComponent,] }]
    };
    return AmexioBorderLayoutComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioBoxComponent = /** @class */ (function () {
    function AmexioBoxComponent() {
        /*
        Properties
        name : padding
        datatype : boolean
        version : 4.1 onwards
        default : false
        description : Padding to all sides
        */
        this.padding = false;
        /*
        Properties
        name : border-dotted
        datatype : boolean
        version : 4.1.8 onwards
        default : false
        description : Dotted border
        */
        this.borderDotted = false;
        /*
        Properties
        name : closable
        datatype : boolean
        version : 4.1.8 onwards
        default : false
        description : closable box
        */
        this.closable = false;
        this.close = true;
    }
    /**
     * @return {?}
     */
    AmexioBoxComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.borderColor == null) {
            this.borderColor = 'box-default';
        }
        if (this.borderColor != null && this.bgColor == null) {
            this.bgColor = this.borderColor;
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioBoxComponent.prototype.closeBox = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.close = false;
        this.closable = false;
    };
    AmexioBoxComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-box',
                    template: "\n   <div for=\"boxText\" id=\"{{componentId}}\" class=\"box-content\" *ngIf=\"close\" [style.height]=\"height ? height:'none'\" [style.width]=\"width ? width:'none'\" [style.align]=\"align ? align:'none'\" [ngClass]=\"{\n   'box-default': borderColor=='default' || borderColor ==null,\n   'border-topbar': border=='top',\n   'border-bottombar': border =='bottom',\n   'border-rightbar': border =='right',\n   'border-leftbar': border =='left',\n   'border-all' : border =='all',\n   'border-top-bottom' : border =='top-bottom' || border =='bottom-top',\n   'border-right-left' : border =='right-left' || border =='left-right',\n\n   'bg-brown': bgColor=='brown', \n   'bg-red': bgColor=='red',\n   'bg-green': bgColor=='green',\n   'bg-yellow': bgColor=='yellow',\n   'bg-blue': bgColor=='blue',\n   'bg-purple': bgColor=='purple',\n   'bg-theme-color' : bgColor =='theme-color',\n   'box-transparent' : bgColor =='transparent',\n\n   'border-theme-color' : borderColor =='theme-color',\n   'border-red' : borderColor =='red',\n   'border-yellow' : borderColor =='yellow',\n   'border-green' : borderColor =='green',\n   'border-blue' : borderColor =='blue',\n   'border-brown' : borderColor =='brown',\n   'border-purple' : borderColor =='purple',\n   'border-transparent' : borderColor =='transparent',\n   'padding' : padding,\n   'border-dotted' : borderDotted\n    }\">\n       <span *ngIf=\"closable\" class=\"box-close\">\n    <amexio-c-icon key=\"tab_close\" (onClick)=\"closeBox($event)\"></amexio-c-icon>\n    </span>\n       <span role=\"tooltip\" tabindex=\"0\" id=\"boxText\" name=\"boxText\" attr.aria-labelledby=\"{{componentId}}\">\n     <ng-content ></ng-content>\n   </span>\n   </div>\n ",
                },] },
    ];
    /** @nocollapse */
    AmexioBoxComponent.ctorParameters = function () { return []; };
    AmexioBoxComponent.propDecorators = {
        border: [{ type: i0.Input, args: ['border',] }],
        borderColor: [{ type: i0.Input, args: ['border-color',] }],
        bgColor: [{ type: i0.Input, args: ['background-color',] }],
        padding: [{ type: i0.Input, args: ['padding',] }],
        height: [{ type: i0.Input, args: ['box-height',] }],
        width: [{ type: i0.Input, args: ['box-width',] }],
        borderDotted: [{ type: i0.Input, args: ['border-dotted',] }],
        align: [{ type: i0.Input, args: ['align',] }],
        closable: [{ type: i0.Input, args: ['closable',] }]
    };
    return AmexioBoxComponent;
}());

var __extends$28 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/18/17.
*/
var AmexioCardComponent = /** @class */ (function (_super) {
    __extends$28(AmexioCardComponent, _super);
    function AmexioCardComponent(renderer) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        /*
        Properties
        name : show
        datatype :  boolean
        version : 4.0 onwards
        default : true
        description : User can bind variable to this and hide/unhide card based on requirement..
        */
        _this.show = true;
        _this.nodeRightClick = new i0.EventEmitter();
        _this.rightClick = new i0.EventEmitter();
        _this.mouseLocation = { left: 0, top: 0 };
        _this.headeralign = 'left';
        _this.footeralign = 'right';
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioCardComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @return {?}
     */
    AmexioCardComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
    };
    /**
     * @return {?}
     */
    AmexioCardComponent.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioCardComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        // FOR HEADER PADING
        this.headerComponentList = this.amexioHeader.toArray();
        this.headerComponentList.forEach(function (item, currentIndex) {
            if (item.padding) {
                _this.headerPadding = item.padding;
            }
        });
        // FOR BODY PADDING
        this.bodyComponentList = this.amexioBody.toArray();
        this.bodyComponentList.forEach(function (item, currentIndex) {
            if (item.padding) {
                _this.bodyPadding = item.padding;
            }
        });
        // FOR FOOTER PADDING
        this.footerComponentList = this.amexioFooter.toArray();
        this.footerComponentList.forEach(function (item, currentIndex) {
            if (item.padding) {
                _this.footerPadding = item.padding;
            }
            item.footer = _this.footer;
            item.setFooterAlignment(_this.footeralign);
        });
        this.onResize();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCardComponent.prototype.adjustHeight = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onResize();
    };
    // Calculate body size based on browser height
    /**
     * @return {?}
     */
    AmexioCardComponent.prototype.onResize = /**
     * @return {?}
     */
    function () {
        if (this.bodyheight) {
            var /** @type {?} */ h = (window.innerHeight / 100) * this.bodyheight;
            if (this.cardHeader && this.cardHeader.nativeElement && this.cardHeader.nativeElement.offsetHeight) {
                h = h - this.cardHeader.nativeElement.offsetHeight;
            }
            if (this.cardFooter && this.cardFooter.nativeElement && this.cardFooter.nativeElement.offsetHeight) {
                h = h - this.cardFooter.nativeElement.offsetHeight;
            }
            if (this.bodyheight === 100) {
                h = h - 40;
            }
            this.minHeight = h;
            this.height = h;
        }
    };
    /**
     * @return {?}
     */
    AmexioCardComponent.prototype.getContextMenu = /**
     * @return {?}
     */
    function () {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioCardComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    AmexioCardComponent.prototype.loadContextMenu = /**
     * @param {?} rightClickData
     * @return {?}
     */
    function (rightClickData) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.mouseLocation.left = rightClickData.event.clientX;
            this.mouseLocation.top = rightClickData.event.clientY;
            this.getContextMenu();
            this.posixUp = this.getListPosition(rightClickData.ref);
            rightClickData.event.preventDefault();
            rightClickData.event.stopPropagation();
            this.rightClickNodeData = rightClickData.data;
            this.nodeRightClick.emit(rightClickData);
        }
    };
    /**
     * @param {?} Data
     * @return {?}
     */
    AmexioCardComponent.prototype.rightClickDataEmit = /**
     * @param {?} Data
     * @return {?}
     */
    function (Data) {
        this.rightClick.emit(Data);
    };
    /**
     * @return {?}
     */
    AmexioCardComponent.prototype.addListner = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.globalClickListenFunc = this.renderer.listen('document', 'click', function (e) {
            _this.flag = false;
            if (!_this.flag) {
                _this.removeListner();
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioCardComponent.prototype.removeListner = /**
     * @return {?}
     */
    function () {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    };
    /**
     * @return {?}
     */
    AmexioCardComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
        this.removeListner();
    };
    AmexioCardComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-card',
                    template: "\n    <div #id class=\"card-container\" *ngIf=\"show\" (window:resize)=\"onResize()\" (contextmenu)=\"loadContextMenu({event:$event,ref:id})\">\n        <header #cardHeader [style.padding]=\"headerPadding\" class=\"card-header\" *ngIf=\"header\"\n         [ngClass]=\"{'flex-start':(headeralign=='left'),'flex-end':(headeralign=='right'),'flex-center':(headeralign=='center')}\">\n            <ng-content select=\"amexio-header\"></ng-content>\n        </header>\n        <div class=\"card-body cardbody\" [style.padding]=\"bodyPadding\"\n         [ngStyle]=\"{'height.px' : height,'overflow-y' : height!= null ? 'auto' : '','min-height.px' : minHeight}\">\n            <ng-content select=\"amexio-body\"></ng-content>\n        </div>\n        <footer #cardFooter [style.padding]=\"footerPadding\" class=\"card-footer\" *ngIf=\"footer\"\n         [ngClass]=\"{'flex-start':(footeralign=='left'),'flex-end':(footeralign=='right'),'flex-center':(footeralign=='center')}\">\n            <ng-content select=\"amexio-action\"></ng-content>\n        </footer>\n    </div>\n\n    <ng-container *ngIf=\"flag\">\n        <base-contextmenu \n        [base-context-menu]=\"contextmenu\" \n        [mouse-location-top]=\"mouseLocation.top\"\n        [mouse-location-left]=\"mouseLocation.left\" \n        [is-FlagShow]=\"flag\" \n        [right-click-data]=\"nodeRightClick\"\n        (onRightClick) =\"rightClickDataEmit($event)\"\n        [position-up]=\"posixUp\">\n        </base-contextmenu>\n    </ng-container>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioCardComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };
    AmexioCardComponent.propDecorators = {
        headeralign: [{ type: i0.Input, args: ['header-align',] }],
        header: [{ type: i0.Input }],
        footer: [{ type: i0.Input }],
        footeralign: [{ type: i0.Input, args: ['footer-align',] }],
        show: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        minHeight: [{ type: i0.Input, args: ['min-height',] }],
        bodyheight: [{ type: i0.Input, args: ['body-height',] }],
        contextmenu: [{ type: i0.Input, args: ['context-menu',] }],
        parentRef: [{ type: i0.Input }],
        nodeRightClick: [{ type: i0.Output }],
        rightClick: [{ type: i0.Output }],
        cardHeader: [{ type: i0.ViewChild, args: ['cardHeader', { read: i0.ElementRef },] }],
        cardFooter: [{ type: i0.ViewChild, args: ['cardFooter', { read: i0.ElementRef },] }],
        amexioHeader: [{ type: i0.ContentChildren, args: [AmexioHeaderComponent,] }],
        amexioBody: [{ type: i0.ContentChildren, args: [AmexioBodyComponent,] }],
        amexioFooter: [{ type: i0.ContentChildren, args: [AmexioFooterComponent,] }]
    };
    return AmexioCardComponent;
}(LifeCycleBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 8/1/18.
*/
var AmexioColumnComponent = /** @class */ (function () {
    function AmexioColumnComponent() {
        this.role = this.colclass;
    }
    Object.defineProperty(AmexioColumnComponent.prototype, "size", {
        get: /**
         * @return {?}
         */
        function () {
            return this.size_;
        },
        /*
        Properties
        name : size
        datatype : any
        version : 4.0 onwards
        default :
        description : Column size*/
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this.size_ = value;
            this.colclass = 'flex-col flex-col-' + value;
            this.role = this.colclass;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioColumnComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioColumnComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-column', template: "\n\n    <div [ngStyle]=\"{'height':fit ? '100%':''}\">\n        <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioColumnComponent.ctorParameters = function () { return []; };
    AmexioColumnComponent.propDecorators = {
        role: [{ type: i0.HostBinding, args: ['attr.class',] }],
        fit: [{ type: i0.Input, args: ['fit',] }],
        size: [{ type: i0.Input }]
    };
    return AmexioColumnComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioGridLayoutService = /** @class */ (function () {
    function AmexioGridLayoutService() {
        this.layoutData = [];
    }
    /**
     * @param {?} dataLayout
     * @return {?}
     */
    AmexioGridLayoutService.prototype.createLayout = /**
     * @param {?} dataLayout
     * @return {?}
     */
    function (dataLayout) {
        var /** @type {?} */ findStatus = false;
        this.count = dataLayout.count;
        var /** @type {?} */ data = dataLayout.getLayout();
        data.count = this.count;
        if (this.layoutData.length <= 0) {
            this.layoutData.push(data);
        }
        else {
            this.layoutData.forEach(function (obj) {
                if (obj.name === data.name) {
                    obj[data.layoutType] = data[data.layoutType];
                    findStatus = true;
                }
            });
            if (!findStatus) {
                this.layoutData.push(data);
            }
        }
    };
    /**
     * @param {?} layoutName
     * @return {?}
     */
    AmexioGridLayoutService.prototype.getLayoutData = /**
     * @param {?} layoutName
     * @return {?}
     */
    function (layoutName) {
        return this.layoutData.find(function (obj) { return obj.name === layoutName; });
    };
    AmexioGridLayoutService.decorators = [
        { type: i0.Injectable },
    ];
    /** @nocollapse */
    AmexioGridLayoutService.ctorParameters = function () { return []; };
    return AmexioGridLayoutService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioGridItemComponent = /** @class */ (function () {
    function AmexioGridItemComponent() {
    }
    Object.defineProperty(AmexioGridItemComponent.prototype, "name", {
        get: /**
         * @return {?}
         */
        function () {
            return this._name;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._name = value;
            this.hostname = this._name;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioGridItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.insertStyleSheetRule('.' + this.name + '{ grid-area: ' + this.name + ' ; padding: 5px } ');
    };
    /**
     * @param {?} ruleText
     * @return {?}
     */
    AmexioGridItemComponent.prototype.insertStyleSheetRule = /**
     * @param {?} ruleText
     * @return {?}
     */
    function (ruleText) {
        var /** @type {?} */ sheets = document.styleSheets;
        if (sheets.length === 0) {
            var /** @type {?} */ style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        var /** @type {?} */ isCssAdded = false;
        for (var _i = 0, sheets_1 = sheets; _i < sheets_1.length; _i++) {
            var sh = sheets_1[_i];
            var /** @type {?} */ sheet = sh;
            if (!isCssAdded && (sheet && sheet.href === null && sheet.rules)) {
                try {
                    sheet.insertRule(ruleText, 0);
                    isCssAdded = true;
                }
                catch (/** @type {?} */ e) {
                }
            }
        }
    };
    AmexioGridItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-grid-item',
                    template: "\n          <ng-content></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioGridItemComponent.ctorParameters = function () { return []; };
    AmexioGridItemComponent.propDecorators = {
        hostname: [{ type: i0.HostBinding, args: ['class',] }],
        name: [{ type: i0.Input, args: ['name',] }]
    };
    return AmexioGridItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var GridConstants = /** @class */ (function () {
    function GridConstants() {
    }
    GridConstants.Tablet = 'tab';
    GridConstants.Desktop = 'desktop';
    GridConstants.Mobile = 'mobile';
    return GridConstants;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioGridComponent = /** @class */ (function () {
    function AmexioGridComponent(_gridlayoutService) {
        this._gridlayoutService = _gridlayoutService;
        this.isInit = false;
        this.desktopWidth = '(min-width: 1025px)';
        this.mobileWidth = '(max-width: 767px)';
        this.tabletWidth = '(min-width: 768px) and (max-width: 1024px)';
    }
    Object.defineProperty(AmexioGridComponent.prototype, "layout", {
        get: /**
         * @return {?}
         */
        function () {
            return this._layout;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            if (value != null) {
                this._layout = value;
                if (this.isInit) {
                    this.gridInit();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioGridComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.gridInit();
        this.isInit = true;
    };
    /**
     * @return {?}
     */
    AmexioGridComponent.prototype.gridInit = /**
     * @return {?}
     */
    function () {
        this.containerClass = '';
        this.className = '';
        this.cssGenreration(this._gridlayoutService.getLayoutData(this.layout));
    };
    /**
     * @return {?}
     */
    AmexioGridComponent.prototype.getCssAttribute = /**
     * @return {?}
     */
    function () {
        return 'display: grid;' + ' grid-gap: 5px;' + 'grid-template-columns: repeat(' + this.colCount + ', 1fr);';
    };
    /**
     * @param {?} ruleText
     * @return {?}
     */
    AmexioGridComponent.prototype.insertStyleSheetRuleParent = /**
     * @param {?} ruleText
     * @return {?}
     */
    function (ruleText) {
        var /** @type {?} */ sheets = document.styleSheets;
        if (sheets.length === 0) {
            var /** @type {?} */ style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        var /** @type {?} */ isCssAdded = false;
        for (var _i = 0, sheets_1 = sheets; _i < sheets_1.length; _i++) {
            var sh = sheets_1[_i];
            var /** @type {?} */ sheet = sh;
            if (!isCssAdded && (sheet && sheet.href === null && sheet.rules)) {
                try {
                    sheet.insertRule(ruleText, 0);
                    isCssAdded = true;
                }
                catch (/** @type {?} */ e) {
                }
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioGridComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.itemCollection = this.queryItem.toArray();
    };
    /**
     * @param {?} deviceName
     * @return {?}
     */
    AmexioGridComponent.prototype.dataCreation = /**
     * @param {?} deviceName
     * @return {?}
     */
    function (deviceName) {
        var _this = this;
        this.containerClass = '';
        deviceName.forEach(function (ele) {
            _this.containerClass = _this.containerClass + '"' + ele.join(' ') + '"';
        });
        return this.containerClass;
    };
    /**
     * @param {?} layoutData
     * @return {?}
     */
    AmexioGridComponent.prototype.cssGenreration = /**
     * @param {?} layoutData
     * @return {?}
     */
    function (layoutData) {
        this.colCount = layoutData.count;
        this.className = this.className + '' + layoutData.name;
        if (layoutData.desktop.length > 0) {
            this.cssGenerationCommonMethod(layoutData, this.desktopWidth, GridConstants.Desktop);
            if (layoutData.tab.length === 0) {
                this.cssGenerationCommonMethod(layoutData, this.tabletWidth, GridConstants.Desktop);
            }
            else {
                this.cssGenerationCommonMethod(layoutData, this.tabletWidth, GridConstants.Desktop);
                this.cssGenerationCommonMethod(layoutData, this.tabletWidth, GridConstants.Tablet);
            }
            if (layoutData.mobile.length === 0 && layoutData.tab.length === 0) {
                this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Desktop);
            }
            else if (layoutData.mobile.length === 0 && layoutData.tab.length > 0) {
                this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Tablet);
            }
            else {
                this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Mobile);
            }
        }
        else {
            this.cssGenerationNoDesktop(layoutData);
        }
    };
    // Refactored above method
    /**
     * @param {?} layoutData
     * @return {?}
     */
    AmexioGridComponent.prototype.cssGenerationNoDesktop = /**
     * @param {?} layoutData
     * @return {?}
     */
    function (layoutData) {
        if (layoutData.tab.length > 0 && layoutData.mobile.length === 0) {
            this.cssGenerationCommonMethod(layoutData, this.desktopWidth, GridConstants.Tablet);
            this.cssGenerationCommonMethod(layoutData, this.tabletWidth, GridConstants.Tablet);
            this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Tablet);
        }
        else if (layoutData.tab.length === 0 && layoutData.mobile.length > 0) {
            this.cssGenerationCommonMethod(layoutData, this.mobileWidth, GridConstants.Mobile);
            this.cssGenerationCommonMethod(layoutData, this.tabletWidth, GridConstants.Mobile);
            this.cssGenerationCommonMethod(layoutData, this.desktopWidth, GridConstants.Mobile);
        }
    };
    /**
     * @param {?} layoutData
     * @param {?} screenWidth
     * @param {?} deviceType
     * @return {?}
     */
    AmexioGridComponent.prototype.cssGenerationCommonMethod = /**
     * @param {?} layoutData
     * @param {?} screenWidth
     * @param {?} deviceType
     * @return {?}
     */
    function (layoutData, screenWidth, deviceType) {
        this.insertStyleSheetRuleParent('@' + 'media' + screenWidth + '{' + '.' + layoutData.name +
            '{' + this.getCssAttribute() + ' grid-template-areas: ' +
            this.dataCreation(layoutData[deviceType]) + '}' + '}');
    };
    AmexioGridComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-layout-grid',
                    template: "\n    <div [ngClass]=\"className\" >\n          <ng-content select=\"amexio-grid-item\"></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioGridComponent.ctorParameters = function () { return [
        { type: AmexioGridLayoutService }
    ]; };
    AmexioGridComponent.propDecorators = {
        queryItem: [{ type: i0.ContentChildren, args: [AmexioGridItemComponent,] }],
        layout: [{ type: i0.Input, args: ['layout',] }]
    };
    return AmexioGridComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioRowComponent = /** @class */ (function () {
    function AmexioRowComponent() {
    }
    /**
     * @return {?}
     */
    AmexioRowComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioRowComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioRowComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-row', template: "\n    <div class=\"flex-row\">\n      <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioRowComponent.ctorParameters = function () { return []; };
    return AmexioRowComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by pratik on 24/1/18.
*/
var AccordionService = /** @class */ (function () {
    function AccordionService() {
        this.subject = new rxjs_5();
    }
    /**
     * @param {?} data
     * @param {?} parent
     * @return {?}
     */
    AccordionService.prototype.onClickEvent = /**
     * @param {?} data
     * @param {?} parent
     * @return {?}
     */
    function (data, parent) {
        this.subject.next({ data: data, parent: parent });
    };
    /**
     * @return {?}
     */
    AccordionService.prototype.clearEvents = /**
     * @return {?}
     */
    function () {
        this.subject.next();
    };
    /**
     * @return {?}
     */
    AccordionService.prototype.getEvents = /**
     * @return {?}
     */
    function () {
        return this.subject.asObservable();
    };
    AccordionService.decorators = [
        { type: i0.Injectable },
    ];
    return AccordionService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by pratik on 27/11/17.
*/
var LAYOUT_COMPONENTS = [
    AmexioRowComponent,
    AmexioColumnComponent,
    AmexioGridComponent,
    AmexioGridItemComponent,
    AmexioBorderLayoutItemComponent,
    AmexioBorderLayoutComponent,
    AmexioCardComponent,
    AmexioBoxComponent,
    AmexioAccordionTabComponent,
    AmexioAccordionComponent,
    AmexioAccordionHeaderComponent,
    AmexioLayoutComponent,
    AmexioLayoutItemComponent,
];
var AmexioLayoutModule = /** @class */ (function () {
    function AmexioLayoutModule() {
    }
    /**
     * @return {?}
     */
    AmexioLayoutModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioLayoutModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService, AmexioGridLayoutService],
        };
    };
    AmexioLayoutModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        HttpClientModule,
                        AmexioBaseContextMenuModule,
                        AmexioCommonModule,
                    ],
                    exports: LAYOUT_COMPONENTS,
                    declarations: LAYOUT_COMPONENTS,
                    providers: [CommonDataService, DeviceQueryService, IconLoaderService, AmexioGridLayoutService],
                },] },
    ];
    return AmexioLayoutModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ScriptLoadService = /** @class */ (function () {
    function ScriptLoadService() {
    }
    // THIS FUNCTION IS CREATING SCRIPT TAG AND DYNAMIC LOAD SCRIPT INFO HEAD
    /**
     * @param {?} loginProviderObj
     * @param {?=} onload
     * @return {?}
     */
    ScriptLoadService.prototype.loadScript = /**
     * @param {?} loginProviderObj
     * @param {?=} onload
     * @return {?}
     */
    function (loginProviderObj, onload) {
        var /** @type {?} */ signInJS = document.createElement('script');
        signInJS.async = true;
        signInJS.onload = onload;
        signInJS.src = loginProviderObj.url;
        if (loginProviderObj.name === 'linkedin') {
            signInJS.async = false;
            signInJS.text = ('api_key: ' + loginProviderObj.id).replace('\'', '');
        }
        if (!this.isScriptAlreadyPresent(signInJS.src)) {
            document.head.appendChild(signInJS);
        }
    };
    // THIS METHOD IS USED FOR CHEKING SCIRPT IS PRESENT IN BODY OT NOT
    /**
     * @param {?} script
     * @return {?}
     */
    ScriptLoadService.prototype.isScriptAlreadyPresent = /**
     * @param {?} script
     * @return {?}
     */
    function (script) {
        var /** @type {?} */ scripts = document.getElementsByTagName('script');
        var /** @type {?} */ isScriptLoaded;
        // tslint:disable-next-line:prefer-for-of
        for (var /** @type {?} */ i = 0; i < scripts.length; i++) {
            var /** @type {?} */ scriptData = scripts[i];
            if (scriptData.src === script) {
                isScriptLoaded = true;
                return isScriptLoaded;
            }
        }
        return isScriptLoaded;
    };
    ScriptLoadService.decorators = [
        { type: i0.Injectable },
    ];
    /** @nocollapse */
    ScriptLoadService.ctorParameters = function () { return []; };
    return ScriptLoadService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioBadgeComponent = /** @class */ (function () {
    function AmexioBadgeComponent() {
        this.orientation = 'vertical';
        this.cClass = '';
    }
    /**
     * @return {?}
     */
    AmexioBadgeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.color && !this.background) {
            this.cClass = 'amexio-badge-color';
        }
    };
    AmexioBadgeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-badge',
                    template: "\n      <div class=\"amexio-badge\" [ngClass]=\"cClass\" [style.background]=\"background\" [style.color]=\"color\" [style.top]=\"top\" [style.left]=\"left\" [style.right]=\"right\" [style.bottom]=\"bottom\" [style.height]=\"height\" [style.width]=\"width\" [ngStyle]=\"{'position': absolute ? 'absolute' : 'relative',\n                      'flex-direction': (orientation === 'horizontal') ? 'row' : 'column'\n                      }\">\n          <ng-content></ng-content>\n      </div>\n    ",
                },] },
    ];
    /** @nocollapse */
    AmexioBadgeComponent.ctorParameters = function () { return []; };
    AmexioBadgeComponent.propDecorators = {
        absolute: [{ type: i0.Input, args: ['absolute',] }],
        background: [{ type: i0.Input, args: ['background',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        top: [{ type: i0.Input, args: ['top',] }],
        left: [{ type: i0.Input, args: ['left',] }],
        right: [{ type: i0.Input, args: ['right',] }],
        bottom: [{ type: i0.Input, args: ['bottom',] }],
        orientation: [{ type: i0.Input, args: ['orientation',] }],
        height: [{ type: i0.Input, args: ['height',] }],
        width: [{ type: i0.Input, args: ['width',] }]
    };
    return AmexioBadgeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SocialBaseComponent = /** @class */ (function () {
    function SocialBaseComponent() {
        /*
            Properties
            name : style-type
            datatype : string
            version : 5.5.3 onwards
            default : null
            description : style of component
           */
        this.styleType = 'square';
    }
    SocialBaseComponent.propDecorators = {
        clientId: [{ type: i0.Input, args: ['client-id',] }],
        label: [{ type: i0.Input, args: ['label',] }],
        styleType: [{ type: i0.Input, args: ['style-type',] }]
    };
    return SocialBaseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var LoginProvider = /** @class */ (function () {
    function LoginProvider() {
    }
    return LoginProvider;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by sagar on 23/1/19.
  INFO: THIS CONSTANT USE FOR SOCIAL COMPONENT
*/
var SOCIAL_CONSTANT = {
    GOOGLE: 'google',
    FACEBOOK: 'facebook',
    LINKEDIN: 'linkedin',
    FACEBOOK_API_URL: 'https://connect.facebook.net/en_US/sdk.js',
    GOOGLE_GMAIL_API_URL: 'https://apis.google.com/js/platform.js',
    LINKEDIN_API_URL: 'https://platform.linkedin.com/in.js',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var SocialUserInfo = /** @class */ (function () {
    function SocialUserInfo() {
    }
    return SocialUserInfo;
}());

var __extends$29 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FacebookAuthComponent = /** @class */ (function (_super) {
    __extends$29(FacebookAuthComponent, _super);
    function FacebookAuthComponent(scriptLoadService) {
        var _this = _super.call(this) || this;
        _this.scriptLoadService = scriptLoadService;
        _this.loginProviderObj = new LoginProvider();
        _this.onLogin = new i0.EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    FacebookAuthComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.styleType && this.styleType.toLowerCase() === 'circle') {
            this.isCircle = true;
        }
        if (this.styleType && this.styleType.toLowerCase() === 'square') {
            this.isCircle = false;
        }
        this.loginProviderObj.id = this.clientId;
        this.loginProviderObj.name = SOCIAL_CONSTANT.FACEBOOK;
        this.loginProviderObj.url = SOCIAL_CONSTANT.FACEBOOK_API_URL;
        this.initialize();
    };
    // ON CLICK EVENT CALL SIGNIN FUNCTION
    /**
     * @return {?}
     */
    FacebookAuthComponent.prototype.onButtonClick = /**
     * @return {?}
     */
    function () {
        this.signIn();
    };
    // THIS FUNCTION IS USED FOR INITALIZE THE AUTH2 OBJECT AND RETURN USER INFO
    /**
     * @return {?}
     */
    FacebookAuthComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.scriptLoadService.loadScript(_this.loginProviderObj, function () {
                FB.init({
                    appId: _this.clientId,
                    autoLogAppEvents: true,
                    cookie: true,
                    xfbml: true,
                    version: 'v2.10',
                });
                FB.AppEvents.logPageView();
                FB.getLoginStatus(function (response) {
                    var _this = this;
                    if (response.status === 'connected') {
                        var /** @type {?} */ accessToken_1 = FB.getAuthResponse()['accessToken'];
                        FB.api('/me?fields=name,email,picture', function (res) {
                            resolve(_this.getUserinfo(Object.assign({}, { token: accessToken_1 }, res)));
                        });
                    }
                });
            });
        });
    };
    /**
     * @param {?} response
     * @return {?}
     */
    FacebookAuthComponent.prototype.getUserinfo = /**
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var /** @type {?} */ user = new SocialUserInfo();
        user.id = response.id;
        user.name = response.name;
        user.email = response.email;
        user.token = response.token;
        user.image = 'https://graph.facebook.com/' + response.id + '/picture?type=normal';
        if (user && user.name) {
            this.onLogin.emit(user);
        }
        return user;
    };
    /**
     * @return {?}
     */
    FacebookAuthComponent.prototype.signIn = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            FB.login(function (response) {
                if (response.authResponse) {
                    var /** @type {?} */ accessToken_2 = FB.getAuthResponse()['accessToken'];
                    FB.api('/me?fields=name,email,picture', function (res) {
                        resolve(_this.getUserinfo(Object.assign({}, { token: accessToken_2 }, res)));
                    });
                }
            }, { scope: 'email,public_profile' });
        });
    };
    FacebookAuthComponent.decorators = [
        { type: i0.Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'amexio-facebook-auth-provider',
                    template: "\n    <div class=\"social-button\">\n            <ng-container *ngIf=\"!isCircle && styleType != 'square'\" >\n                    <amexio-button [bg-color]=\"'#3b5998'\" [color]=\"'#fff'\" [label]=\"label\" [tooltip]=\"'Facebook'\" [icon]=\"'fa fa-facebook'\" (onClick)=\"onButtonClick()\"></amexio-button>\n            </ng-container>\n    \n            <ng-container *ngIf=\"styleType == 'square'\">\n                    <amexio-floating-button  [block]=\"'square'\" [bg-color]=\"'#3b5998'\" [color]=\"'#fff'\" [relative]=\"true\" [type]=\"'default'\" [icon]=\"'fa fa-facebook'\" (onClick)=\"onButtonClick()\"></amexio-floating-button>\n            </ng-container>\n    \n            <ng-container *ngIf=\"styleType == 'circle'\">\n                    <amexio-floating-button [bg-color]=\"'#3b5998'\" [color]=\"'#fff'\" [relative]=\"true\" [icon]=\"'fa fa-facebook'\" [type]=\"'default'\" (onClick)=\"onButtonClick()\"></amexio-floating-button>\n            </ng-container>\n        </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    FacebookAuthComponent.ctorParameters = function () { return [
        { type: ScriptLoadService }
    ]; };
    FacebookAuthComponent.propDecorators = {
        onLogin: [{ type: i0.Output }]
    };
    return FacebookAuthComponent;
}(SocialBaseComponent));

var __extends$30 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var GoogleAuthComponent = /** @class */ (function (_super) {
    __extends$30(GoogleAuthComponent, _super);
    function GoogleAuthComponent(meta, scriptLoadService) {
        var _this = _super.call(this) || this;
        _this.meta = meta;
        _this.scriptLoadService = scriptLoadService;
        _this.loginProviderObj = new LoginProvider();
        _this.onLogin = new i0.EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    GoogleAuthComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.loginProviderObj.id = this.clientId;
        this.loginProviderObj.name = SOCIAL_CONSTANT.GOOGLE;
        this.loginProviderObj.url = SOCIAL_CONSTANT.GOOGLE_GMAIL_API_URL;
        this.meta.addTag({
            name: 'google-signin-client_id',
            content: this.clientId,
        });
        if (this.styleType && this.styleType.toLowerCase() === 'circle') {
            this.isCircle = true;
        }
        if (!this.label && this.styleType && this.styleType.toLowerCase() !== 'circle') {
            this.label = 'GOOGLE';
        }
        this.initialize();
    };
    // ON CLICK EVENT CALL SIGNIN FUNCTION
    /**
     * @return {?}
     */
    GoogleAuthComponent.prototype.onButtonClick = /**
     * @return {?}
     */
    function () {
        this.signIn();
    };
    // THIS FUNCTION IS USED FOR INITALIZE THE AUTH2 OBJECT AND RETURN USER INFO
    /**
     * @return {?}
     */
    GoogleAuthComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.scriptLoadService.loadScript(_this.loginProviderObj, function () {
                gapi.load('auth2', function () {
                    _this.auth2 = gapi.auth2.init({
                        client_id: _this.clientId,
                        scope: 'email',
                    });
                    _this.auth2.then(function () {
                        if (_this.auth2.isSignedIn.get()) {
                            resolve(_this.getLoginInUserInfo());
                        }
                    });
                });
            });
        });
    };
    // THIS FUNCTION IS USED FOR GETTING USER INFO
    /**
     * @return {?}
     */
    GoogleAuthComponent.prototype.getLoginInUserInfo = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ user = new SocialUserInfo();
        var /** @type {?} */ profile = this.auth2.currentUser.get().getBasicProfile();
        var /** @type {?} */ authResponseObj = this.auth2.currentUser.get().getAuthResponse(true);
        if (profile && authResponseObj) {
            user.id = profile.getId();
            user.name = profile.getName();
            user.email = profile.getEmail();
            user.image = profile.getImageUrl();
            user.token = authResponseObj.access_token;
            user.idToken = authResponseObj.id_token;
            this.onLogin.emit(user);
        }
        return user;
    };
    // THIS FUNCTION IS USED FOR SIGN IN AND GET USER INFO
    /**
     * @return {?}
     */
    GoogleAuthComponent.prototype.signIn = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            var /** @type {?} */ promise = _this.auth2.signIn();
            promise.then(function () {
                resolve(_this.getLoginInUserInfo());
            });
        });
    };
    GoogleAuthComponent.decorators = [
        { type: i0.Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'amexio-google-auth-provider',
                    template: "\n    <div class=\"social-button\">\n\n        <ng-container *ngIf=\"!isCircle && styleType != 'square'\" >\n                <amexio-button [bg-color]=\"'#dd4b39'\" [color]=\"'#fff'\" [label]=\"label\" [tooltip]=\"'Google'\" [icon]=\"'fa fa-google'\" (onClick)=\"onButtonClick()\"></amexio-button>\n        </ng-container>\n\n        <ng-container *ngIf=\"styleType == 'square'\">\n                <amexio-floating-button  [block]=\"'square'\" [bg-color]=\"'#dd4b39'\" [color]=\"'#fff'\" [relative]=\"true\" [type]=\"'default'\" [icon]=\"'fa fa-google'\" (onClick)=\"onButtonClick()\"></amexio-floating-button>\n        </ng-container>\n\n        <ng-container *ngIf=\"styleType == 'circle'\">\n                <amexio-floating-button [bg-color]=\"'#dd4b39'\" [color]=\"'#fff'\" [relative]=\"true\" [icon]=\"'fa fa-google'\" [type]=\"'default'\" (onClick)=\"onButtonClick()\"></amexio-floating-button>\n        </ng-container>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    GoogleAuthComponent.ctorParameters = function () { return [
        { type: platformBrowser.Meta },
        { type: ScriptLoadService }
    ]; };
    GoogleAuthComponent.propDecorators = {
        onLogin: [{ type: i0.Output }]
    };
    return GoogleAuthComponent;
}(SocialBaseComponent));

var __extends$31 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by sagar on 23/1/19.
 * INFO: LINKEDIN AUTH COMPONENT IS USED FOR THIRD PARTY LOGIN USING LINKEDIN OAUTH API
 */
var LinkedInAuthComponent = /** @class */ (function (_super) {
    __extends$31(LinkedInAuthComponent, _super);
    function LinkedInAuthComponent(scriptLoadService) {
        var _this = _super.call(this) || this;
        _this.scriptLoadService = scriptLoadService;
        _this.loginProviderObj = new LoginProvider();
        _this.onLogin = new i0.EventEmitter();
        return _this;
    }
    /**
     * @return {?}
     */
    LinkedInAuthComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.styleType && this.styleType.toLowerCase() === 'circle') {
            this.isCircle = true;
        }
        if (!this.label && this.styleType && this.styleType.toLowerCase() !== 'circle') {
            this.label = 'Linkedin';
        }
        this.loginProviderObj.id = this.clientId;
        this.loginProviderObj.name = SOCIAL_CONSTANT.LINKEDIN;
        this.loginProviderObj.url = SOCIAL_CONSTANT.LINKEDIN_API_URL;
        this.initialize();
    };
    // ON CLICK EVENT CALL SIGNIN FUNCTION
    /**
     * @return {?}
     */
    LinkedInAuthComponent.prototype.onButtonClick = /**
     * @return {?}
     */
    function () {
        if (IN && IN.User.authorize()) {
            console.log('User already loggedin...');
            return;
        }
        else {
            this.signIn();
        }
    };
    // THIS FUNCTION IS USED FOR INITALIZE THE AUTH2 OBJECT AND RETURN USER INFO
    /**
     * @return {?}
     */
    LinkedInAuthComponent.prototype.initialize = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.scriptLoadService.loadScript(_this.loginProviderObj, function () {
                IN.init({
                    api_key: _this.clientId,
                    authorize: true,
                });
                IN.Event.on(IN, 'auth', function () {
                    if (IN.User.isAuthorized()) {
                        IN.API.Raw('/people/~:(id,first-name,last-name,email-address,picture-url)').result(function (res) {
                            resolve(_this.getLoginInUserInfo(res));
                        });
                    }
                });
            });
        });
    };
    // THIS FUNCTION IS USED FOR LINKEDIN
    /**
     * @return {?}
     */
    LinkedInAuthComponent.prototype.onLinkedInLoad = /**
     * @return {?}
     */
    function () {
        IN.Event.on(IN, 'systemReady', function () {
            IN.User.refresh();
        });
    };
    /**
     * @param {?} response
     * @return {?}
     */
    LinkedInAuthComponent.prototype.getLoginInUserInfo = /**
     * @param {?} response
     * @return {?}
     */
    function (response) {
        var /** @type {?} */ user = new SocialUserInfo();
        user.id = response.emailAddress;
        user.name = response.firstName + ' ' + response.lastName;
        user.email = response.emailAddress;
        user.image = response.pictureUrl;
        user.token = IN.ENV.auth.oauth_token;
        this.onLogin.emit(user);
        return user;
    };
    /**
     * @return {?}
     */
    LinkedInAuthComponent.prototype.signIn = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new Promise(function (resolve, reject) {
            // tslint:disable-next-line:no-identical-functions
            IN.Event.on(IN, 'auth', function () {
                if (IN.User.isAuthorized()) {
                    IN.API.Raw('/people/~:(id,first-name,last-name,email-address,picture-url)').result(function (res) {
                        resolve(_this.getLoginInUserInfo(res));
                    });
                }
            });
        });
    };
    LinkedInAuthComponent.decorators = [
        { type: i0.Component, args: [{
                    // tslint:disable-next-line:component-selector
                    selector: 'amexio-linkedin-auth-provider',
                    template: "\n    <div class=\"social-button\">\n\n        <ng-container *ngIf=\"!isCircle && styleType != 'square'\" >\n                <amexio-button [bg-color]=\"'#0082ca'\" [color]=\"'#fff'\" [label]=\"label\" [tooltip]=\"'Linkedin'\" [icon]=\"'fa fa-linkedin'\" (onClick)=\"onButtonClick()\"></amexio-button>\n        </ng-container>\n\n        <ng-container *ngIf=\"styleType == 'square'\">\n                <amexio-floating-button  [block]=\"'square'\" [bg-color]=\"'#0082ca'\" [color]=\"'#fff'\" [relative]=\"true\" [type]=\"'default'\" [icon]=\"'fa fa-linkedin'\" (onClick)=\"onButtonClick()\"></amexio-floating-button>\n        </ng-container>\n\n        <ng-container *ngIf=\"styleType == 'circle'\">\n                <amexio-floating-button [bg-color]=\"'#0082ca'\" [color]=\"'#fff'\" [relative]=\"true\" [icon]=\"'fa fa-linkedin'\" [type]=\"'default'\" (onClick)=\"onButtonClick()\"></amexio-floating-button>\n        </ng-container>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    LinkedInAuthComponent.ctorParameters = function () { return [
        { type: ScriptLoadService }
    ]; };
    LinkedInAuthComponent.propDecorators = {
        onLogin: [{ type: i0.Output }]
    };
    return LinkedInAuthComponent;
}(SocialBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioSocialComponent = /** @class */ (function () {
    function AmexioSocialComponent() {
        this.onLogin = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    AmexioSocialComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.type) {
            this.type = this.type.toLocaleLowerCase();
        }
    };
    /**
     * @param {?} socialUserInfo
     * @return {?}
     */
    AmexioSocialComponent.prototype.onLoginClick = /**
     * @param {?} socialUserInfo
     * @return {?}
     */
    function (socialUserInfo) {
        this.onLogin.emit(socialUserInfo);
    };
    AmexioSocialComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-login-social',
                    template: "\n    <ng-container *ngIf=\"type ==='google'\">\n        <amexio-google-auth-provider [client-id]=\"key\" [label]=\"label\" [style-type]=\"styleType\" (onLogin)=\"onLoginClick($event)\"></amexio-google-auth-provider>\n    </ng-container>\n    <ng-container *ngIf=\"type === 'linkedin'\">\n        <amexio-linkedin-auth-provider [client-id]=\"key\" [label]=\"label\" [style-type]=\"styleType\" (onLogin)=\"onLoginClick($event)\"></amexio-linkedin-auth-provider>\n    </ng-container>\n\n    <ng-container *ngIf=\"type === 'facebook'\">\n        <amexio-facebook-auth-provider [client-id]=\"key\" [label]=\"label\" [style-type]=\"styleType\" (onLogin)=\"onLoginClick($event)\"></amexio-facebook-auth-provider>\n    </ng-container>\n  ",
                    styles: ["\n  .social-button .button-default:hover {\n      box-shadow: 0 2px 5px 0 rgba(0, 0, 0, .16), 0 2px 10px 0 rgba(0, 0, 0, .12)!important;\n  }"],
                },] },
    ];
    /** @nocollapse */
    AmexioSocialComponent.ctorParameters = function () { return []; };
    AmexioSocialComponent.propDecorators = {
        type: [{ type: i0.Input, args: ['type',] }],
        key: [{ type: i0.Input, args: ['api-key',] }],
        label: [{ type: i0.Input, args: ['label',] }],
        styleType: [{ type: i0.Input, args: ['style-type',] }],
        onLogin: [{ type: i0.Output }]
    };
    return AmexioSocialComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var FORM_COMPONENTS$1 = [
    AmexioTextInputComponent,
    AmexioCheckBoxComponent,
    AmexioDropDownComponent,
    AmexioTypeAheadComponent,
    AmexioInputHelperComponent,
    AmexioRadioGroupComponent,
    AmexioEmailInputComponent,
    AmexioNumberInputComponent,
    AmexioPasswordComponent,
    AmexioTextAreaComponent,
    AmexioToggleComponent,
    AmexioRatingComponent,
    AmexioButtonComponent,
    AmexioButtonGroupComponent,
    AmexioButtonDropdownComponent,
    AmexioSpiltButtonDropdownComponent,
    AmexioButtonDropDownItemComponent,
    AmexioCheckBoxGroupComponent,
    CheckboxComponent,
    AmexioSliderComponent,
    AmexioTagsInputComponent,
    AmexioDateTimePickerComponent,
    AmexioButtonDropDownItemComponent,
    AmexioButtonDropdownComponent,
    AmexioSpiltButtonDropdownComponent,
    AmexioFileUploadComponent,
    AmexioLabelComponent,
    AmexioFloatingButtonComponent,
    AmexioFloatingGroupButtonComponent,
    AmexioDropDownitemsComponent,
    AmexioDropDownMenuComponent,
    ToolbarComponent,
    ToolbaroneComponent,
    ToolBarActionComponent,
    SearchboxtoolComponent,
    AmexioSearchAdvanceComponent,
    RecaptchaComponent,
    AmexioSpinnerComponent,
    AmexioCreditcardComponent,
    AmexioChipComponent,
    AmexioChipsComponent,
    GoogleAuthComponent,
    LinkedInAuthComponent,
    FacebookAuthComponent,
    AmexioSocialComponent,
    AmexioBadgeComponent,
    DarkmodeComponent,
    AmexioRangeSliderComponent,
    AmexioMultipleDatePickerComponent,
];
var AmexioFormsModule = /** @class */ (function () {
    function AmexioFormsModule() {
    }
    /**
     * @return {?}
     */
    AmexioFormsModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioFormsModule,
            providers: [CommonDataService, LoadRecaptchaService, ScriptLoadService],
        };
    };
    AmexioFormsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        AmexioLayoutModule,
                        HttpClientModule,
                        AmexioCommonModule.forRoot(),
                    ],
                    exports: FORM_COMPONENTS$1,
                    declarations: FORM_COMPONENTS$1,
                    providers: [CommonDataService, DomHandler, ScriptLoadService,
                    ],
                },] },
    ];
    return AmexioFormsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var OverlayContainerComponent = /** @class */ (function () {
    function OverlayContainerComponent(_renderer) {
        this._renderer = _renderer;
        this.show = false;
        this.right = null;
        this.left = null;
        this.top = null;
        this.bottom = null;
        this.marginLeft = null;
        this.height = '100%';
        this.arrowClass = 'leftTopArrow';
        this.width = 'auto';
        this.bodyHeight = null;
        this.closeonescape = true;
    }
    /**
     * @return {?}
     */
    OverlayContainerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    OverlayContainerComponent.prototype.onClose = /**
     * @return {?}
     */
    function () {
        this.resetData();
    };
    /**
     * @return {?}
     */
    OverlayContainerComponent.prototype.resetData = /**
     * @return {?}
     */
    function () {
        this.left = null;
        this.top = null;
        this.right = null;
        this.bottom = null;
        this.marginLeft = null;
        this.show = false;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OverlayContainerComponent.prototype.toggle = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        this.resetData();
        this.show = !this.show;
        this.eventRef = event;
        if (this.show && this.closeonescape) {
            this.globalListenFunc = this._renderer.listen('document', 'keyup.esc', function (e) {
                _this.show = false;
                if (_this.globalListenFunc) {
                    _this.globalListenFunc();
                }
            });
        }
    };
    /**
     * @return {?}
     */
    OverlayContainerComponent.prototype.setRenderPositionClass = /**
     * @return {?}
     */
    function () {
        if (this.position === 'relative') {
            this.left = null;
            this.marginLeft = null;
        }
        return {
            'bottom': this.bottom + 'px', 'margin-left': this.marginLeft + 'px',
            'right': this.right + 'px', 'margin-top': this.top + 'px',
            'left': this.left + 'px', 'width': this.width,
        };
    };
    /**
     * @param {?} event
     * @return {?}
     */
    OverlayContainerComponent.prototype.onAnimationStart = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.show) {
            var /** @type {?} */ positions = this.findOverlayPosition(event.element, this.eventRef.target || this.eventRef.currentTarget);
            this.top = this.eventRef.target.offsetHeight + 20;
            this.left = this.eventRef.pageX - this.eventRef.target.offsetWidth;
            this.marginLeft = this.eventRef.target.offsetWidth - this.left;
            if (positions.right) {
                this.iconPosition = {
                    left: '-8px',
                    right: '',
                };
                this.arrowClass = 'rightTopArrow';
                this.left = null;
                this.right = document.body.clientWidth - this.eventRef.pageX;
                if (positions.bottom) {
                    this.arrowClass = 'rightBottomArrow';
                    this.top = null;
                    this.bottom = Math.abs(document.body.offsetHeight - this.eventRef.pageY);
                }
            }
            else {
                this.iconPosition = {
                    right: '-8px', left: '',
                };
                this.arrowClass = 'leftTopArrow';
            }
            if (!positions.right && positions.bottom) {
                this.arrowClass = 'leftBottomArrow';
                this.top = null;
                this.bottom = Math.abs(document.body.offsetHeight - this.eventRef.pageY);
            }
            this.renderPositionClass = this.setRenderPositionClass();
            if (this.bodyHeight) {
                this.height = (window.outerHeight / 100) * this.bodyHeight + 'px';
            }
        }
    };
    /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    OverlayContainerComponent.prototype.findOverlayPosition = /**
     * @param {?} element
     * @param {?} target
     * @return {?}
     */
    function (element, target) {
        var /** @type {?} */ rightAlign = false;
        var /** @type {?} */ bottomAlign = false;
        var /** @type {?} */ elementOuterHeight = element.offsetParent ? element.offsetHeight : '';
        var /** @type {?} */ targetOuterHeight = target.offsetHeight;
        var /** @type {?} */ targetOuterWidth = target.offsetWidth;
        var /** @type {?} */ targetOffset = target.getBoundingClientRect();
        var /** @type {?} */ windowScrollTop = this.getWindowScrollTop();
        var /** @type {?} */ windowScrollLeft = this.getWindowScrollLeft();
        var /** @type {?} */ viewport = this.getViewportDetails();
        var /** @type {?} */ top;
        var /** @type {?} */ left;
        if (targetOffset.top + targetOuterHeight + elementOuterHeight > viewport.height) {
            top = targetOffset.top + windowScrollTop - elementOuterHeight;
            if (top < 0) {
                top = 0 + windowScrollTop;
            }
            bottomAlign = true;
        }
        else {
            top = targetOuterHeight + targetOffset.top + windowScrollTop;
        }
        if (targetOffset.left + targetOuterWidth + 150 > viewport.width) {
            rightAlign = true;
        }
        else {
            left = targetOffset.left + windowScrollLeft;
        }
        return { topPosi: top, leftPosi: left, right: rightAlign, bottom: bottomAlign };
    };
    /**
     * @return {?}
     */
    OverlayContainerComponent.prototype.getWindowScrollTop = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ doc = document.documentElement;
        return (window.pageYOffset || doc.scrollTop) - (doc.clientTop || 0);
    };
    /**
     * @return {?}
     */
    OverlayContainerComponent.prototype.getWindowScrollLeft = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ doc = document.documentElement;
        return (window.pageXOffset || doc.scrollLeft) - (doc.clientLeft || 0);
    };
    /**
     * @return {?}
     */
    OverlayContainerComponent.prototype.getViewportDetails = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ win = window;
        var /** @type {?} */ doc = document;
        var /** @type {?} */ ele = doc.documentElement;
        var /** @type {?} */ body = doc.getElementsByTagName('body')[0];
        var /** @type {?} */ widthW = win.innerWidth || ele.clientWidth || body.clientWidth;
        var /** @type {?} */ heightW = win.innerHeight || ele.clientHeight || body.clientHeight;
        return { width: widthW, height: heightW };
    };
    /**
     * @return {?}
     */
    OverlayContainerComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    };
    OverlayContainerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-overlay-container',
                    template: "\n\n    <ng-container *ngIf=\"show\">\n      <div #overlay class=\"overlayContainer {{arrowClass}}\"\n           [ngStyle]=\"renderPositionClass\"\n           [@animation]=\"{value: 'show'}\"\n           (@animation.start)=\"onAnimationStart($event)\">\n        <i *ngIf=\"closable\"\n           class=\"fa fa-times-circle-o iconClass \" [ngStyle]=\"iconPosition\"\n           aria-hidden=\"true\" (click)=\"onClose()\"></i>\n        <div class=\"containerClass\" [style.height]=\"height\">\n          <ng-content></ng-content>\n        </div>\n      </div>\n    </ng-container>\n\n\n\n\n\n  \n  ",
                    animations: [
                        trigger('animation', [
                            state('void', style({
                                transform: 'translateY(5%)',
                                opacity: 0,
                            })),
                            state('show', style({
                                transform: 'translateY(0)',
                                opacity: 1,
                            })),
                            transition('void => show', animate('200ms')),
                            transition('show => void', animate('200ms')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    OverlayContainerComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };
    OverlayContainerComponent.propDecorators = {
        closable: [{ type: i0.Input, args: ['closable',] }],
        position: [{ type: i0.Input, args: ['position',] }],
        width: [{ type: i0.Input, args: ['width',] }],
        bodyHeight: [{ type: i0.Input, args: ['body-height',] }],
        closeonescape: [{ type: i0.Input, args: ['close-on-escape',] }]
    };
    return OverlayContainerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PANE_COMPONENTS = [
    AmexioHeaderComponent,
    AmexioFooterComponent,
    AmexioBodyComponent,
    AmexioFieldSetComponent,
    AmexioWindowPaneComponent,
    AmexioWindowHeaderComponent,
    AmexioStepsComponent,
    AmexioTabPillComponent,
    AmexioTabComponent,
    AmexioVerticalTabComponent,
    AmexioRightVerticalTabComponent,
    AmexioCarouselComponent,
    AmexioTemplateDirective,
    AmexioTemplateWrapperDirective,
    StepBlockComponent,
    AmexioPanelComponent,
    AmexioPanelHeaderComponent,
    AmexiodialoguePaneComponent,
    AmexioFormComponent,
    AmexioFormActionComponent,
    AmexioFormHeaderComponent,
    AmexioFormBodyComponent,
    AmexioFormGroupDirective,
    AmexioTabActionComponent,
    AmexiotimelineComponent,
    AmexiotimelineeventComponent,
    OverlayContainerComponent,
];
var AmexioPaneModule = /** @class */ (function () {
    function AmexioPaneModule() {
    }
    /**
     * @return {?}
     */
    AmexioPaneModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioPaneModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService],
        };
    };
    AmexioPaneModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        AmexioFormsModule,
                        HttpClientModule,
                        AmexioBaseContextMenuModule,
                        AmexioCommonModule,
                    ],
                    entryComponents: [AmexioTabPillComponent],
                    exports: PANE_COMPONENTS,
                    declarations: PANE_COMPONENTS,
                    providers: [CommonDataService, DeviceQueryService, IconLoaderService],
                },] },
    ];
    return AmexioPaneModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TitleModel = /** @class */ (function () {
    function TitleModel() {
        this.centerTitle = '';
        this.previousTitle = '';
        this.nextTitle = '';
    }
    /**
     * @param {?} prev
     * @param {?} center
     * @param {?} next
     * @return {?}
     */
    TitleModel.prototype.setTitle = /**
     * @param {?} prev
     * @param {?} center
     * @param {?} next
     * @return {?}
     */
    function (prev, center, next) {
        this.previousTitle = prev;
        this.centerTitle = center;
        this.nextTitle = next;
    };
    return TitleModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCarouselCEComponent = /** @class */ (function () {
    function AmexioCarouselCEComponent(http, dataService) {
        this.http = http;
        this.dataService = dataService;
        this.currentImageIndex = 0;
        this.titleModel = new TitleModel();
    }
    /**
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.setData(this.data);
        }
        this.positionCalculation();
    };
    /**
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.templates.forEach(function (item) {
            _this.itemTemplate = item.template;
        });
    };
    /**
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.positionCalculation = /**
     * @return {?}
     */
    function () {
        if (this.templateWidth) {
            if (this.position === 'left') {
                this.positionRight = (100 - this.templateWidth);
                this.positionLeft = 0;
            }
            else if (this.position === 'right') {
                this.positionRight = 0;
                this.positionLeft = (100 - this.templateWidth);
            }
            else if (this.position === 'center') {
                this.positionLeft = ((100 - this.templateWidth) / 2);
                this.positionRight = this.positionLeft;
            }
        }
        else {
            if (this.position === 'left') {
                this.positionRight = 60;
                this.positionLeft = 0;
            }
            else if (this.position === 'right') {
                this.positionRight = 0;
                this.positionLeft = 60;
            }
            else if (this.position === 'center') {
                this.positionLeft = 30;
                this.positionRight = 30;
            }
        }
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        // Check if key is added?
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.imageData = responsedata;
        this.titleModel.previousTitle = this.imageData[this.imageData.length - 1].title ? this.imageData[this.imageData.length - 1].title : '';
        this.titleModel.centerTitle = this.imageData[0].title ? this.imageData[0].title : '';
        this.titleModel.nextTitle = this.imageData[1].title ? this.imageData[1].title : '';
    };
    /**
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.dividedPreviousMethod = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.imageData.forEach(function (element, index) {
            if (element && element.active) {
                _this.currentImageIndex = index;
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.previousClick = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dividedPreviousMethod();
        if (this.currentImageIndex === 0) {
            this.previousClickMethod();
        }
        else {
            this.imageData.forEach(function (element, index) {
                if (index === _this.currentImageIndex - 1) {
                    var /** @type {?} */ duplicateIndex = _this.currentImageIndex - 1;
                    _this.imageData[duplicateIndex].active = true;
                    if (_this.imageData[duplicateIndex] && _this.imageData[duplicateIndex - 1] &&
                        _this.imageData[duplicateIndex].title && _this.imageData[duplicateIndex + 1].title) {
                        _this.titleModel.setTitle(_this.imageData[duplicateIndex - 1].title, _this.imageData[duplicateIndex].title, _this.imageData[duplicateIndex + 1].title);
                    }
                    else {
                        _this.titleModel.setTitle(_this.imageData[_this.imageData.length - 1].title, _this.imageData[0].title, _this.imageData[_this.currentImageIndex].title);
                    }
                }
                else {
                    _this.imageData[index].active = false;
                }
            });
        }
    };
    /**
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.previousClickMethod = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.imageData[this.currentImageIndex].active = true;
        var /** @type {?} */ lastIndex = this.imageData.length - 1;
        this.currentImageIndex = this.imageData.length - 1;
        this.imageData.forEach(function (element, index) {
            if (index === _this.currentImageIndex) {
                _this.imageData[index].active = true;
                if (_this.imageData[lastIndex] && _this.imageData[lastIndex].title) {
                    _this.titleModel.setTitle(_this.imageData[lastIndex - 1].title, _this.imageData[lastIndex].title, _this.imageData[0].title);
                }
            }
            else {
                _this.imageData[index]['active'] = false;
            }
        });
    };
    /**
     * @param {?} i
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.onPreBtnHover = /**
     * @param {?} i
     * @return {?}
     */
    function (i) {
        if (i === 0) {
            this.preImagePath = this.imageData[this.imageData.length - 1].imagepath;
        }
        else {
            var /** @type {?} */ ind = i - 1;
            this.preImagePath = this.imageData[ind].imagepath;
        }
    };
    /**
     * @param {?} i
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.onNextBtnHover = /**
     * @param {?} i
     * @return {?}
     */
    function (i) {
        if (i === 0) {
            var /** @type {?} */ ind = i + 1;
            this.nextImagePath = this.imageData[ind].imagepath;
        }
        else {
            var /** @type {?} */ ind = i + 1;
            if (ind === this.imageData.length) {
                this.nextImagePath = this.imageData[0].imagepath;
            }
            else {
                this.nextImagePath = this.imageData[ind].imagepath;
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.nextClick = /**
     * @return {?}
     */
    function () {
        this.dividedPreviousMethod();
        if (this.currentImageIndex === 0) {
            this.currentImageIndex = 1;
            this.imageData[this.currentImageIndex].active = true;
            var /** @type {?} */ nextIndex = this.currentImageIndex;
            if (this.imageData[nextIndex] && this.imageData[nextIndex].title) {
                this.titleModel.setTitle(this.imageData[nextIndex - 1].title, this.imageData[nextIndex].title, this.imageData[nextIndex + 1].title);
            }
            this.setFlag();
        }
        else {
            if (this.currentImageIndex === this.imageData.length - 1) {
                this.currentImageIndex = 0;
                this.titleModel.setTitle(this.imageData[this.imageData.length - 1].title, this.imageData[this.currentImageIndex].title, this.imageData[this.currentImageIndex + 1].title);
            }
            else {
                this.currentImageIndex++;
                var /** @type {?} */ nextIndex = this.currentImageIndex;
                if (this.currentImageIndex < this.imageData.length - 1) {
                    this.titleModel.setTitle(this.imageData[nextIndex - 1].title, this.imageData[nextIndex].title, this.imageData[nextIndex + 1].title);
                }
                else {
                    this.titleModel.setTitle(this.imageData[nextIndex - 1].title, this.imageData[nextIndex].title, this.imageData[0].title);
                }
            }
            this.setFlag();
        }
    };
    /**
     * @return {?}
     */
    AmexioCarouselCEComponent.prototype.setFlag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.imageData.forEach(function (element, index) {
            if (index === _this.currentImageIndex) {
                _this.imageData[index].active = true;
            }
            else {
                _this.imageData[index]['active'] = false;
            }
        });
    };
    AmexioCarouselCEComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-carousel-ce',
                    template: "\n    <br />\n    <div class=\"wrapper\" #tab>\n        <div *ngFor=\"let item of imageData ;let i=index\">\n            <ng-container *ngIf=\"item.active\">\n\n                <div class=\"ce-caroueslslideshow\" [ngStyle]=\"{'visibility':item.active ? 'visible':'hidden'}\">\n                    <div class=\"ce-caroueslimages\">\n                        <img src={{item.imagepath}} style='height: 100%; width: 100%; object-fit: cover' />\n\n                    </div>\n                    <ng-container *ngIf=\"itemTemplate\">\n                        <div style=\" position: absolute;\" [style.left]=\"positionLeft+'%'\" [style.right]=\"positionRight+'%'\">\n                            <ng-template tabindex=\"1\" [amexioTemplateWrapper]=\"itemTemplate\" [item]=\"item\"></ng-template>\n                        </div>\n\n                    </ng-container>\n                    <div class=\"ce-caroueslbar\">\n                        <div class=\"ce-caroueslnav\">\n                            <a class=\"ce-caroueslnav-prev\">\n                                <span>Previous</span>\n                                <div (click)=\"previousClick(i)\" (mouseenter)=\"onPreBtnHover(i)\">\n                                    <!-- <amexio-image [path]='preImagePath'>\n                                    </amexio-image> -->\n                                    <img src=\"{{preImagePath}}\" style='height: 100%; width: 100%; object-fit: cover; cursor:pointer' />\n\n                                </div>\n                            </a>\n                            <a class=\"ce-caroueslnav-next\">\n                                <span>Next</span>\n                                <div (click)=\"nextClick(i)\" (mouseenter)=\"onNextBtnHover(i)\">\n\n                                    <img src=\"{{nextImagePath}}\" style='height: 100%; width: 100%; object-fit: cover; cursor:pointer' />\n\n                                </div>\n                            </a>\n                        </div>\n\n                        <div class=\"ce-caroueslnav-content\">\n                            <div class=\"ce-caroueslnav-content-prev\">\n                                <span> {{titleModel.previousTitle}}</span>\n                            </div>\n                            <div class=\"ce-caroueslnav-content-current\">\n                                <span>\n                                    {{titleModel.centerTitle}}\n                                </span>\n                            </div>\n                            <div class=\"ce-caroueslnav-content-next\">\n                                <span> {{titleModel.nextTitle}}</span>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </ng-container>\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioCarouselCEComponent.ctorParameters = function () { return [
        { type: HttpClient },
        { type: CommonDataService }
    ]; };
    AmexioCarouselCEComponent.propDecorators = {
        data: [{ type: i0.Input }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        templateWidth: [{ type: i0.Input, args: ['template-width',] }],
        position: [{ type: i0.Input, args: ['position',] }],
        templates: [{ type: i0.ContentChildren, args: [AmexioTemplateDirective,] }],
        tabs: [{ type: i0.ViewChild, args: ['tab', { read: i0.ElementRef },] }]
    };
    return AmexioCarouselCEComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ProgressModel = /** @class */ (function () {
    function ProgressModel(firstDegree, secondDegree, progresscolor, inactiveprogresscolor) {
        this.firstDegree = firstDegree;
        this.secondDegree = secondDegree;
        this.progresscolor = progresscolor;
        this.inactiveprogresscolor = inactiveprogresscolor;
    }
    /**
     * @return {?}
     */
    ProgressModel.prototype.getStyle = /**
     * @return {?}
     */
    function () {
        if (parseFloat(this.firstDegree) > -90 && parseFloat(this.firstDegree) < 90) {
            return {
                'background-image': 'linear-gradient( ' + this.firstDegree + ', ' + this.progresscolor +
                    ' 50%, transparent 50%, transparent), linear-gradient(' + this.secondDegree + ', ' + this.progresscolor +
                    ' 50%,' + this.inactiveprogresscolor + ' 50%, ' + this.inactiveprogresscolor + ')',
            };
        }
        else {
            return {
                'background-image': 'linear-gradient( ' + this.firstDegree + ', ' + this.inactiveprogresscolor +
                    ' 50%, transparent 50%, transparent), linear-gradient(' + this.secondDegree + ', ' + this.progresscolor +
                    ' 50%,' + this.inactiveprogresscolor + ' 50%, ' + this.inactiveprogresscolor + ')',
            };
        }
    };
    return ProgressModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioProgressCEComponent = /** @class */ (function () {
    function AmexioProgressCEComponent() {
        /*
             Properties
             name : font-size
             datatype : string
             version : 5.6.0 onwards
             default :
             description : Set size to label of progress bar.
             */
        this.size = '30px';
        /*
             Properties
             name : background-color
             datatype : string
             version : 5.6.0 onwards
             default :
             description : Set background color to the circular creative progress bar.
             */
        this.background = 'rgb(242,244,245)';
        /*
             Properties
             name : background-color
             datatype : string
             version : 5.6.0 onwards
             default :
             description : Set label color to the circular creative progress bar.
             */
        this.labelcolor = 'black';
        /*
             Properties
             name : progress-color
             datatype : string
             version : 5.6.0 onwards
             default : '#2ecc71'
             description : Set progress color to the border of creative progress bar.
             */
        this.progresscolor = '#1565c0';
        /*
             Properties
             name : inactive-progress-color
             datatype : string
             version : 5.6.0 onwards
             default : '#d0d0d0'
             description : Set inactive color to the remaining border of creative progress bar.
             */
        this.inactiveprogresscolor = '#cce2f5';
        /*
          Properties
          name : unit
          datatype : string
          version : 5.6.0 onwards
          default : '%'
          description : Set unit to the label of progress bar.
          */
        this.unit = '%';
        this.showlabel = false;
        this.showunit = false;
    }
    /**
     * @return {?}
     */
    AmexioProgressCEComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.dyanmicHeightCreation();
        this.progressBarDegreeMap = new Map();
        this.progressBarDegreeMap.set('0', new ProgressModel('90deg', '90deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('1', new ProgressModel('90deg', '93.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('2', new ProgressModel('90deg', '97.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('3', new ProgressModel('90deg', '100.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('4', new ProgressModel('90deg', '104.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('5', new ProgressModel('90deg', '108deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('6', new ProgressModel('90deg', '111.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('7', new ProgressModel('90deg', '115.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('8', new ProgressModel('90deg', '118.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('9', new ProgressModel('90deg', '122.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('10', new ProgressModel('90deg', '126deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('11', new ProgressModel('90deg', '129.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('12', new ProgressModel('90deg', '133.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('13', new ProgressModel('90deg', '136.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('14', new ProgressModel('90deg', '140.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('15', new ProgressModel('90deg', '144deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('16', new ProgressModel('90deg', '147.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('17', new ProgressModel('90deg', '151.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('18', new ProgressModel('90deg', '154.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('19', new ProgressModel('90deg', '158.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('20', new ProgressModel('90deg', '162deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('21', new ProgressModel('90deg', '165.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('22', new ProgressModel('90deg', '169.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('23', new ProgressModel('90deg', '172.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('24', new ProgressModel('90deg', '176.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('25', new ProgressModel('90deg', '180deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('26', new ProgressModel('90deg', '183.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('27', new ProgressModel('90deg', '187.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('28', new ProgressModel('90deg', '190.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('29', new ProgressModel('90deg', '194.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('30', new ProgressModel('90deg', '198deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('31', new ProgressModel('90deg', '201.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('32', new ProgressModel('90deg', '205.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('33', new ProgressModel('90deg', '208.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('34', new ProgressModel('90deg', '212.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('35', new ProgressModel('90deg', '216deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('36', new ProgressModel('90deg', '219.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('37', new ProgressModel('90deg', '223.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('38', new ProgressModel('90deg', '226.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('39', new ProgressModel('90deg', '230.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('40', new ProgressModel('90deg', '234deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('41', new ProgressModel('90deg', '237.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('42', new ProgressModel('90deg', '241.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('43', new ProgressModel('90deg', '244.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('44', new ProgressModel('90deg', '248.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('45', new ProgressModel('90deg', '252deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('46', new ProgressModel('90deg', '255.6deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('47', new ProgressModel('90deg', '259.2deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('48', new ProgressModel('90deg', '262.8deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('49', new ProgressModel('90deg', '266.4deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('50', new ProgressModel('-90deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('51', new ProgressModel('-86.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('52', new ProgressModel('-82.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('53', new ProgressModel('-79.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('54', new ProgressModel('-75.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('55', new ProgressModel('-72deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('56', new ProgressModel('-68.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('57', new ProgressModel('-64.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('58', new ProgressModel('-61.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('59', new ProgressModel('-57.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('60', new ProgressModel('-54deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('61', new ProgressModel('-50.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('62', new ProgressModel('-46.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('63', new ProgressModel('-43.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('64', new ProgressModel('-39.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('65', new ProgressModel('-36deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('66', new ProgressModel('-32.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('67', new ProgressModel('-28.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('68', new ProgressModel('-25.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('69', new ProgressModel('-21.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('70', new ProgressModel('-18deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('71', new ProgressModel('-14.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('72', new ProgressModel('-10.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('73', new ProgressModel('-7.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('74', new ProgressModel('-3.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('75', new ProgressModel('0deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('76', new ProgressModel('3.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('77', new ProgressModel('7.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('78', new ProgressModel('10.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('79', new ProgressModel('14.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('80', new ProgressModel('18deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('81', new ProgressModel('21.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('82', new ProgressModel('25.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('83', new ProgressModel('28.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('84', new ProgressModel('32.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('85', new ProgressModel('36deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('86', new ProgressModel('39.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('87', new ProgressModel('43.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('88', new ProgressModel('46.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('89', new ProgressModel('50.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('90', new ProgressModel('54deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('91', new ProgressModel('57.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('92', new ProgressModel('61.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('93', new ProgressModel('64.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('94', new ProgressModel('68.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('95', new ProgressModel('72deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('96', new ProgressModel('76.6deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('97', new ProgressModel('79.2deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('98', new ProgressModel('82.8deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('99', new ProgressModel('86.4deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.set('100', new ProgressModel('90deg', '270deg', this.progresscolor, this.inactiveprogresscolor));
        this.progressBarDegreeMap.forEach(function (element, key) {
            if (_this.progressvalue === parseInt(key, 10)) {
                _this.pStyle = element.getStyle();
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioProgressCEComponent.prototype.dyanmicHeightCreation = /**
     * @return {?}
     */
    function () {
        if (this.width && this.width.length > 0 && this.height && this.height.length > 0) {
            this.outerWidth = this.getCal(this.width);
            this.outerHeight = this.getCal(this.height);
        }
    };
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioProgressCEComponent.prototype.getCal = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        return (parseInt(value, 10) + 32).toString() + 'px';
    };
    AmexioProgressCEComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-progress-ce',
                    template: "\n    <!-- Radial -->\n    <ng-container *ngIf=\"type =='radial'\">\n        <div class=\"circularProgress\" [style.width]=\"outerWidth\" [style.height]=\"outerHeight\" [ngStyle]=\"pStyle\">\n            <div [style.background-color]=\"background\" [style.width]=\"width+'px'\" [style.height]=\"height+'px'\" class=\"innerCircle\"\n                [ngClass]=\"type\">\n                <label tabindex=\"0\" attr.aria-label=\"{{progressvalue}} {{unit}} {{tooltip}}\" [style.font-size]=\"size\"\n                    [style.color]=\"labelcolor\">\n                    <ng-container *ngIf=\"showlabel\">{{progressvalue }}</ng-container>\n                    <ng-container *ngIf=\"showunit\"> {{unit}}</ng-container>\n                </label>\n            </div>\n        </div>\n    </ng-container>\n    <!-- Ring -->\n    <ng-container *ngIf=\"type =='ring'\">\n        <div class=\"circularProgress\" [style.width]=\"outerWidth\" [style.height]=\"outerHeight\" [ngStyle]=\"pStyle\">\n            <div [style.width]=\"width+'px'\" [style.height]=\"height+'px'\" class=\"innerCircle\" [ngClass]=\"type\">\n                <label tabindex=\"0\" attr.aria-label=\"{{progressvalue}} {{unit}} {{tooltip}}\" [style.color]=\"labelcolor\"\n                    [style.font-size]=\"size\">\n                    <ng-container *ngIf=\"showlabel\">{{progressvalue }}</ng-container>\n                    <ng-container *ngIf=\"showunit\"> {{unit}}</ng-container>\n                </label>\n            </div>\n        </div>\n    </ng-container>\n\n    <!-- Pie -->\n    <ng-container *ngIf=\"type =='pie'\">\n        <div class=\"circularProgress\" [style.width]=\"outerWidth\" [style.height]=\"outerHeight\" [ngStyle]=\"pStyle\">\n            <div [style.width]=\"width+'px'\" [style.height]=\"height+'px'\" [ngClass]=\"type\" class=\"innerCircle\">\n                <label tabindex=\"0\" attr.aria-label=\"{{progressvalue}} {{unit}} {{tooltip}}\" [style.color]=\"labelcolor\"\n                    [style.font-size]=\"size\">\n                    <ng-container *ngIf=\"showlabel\">{{progressvalue }}</ng-container>\n                    <ng-container *ngIf=\"showunit\"> {{unit}}</ng-container>\n\n                </label>\n            </div>\n        </div>\n    </ng-container>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioProgressCEComponent.ctorParameters = function () { return []; };
    AmexioProgressCEComponent.propDecorators = {
        type: [{ type: i0.Input, args: ['type',] }],
        size: [{ type: i0.Input, args: ['font-size',] }],
        background: [{ type: i0.Input, args: ['background-color',] }],
        labelcolor: [{ type: i0.Input, args: ['label-color',] }],
        progresscolor: [{ type: i0.Input, args: ['progress-color',] }],
        inactiveprogresscolor: [{ type: i0.Input, args: ['inactive-progress-color',] }],
        unit: [{ type: i0.Input, args: ['unit',] }],
        label: [{ type: i0.Input, args: ['label',] }],
        height: [{ type: i0.Input, args: ['height',] }],
        width: [{ type: i0.Input, args: ['width',] }],
        progressvalue: [{ type: i0.Input, args: ['progress-value',] }],
        tooltip: [{ type: i0.Input, args: ['tooltip',] }],
        showlabel: [{ type: i0.Input, args: ['show-label',] }],
        showunit: [{ type: i0.Input, args: ['show-unit',] }]
    };
    return AmexioProgressCEComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioVideoPlayerComponent = /** @class */ (function () {
    function AmexioVideoPlayerComponent() {
        // Internal Use Only
        this.rederVideo = true;
        this.currentVolume = 1;
    }
    /**
     * @return {?}
     */
    AmexioVideoPlayerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioVideoPlayerComponent.prototype.onVolumeChange = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.videoPlayer.nativeElement.volume = this.currentVolume = event.target.value;
    };
    /**
     * @return {?}
     */
    AmexioVideoPlayerComponent.prototype.updateMuteUI = /**
     * @return {?}
     */
    function () {
        if (this.videoPlayer.nativeElement.muted) {
            this.isMuted = true;
        }
        else {
            this.isMuted = false;
        }
    };
    /**
     * @return {?}
     */
    AmexioVideoPlayerComponent.prototype.onPlay = /**
     * @return {?}
     */
    function () {
        if (!this.isPlaying) {
            this.videoPlayer.nativeElement.play();
            this.isPlaying = true;
        }
        else {
            this.videoPlayer.nativeElement.pause();
            this.isPlaying = false;
        }
    };
    /**
     * @return {?}
     */
    AmexioVideoPlayerComponent.prototype.onTimeUpdate = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ percentage = Math.floor((100 / this.videoPlayer.nativeElement.duration) * this.videoPlayer.nativeElement.currentTime);
        this.progressBar.nativeElement.value = percentage;
        // Update the progress bar's text (for browsers that don't support the progress element)
        this.progressBar.nativeElement.innerHTML = percentage + '% played';
        if (percentage === 100) {
            this.isPlaying = false;
        }
    };
    /**
     * @return {?}
     */
    AmexioVideoPlayerComponent.prototype.replayVideo = /**
     * @return {?}
     */
    function () {
        this.resetPlayer();
        this.onPlay();
    };
    /**
     * @return {?}
     */
    AmexioVideoPlayerComponent.prototype.resetPlayer = /**
     * @return {?}
     */
    function () {
        this.videoPlayer.nativeElement.pause();
        this.progressBar.nativeElement.value = 0;
        this.videoPlayer.nativeElement.currentTime = 0;
        this.isPlaying = false;
    };
    /**
     * @return {?}
     */
    AmexioVideoPlayerComponent.prototype.onFullScreen = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ elem = this.videoPlayer.nativeElement;
        if (elem.requestFullscreen) {
            elem.requestFullscreen();
        }
        else if (elem.mozRequestFullScreen) {
            elem.mozRequestFullScreen();
        }
        else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
        }
    };
    /**
     * @return {?}
     */
    AmexioVideoPlayerComponent.prototype.onMute = /**
     * @return {?}
     */
    function () {
        if (!this.isMuted) {
            this.videoPlayer.nativeElement.muted = true;
            this.isMuted = true;
            this.volumebar.nativeElement.value = 0;
        }
        else {
            this.videoPlayer.nativeElement.muted = false;
            this.isMuted = false;
            this.volumebar.nativeElement.value = this.currentVolume;
        }
    };
    AmexioVideoPlayerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-video-player',
                    template: "\n\n      <ng-container *ngIf=\"rederVideo\">\n      <video [style.width.px]=\"width\" controls>\n          <source [attr.src]=\"path\">\n          Your browser does not support HTML5 video.\n      </video>\n    </ng-container>\n  ",
                    styles: ["\n    video{width:100%;height:100%;background:#000}progress{color:#4682b4;font-size:12px;width:220px;height:16px;border:none;margin-right:10px;background:#434343;border-radius:9px;vertical-align:middle}progress::-moz-progress-bar{color:#4682b4;background:#434343}progress[value]::-webkit-progress-bar{background-color:#434343;border-radius:2px;-webkit-box-shadow:0 2px 5px rgba(0,0,0,.25) inset;box-shadow:inset 0 2px 5px rgba(0,0,0,.25)}progress[value]::-webkit-progress-value{background-color:#4682b4}@media screen and (max-width:600px){video{border:1px solid #4682b4;width:98%;height:231px;background:#000}}\n  "],
                },] },
    ];
    /** @nocollapse */
    AmexioVideoPlayerComponent.ctorParameters = function () { return []; };
    AmexioVideoPlayerComponent.propDecorators = {
        path: [{ type: i0.Input }],
        extension: [{ type: i0.Input }],
        width: [{ type: i0.Input }],
        rederVideo: [{ type: i0.Input }],
        videoPlayer: [{ type: i0.ViewChild, args: ['videoRef',] }],
        progressBar: [{ type: i0.ViewChild, args: ['progressbar',] }],
        volumebar: [{ type: i0.ViewChild, args: ['volumebar',] }]
    };
    return AmexioVideoPlayerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MEDIA_COMPONENTS = [
    AmexioVideoPlayerComponent,
    AmexioImageComponent,
];
var AmexioMediaModule = /** @class */ (function () {
    function AmexioMediaModule() {
    }
    /**
     * @return {?}
     */
    AmexioMediaModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioMediaModule,
            providers: [CommonDataService, DeviceQueryService],
        };
    };
    AmexioMediaModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        HttpClientModule,
                        AmexioCommonModule,
                    ],
                    exports: MEDIA_COMPONENTS,
                    declarations: MEDIA_COMPONENTS,
                    providers: [CommonDataService, DeviceQueryService, IconLoaderService],
                },] },
    ];
    return AmexioMediaModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioFormActionCEComponent = /** @class */ (function () {
    function AmexioFormActionCEComponent(formBuilder) {
        this.formBuilder = formBuilder;
        this.enableaction = false;
        this.isFormValid = false;
        this.showDialogue = false;
        this.errorMsgArray = [];
    }
    /**
     * @return {?}
     */
    AmexioFormActionCEComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioFormActionCEComponent.prototype.showErrors = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.errorMsgArray = [];
        this.addErrorMsg();
        this.showDialogue = !this.isFormValid;
        if (!this.isFormValid) {
            this.showDialogue = true;
        }
        else {
            this.showDialogue = false;
        }
    };
    /**
     * @return {?}
     */
    AmexioFormActionCEComponent.prototype.closeDialogue = /**
     * @return {?}
     */
    function () {
        this.showDialogue = !this.showDialogue;
    };
    // THIS METHOD IS USED FOR ADDING MSG
    /**
     * @return {?}
     */
    AmexioFormActionCEComponent.prototype.addErrorMsg = /**
     * @return {?}
     */
    function () {
        if (this.form && this.form.status === 'INVALID') {
            for (var _i = 0, _a = Object.entries(this.form.controls); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], value = _b[1];
                if (value && value.status === 'INVALID') {
                    var /** @type {?} */ errorObject = {};
                    errorObject['label'] = key;
                    this.errorMsgArray.push(errorObject);
                }
            }
        }
    };
    /**
     * @param {?} form
     * @param {?} formFlag
     * @return {?}
     */
    AmexioFormActionCEComponent.prototype.getValidationForm = /**
     * @param {?} form
     * @param {?} formFlag
     * @return {?}
     */
    function (form, formFlag) {
        this.enableaction = true;
        this.formFlag = formFlag;
        this.form = form;
    };
    AmexioFormActionCEComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'form-action-ce',
                    template: "\n        <ng-container *ngIf=\"enableaction\">  \n          <span  *ngIf=\"!form.valid\" style=\"padding-bottom:10px;position:relative\">\n                  <button class=\"button\" [attr.title]=\"'click'\" (click)=\"showErrors($event)\" [ngClass]=\"'button-warning button-small button-round'\">\n                              <span class=\"button-text\">\n                                <span style=\"padding-right: 5px;\" *ngIf=\"icon\">\n                                  <amexio-c-icon [customclass]=\"icon\" >\n                                  </amexio-c-icon>\n                                </span>\n          <span style=\"padding-right: 5px;\" *ngIf=\"loading\">\n                                  <amexio-c-icon key=\"button-loading-icon\"></amexio-c-icon>\n                                </span> ?\n          </span>\n          </button>\n          <amexio-dialogue class=\"dailogue-header-ce\" [(show)]=\"showDialogue\" [custom]=\"true\" [content-align]=\"'left'\" [closable]=\"false\"\n              [title]=\"'Invalid Fields'\" [type]=\"'confirm'\">\n\n              <amexio-body *ngFor=\"let msg of errorMsgArray let index=index\">\n                  <amexio-label>{{index+1}}) {{msg.label}}</amexio-label><br>\n              </amexio-body>\n\n              <amexio-action>\n                  <amexio-button type=\"primary\" (onClick)=\"closeDialogue()\" [label]=\"'OK'\">\n                  </amexio-button>\n              </amexio-action>\n          </amexio-dialogue>\n          </span>\n        </ng-container>  \n    ",
                },] },
    ];
    /** @nocollapse */
    AmexioFormActionCEComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder }
    ]; };
    return AmexioFormActionCEComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCardCEActionComponent = /** @class */ (function () {
    function AmexioCardCEActionComponent(formBuilder) {
        this.formBuilder = formBuilder;
        this.align = '';
        this.direction = 'row';
        this.cclass = '';
        this.formFlag = false;
        this.showError = false;
        this.buttons = [];
        this.isFormValid = false;
        this.showDialogue = false;
        this.errorMsgArray = [];
    }
    /**
     * @return {?}
     */
    AmexioCardCEActionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.bordertop) {
            this.cclass = 'card-action-border';
        }
    };
    /**
     * @return {?}
     */
    AmexioCardCEActionComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.btns.length > 0) {
            this.buttons = this.btns.toArray();
        }
        else if (this.btngrp.length > 0) {
            this.buttons = this.btngrp.toArray()[0].buttons;
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioCardCEActionComponent.prototype.checkFormValidation = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        if (this.formAction && data && this.formFlag) {
            this.form = data;
            this.formAction.getValidationForm(this.form, this.formFlag);
        }
    };
    AmexioCardCEActionComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-action-ce',
                    template: "\n\n    <div   [ngStyle]=\"{'background': ' url(' + bgimage + ') center/cover no-repeat','height': height }\" [ngClass]=\"cclass\">\n        <div class=\"creative-footer\" [style.flex-direction]=\"direction\" [ngStyle]=\"{'color': color, 'background':background, 'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align}\">\n            <ng-content></ng-content>\n            <form-action-ce *ngIf=\"(formFlag && showError)\"></form-action-ce>\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioCardCEActionComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder }
    ]; };
    AmexioCardCEActionComponent.propDecorators = {
        align: [{ type: i0.Input, args: ['align',] }],
        bgimage: [{ type: i0.Input, args: ['bg-image',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        background: [{ type: i0.Input, args: ['background',] }],
        height: [{ type: i0.Input, args: ['height',] }],
        bordertop: [{ type: i0.Input, args: ['border-top',] }],
        direction: [{ type: i0.Input, args: ['direction',] }],
        btns: [{ type: i0.ContentChildren, args: [AmexioButtonComponent,] }],
        btngrp: [{ type: i0.ContentChildren, args: [AmexioButtonGroupComponent,] }],
        formAction: [{ type: i0.ViewChild, args: [AmexioFormActionCEComponent,] }]
    };
    return AmexioCardCEActionComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCardCEBodyComponent = /** @class */ (function () {
    function AmexioCardCEBodyComponent() {
        this.cardclass = 'card-container-body';
        this.align = '';
    }
    AmexioCardCEBodyComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-body-ce',
                    template: "\n      <div [ngStyle]=\"{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align,'background': ' url(' + bgimage + ') center/cover no-repeat', 'color': color,'background-color':background, 'height': height }\">\n          <ng-content></ng-content>\n      </div>\n    ",
                },] },
    ];
    AmexioCardCEBodyComponent.propDecorators = {
        cardclass: [{ type: i0.HostBinding, args: ['attr.class',] }],
        align: [{ type: i0.Input, args: ['align',] }],
        bgimage: [{ type: i0.Input, args: ['bg-image',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        background: [{ type: i0.Input, args: ['background',] }],
        height: [{ type: i0.Input, args: ['height',] }]
    };
    return AmexioCardCEBodyComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCardCEHeaderComponent = /** @class */ (function () {
    function AmexioCardCEHeaderComponent() {
        this.align = '';
        this.verticalalign = '';
        this.direction = 'row';
        this.applyThemeColor = false;
        this.cclass = '';
        this.closeable = false;
        this.maximize = false;
        this.isFullWindow = false;
        this.closeableBehaiour = new rxjs_6(false);
        this.maximizeBehaiour = new rxjs_6(false);
    }
    /**
     * @return {?}
     */
    AmexioCardCEHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.borderbottom) {
            this.cclass = 'card-header-border';
        }
        this.setIconPosition();
    };
    /**
     * @param {?} maximize
     * @param {?} isFullWindow
     * @return {?}
     */
    AmexioCardCEHeaderComponent.prototype.setMaximizeData = /**
     * @param {?} maximize
     * @param {?} isFullWindow
     * @return {?}
     */
    function (maximize, isFullWindow) {
        this.maximize = maximize;
        this.isFullWindow = isFullWindow;
        this.maximizeBehaiour.next(this.isFullWindow);
    };
    /**
     * @return {?}
     */
    AmexioCardCEHeaderComponent.prototype.sizeChange = /**
     * @return {?}
     */
    function () {
        this.isFullWindow = !this.isFullWindow;
        this.maximizeBehaiour.next(this.isFullWindow);
    };
    /**
     * @return {?}
     */
    AmexioCardCEHeaderComponent.prototype.onCloseClick = /**
     * @return {?}
     */
    function () {
        this.closeableBehaiour.next(false);
    };
    /**
     * @return {?}
     */
    AmexioCardCEHeaderComponent.prototype.setIconPosition = /**
     * @return {?}
     */
    function () {
        switch (this.verticalalign) {
            case 'top': {
                this.iconPosition = {
                    top: '0',
                    bottom: '',
                };
                break;
            }
            case 'center': {
                this.iconPosition = {
                    top: '',
                    bottom: '',
                };
                break;
            }
            case 'bottom': {
                this.iconPosition = {
                    top: '',
                    bottom: '0',
                };
                break;
            }
        }
    };
    AmexioCardCEHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-header-ce',
                    template: "\n\n     <div  [ngClass]=\"cclass\" class=\"creative-header-div\" [ngStyle]=\"{'background': ' url(' + bgimage + ') center/cover no-repeat' }\">\n        <header  class=\"creative-header\" [style.flex-direction]=\"direction\"\n        [ngStyle]=\"{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align ,\n         'color': color,'background':background,'height': height}\"\n         [ngClass]=\"{'card-container-ce-theme-color': applyThemeColor}\"\n         >\n          \n                <ng-content></ng-content>\n            <span *ngIf=\"windowFlag\" class=\"creative-header-icon-div\" [ngStyle]=\"iconPosition\">\n                <amexio-c-icon class=\"cursor-style\" *ngIf=\"(isFullWindow && maximize )\" [key]=\"'window_maximize'\" (onClick)=\"sizeChange()\"></amexio-c-icon>\n                <amexio-c-icon class=\"cursor-style\" *ngIf=\"(!isFullWindow && maximize )\" [key]=\"'window_restore'\" (click)=\"sizeChange()\"></amexio-c-icon>\n                <amexio-c-icon class=\"cursor-style\" style=\"padding-left:5px;\" *ngIf=\"closeable\" [key]=\"'window_close'\" (onClick)=\"onCloseClick()\"></amexio-c-icon>\n             </span> \n        </header>\n    </div> \n \n \n \n  ",
                    styles: [
                        "\n  .cursor-style {\n  cursor:pointer;\n  }\n  ",
                    ],
                },] },
    ];
    AmexioCardCEHeaderComponent.propDecorators = {
        align: [{ type: i0.Input, args: ['align',] }],
        verticalalign: [{ type: i0.Input, args: ['icon-align',] }],
        bgimage: [{ type: i0.Input, args: ['bg-image',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        background: [{ type: i0.Input, args: ['background',] }],
        height: [{ type: i0.Input, args: ['height',] }],
        borderbottom: [{ type: i0.Input, args: ['border-bottom',] }],
        direction: [{ type: i0.Input, args: ['direction',] }],
        applyThemeColor: [{ type: i0.Input, args: ['apply-theme-color',] }]
    };
    return AmexioCardCEHeaderComponent;
}());

var __extends$32 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCardCEComponent = /** @class */ (function (_super) {
    __extends$32(AmexioCardCEComponent, _super);
    function AmexioCardCEComponent() {
        var _this = _super.call(this) || this;
        _this.windowFlag = false;
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioCardCEComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.color) {
            this.cclass = 'card-container-ce-color';
        }
        if (!this.background) {
            this.cclass = this.cclass + ' card-container-ce-bg-color';
        }
        this.setWiderAndNarrower();
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @return {?}
     */
    AmexioCardCEComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
    };
    // THIS METHOD CALLL FOR HEADER AND ACTION STYLE
    /**
     * @return {?}
     */
    AmexioCardCEComponent.prototype.setWiderAndNarrower = /**
     * @return {?}
     */
    function () {
        switch (this.styleType) {
            case 'wider-header':
                this.cclass = this.cclass + ' card-container-wider-header';
                break;
            case 'narrower-header':
                this.cclass = this.cclass + ' card-container-narrower-header';
                break;
            case 'wider-action':
                this.cclass = this.cclass + ' card-container-wider-action';
                break;
            case 'narrower-action':
                this.cclass = this.cclass + ' card-container-narrower-action';
                break;
            case 'wider-all':
                this.cclass = this.cclass + ' card-container-wider-header card-container-wider-action';
                break;
            case 'narrower-all':
                this.cclass = this.cclass + ' card-container-narrower-header card-container-narrower-action';
                break;
            case 'wider-header-narrower-action':
                this.cclass = this.cclass + ' card-container-wider-header card-container-narrower-action';
                break;
            case 'narrower-header-wider-action':
                this.cclass = this.cclass + ' card-container-narrower-header card-container-wider-action';
                break;
            default:
                break;
        }
    };
    /**
     * @return {?}
     */
    AmexioCardCEComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.AmexioCardCEHeaderQueryList) {
            this.amexioCardHeaderList = this.AmexioCardCEHeaderQueryList.toArray();
            
        }
        this.setCardAligementForAllInnerComponent();
    };
    // TO SET ALIGN TO ALL INNER COMPONENT IN CARD
    /**
     * @return {?}
     */
    AmexioCardCEComponent.prototype.setCardAligementForAllInnerComponent = /**
     * @return {?}
     */
    function () {
        this.amexioCardHeaderList = this.AmexioCardCEHeaderQueryList.toArray();
        if (this.amexioCardHeaderList[0]) {
            this.amexioCardHeaderList[0].windowFlag = false;
        }
        if (this.amexioCardHeaderList[0] !== undefined && !this.amexioCardHeaderList[0].align &&
            this.amexioCardHeaderList[0].align.length > 0) {
            this.amexioCardHeaderList[0].align = this.align;
        }
        this.amexioCardBodyList = this.AmexioCardCEBodyQueryList.toArray();
        if (this.amexioCardBodyList[0] !== undefined && !this.amexioCardBodyList[0].align && this.amexioCardBodyList[0].align.length > 0) {
            this.amexioCardBodyList[0].align = this.align;
        }
        this.amexioCardActionList = this.AmexioCardCEActionQueryList.toArray();
        if (this.amexioCardActionList[0] !== undefined && !this.amexioCardActionList[0].align &&
            this.amexioCardActionList[0].align.length > 0) {
            this.amexioCardActionList[0].align = this.align;
        }
        else if (this.amexioCardActionList[0] !== undefined &&
            this.amexioCardActionList[0].align === '') {
            this.amexioCardActionList[0].align = 'end';
        }
    };
    /**
     * @return {?}
     */
    AmexioCardCEComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
    };
    AmexioCardCEComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-card-ce',
                    template: "\n    <div style=\"height:100%;\" [ngStyle]=\"{'background': bgimage ? 'url(' + bgimage + ') center/cover no-repeat' : null}\" [ngClass]=\"cclass\">\n        <div class=\"card-container-ce\" [ngStyle]=\"{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align , 'color':color, 'background': background}\">\n            <ng-content></ng-content>\n            <div>\n            </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioCardCEComponent.ctorParameters = function () { return []; };
    AmexioCardCEComponent.propDecorators = {
        bgimage: [{ type: i0.Input, args: ['bg-image',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        background: [{ type: i0.Input, args: ['background',] }],
        height: [{ type: i0.Input, args: ['height',] }],
        align: [{ type: i0.Input, args: ['align',] }],
        styleType: [{ type: i0.Input, args: ['style-type',] }],
        AmexioCardCEHeaderQueryList: [{ type: i0.ContentChildren, args: [AmexioCardCEHeaderComponent,] }],
        AmexioCardCEBodyQueryList: [{ type: i0.ContentChildren, args: [AmexioCardCEBodyComponent,] }],
        AmexioCardCEActionQueryList: [{ type: i0.ContentChildren, args: [AmexioCardCEActionComponent,] }]
    };
    return AmexioCardCEComponent;
}(LifeCycleBaseComponent));

var __extends$33 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioFormCEComponent = /** @class */ (function (_super) {
    __extends$33(AmexioFormCEComponent, _super);
    function AmexioFormCEComponent(formBuilder) {
        var _this = _super.call(this) || this;
        _this.formBuilder = formBuilder;
        _this.showError = false;
        _this.showErrorMsg = new i0.EventEmitter();
        _this.componentError = [];
        _this.windowFlag = false;
        _this.checkForm = false;
        _this.isFormValid = false;
        _this.showDialogue = false;
        _this.errorMsgArray = [];
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioFormCEComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.setCardAligementForAllInnerComponent();
    };
    /**
     * @return {?}
     */
    AmexioFormCEComponent.prototype.onResize = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioFormCEComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ ngContentModels = this.models.toArray();
        var /** @type {?} */ innerModelArray = [];
        this.fb.forEach(function (fbnode) {
            var /** @type {?} */ modelarray = fbnode.modelsarray;
            var /** @type {?} */ fgc = {};
            modelarray.forEach(function (m) {
                fgc[m.name] = m.control;
                innerModelArray.push(m);
            });
            var /** @type {?} */ grp = _this.formBuilder.group(fgc);
            _this.form.form.registerControl(fbnode.group, grp);
        });
        ngContentModels.forEach(function (model) {
            if (!_this.isFieldPresentInParentAndChildBoth(innerModelArray, model.name)) {
                if (!model.name || model.name === null) {
                    model.name = model.valueAccessor['name'];
                }
                _this.form.control.registerControl(model.name, model.control);
            }
        });
        this.clearTimeout = setTimeout(function () {
            _this.form.form.updateValueAndValidity();
        }, 100);
        this.btns.toArray().forEach(function (btnCom) {
            if ((btnCom.formbind === _this.fname) && !btnCom.disabled) {
                _this.buttons.push(btnCom);
            }
        });
        this.AmexioCardCEActionQueryList.toArray()[0].formFlag = true;
        this.AmexioCardCEActionQueryList.toArray()[0].showError = this.showError;
        this.AmexioCardCEHeaderQueryList.toArray()[0].windowFlag = false;
        this.validateForm();
        this.onResize();
        _super.prototype.ngAfterViewInit.call(this);
    };
    /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    AmexioFormCEComponent.prototype.isFieldPresentInParentAndChildBoth = /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    function (innerModelArray, name) {
        var /** @type {?} */ isPresent = false;
        innerModelArray.forEach(function (innerModel) {
            if (name === innerModel.name) {
                isPresent = true;
            }
        });
        return isPresent;
    };
    // THIS METHOD IS USED FOR DISABLE BUTTON
    /**
     * @return {?}
     */
    AmexioFormCEComponent.prototype.validateForm = /**
     * @return {?}
     */
    function () {
        if (this.form && this.form.status === 'INVALID') {
            this.disableButton(true);
        }
        else {
            this.disableButton(false);
        }
    };
    /**
     * @param {?} flag
     * @return {?}
     */
    AmexioFormCEComponent.prototype.disableButton = /**
     * @param {?} flag
     * @return {?}
     */
    function (flag) {
        this.buttons.forEach(function (btn) {
            btn.disabled = flag;
        });
    };
    /**
     * @return {?}
     */
    AmexioFormCEComponent.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        this.validateForm();
        var /** @type {?} */ form;
        form = this.form;
        this.AmexioCardCEActionQueryList.toArray()[0].checkFormValidation(form);
    };
    /**
     * @return {?}
     */
    AmexioFormCEComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        clearTimeout(this.clearTimeout);
        _super.prototype.ngOnDestroy.call(this);
    };
    /**
     * @return {?}
     */
    AmexioFormCEComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.buttons = [];
        if (!this.color) {
            this.cclass = 'card-container-ce-color';
        }
        if (!this.background) {
            this.cclass = this.cclass + ' card-container-ce-bg-color';
        }
        this.setWiderAndNarrower();
        _super.prototype.ngOnInit.call(this);
    };
    // THIS METHOD CALLL FOR HEADER AND ACTION STYLE
    /**
     * @return {?}
     */
    AmexioFormCEComponent.prototype.setWiderAndNarrower = /**
     * @return {?}
     */
    function () {
        switch (this.styleType) {
            case 'wider-header':
                this.cclass = this.cclass + ' card-container-wider-header';
                break;
            case 'narrower-header':
                this.cclass = this.cclass + ' card-container-narrower-header';
                break;
            case 'wider-action':
                this.cclass = this.cclass + ' card-container-wider-action';
                break;
            case 'narrower-action':
                this.cclass = this.cclass + ' card-container-narrower-action';
                break;
            case 'wider-all':
                this.cclass = this.cclass + ' card-container-wider-header card-container-wider-action';
                break;
            case 'narrower-all':
                this.cclass = this.cclass + ' card-container-narrower-header card-container-narrower-action';
                break;
            case 'wider-header-narrower-action':
                this.cclass = this.cclass + ' card-container-wider-header card-container-narrower-action';
                break;
            case 'narrower-header-wider-action':
                this.cclass = this.cclass + ' card-container-narrower-header card-container-wider-action';
                break;
            default:
                break;
        }
    };
    // TO SET ALIGN TO ALL INNER COMPONENT IN CARD
    /**
     * @return {?}
     */
    AmexioFormCEComponent.prototype.setCardAligementForAllInnerComponent = /**
     * @return {?}
     */
    function () {
        this.amexioCardHeaderList = this.AmexioCardCEHeaderQueryList.toArray();
        if (this.amexioCardHeaderList[0] !== undefined && !this.amexioCardHeaderList[0].align &&
            this.amexioCardHeaderList[0].align.length > 0) {
            this.amexioCardHeaderList[0].align = this.align;
        }
        this.amexioCardBodyList = this.AmexioCardCEBodyQueryList.toArray();
        if (this.amexioCardBodyList[0] !== undefined && !this.amexioCardBodyList[0].align && this.amexioCardBodyList[0].align.length > 0) {
            this.amexioCardBodyList[0].align = this.align;
        }
        this.amexioCardActionList = this.AmexioCardCEActionQueryList.toArray();
        if (this.amexioCardActionList[0] !== undefined && !this.amexioCardActionList[0].align &&
            this.amexioCardActionList[0].align.length > 0) {
            this.amexioCardActionList[0].align = this.align;
        }
        else if (this.amexioCardActionList[0] !== undefined &&
            this.amexioCardActionList[0].align === '') {
            this.amexioCardActionList[0].align = 'end';
        }
    };
    AmexioFormCEComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-form-ce',
                    template: "\n      <div [ngStyle]=\"{'background': bgimage ? 'url(' + bgimage + ') center/cover no-repeat' : null}\" [ngClass]=\"cclass\">\n          <div [ngStyle]=\"{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align , 'color':color, 'background': background}\">\n              <form name=\"fname\" class=\"form-container-ce form-group\">\n                  <ng-content></ng-content>\n              </form>\n          <div>\n      </div>\n    ",
                },] },
    ];
    /** @nocollapse */
    AmexioFormCEComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder }
    ]; };
    AmexioFormCEComponent.propDecorators = {
        fname: [{ type: i0.Input, args: ['form-name',] }],
        showError: [{ type: i0.Input, args: ['show-error',] }],
        showErrorMsg: [{ type: i0.Output }],
        bgimage: [{ type: i0.Input, args: ['bg-image',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        background: [{ type: i0.Input, args: ['background',] }],
        height: [{ type: i0.Input, args: ['height',] }],
        align: [{ type: i0.Input, args: ['align',] }],
        styleType: [{ type: i0.Input, args: ['style-type',] }],
        AmexioCardCEHeaderQueryList: [{ type: i0.ContentChildren, args: [AmexioCardCEHeaderComponent,] }],
        AmexioCardCEBodyQueryList: [{ type: i0.ContentChildren, args: [AmexioCardCEBodyComponent,] }],
        AmexioCardCEActionQueryList: [{ type: i0.ContentChildren, args: [AmexioCardCEActionComponent,] }],
        btns: [{ type: i0.ContentChildren, args: [AmexioButtonComponent, { descendants: true },] }],
        form: [{ type: i0.ViewChild, args: [forms.NgForm,] }],
        models: [{ type: i0.ContentChildren, args: [forms.NgModel, { descendants: true },] }],
        fb: [{ type: i0.ContentChildren, args: [AmexioFormGroupDirective, { descendants: true },] }]
    };
    return AmexioFormCEComponent;
}(LifeCycleBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioHomePageCenterPanelComponent = /** @class */ (function () {
    function AmexioHomePageCenterPanelComponent(matchMediaService) {
        this.matchMediaService = matchMediaService;
    }
    /**
     * @return {?}
     */
    AmexioHomePageCenterPanelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioHomePageCenterPanelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-homepage-centerpanel',
                    template: "\n    <div class=\"homepage-centerpanel\">\n        <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioHomePageCenterPanelComponent.ctorParameters = function () { return [
        { type: DeviceQueryService }
    ]; };
    AmexioHomePageCenterPanelComponent.propDecorators = {
        type: [{ type: i0.Input, args: ['type',] }]
    };
    return AmexioHomePageCenterPanelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioHomePageEastPanelComponent = /** @class */ (function () {
    function AmexioHomePageEastPanelComponent(matchMediaService) {
        this.matchMediaService = matchMediaService;
    }
    /**
     * @return {?}
     */
    AmexioHomePageEastPanelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioHomePageEastPanelComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioHomePageEastPanelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-homepage-eastpanel',
                    template: "\n    <div class=\"homepage-westpanel\">\n        <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioHomePageEastPanelComponent.ctorParameters = function () { return [
        { type: DeviceQueryService }
    ]; };
    AmexioHomePageEastPanelComponent.propDecorators = {
        type: [{ type: i0.Input, args: ['type',] }]
    };
    return AmexioHomePageEastPanelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioHomePageWestPanelComponent = /** @class */ (function () {
    function AmexioHomePageWestPanelComponent(matchMediaService) {
        this.matchMediaService = matchMediaService;
    }
    /**
     * @return {?}
     */
    AmexioHomePageWestPanelComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioHomePageWestPanelComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-homepage-westpanel',
                    template: "\n    <div class=\"homepage-westpanel\">\n        <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioHomePageWestPanelComponent.ctorParameters = function () { return [
        { type: DeviceQueryService }
    ]; };
    AmexioHomePageWestPanelComponent.propDecorators = {
        type: [{ type: i0.Input, args: ['type',] }]
    };
    return AmexioHomePageWestPanelComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ViewportBackgroundComponent = /** @class */ (function () {
    function ViewportBackgroundComponent() {
    }
    /**
     * @return {?}
     */
    ViewportBackgroundComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    ViewportBackgroundComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        // IMAGE
        if (this.imageTemplate) {
            this.imagePath = this.imageTemplate.path;
            this.bgCss = 'bgCss' + Math.floor(Math.random() * 1000) + 'background';
        }
        // VIDEO
        if (this.videoTemplate) {
            this.videoPath = this.videoTemplate.path;
        }
    };
    ViewportBackgroundComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-viewport-background',
                    template: "\n    <!-- <div id=\"{{componentId}}\" class=\"backgroundCss filterCss {{bgCss}}\">\n         <ng-content></ng-content>\n    </div> -->\n  ",
                },] },
    ];
    /** @nocollapse */
    ViewportBackgroundComponent.ctorParameters = function () { return []; };
    ViewportBackgroundComponent.propDecorators = {
        imageTemplate: [{ type: i0.ContentChild, args: [AmexioImageComponent,] }],
        videoTemplate: [{ type: i0.ContentChild, args: [AmexioVideoPlayerComponent,] }],
        backgroundColor: [{ type: i0.Input, args: ['background-color',] }]
    };
    return ViewportBackgroundComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ViewportContentBodyComponent = /** @class */ (function () {
    function ViewportContentBodyComponent() {
        this.scrollable = false;
    }
    /**
     * @return {?}
     */
    ViewportContentBodyComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    ViewportContentBodyComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-viewport-content-body',
                    template: "\n\n            <ng-content></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    ViewportContentBodyComponent.ctorParameters = function () { return []; };
    ViewportContentBodyComponent.propDecorators = {
        navTemplate: [{ type: i0.ContentChild, args: [AmexioNavBarComponent,] }],
        scrollable: [{ type: i0.Input, args: ['scrollable',] }]
    };
    return ViewportContentBodyComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ViewportContentComponent = /** @class */ (function () {
    function ViewportContentComponent() {
        this.scrollable = false;
    }
    /**
     * @return {?}
     */
    ViewportContentComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    ViewportContentComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    ViewportContentComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.bgImageTemplate.backgroundColor) {
            this.backgroundColor = this.bgImageTemplate.backgroundColor;
        }
        // IMAGE
        if (this.bgImageTemplate.imagePath) {
            this.backgroundCss = 'bgCss' + Math.floor(Math.random() * 1000) + 'backgound';
            this.insertStyleSheetRule('.' + this.backgroundCss + '{ background-image: url(' + this.bgImageTemplate.imagePath + ')}');
        }
        // VIDEO
        if (this.bgImageTemplate.videoPath) {
            this.bgImageTemplate.videoTemplate.rederVideo = false;
            this.bgvid = 'videoId' + Math.floor(Math.random() * 1000);
            this.tempUrl = this.bgImageTemplate.videoPath;
            this.playVideo();
        }
    };
    /**
     * @return {?}
     */
    ViewportContentComponent.prototype.playVideo = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ media = this.videoId.nativeElement;
        media.muted = true;
        media.play();
    };
    /**
     * @param {?} ruleText
     * @return {?}
     */
    ViewportContentComponent.prototype.insertStyleSheetRule = /**
     * @param {?} ruleText
     * @return {?}
     */
    function (ruleText) {
        var /** @type {?} */ sheets = document.styleSheets;
        if (sheets.length === 0) {
            var /** @type {?} */ style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        var /** @type {?} */ sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
    };
    ViewportContentComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-viewport-content',
                    template: "\n\n    <!-- <div class=\"viewportContent {{backgroundCss}}\" [ngStyle]=\"{'height':height}\" onscroll=\"myFunction()\">\n        <video id=\"{{bgvid}}\" src=\"{{tempUrl}}\" type=\"video/mp4\" poster loop autoplay playsinline>\n        </video>\n        <div class=\"viewportBody\" [ngStyle]=\"{'overflow-y': internalScroll ? 'scroll' : 'hidden',\n    'background-color':backgroundColor, 'height':height}\">\n            <ng-content select=\"amexio-viewport-content-body\"></ng-content>\n\n        </div>\n    </div> -->\n\n\n\n    <div class=\"viewportContent {{backgroundCss}}\" [ngStyle]=\"{'height':height}\" onscroll=\"myFunction()\">\n        <video #videoId src=\"{{tempUrl}}\" muted=\"muted\" poster=\"\" loop=\"\" autoplay=\"true\" webkit-playsinline=\"true\" playsinline=\"true\"></video>\n        <div class=\"viewportBody\" [ngStyle]=\"{'overflow-y': internalScroll ? 'scroll' : 'hidden',\n    'background-color':backgroundColor, 'height':height}\">\n            <ng-content select=\"amexio-viewport-content-body\"></ng-content>\n\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    ViewportContentComponent.ctorParameters = function () { return []; };
    ViewportContentComponent.propDecorators = {
        videoId: [{ type: i0.ViewChild, args: ['videoId',] }],
        bgImageTemplate: [{ type: i0.ContentChild, args: [ViewportBackgroundComponent,] }],
        contentTemplate: [{ type: i0.ContentChild, args: [ViewportContentBodyComponent,] }],
        scrollable: [{ type: i0.Input, args: ['scrollable',] }]
    };
    return ViewportContentComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ViewportComponent = /** @class */ (function () {
    function ViewportComponent() {
        this.scrollable = true;
        this.type = '1';
        this.pageColor = 'black';
    }
    /**
     * @param {?} $event
     * @return {?}
     */
    ViewportComponent.prototype.onWindowScroll = /**
     * @param {?} $event
     * @return {?}
     */
    function ($event) {
        if ((this.type === '2') && (this.scrollable && window.scrollY > 0)) {
            this.contentCollection.forEach(function (element) {
                if (element.contentTemplate.navTemplate) {
                    element.contentTemplate.navTemplate.transparent = false;
                    element.contentTemplate.navTemplate.top = 0;
                }
            });
        }
        if (window.scrollY === 0) {
            this.contentCollection.forEach(function (element) {
                if (element.contentTemplate.navTemplate) {
                    element.contentTemplate.navTemplate.transparent = true;
                    element.contentTemplate.navTemplate.top = 'unset';
                }
            });
        }
    };
    /**
     * @return {?}
     */
    ViewportComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        document.body.style.backgroundColor = this.pageColor;
        if (this.scrollable) {
            this.overflow = 'auto';
        }
        else {
            this.overflow = 'hidden';
        }
    };
    /**
     * @return {?}
     */
    ViewportComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.contentCollection = this.queryContent.toArray();
        if (this.type === '2') {
            this.contentCollection.forEach(function (element) {
                if (element.contentTemplate.navTemplate) {
                    element.contentTemplate.navTemplate.opacity = 0.8;
                    element.contentTemplate.navTemplate.top = 'unset';
                }
            });
        }
        if (this.scrollable) {
            this.contentCollection.forEach(function (element) {
                element.internalScroll = false;
                _this.getType(element);
            });
        }
        else {
            this.contentCollection.forEach(function (element) {
                _this.getType(element);
                if (element.scrollable) {
                    element.internalScroll = true;
                    element.height = 100 / _this.contentCollection.length + '%';
                }
                else {
                    element.internalScroll = false;
                }
            });
        }
        this.insertStyleSheetRule('body' + '{ overflow-y:' + this.overflow + '}');
    };
    /**
     * @param {?} ruleText
     * @return {?}
     */
    ViewportComponent.prototype.insertStyleSheetRule = /**
     * @param {?} ruleText
     * @return {?}
     */
    function (ruleText) {
        var /** @type {?} */ sheets = document.styleSheets;
        if (sheets.length === 0) {
            var /** @type {?} */ style = document.createElement('style');
            style.appendChild(document.createTextNode(''));
            document.head.appendChild(style);
        }
        var /** @type {?} */ sheet = sheets[sheets.length - 1];
        sheet.insertRule(ruleText, sheet.rules ? sheet.rules.length : sheet.cssRules.length);
    };
    /**
     * @param {?} element
     * @return {?}
     */
    ViewportComponent.prototype.getType = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (this.type === '1' && element.contentTemplate.navTemplate) {
            element.contentTemplate.navTemplate.transparent = true;
        }
        if (this.type === '2' && element.contentTemplate.navTemplate) {
            element.contentTemplate.navTemplate.transparent = true;
        }
        if (this.type === '3' && element.contentTemplate.navTemplate) {
            element.contentTemplate.navTemplate.transparent = false;
        }
    };
    ViewportComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-viewport',
                    template: "\n        <ng-content select=\"amexio-viewport-content\"></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    ViewportComponent.ctorParameters = function () { return []; };
    ViewportComponent.propDecorators = {
        queryContent: [{ type: i0.ContentChildren, args: [ViewportContentComponent,] }],
        scrollable: [{ type: i0.Input, args: ['scrollable',] }],
        type: [{ type: i0.Input, args: ['type',] }],
        pageColor: [{ type: i0.Input, args: ['page-color',] }],
        onWindowScroll: [{ type: i0.HostListener, args: ['window:scroll', [],] }]
    };
    return ViewportComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by kedarkokil on 26/09/18.
*/
var AmexioBreadcrumbComponent = /** @class */ (function () {
    function AmexioBreadcrumbComponent(element, dataService) {
        this.element = element;
        this.dataService = dataService;
        /*
           Events
           name : onListItemClick
           datatype : any
           version : none
           default :
           description : On click event
           */
        this.onListItemClick = new i0.EventEmitter();
        /*
           Events
           name : onClick
           datatype : any
           version : none
           default :
           description : On click event
           */
        this.onClick = new i0.EventEmitter();
        this.buttonAngleRightCss = 'button_angle-right';
        this.displaykey = 'text';
        this.childarraykey = 'children';
    }
    /**
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.arrowKey = this.buttonAngleRightCss;
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.setData(this.data);
        }
    };
    // ICON ADDED WHEN THE ICON IS NOT GIVEN
    /**
     * @param {?} nodeArray
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.iconAddedMethod = /**
     * @param {?} nodeArray
     * @return {?}
     */
    function (nodeArray) {
        var _this = this;
        if (nodeArray && nodeArray.length > 0) {
            nodeArray.forEach(function (node) {
                if (node[_this.childarraykey]) {
                    node[_this.childarraykey].forEach(function (element, index) {
                        element['id'] = Math.floor(Math.random() * 90000) + 10000 + '_id';
                        if (node[_this.childarraykey]) {
                            _this.iconAddedMethod(node[_this.childarraykey]);
                        }
                        _this.setTabindex(index, element);
                        _this.childIconCheckMethod(element);
                    });
                }
            });
        }
    };
    /**
     * @param {?} index
     * @param {?} element
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.setTabindex = /**
     * @param {?} index
     * @param {?} element
     * @return {?}
     */
    function (index, element) {
        if (index === 0) {
            element['tabindex'] = 1;
        }
        else {
            element['tabindex'] = -1;
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.childIconCheckMethod = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (element.hasOwnProperty([this.childarraykey])) {
            element[this.childarraykey].forEach(function (childIcon) {
                if (childIcon.icon == null || childIcon.icon === '') {
                    childIcon.icon = 'fa fa-file-o';
                }
            });
            if (element.icon == null || element.icon === '') {
                element.icon = 'fa fa-folder-o';
            }
            this.iconAddedMethod(element);
        }
    };
    // THIS METHOD   IS USED FOR ADDING CHILDREN IN OPTIONS
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.getSelectedItem = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ arrayOnly = [event.data];
        this.childItem = arrayOnly;
        event.parentRef.show = true;
        event.parentRef.expand = false;
        this.arrowKey = this.buttonAngleRightCss;
        this.onListItemClick.emit(event.data);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.getEventEmitClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onListItemClick.emit(event);
    };
    /**
     * @param {?} item
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.onArrowClick = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        item.expand = !item.expand;
        if (item.expand) {
            this.arrowKey = 'button_angle-down';
        }
        else {
            this.arrowKey = this.buttonAngleRightCss;
        }
    };
    /**
     * @param {?} nodeArray
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.onArrowDown = /**
     * @param {?} nodeArray
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    function (nodeArray, node, index) {
        var /** @type {?} */ currentindex;
        if (index < nodeArray[this.childarraykey].length - 1) {
            nodeArray[this.childarraykey].forEach(function (element) {
                if (node['id'] === element['id']) {
                    currentindex = index + 1;
                }
            });
        }
        else if (index === nodeArray[this.childarraykey].length - 1) {
            currentindex = 0;
        }
        var /** @type {?} */ itemid = nodeArray[this.childarraykey][currentindex];
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} nodeArray
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.onArrowUp = /**
     * @param {?} nodeArray
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    function (nodeArray, node, index) {
        var /** @type {?} */ currentindex;
        if (index !== 0) {
            nodeArray[this.childarraykey].forEach(function (element) {
                if (node['id'] === element['id']) {
                    currentindex = index - 1;
                }
            });
        }
        else if (index === 0) {
            currentindex = nodeArray[this.childarraykey].length - 1;
        }
        var /** @type {?} */ itemid = nodeArray[this.childarraykey][currentindex];
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.onButtonClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.show = false;
        event.expand = false;
        this.onClick.emit(event);
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        // Check if key is added?
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.iconAddedMethod(this.data);
    };
    /**
     * @param {?} targetElement
     * @return {?}
     */
    AmexioBreadcrumbComponent.prototype.onElementOutClick = /**
     * @param {?} targetElement
     * @return {?}
     */
    function (targetElement) {
        var /** @type {?} */ parentFound = false;
        while (targetElement !== null && !parentFound) {
            if (targetElement === this.element.nativeElement) {
                parentFound = true;
            }
            targetElement = targetElement.parentElement;
        }
        if (!parentFound) {
            var /** @type {?} */ expandData_1;
            this.data.forEach(function (dataObject) {
                if (dataObject) {
                    expandData_1 = dataObject;
                }
                if (expandData_1 && expandData_1.expand != null) {
                    expandData_1.expand = false;
                }
            });
        }
    };
    AmexioBreadcrumbComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-breadcrumb',
                    template: "\n    <ng-container *ngIf=\"data\">\n\n        <div *ngFor=\"let nodeObject of data\">\n\n            <div   class=\"breadcrum-rightshift-css\">\n                <div class=\"breadcrumb-group\" tabindex=\"1\" aria-label=\"breadcrum\">\n                    <label tabindex=\"1\" (click)=\"onButtonClick(nodeObject)\" (keyup.enter)=\"onButtonClick(nodeObject)\" class=\"label-icon-css\">\n                        <ng-container *ngIf=\"nodeObject && nodeObject.icon\">\n                            <span [ngClass]=\"nodeObject.icon\"></span>\n                        </ng-container>&nbsp;\n                        <span>{{nodeObject[displaykey]}}&nbsp;&nbsp;</span>\n                    </label>\n                    <ng-container *ngIf=\"nodeObject[childarraykey]\">\n                        <amexio-c-icon tabindex=\"1\" aria-label=\"button clickable\" (click)=\"onArrowClick(nodeObject)\"\n                            (keyup.enter)=\"onArrowClick(nodeObject)\" class=\"arrow-group-css\" [key]=\"arrowKey\"></amexio-c-icon>\n                    </ng-container>\n                    <div class=\"context-menu-list1\" [@breadCrumbStateState]=\"nodeObject.expand ? 'visible':'hidden'\">\n                        <ng-container *ngFor=\"let node of nodeObject[childarraykey] let rowindex = index\">\n                            <div tabindex=\"{{node.tabindex}}\" id=\"{{node.id}}\" class=\"context-menu-list-items1\" [ngStyle]=\"{'cursor': node.disabled ? 'not-allowed':'pointer'}\"\n                                (click)=\"getSelectedItem({data:node,parentRef:nodeObject})\" (keyup.arrowdown)=\"onArrowDown(nodeObject,node,rowindex)\"\n                                (keyup.arrowup)=\"onArrowUp(nodeObject,node,rowindex)\" (keyup.enter)=\"getSelectedItem({data:node,parentRef:nodeObject})\">\n                                <div class=\"dropdown-icon-css\">\n                                    <ng-container *ngIf=\"node.icon\">\n                                        <amexio-c-icon [ngClass]=\"node.icon\"></amexio-c-icon>\n                                    </ng-container>&nbsp;\n                                </div>\n                                <div class=\"dropdown-label-css\">\n                                    <span>{{node[displaykey]}}&nbsp;</span>\n                                </div>\n                            </div>\n                        </ng-container>\n                    </div>\n                </div>\n                <ng-container *ngIf=\"nodeObject.show\">\n                    <amexio-breadcrumb [data]=\"childItem\" [display-key]=\"displaykey\" [childarray-key]=\"childarraykey\"\n                        (onListItemClick)=\"getEventEmitClick($event)\" (onClick)=\"onButtonClick($event)\">\n                    </amexio-breadcrumb>\n                </ng-container>\n            </div>\n        </div>\n    </ng-container>\n  ",
                    animations: [
                        trigger('breadCrumbStateState', [
                            state('hidden', style({
                                'transform': 'scale(0)',
                                'transform-origin': 'left top 0px',
                            })),
                            state('visible', style({
                                'transform-origin': 'left top 0px',
                                'transform': 'scale(1)',
                            })),
                            transition('*=>hidden', animate('0ms')),
                            transition('*=>visible', animate('200ms')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioBreadcrumbComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: CommonDataService }
    ]; };
    AmexioBreadcrumbComponent.propDecorators = {
        data: [{ type: i0.Input }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        displaykey: [{ type: i0.Input, args: ['display-key',] }],
        childarraykey: [{ type: i0.Input, args: ['childarray-key',] }],
        onListItemClick: [{ type: i0.Output }],
        onClick: [{ type: i0.Output }],
        onElementOutClick: [{ type: i0.HostListener, args: ['document:click', ['$event.target'],] }, { type: i0.HostListener, args: ['document: touchstart', ['$event.target'],] }]
    };
    return AmexioBreadcrumbComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by sagar on 6/9/17.
*/
var DockbarComponent = /** @class */ (function () {
    function DockbarComponent() {
        this.elementId = 'dockbar-item-id' + Math.floor(Math.random() * 90000) + 10000;
    }
    // Close the  dockbar item
    /**
     * @return {?}
     */
    DockbarComponent.prototype.onBarIconClick = /**
     * @return {?}
     */
    function () {
        this.active = false;
    };
    /**
     * @return {?}
     */
    DockbarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    DockbarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-dockbar-item', template: "\n    <div *ngIf=\"active\"  [style.width]=\"width\"\n    class=\"dockbar-active-content dockbar-height\"\n    [style.min-height]=\"height\"  [style.max-height]=\"height\">\n      <ng-container *ngIf=\"active && title\">\n        <div class=\"dockbar-title\">\n          {{title}}\n          <span class=\"dockbar-item-close-bar\" (click)=\"onBarIconClick()\">\n            <amexio-c-icon key=\"dockbar_close\"></amexio-c-icon>\n            <!--\n                        <i class=\"fa fa-times\" aria-hidden=\"true\"></i>\n            -->\n          </span>\n        </div>\n      </ng-container>\n      <ng-content>\n      </ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    DockbarComponent.ctorParameters = function () { return []; };
    DockbarComponent.propDecorators = {
        active: [{ type: i0.Input }],
        label: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        mda: [{ type: i0.Input }],
        width: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        path: [{ type: i0.Input }],
        height: [{ type: i0.Input }]
    };
    return DockbarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Ketan Gote on 8/21/17.
*/
var DockedBarToolComponent = /** @class */ (function () {
    function DockedBarToolComponent() {
    }
    // on docker bar click event
    /**
     * @param {?} event
     * @return {?}
     */
    DockedBarToolComponent.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ tabs = this.dockbarArray;
        tabs.forEach(function (tab) {
            tab.active = false;
            if (tab.elementId === event.elementId) {
                tab.active = true;
            }
        });
    };
    /**
     * @return {?}
     */
    DockedBarToolComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.dockbarArray = this.dockbars.toArray();
    };
    /**
     * @return {?}
     */
    DockedBarToolComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    DockedBarToolComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-dockbar', template: "\n    <div class=\"dockbar\" [style.min-height]=\"height\">\n      <ng-container *ngFor=\"let dockbar of dockbarArray\">\n        <button [ngClass]=\"{'active':dockbar.active}\" (click)=\"onClick(dockbar)\">\n\n          <!--Normal image-->\n          <ng-container *ngIf=\"dockbar.path\">\n            <img [src]=\"dockbar.path\">\n          </ng-container>\n\n          <!--this is for fontawesome-->\n          <ng-container *ngIf=\"(!(dockbar.icon && dockbar.mda) && dockbar.icon)\">\n            <amexio-image [icon-class]=\"dockbar.icon\" [c-class]=\"\"></amexio-image>\n            <!--<i [ngClass]=\"dockbar.icon\"></i>-->\n          </ng-container>\n\n          <!--if dockbar have label instead of icon -->\n          <ng-container *ngIf=\"dockbar.label && dockbar.active\">\n            <p><strong class=\"dockbar-label-highlight\">{{dockbar.label}}</strong></p>\n          </ng-container>\n\n          <ng-container *ngIf=\"dockbar.label && !dockbar.active\">\n            <p>{{dockbar.label}}</p>\n          </ng-container>\n\n        </button>\n      </ng-container>\n    </div>\n    <div class=\"dockbar-content\" [style.min-height]=\"height\">\n      <ng-content></ng-content>\n    </div>\n\n  ",
                },] },
    ];
    /** @nocollapse */
    DockedBarToolComponent.ctorParameters = function () { return []; };
    DockedBarToolComponent.propDecorators = {
        dockbars: [{ type: i0.ContentChildren, args: [DockbarComponent,] }],
        height: [{ type: i0.Input }]
    };
    return DockedBarToolComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/8/17.
*/
var AmexioMenuBarComponent = /** @class */ (function () {
    function AmexioMenuBarComponent(matchMediaService, dataService) {
        this.matchMediaService = matchMediaService;
        this.dataService = dataService;
        /*
        Events
        name : nodeClick
        datatype : any
        version : none
        default : none
        description : Fire when menubar bar click.
        */
        this.nodeClick = new i0.EventEmitter();
        this.xposition = false;
        this.expand = false;
    }
    /**
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.setData(this.data);
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        node['expandflag'] = !node['expandflag'];
        if (this.matchMediaService.IsPhone() || this.matchMediaService.IsTablet()) {
            for (var _i = 0, _a = 'length'; _i < _a.length; _i++) {
                var i = _a[_i];
                if (this.data[i] === node) {
                    this.data[i].expand = !this.data[i].expand;
                }
                else {
                    this.data[i].expand = false;
                }
            }
        }
        this.nodeClick.emit(node);
    };
    /**
     * @param {?} subinnernode
     * @param {?} mainnode
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onSubInnerNodeClick = /**
     * @param {?} subinnernode
     * @param {?} mainnode
     * @return {?}
     */
    function (subinnernode, mainnode) {
        if (mainnode['expandflag']) {
            mainnode['expandflag'] = false;
        }
        this.nodeClick.emit(subinnernode);
    };
    /**
     * @param {?} subnode
     * @param {?} mainnode
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onInnerNodeClick = /**
     * @param {?} subnode
     * @param {?} mainnode
     * @return {?}
     */
    function (subnode, mainnode) {
        if (mainnode['expandflag']) {
            mainnode['expandflag'] = false;
        }
        this.nodeClick.emit(subnode);
    };
    /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onMenubarKeyup = /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    function (event, flag, rowindex, node, data) {
        if (event.keyCode === 37) {
            this.NavigateMenubarLeft(event, flag, rowindex, node, data);
        }
        else if (event.keyCode === 39) {
            this.NavigateMenubarRight(event, flag, rowindex, node, data);
        }
        else if (event.keyCode === 13) {
            this.onEnterClick(rowindex, node);
        }
    };
    /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.NavigateMenubarLeft = /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    function (event, flag, rowindex, node, data) {
        if (node['expand']) {
            node['expand'] = false;
        }
        if (rowindex !== 0) {
            var /** @type {?} */ currentindex = rowindex - 1;
            var /** @type {?} */ itemid = currentindex;
            document.getElementById(itemid).focus();
            var /** @type {?} */ currentnode = data[itemid];
            if (currentnode) {
                currentnode['expand'] = true;
                currentnode['expandflag'] = true;
                this.currentnode = currentnode;
            }
        }
        else if (rowindex === 0) {
            var /** @type {?} */ currentindex = this.data.length - 1;
            var /** @type {?} */ itemid = currentindex;
            document.getElementById(itemid).focus();
        }
    };
    /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.NavigateMenubarRight = /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    function (event, flag, rowindex, node, data) {
        if (node['expand']) {
            node['expand'] = false;
        }
        if (rowindex < data.length - 1) {
            var /** @type {?} */ currentindex = rowindex + 1;
            var /** @type {?} */ itemid = currentindex;
            document.getElementById(itemid).focus();
            var /** @type {?} */ currentnode = data[itemid];
            if (currentnode) {
                currentnode['expand'] = true;
                currentnode['expandflag'] = true;
                this.currentnode = currentnode;
            }
        }
        else if (rowindex === data.length - 1) {
            var /** @type {?} */ currentindex = 0;
            var /** @type {?} */ itemid = currentindex;
            document.getElementById(itemid).focus();
        }
    };
    /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @param {?} nodedata
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.navigateChild = /**
     * @param {?} event
     * @param {?} flag
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @param {?} nodedata
     * @return {?}
     */
    function (event, flag, rowindex, node, data, nodedata) {
        if (event.keyCode === 37) {
            this.navigateChildMenuitemLeft(event, rowindex, node, data);
        }
        else if (event.keyCode === 39) {
            this.navigateChildMenuitemRight(event, rowindex, node, data);
        }
        else if (event.keyCode === 13) {
            this.onnavigateChildEnterClick(event, rowindex, node, data, nodedata);
        }
    };
    /**
     * @param {?} event
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.navigateChildMenuitemLeft = /**
     * @param {?} event
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    function (event, rowindex, node, data) {
        event.stopImmediatePropagation();
        if (rowindex === 0) {
            var /** @type {?} */ currentindex = data.length - 1;
            var /** @type {?} */ itemid = currentindex;
            var /** @type {?} */ childindex = data[itemid]['text'] + itemid;
            document.getElementById(childindex).focus();
        }
        else {
            var /** @type {?} */ currentindex = rowindex - 1;
            var /** @type {?} */ itemid = currentindex;
            var /** @type {?} */ childindex = data[itemid]['text'] + itemid;
            document.getElementById(childindex).focus();
        }
    };
    /**
     * @param {?} event
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.navigateChildMenuitemRight = /**
     * @param {?} event
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @return {?}
     */
    function (event, rowindex, node, data) {
        event.stopImmediatePropagation();
        if (rowindex < data.length - 1) {
            var /** @type {?} */ currentindex = rowindex + 1;
            var /** @type {?} */ itemid = currentindex;
            var /** @type {?} */ childindex = data[itemid]['text'] + itemid;
            document.getElementById(childindex).focus();
        }
        else if (rowindex === data.length - 1) {
            var /** @type {?} */ itemid = 0;
            var /** @type {?} */ childindex = data[itemid]['text'] + itemid;
            document.getElementById(childindex).focus();
        }
    };
    /**
     * @param {?} event
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @param {?} nodedata
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onnavigateChildEnterClick = /**
     * @param {?} event
     * @param {?} rowindex
     * @param {?} node
     * @param {?} data
     * @param {?} nodedata
     * @return {?}
     */
    function (event, rowindex, node, data, nodedata) {
        event.stopImmediatePropagation();
        if (nodedata['expandflag']) {
            nodedata['expandflag'] = false;
        }
        this.nodeClick.emit(node);
    };
    /**
     * @param {?} rowindex
     * @param {?} node
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onEnterClick = /**
     * @param {?} rowindex
     * @param {?} node
     * @return {?}
     */
    function (rowindex, node) {
        if (node['expandflag']) {
            node['expandflag'] = false;
        }
        this.nodeClick.emit(node);
    };
    /**
     * @param {?} event
     * @param {?} subinnerindex
     * @param {?} data
     * @param {?} subinnernode
     * @param {?} mainnode
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.updownInnerChildNavigation = /**
     * @param {?} event
     * @param {?} subinnerindex
     * @param {?} data
     * @param {?} subinnernode
     * @param {?} mainnode
     * @return {?}
     */
    function (event, subinnerindex, data, subinnernode, mainnode) {
        if (event.keyCode === 38) {
            this.onUpInnerChildNavigate(event, subinnerindex, data);
        }
        else if (event.keyCode === 40) {
            this.onDownInnerChildNavigate(event, subinnerindex, data);
        }
        else if (event.keyCode === 13) {
            this.onInnerChildEnterClick(subinnernode, mainnode);
        }
    };
    /**
     * @param {?} event
     * @param {?} subinnerindex
     * @param {?} data
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onUpInnerChildNavigate = /**
     * @param {?} event
     * @param {?} subinnerindex
     * @param {?} data
     * @return {?}
     */
    function (event, subinnerindex, data) {
        event.stopImmediatePropagation();
        if (subinnerindex === 0) {
            var /** @type {?} */ currentindex = data.length - 1;
            var /** @type {?} */ itemid = currentindex;
            var /** @type {?} */ innerchild = data[itemid]['text'] + itemid;
            document.getElementById(innerchild).focus();
        }
        else {
            var /** @type {?} */ currentindex = subinnerindex - 1;
            var /** @type {?} */ itemid = currentindex;
            var /** @type {?} */ innerchild = data[itemid]['text'] + itemid;
            document.getElementById(innerchild).focus();
        }
    };
    /**
     * @param {?} event
     * @param {?} subinnerindex
     * @param {?} data
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onDownInnerChildNavigate = /**
     * @param {?} event
     * @param {?} subinnerindex
     * @param {?} data
     * @return {?}
     */
    function (event, subinnerindex, data) {
        event.stopImmediatePropagation();
        if (subinnerindex < data.length - 1) {
            var /** @type {?} */ currentindex = subinnerindex + 1;
            var /** @type {?} */ itemid = currentindex;
            var /** @type {?} */ innerchild = data[itemid]['text'] + itemid;
            document.getElementById(innerchild).focus();
        }
        else if (subinnerindex === data.length - 1) {
            var /** @type {?} */ itemid = 0;
            var /** @type {?} */ innerchild = data[itemid]['text'] + itemid;
            document.getElementById(innerchild).focus();
        }
    };
    /**
     * @param {?} subinnernode
     * @param {?} mainnode
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onInnerChildEnterClick = /**
     * @param {?} subinnernode
     * @param {?} mainnode
     * @return {?}
     */
    function (subinnernode, mainnode) {
        event.stopImmediatePropagation();
        mainnode['expandflag'] = false;
        this.nodeClick.emit(subinnernode);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.generateIndex = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var _this = this;
        if (data) {
            data.forEach(function (element, index) {
                if (index === 0) {
                    element['tabindex'] = '0';
                    element['expandflag'] = true;
                }
                else {
                    element['tabindex'] = '-1';
                    element['expandflag'] = true;
                }
                if (element.children) {
                    element.children.forEach(function (innerelement, innerindex) {
                        _this.generateInnerIndex(innerindex, innerelement);
                        if (innerelement.children) {
                            innerelement.children.forEach(function (subinnerelement, subinnerindex) {
                                _this.generateSunInnerIndex(subinnerindex, subinnerelement);
                            });
                        }
                    });
                }
            });
        }
    };
    /**
     * @param {?} innerindex
     * @param {?} innerelement
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.generateInnerIndex = /**
     * @param {?} innerindex
     * @param {?} innerelement
     * @return {?}
     */
    function (innerindex, innerelement) {
        if (innerindex === 0) {
            innerelement['tabindex'] = '0';
            innerelement['index'] = innerelement['text'] + innerindex;
        }
        else {
            innerelement['tabindex'] = '-1';
            innerelement['index'] = innerelement['text'] + innerindex;
        }
    };
    /**
     * @param {?} subinnerindex
     * @param {?} subinnerelement
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.generateSunInnerIndex = /**
     * @param {?} subinnerindex
     * @param {?} subinnerelement
     * @return {?}
     */
    function (subinnerindex, subinnerelement) {
        if (subinnerindex === 0) {
            subinnerelement['tabindex'] = '0';
            subinnerelement['index'] = subinnerelement['text'] + subinnerindex;
        }
        else {
            subinnerelement['tabindex'] = '-1';
            subinnerelement['index'] = subinnerelement['text'] + subinnerindex;
        }
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        // Check if key is added?
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            
        }
        this.data = httpResponse;
        this.generateIndex(this.data);
    };
    /**
     * @param {?} event
     * @param {?} node
     * @return {?}
     */
    AmexioMenuBarComponent.prototype.onMouseOver = /**
     * @param {?} event
     * @param {?} node
     * @return {?}
     */
    function (event, node) {
        if (!(this.matchMediaService.IsPhone() || this.matchMediaService.IsTablet())) {
            if ((this.matchMediaService.browserWindow().innerWidth - event.clientX) < 200) {
                this.xposition = true;
            }
            else {
                this.xposition = false;
            }
        }
        else {
            this.xposition = false;
        }
        node['expandflag'] = true;
    };
    AmexioMenuBarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-menu',
                    template: "\n    <div class=\"menu-container\">\n        <div class=\"menubar\">\n            <ul role=\"menubar\" class=\"menuheader\">\n                <li class=\"menulink\">{{label}}</li>\n                <div>\n                    <li role=\"menuitem\" tabindex=\"{{node.tabindex}}\" id=\"{{rowindex}}\" *ngFor=\"let node of data let rowindex = index \"\n                        (keyup)=\"onMenubarKeyup($event,false,rowindex,node,data)\" class=\"menulink\">\n                        <a (click)=\"onClick(node)\" (mouseover)=\"onMouseOver($event, node)\">\n                            <amexio-c-icon *ngIf=\"node.icon\" [customclass]=\"node.icon\"></amexio-c-icon>&nbsp;&nbsp;{{node.text}}\n                        </a>\n                        <!--<i *ngIf=\"node.icon\" [ngClass]=\"node.icon\" aria-hidden=\"true\"></i>-->\n                        <span *ngIf=\"(node.children && node.children[0].children)\">\n                            <div *ngIf=\"(node.children && node.children.length>0)\" class=\"menu-content\" [ngClass]=\"{'menu-content-display':node.expand,'menu-content-hide':!node.expandflag,\n                      ' menu-content-left': (node.children && node.children.length>3),'menu-right':xposition}\">\n                                <ul class=\"menu-content-cols\">\n                                    <li class=\"col-menu-nodes\" [ngClass]=\"{'col-menu-nodes-fixed': (node.children && node.children.length<4),\n                        'col-menu-nodes-percentage': (node.children && node.children.length>3)}\"\n                                        *ngFor=\"let subnode of node.children let rowindex = index\">\n                                        <div class=\"content\">\n                                            <div *ngIf=\"(subnode.text && subnode.text.length>0)\" id=\"{{subnode.index}}\"\n                                                tabindex=\"{{subnode.tabindex}}\" (click)=\"onInnerNodeClick(subnode,node)\"\n                                                (keyup)=\"navigateChild($event,true,rowindex,subnode,node.children,node)\"\n                                                class=\"menu-links-header\">\n                                                <amexio-c-icon *ngIf=\"subnode.icon\" [customclass]=\"subnode.icon\"></amexio-c-icon>&nbsp;&nbsp;{{subnode.text}}\n                                                <!--<i *ngIf=\"subnode.icon\" [ngClass]=\"subnode.icon\" aria-hidden=\"true\"></i>-->\n                                            </div>\n                                            <div *ngIf=\"subnode.image\" style=\"padding: 10px;\">\n                                                <img [attr.src]=\"subnode.image\">\n                                            </div>\n                                            <ul class=\"menu-content-cols\">\n                                                <li *ngFor=\"let subinnernode of subnode.children let subinnerindex = index\"\n                                                    tabindex=\"{{subinnernode.tabindex}}\" (click)=\"onSubInnerNodeClick(subinnernode,node)\"\n                                                    id={{subinnernode.index}} (keyup)=\"updownInnerChildNavigation($event,subinnerindex,subnode.children,subinnernode,node)\"\n                                                    class=\"menulinks\">\n                                                    <div *ngIf=\"subinnernode.image\" style=\"padding: 10px;\">\n                                                        <img [attr.src]=\"subinnernode.image\">\n                                                    </div>\n                                                    <!--<i *ngIf=\"subinnernode.icon\" class=\"fa fa-ravelry\"\n                              aria-hidden=\"true\"></i>-->\n                                                    <amexio-c-icon *ngIf=\"subinnernode.icon\" key=\"menubar_ravelry\">\n                                                    </amexio-c-icon>\n                                                    &nbsp;&nbsp;{{subinnernode.text}}{{subinnernode.template}}\n                                                </li>\n                                            </ul>\n                                        </div>\n                                    </li>\n\n                                </ul>\n                            </div>\n\n                        </span>\n                        <ng-container *ngIf=\"(node.children && !node.children[0].children)\">\n                            <div class=\"menu-content\" [ngClass]=\"{'menu-content-display':node.expand}\">\n                                <ul class=\"menu-content-cols\">\n                                    <li class=\"col-menu-nodes col-menu-nodes-fixed\">\n                                        <div class=\"content\">\n                                            <ul class=\"menu-content-cols\">\n                                                <li *ngFor=\"let subnode of node.children\" class=\"menulinks\">\n                                                    <div *ngIf=\"subnode.image\" style=\"padding: 10px;\">\n                                                        <img [attr.src]=\"subnode.image\">\n                                                    </div>\n                                                    <!--<i *ngIf=\"subnode.icon\" class=\"fa fa-ravelry\" aria-hidden=\"true\"></i>-->\n                                                    <amexio-c-icon *ngIf=\"subnode.icon\" key=\"menubar_ravelry\"></amexio-c-icon>&nbsp;&nbsp;{{subnode.text}}\n                                                </li>\n                                            </ul>\n                                        </div>\n                                    </li>\n                                </ul>\n                            </div>\n                        </ng-container>\n\n\n                    </li>\n                </div>\n\n            </ul>\n        </div>\n    </div>\n  ",
                    providers: [CommonDataService],
                },] },
    ];
    /** @nocollapse */
    AmexioMenuBarComponent.ctorParameters = function () { return [
        { type: DeviceQueryService },
        { type: CommonDataService }
    ]; };
    AmexioMenuBarComponent.propDecorators = {
        data: [{ type: i0.Input }],
        label: [{ type: i0.Input }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        nodeClick: [{ type: i0.Output }]
    };
    return AmexioMenuBarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by manisha on 1/4/18.
*/
var AmexioInnerNavMenuComponent = /** @class */ (function () {
    function AmexioInnerNavMenuComponent() {
        this.submenuposition = 'right';
        /*
          Events
          name : navLinkClick
          datatype : any
          version : none
          default : none
          description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
          */
        this.navLinkClick = new i0.EventEmitter();
        this.mobilemode = false;
        this.issubmenu = false;
        this.ishovered = true;
        this.divid = Math.floor(Math.random() * 90000) + 10000 + '_menuid';
    }
    /**
     * @return {?}
     */
    AmexioInnerNavMenuComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} flag
     * @return {?}
     */
    AmexioInnerNavMenuComponent.prototype.setMobileMode = /**
     * @param {?} flag
     * @return {?}
     */
    function (flag) {
        this.mobilemode = flag;
    };
    /**
     * @param {?} _node
     * @param {?} _event
     * @return {?}
     */
    AmexioInnerNavMenuComponent.prototype.onClick = /**
     * @param {?} _node
     * @param {?} _event
     * @return {?}
     */
    function (_node, _event) {
        var /** @type {?} */ n = {
            title: this.title,
            data: this.data,
            icon: this.icon,
            node: _node,
            mobilemode: this.mobilemode,
        };
        this.navLinkClick.emit(this.dataObject(n, _event));
    };
    /**
     * @param {?} n
     * @param {?} _event
     * @return {?}
     */
    AmexioInnerNavMenuComponent.prototype.dataObject = /**
     * @param {?} n
     * @param {?} _event
     * @return {?}
     */
    function (n, _event) {
        return { data: n, event: _event };
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioInnerNavMenuComponent.prototype.onHeaderClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ node = {
            header: true,
            title: this.title,
            icon: this.icon,
        };
        this.onClick(node, event);
    };
    /**
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    AmexioInnerNavMenuComponent.prototype.onNodehover = /**
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    function (node, event) {
        var _this = this;
        this.ishovered = false;
        // clear hover flag;
        this.data.forEach(function (element) {
            _this.clearNodeHover(element);
        });
        if (node.submenus && (node.submenus.length > 0)) {
            node.ishover = true;
        }
        event.stopPropagation();
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioInnerNavMenuComponent.prototype.setNodeHover = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        node.ishover = true;
        if (node.submenus && (node.submenus.length > 0)) {
            this.setNodeHover(node.submenus);
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioInnerNavMenuComponent.prototype.clearNodeHover = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        // clear flags
        node.ishover = false;
        if (node.submenus && (node.submenus.length > 0)) {
            node.submenus.forEach(function (element) {
                _this.clearNodeHover(element);
            });
        }
    };
    AmexioInnerNavMenuComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-nav-innermenu',
                    template: "\n      <ng-container *ngFor=\"let node of data\">\n          <div class=\"nav-dropdown-content-subnode\">\n\n              <div style=\"padding: 10px; padding-left: 20px;\">\n                  <span *ngIf=\"submenuposition == 'left' && node.submenus\">\n                      <i class=\"fa fa-angle-left\" style=\"padding-bottom:5px\" aria-hidden=\"true\"></i>\n                      <!-- {{node.text}} -->\n                  </span>\n                  <span (click)=\"onClick(node, $event)\" >{{node.text}}</span>\n              </div>\n\n              <div style=\"padding: 10px\">\n                  <span *ngIf=\"submenuposition == 'right' && node.submenus\">\n                      <!-- {{node.text}} -->\n                      <i class=\"fa fa-angle-right\" aria-hidden=\"true\"></i>\n                  </span>\n                  <!-- <span>{{node.text}}</span> -->\n              </div>\n\n              <div [ngClass]=\"{'innersubmenunodes':submenuposition == 'right', 'innersubmenunodesright':submenuposition == 'left' }\" *ngIf=\"node.submenus\">\n                  <amexio-nav-innermenu [color]=\"itemcolor\" [submenuposition]=\"submenuposition\" [data]=\"node.submenus\" (navLinkClick)=\"navItemClick($event)\">\n                  </amexio-nav-innermenu>\n              </div>\n\n          </div>\n          <br/>\n      </ng-container>\n    ",
                },] },
    ];
    /** @nocollapse */
    AmexioInnerNavMenuComponent.ctorParameters = function () { return []; };
    AmexioInnerNavMenuComponent.propDecorators = {
        type: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        data: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        submenuposition: [{ type: i0.Input }],
        navLinkClick: [{ type: i0.Output }],
        color: [{ type: i0.Input, args: ['color',] }]
    };
    return AmexioInnerNavMenuComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioNavActionComponent = /** @class */ (function () {
    function AmexioNavActionComponent() {
        /*
        Events
        name : navLinkClick
        datatype : any
        version : none
        default : none
        description : Fire when nav item is clicked, This event is fired when nav item type is defined as 'link/button/menu'
        
        */
        this.navLinkClick = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    AmexioNavActionComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNavActionComponent.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var /** @type {?} */ node = {};
        this.navLinkClick.emit({ node: node, event: event });
    };
    AmexioNavActionComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-nav-action',
                    template: "\n    <a *ngIf=\"(type=='link')\" [ngStyle]=\"{'color':color}\" class=\"top-nav-link\"\n    (click)=\"onClick($event)\"><i *ngIf=\"icon\" [ngClass]=\"icon\"></i>{{title}}</a>\n\n    <button *ngIf=\"(type=='button')\" class=\"top-nav-button\" (click)=\"onClick($event)\">\n    <i *ngIf=\"icon\" style=\"padding-right:10px\" [ngClass]=\"icon\"></i>{{title}}</button>\n    <div  *ngIf=\"(type=='toggle')\" class=\"top-nav-button\">\n    <amexio-darkmode [size]=\"'small'\"></amexio-darkmode>\n    </div>\n    ",
                },] },
    ];
    /** @nocollapse */
    AmexioNavActionComponent.ctorParameters = function () { return []; };
    AmexioNavActionComponent.propDecorators = {
        type: [{ type: i0.Input }],
        title: [{ type: i0.Input }],
        icon: [{ type: i0.Input }],
        navLinkClick: [{ type: i0.Output }],
        color: [{ type: i0.Input, args: ['color',] }]
    };
    return AmexioNavActionComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var noop$11 = function () {
};
var AmexioNavTextFieldComponent = /** @class */ (function () {
    function AmexioNavTextFieldComponent() {
        this.innerValue = '';
        this.onTouchedCallback = noop$11;
        this.onChangeCallback = noop$11;
    }
    /**
     * @return {?}
     */
    AmexioNavTextFieldComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    Object.defineProperty(AmexioNavTextFieldComponent.prototype, "value", {
        // The internal dataviews model
        // Placeholders for the callbacks which are later provided
        // by the Control Value Accessor
        // get accessor
        get: /**
         * @return {?}
         */
        function () {
            return this.innerValue;
        },
        // set accessor including call the onchange callback
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v !== this.innerValue) {
                this.innerValue = v;
                this.onChangeCallback(v);
            }
        },
        enumerable: true,
        configurable: true
    });
    // From ControlValueAccessor interface
    /**
     * @param {?} value
     * @return {?}
     */
    AmexioNavTextFieldComponent.prototype.writeValue = /**
     * @param {?} value
     * @return {?}
     */
    function (value) {
        if (value !== this.innerValue) {
            this.innerValue = value;
        }
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioNavTextFieldComponent.prototype.registerOnChange = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onChangeCallback = fn;
    };
    // From ControlValueAccessor interface
    /**
     * @param {?} fn
     * @return {?}
     */
    AmexioNavTextFieldComponent.prototype.registerOnTouched = /**
     * @param {?} fn
     * @return {?}
     */
    function (fn) {
        this.onTouchedCallback = fn;
    };
    AmexioNavTextFieldComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-nav-textfield',
                    template: "\n  <input  [ngStyle]=\"{'color':color}\" type=\"text\" class=\"top-nav-input-control\" [(ngModel)]=\"value\"/>\n\n  ",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR, useExisting: i0.forwardRef(function () { return AmexioNavTextFieldComponent; }), multi: true,
                        }],
                    encapsulation: i0.ViewEncapsulation.None,
                },] },
    ];
    /** @nocollapse */
    AmexioNavTextFieldComponent.ctorParameters = function () { return []; };
    AmexioNavTextFieldComponent.propDecorators = {
        color: [{ type: i0.Input, args: ['color',] }]
    };
    return AmexioNavTextFieldComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 12/18/17.
*/
/** @enum {number} */
var KEY_CODE_notify = {
    esc: 27,
};
KEY_CODE_notify[KEY_CODE_notify.esc] = "esc";
var AmexioNotificationComponent = /** @class */ (function () {
    function AmexioNotificationComponent(ref) {
        this.ref = ref;
        /*
         Properties
         name : data
         datatype : any
         version : 4.2 onwards
         default : none
         description :  what you want to display on notification window by using data.
         */
        this.messageData = [];
        /*
        Properties
        name : closable
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : User can close the window.
        */
        this.closable = true;
        this.notificationVertialCss = 'notification-vertical-';
        this.notificationHorizontalCss = ' notification-horizontal-';
    }
    // Escape Key Functionality
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioNotificationComponent.prototype.keyEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.closeonescape === true) {
            this.messageData.length = 0;
        }
    };
    /**
     * @return {?}
     */
    AmexioNotificationComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.componentID = Math.floor(Math.random() * 1000 + 999);
        if (this.autodismissmsg) {
            if (!this.autodismissmsginterval) {
                this.autodismissmsginterval = 1500;
            }
            if (this.messageData !== null) {
                setInterval(function () {
                    if (_this.messageData.length > 0) {
                        _this.messageData.shift();
                        _this.ref.markForCheck();
                    }
                }, this.autodismissmsginterval);
            }
        }
        if (this.verticalposition === null) {
            this.verticalposition = 'top';
        }
        else if (this.horizontalposition === null) {
            this.horizontalposition = 'right';
        }
        this.positionclass = this.notificationVertialCss + this.verticalposition + this.notificationHorizontalCss + this.horizontalposition;
    };
    /**
     * @param {?} msg
     * @return {?}
     */
    AmexioNotificationComponent.prototype.closeNotification = /**
     * @param {?} msg
     * @return {?}
     */
    function (msg) {
        var /** @type {?} */ count = this.messageData.length;
        for (var /** @type {?} */ i = 0; i < count; i++) {
            if (this.messageData[i] === msg) {
                this.messageData.splice(msg, 1);
            }
        }
    };
    AmexioNotificationComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-notification', template: "\n    <div class=\"notification-content\" [ngClass]=\"positionclass\">\n\n        <ng-container *ngIf=\"!notificationTemplate\">\n            <div id=\"{{componentID}}\" role=\"alert\" [attr.aria-label]=\"'notification is'+ messageData\" class=\"notification\" *ngFor=\"let msg of messageData\" [style.color]=\"foregroundColor\" [style.background-color]=\"backgroundColor\">\n                <span class=\"float-right\" (click)=\"closeNotification(msg)\">\n            <ng-container *ngIf=\"closable\">\n              <amexio-c-icon style=\"cursor: pointer\" key=\"notify_close\"></amexio-c-icon>\n            </ng-container>\n          </span>\n\n                <table>\n                    <ng-container *ngIf=\"icon\">\n                        <th>\n                            <amexio-c-icon style=\" padding-right: 18px;\" [ngClass]=\"icon\">\n                            </amexio-c-icon>\n                        </th>\n                    </ng-container>\n\n                    <th style=\" text-align: left;\">\n\n                        <span>{{msg}}</span>&nbsp;&nbsp;&nbsp;&nbsp;\n                    </th>\n\n                </table>\n\n            </div>\n        </ng-container>\n\n        <ng-container *ngIf=\"notificationTemplate\">\n            <div id=\"{{componentID}}\" role=\"alert\" [attr.aria-label]=\"'notification is'+ messageData\" class=\"notification\" *ngFor=\"let msg of messageData\" [style.color]=\"foregroundColor\" [style.background-color]=\"backgroundColor\">\n\n                <span class=\"float-right\" (click)=\"closeNotification(msg)\">\n            <ng-container *ngIf=\"closable\">\n              <amexio-c-icon style=\"cursor: pointer\" key=\"notify_close\"></amexio-c-icon>\n            </ng-container>\n          </span>\n\n                <table>\n                    <ng-container *ngIf=\"icon\">\n                        <th>\n                            <amexio-c-icon style=\" padding-right: 18px;\" [ngClass]=\"icon\">\n                            </amexio-c-icon>\n                        </th>\n                    </ng-container>\n                    <th style=\" text-align: left;\">\n                        <ng-template [ngTemplateOutlet]=\"notificationTemplate\" [ngTemplateOutletContext]=\"{data:msg}\">\n                        </ng-template>\n                    </th>\n                </table>\n            </div>\n        </ng-container>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioNotificationComponent.ctorParameters = function () { return [
        { type: i0.ChangeDetectorRef }
    ]; };
    AmexioNotificationComponent.propDecorators = {
        messageData: [{ type: i0.Input, args: ['data',] }],
        icon: [{ type: i0.Input, args: ['icon',] }],
        closable: [{ type: i0.Input }],
        verticalposition: [{ type: i0.Input, args: ['vertical-position',] }],
        horizontalposition: [{ type: i0.Input, args: ['horizontal-position',] }],
        autodismissmsg: [{ type: i0.Input, args: ['auto-dismiss-msg',] }],
        autodismissmsginterval: [{ type: i0.Input, args: ['auto-dismiss-msg-interval',] }],
        closeonescape: [{ type: i0.Input, args: ['close-on-escape',] }],
        backgroundColor: [{ type: i0.Input, args: ['background-color',] }],
        foregroundColor: [{ type: i0.Input, args: ['foreground-color',] }],
        notificationTemplate: [{ type: i0.ContentChild, args: ['amexioNotificationTemp',] }],
        keyEvent: [{ type: i0.HostListener, args: ['window:keyup.esc', ['$event'],] }]
    };
    return AmexioNotificationComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioSideNavInnerNodeComponent = /** @class */ (function () {
    function AmexioSideNavInnerNodeComponent() {
        this.onClick = new i0.EventEmitter();
        this.onDrag = new i0.EventEmitter();
        this.emitNode = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    AmexioSideNavInnerNodeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioSideNavInnerNodeComponent.prototype.onNodeClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        node.expand = !node.expand;
        if (node.children && node.expand === false) {
            node.children.forEach(function (element) {
                element['tabindex'] = '-1';
            });
        }
        else if (node.children && node.expand === true) {
            node.children.forEach(function (element) {
                element['tabindex'] = '1';
            });
        }
        this.getOnClick(node);
        this.emitNode.emit(this.data);
    };
    /**
     * @param {?} event
     * @param {?} node
     * @return {?}
     */
    AmexioSideNavInnerNodeComponent.prototype.onenterNodeClick = /**
     * @param {?} event
     * @param {?} node
     * @return {?}
     */
    function (event, node) {
        event.stopImmediatePropagation();
        node.expand = !node.expand;
        if (node.children && node.expand === true) {
            node.children.forEach(function (element, index) {
                element['tabindex'] = '1';
            });
        }
        this.getOnClick(node);
        this.emitNode.emit(this.data);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioSideNavInnerNodeComponent.prototype.getOnClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.onClick.emit(node);
        this.activateNode(this.data, node);
    };
    /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    AmexioSideNavInnerNodeComponent.prototype.activateNode = /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    function (data, node) {
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var i = data_1[_i];
            if (node === i && !i[this.childarraykey]) {
                i['active'] = true;
            }
            else {
                i['active'] = false;
            }
            if (i[this.childarraykey]) {
                this.activateNode(i[this.childarraykey], node);
            }
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioSideNavInnerNodeComponent.prototype.dragStartEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.enabledrag) {
            event.event.dataTransfer.setData('dragData', JSON.stringify(event.data));
            this.onDrag.emit(event);
        }
    };
    AmexioSideNavInnerNodeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-sidenav-innernode',
                    template: "\n    <ul>\n        <li  role=\"option\" *ngFor=\"let node of data\">\n             <div [attr.tabindex]= \"node.tabindex\" (keyup.enter)=\"onenterNodeClick($event,node)\" [attr.draggable]=\"enabledrag\" (dragstart)=\"dragStartEvent({event:$event,data:node})\" class=\"defaultnode\" [ngClass]=\"{'activenode':node.active}\"\n                (click)=\"onNodeClick(node)\">\n            \n                <span *ngIf=\"node.icon\">\n                    <amexio-c-icon class=\"node-icon\" [customclass]=\"node.icon\" [color]=\"node.iconcolor\"></amexio-c-icon>\n                    <span>{{node[displaykey]}}</span>\n                    </span>\n                \n                \n                    <span *ngIf=\"!node.icon\">\n                    <amexio-c-icon class=\"node-icon\" [customclass]=\"node.icon\" [color]=\"node.iconcolor\"></amexio-c-icon>\n                    <span style=\"padding-left:40px;\">{{node[displaykey]}}</span>\n                    </span>\n\n\n                <ng-container *ngIf=\"node.badge\">\n                    <span class=\"nav-badge\">{{node.badge}}</span>\n                </ng-container>\n                <ng-container *ngIf=\"node[childarraykey] && (node[childarraykey].length>0)\">\n                    <span style=\"padding-right: 10px; float: right\" *ngIf=\"node.expand\">\n                        <amexio-c-icon key=\"sidenav-angle-up\"></amexio-c-icon>\n                    </span>\n                    <span style=\"padding-right: 10px;float: right;\" *ngIf=\"!node.expand\">\n                        <amexio-c-icon key=\"sidenav-angle-down\"></amexio-c-icon>\n                    </span>\n                </ng-container>\n            </div>\n            <div class=\"submenu-details\" [ngClass]=\"{'sidenav-submenu-expanded':node.expand}\">\n                <amexio-sidenav-innernode *ngIf=\"node[childarraykey] && (node[childarraykey].length>0)\" [enable-drag]=\"enabledrag\" (onDrag)=\"dragStartEvent($event)\"\n                    [display-key]=\"displaykey\" [child-array-key]=\"childarraykey\" [data]=\"node[childarraykey]\" (onDrag)=\"dragStartEvent($event)\"\n                    (onClick)=\"getOnClick($event)\">\n                </amexio-sidenav-innernode>\n            </div>\n        </li>\n    </ul>\n  ",
                },] },
    ];
    AmexioSideNavInnerNodeComponent.propDecorators = {
        displaykey: [{ type: i0.Input, args: ['display-key',] }],
        icon: [{ type: i0.Input, args: ['icon',] }],
        childarraykey: [{ type: i0.Input, args: ['child-array-key',] }],
        data: [{ type: i0.Input, args: ['data',] }],
        onClick: [{ type: i0.Output }],
        enabledrag: [{ type: i0.Input, args: ['enable-drag',] }],
        onDrag: [{ type: i0.Output }],
        emitNode: [{ type: i0.Output }]
    };
    return AmexioSideNavInnerNodeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var NAV_COMPONENTS = [
    AmexioSideNavComponent,
    SideNavNodeComponent,
    AmexioNavBarComponent,
    AmexioNavItemComponent,
    AmexioNotificationComponent,
    AmexioNavActionComponent,
    AmexioNavTextFieldComponent,
    AmexioNavMenuComponent,
    AmexioNavItemComponent,
    AmexioInnerNavMenuComponent,
    DockbarComponent,
    DockedBarToolComponent,
    AmexioMenuBarComponent,
    AmexioBreadcrumbComponent,
    AmexioSideNavInnerNodeComponent,
];
var AmexioNavModule = /** @class */ (function () {
    function AmexioNavModule() {
    }
    /**
     * @return {?}
     */
    AmexioNavModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioNavModule,
            providers: [CommonDataService, DeviceQueryService],
        };
    };
    AmexioNavModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        AmexioMediaModule,
                        AmexioLayoutModule,
                        AmexioFormsModule,
                        HttpClientModule,
                        AmexioCommonModule.forRoot(),
                    ],
                    exports: NAV_COMPONENTS,
                    declarations: NAV_COMPONENTS,
                    providers: [CommonDataService, DeviceQueryService],
                },] },
    ];
    return AmexioNavModule;
}());

var __extends$34 = (undefined && undefined.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright [2019] [Metamagic]
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Created by Ashwini Agre on 06/03/19.
 */
var AmexioWindowCEComponent = /** @class */ (function (_super) {
    __extends$34(AmexioWindowCEComponent, _super);
    function AmexioWindowCEComponent(renderer) {
        var _this = _super.call(this) || this;
        _this.renderer = renderer;
        _this.verticalposition = 'center';
        _this.closeonescape = true;
        _this.showChange = new i0.EventEmitter();
        _this.maximize = false;
        _this.closable = true;
        _this.window = ' window-';
        _this.width = '90%';
        _this.close = new i0.EventEmitter();
        _this.windowFlag = true;
        return _this;
    }
    /**
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.onCloseClick = /**
     * @return {?}
     */
    function () {
        if (this.closable) {
            this.showWindow = false;
            this.show = false;
            this.showChange.emit(false);
            this.close.emit(this.showWindow);
        }
    };
    /**
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (!this.color) {
            this.cclass = 'card-container-ce-color';
        }
        if (!this.background) {
            this.cclass = this.cclass + ' card-container-ce-bg-color';
        }
        this.setVerticlePosition();
        this.setHorizontalPosition();
        if (this.maximize) {
            this.dummyWidth = this.width;
            this.isFullWindow = true;
            this.maximumWindowStyle = this.setMaximizeClass(this.isFullWindow);
        }
        if (this.showWindow) {
            this.show = this.showWindow;
        }
        _super.prototype.ngOnInit.call(this);
    };
    /**
     * @param {?} isFullWindow
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.setMaximizeClass = /**
     * @param {?} isFullWindow
     * @return {?}
     */
    function (isFullWindow) {
        this.isFullWindow = isFullWindow;
        if (isFullWindow) {
            this.width = '100%';
            return {
                'margin-top': '0', 'height': '100%',
            };
        }
        else {
            this.width = this.dummyWidth;
            return {
                'margin-top': '1%', 'height': '96%',
            };
        }
    };
    /**
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.setVerticlePosition = /**
     * @return {?}
     */
    function () {
        switch (this.verticalposition) {
            case 'top': {
                this.verticalposition = 'flex-start';
                break;
            }
            case 'center': {
                this.verticalposition = 'center';
                break;
            }
            case 'bottom': {
                this.verticalposition = 'flex-end';
                break;
            }
            default: {
                this.verticalposition = 'center';
                break;
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.setHorizontalPosition = /**
     * @return {?}
     */
    function () {
        switch (this.horizontalposition) {
            case 'left': {
                this.horizontalposition = 'flex-start';
                break;
            }
            case 'center': {
                this.horizontalposition = 'center';
                break;
            }
            case 'right': {
                this.horizontalposition = 'flex-end';
                break;
            }
            default: {
                this.horizontalposition = 'center';
                break;
            }
        }
    };
    /* ASSIGN PROPERTIES TO FOOTER AND HEADER*/
    /**
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.amexioHeader && this.amexioHeader.toArray().length > 0) {
            setTimeout(function () {
                _this.amexioHeader.toArray()[0].closeable = _this.closable;
                _this.amexioHeader.toArray()[0].windowFlag = true;
            }, 3000);
            if (this.maximize) {
                this.amexioHeader.toArray()[0].setMaximizeData(this.maximize, this.isFullWindow);
                this.amexioHeader.toArray()[0].maximizeBehaiour.subscribe(function (max) {
                    _this.maximumWindowStyle = _this.setMaximizeClass(max);
                });
            }
            this.amexioHeader.toArray()[0].closeableBehaiour.subscribe(function (close) {
                _this.onCloseClick();
            });
        }
        this.setCardAligementForAllInnerComponent();
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['show']) {
            this.setShowFlag(changes["show"].currentValue);
        }
        if (changes['showWindow']) {
            this.setShowFlag(changes["showWindow"].currentValue);
        }
    };
    /**
     * @param {?} changedValue
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.setShowFlag = /**
     * @param {?} changedValue
     * @return {?}
     */
    function (changedValue) {
        var _this = this;
        this.show = changedValue;
        if (this.closeonescape) {
            this.globalListenFunc = this.renderer.listen('document', 'keyup.esc', function (e) {
                _this.showWindow = false;
                _this.show = false;
                _this.showChange.emit(false);
                _this.close.emit(_this.showWindow);
            });
        }
        else if (this.globalListenFunc) {
            this.globalListenFunc();
        }
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngAfterViewInit.call(this);
    };
    // TO SET ALIGN TO ALL INNER COMPONENT IN CARD
    /**
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.setCardAligementForAllInnerComponent = /**
     * @return {?}
     */
    function () {
        this.amexioCardHeaderList = this.amexioHeader.toArray();
        if (this.amexioCardHeaderList[0] !== undefined && !this.amexioCardHeaderList[0].align &&
            this.amexioCardHeaderList[0].align.length > 0) {
            this.amexioCardHeaderList[0].align = this.align;
        }
        this.amexioCardBodyList = this.amexioBody.toArray();
        if (this.amexioCardBodyList[0] !== undefined && !this.amexioCardBodyList[0].align && this.amexioCardBodyList[0].align.length > 0) {
            this.amexioCardBodyList[0].align = this.align;
        }
        this.amexioCardActionList = this.amexioFooter.toArray();
        if (this.amexioCardActionList[0] !== undefined && !this.amexioCardActionList[0].align &&
            this.amexioCardActionList[0].align.length > 0) {
            this.amexioCardActionList[0].align = this.align;
        }
        else if (this.amexioCardActionList[0] !== undefined &&
            this.amexioCardActionList[0].align === '') {
            this.amexioCardActionList[0].align = 'end';
        }
    };
    /**
     * @return {?}
     */
    AmexioWindowCEComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        _super.prototype.ngOnDestroy.call(this);
    };
    AmexioWindowCEComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-window-ce',
                    template: "\n    <div *ngIf=\"show\" class=\"amexio-root-window-ce\" [style.justify-content]=\"horizontalposition\">\n      <div class=\"amexio-root-window-content-ce\" [@animation]=\"{value: 'visible', params: {transitionParams: transitionOptions}}\"\n        [style.width]=\"width\" [style.justify-content]=\"verticalposition\" [ngStyle]=\"maximumWindowStyle\" [ngClass]=\"{'content-max-height': (maximize && isFullWindow)}\">\n        <div [ngStyle]=\"{'background': bgimage ? 'url(' + bgimage + ') center/cover no-repeat' : null}\" [ngClass]=\"cclass\">\n          <div [ngStyle]=\"{'justify-content': (align === 'start' || align === 'end') ? 'flex-'+align:align , 'color':color, 'background': background}\">\n            <ng-content></ng-content>\n          </div>\n        </div>\n      </div>\n    </div>\n  ",
                    animations: [
                        trigger('animation', [
                            state('void', style({
                                transform: 'translate3d(0, 25%, 0) scale(0.9)',
                                opacity: 0,
                            })),
                            state('visible', style({
                                transform: 'none',
                                opacity: 1,
                            })),
                            transition('* => *', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)')),
                        ]),
                    ],
                },] },
    ];
    /** @nocollapse */
    AmexioWindowCEComponent.ctorParameters = function () { return [
        { type: i0.Renderer2 }
    ]; };
    AmexioWindowCEComponent.propDecorators = {
        bgimage: [{ type: i0.Input, args: ['bg-image',] }],
        color: [{ type: i0.Input, args: ['color',] }],
        background: [{ type: i0.Input, args: ['background',] }],
        height: [{ type: i0.Input, args: ['height',] }],
        align: [{ type: i0.Input, args: ['align',] }],
        verticalposition: [{ type: i0.Input, args: ['vertical-position',] }],
        horizontalposition: [{ type: i0.Input, args: ['horizontal-position',] }],
        closeonescape: [{ type: i0.Input, args: ['close-on-escape',] }],
        top: [{ type: i0.Input, args: ['position-top',] }],
        showWindow: [{ type: i0.Input, args: ['show-window',] }],
        show: [{ type: i0.Input }],
        showChange: [{ type: i0.Output }],
        maximize: [{ type: i0.Input }],
        closable: [{ type: i0.Input }],
        width: [{ type: i0.Input, args: ['width',] }],
        amexioHeader: [{ type: i0.ContentChildren, args: [AmexioCardCEHeaderComponent,] }],
        amexioFooter: [{ type: i0.ContentChildren, args: [AmexioCardCEActionComponent,] }],
        amexioBody: [{ type: i0.ContentChildren, args: [AmexioCardCEBodyComponent,] }],
        close: [{ type: i0.Output }]
    };
    return AmexioWindowCEComponent;
}(LifeCycleBaseComponent));

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CREATIVE_COMPONENTS = [
    AmexioCardCEHeaderComponent,
    AmexioCardCEBodyComponent,
    AmexioCardCEActionComponent,
    AmexioCardCEComponent,
    AmexioFormActionCEComponent,
    AmexioFormCEComponent,
    AmexioProgressCEComponent,
    AmexioHomePageComponent,
    AmexioHomePageCenterPanelComponent,
    AmexioHomePageEastPanelComponent,
    AmexioHomePageNorthPanelComponent,
    AmexioHomePageWestPanelComponent,
    AmexioWindowCEComponent,
    ViewportComponent,
    ViewportBackgroundComponent,
    ViewportContentComponent,
    ViewportContentBodyComponent,
    AmexioCarouselCEComponent,
];
var AmexioCreativeModule = /** @class */ (function () {
    function AmexioCreativeModule() {
    }
    /**
     * @return {?}
     */
    AmexioCreativeModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioCreativeModule,
            providers: [IconLoaderService],
        };
    };
    AmexioCreativeModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        forms.ReactiveFormsModule,
                        AmexioFormsModule,
                        AmexioNavModule,
                        AmexioLayoutModule,
                        AmexioPaneModule,
                        AmexioMediaModule,
                        AmexioCommonModule.forRoot(),
                    ],
                    exports: CREATIVE_COMPONENTS,
                    declarations: CREATIVE_COMPONENTS,
                    providers: [IconLoaderService],
                },] },
    ];
    return AmexioCreativeModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 10/1/18.
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Ketan Gote, Pratik Kelwalkar, Dattaram Gawas, Rashmi Thakkar
 *
 */
var AmexioGridColumnComponent = /** @class */ (function () {
    function AmexioGridColumnComponent() {
        /*
           Properties
           name : sort
           datatype : boolean
           version : 4.2.6 onwards
           default : true
           description : Set column Sortable.
           */
        this.sort = true;
        /*
        Properties
        name : hidden
        datatype : boolean
        version : 4.0 onwards
        default : none
        description : Hide column
        */
        this.hidden = false;
    }
    AmexioGridColumnComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-data-table-column', template: "",
                },] },
    ];
    AmexioGridColumnComponent.propDecorators = {
        text: [{ type: i0.Input }],
        sort: [{ type: i0.Input }],
        dataindex: [{ type: i0.Input, args: ['data-index',] }],
        hidden: [{ type: i0.Input }],
        datatype: [{ type: i0.Input, args: ['data-type',] }],
        contextmenu: [{ type: i0.Input, args: ['context-menu',] }],
        summarytype: [{ type: i0.Input, args: ['summary-type',] }],
        summarycaption: [{ type: i0.Input, args: ['summary-caption',] }],
        width: [{ type: i0.Input }],
        headerTemplate: [{ type: i0.ContentChild, args: ['amexioHeaderTmpl',] }],
        bodyTemplate: [{ type: i0.ContentChild, args: ['amexioBodyTmpl',] }]
    };
    return AmexioGridColumnComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Pratik on 2/01/18.
*/
var DataGridFilterComponent = /** @class */ (function () {
    function DataGridFilterComponent(dataTableService, renderer) {
        this.dataTableService = dataTableService;
        this.renderer = renderer;
        /*
          for internal use
          */
        this.filterObject = new i0.EventEmitter();
        this.onFilterClick = new i0.EventEmitter();
        this.showToolTip = false;
        this.checkIcon = 'fa fa-check';
        this.numberFilterArray = [];
        this.stringFilterArray = [];
        this.filterOptions = [{
                key: 'Is Equal To', value: '==', type: 'string', checkedStatus: '',
            }, {
                key: 'Is Not Equal To', value: '!=', type: 'string', checkedStatus: '',
            }, {
                key: 'Start With', value: '1', type: 'string', checkedStatus: this.checkIcon,
            },
            {
                key: 'Ends With', value: '2', type: 'string', checkedStatus: '',
            }, {
                key: 'Contains', value: '3', type: 'string', checkedStatus: '',
            }, {
                key: 'Is Equal To', value: '==', type: 'number', checkedStatus: '',
            }, {
                key: 'Is Not Equal To', value: '!=', type: 'number', checkedStatus: '',
            }, {
                key: 'Is greater Than', value: '<', type: 'number', checkedStatus: '',
            }, {
                key: 'Is less Than', value: '>', type: 'number', checkedStatus: '',
            }, {
                key: 'Is less Than or equal to', value: '>=', type: 'number', checkedStatus: '',
            }, {
                key: 'Is greater Than or equal to', value: '=<', type: 'number', checkedStatus: this.checkIcon,
            }];
    }
    /**
     * @return {?}
     */
    DataGridFilterComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.sortFilterData();
    };
    /**
     * @param {?} col
     * @param {?} opt
     * @return {?}
     */
    DataGridFilterComponent.prototype.selectedOption = /**
     * @param {?} col
     * @param {?} opt
     * @return {?}
     */
    function (col, opt) {
        this.checkStatus();
        var /** @type {?} */ filter = {
            key: col.dataindex,
            value: this.filterValue,
            filter: opt.value,
            type: col.datatype,
        };
        opt.checkedStatus = this.checkIcon;
        if (this.filterValue) {
            col.filterIcon = true;
            this.filterDataObject(filter, col);
        }
        this.showToolTip = false;
    };
    /**
     * @param {?} col
     * @return {?}
     */
    DataGridFilterComponent.prototype.keyUpSearch = /**
     * @param {?} col
     * @return {?}
     */
    function (col) {
        var _this = this;
        this.showToolTip = false;
        if (this.filterValue == null || this.filterValue === '') {
            this.removeFilter(col);
        }
        else {
            col.filterIcon = true;
            var /** @type {?} */ filter_1 = {
                key: col.dataindex,
                value: this.filterValue,
                type: col.datatype,
            };
            this.filterOptions.forEach(function (opt) {
                if (opt.checkedStatus === _this.checkIcon && col.datatype === opt.type) {
                    filter_1['filter'] = opt.value;
                }
            });
            this.filterDataObject(filter_1, col);
        }
    };
    /**
     * @param {?} column
     * @return {?}
     */
    DataGridFilterComponent.prototype.removeFilter = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        var _this = this;
        this.filterValue = '';
        column.filterIcon = false;
        this.dataTableService.filteredObject.forEach(function (option, index) {
            if (option.key === column.dataindex) {
                _this.dataTableService.filteredObject.splice(index, 1);
            }
        });
        this.filterObject.emit(this.dataTableService.filteredObject);
    };
    /**
     * @return {?}
     */
    DataGridFilterComponent.prototype.checkStatus = /**
     * @return {?}
     */
    function () {
        this.filterOptions.forEach(function (opt) {
            opt.checkedStatus = '';
        });
    };
    /**
     * @param {?} filter
     * @param {?} col
     * @return {?}
     */
    DataGridFilterComponent.prototype.filterDataObject = /**
     * @param {?} filter
     * @param {?} col
     * @return {?}
     */
    function (filter, col) {
        var _this = this;
        this.dataTableService.filteredObject.forEach(function (option, index) {
            if (option.key === col.dataindex) {
                _this.dataTableService.filteredObject.splice(index, 1);
            }
        });
        this.dataTableService.filteredObject.push(filter);
        this.filterObject.emit(this.dataTableService.filteredObject);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DataGridFilterComponent.prototype.onDataFilterIconClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopImmediatePropagation();
        this.onFilterClick.emit();
        this.addListner();
        this.showToolTip = !this.showToolTip;
    };
    /**
     * @return {?}
     */
    DataGridFilterComponent.prototype.addListner = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.globalClickListenFunc = this.renderer.listen('document', 'click', function (e) {
            _this.showToolTip = false;
            if (!_this.showToolTip) {
                _this.removeListner();
            }
        });
    };
    /**
     * @return {?}
     */
    DataGridFilterComponent.prototype.removeListner = /**
     * @return {?}
     */
    function () {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    };
    /**
     * @param {?} listId
     * @param {?} datatype
     * @return {?}
     */
    DataGridFilterComponent.prototype.onArrowUpList = /**
     * @param {?} listId
     * @param {?} datatype
     * @return {?}
     */
    function (listId, datatype) {
        var /** @type {?} */ unitId = parseInt(listId, 10);
        var /** @type {?} */ previousId = unitId - 1;
        var /** @type {?} */ nextId;
        if (previousId >= 0) {
            document.getElementById(previousId.toString()).focus();
        }
        else {
            if (datatype === 'string') {
                nextId = this.stringFilterArray.length;
            }
            else {
                nextId = this.numberFilterArray.length;
            }
            listId = nextId.toString();
            this.onArrowUpList(listId, datatype);
        }
    };
    /**
     * @param {?} listId
     * @param {?} datatype
     * @return {?}
     */
    DataGridFilterComponent.prototype.onArrowdownList = /**
     * @param {?} listId
     * @param {?} datatype
     * @return {?}
     */
    function (listId, datatype) {
        var /** @type {?} */ unitId = parseInt(listId, 10);
        var /** @type {?} */ nextId = unitId + 1;
        var /** @type {?} */ datatypeLength;
        if (datatype === 'string') {
            datatypeLength = this.stringFilterArray.length;
        }
        else if (datatype === 'number') {
            datatypeLength = this.numberFilterArray.length;
        }
        if (nextId < datatypeLength) {
            document.getElementById(nextId.toString()).focus();
        }
        else {
            listId = '-1';
            this.onArrowdownList(listId, datatype);
        }
    };
    /**
     * @return {?}
     */
    DataGridFilterComponent.prototype.sortFilterData = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.stringFilterArray = [];
        this.numberFilterArray = [];
        this.filterOptions.forEach(function (element) {
            if (element.type === 'string') {
                _this.stringFilterArray.push(element);
            }
            else {
                _this.numberFilterArray.push(element);
            }
        });
    };
    DataGridFilterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'data-grid-filter',
                    template: "\n    <ng-container *ngIf=\"column.datatype==='string'\">\n        <div class=\"inputgroup\">\n            <input  tabindex = \"1\" type=\"text\" [(ngModel)]=\"filterValue\" [attr.placeholder]=\"column.text\" (keyup)=\"keyUpSearch(column)\" type=\"text\" class=\"input-control\" aria-label=\"Text input with dropdown button\">\n            <!--<i class=\"fa fa-filter\" aria-hidden=\"true\" (click)=\"showToolTip = !showToolTip\"></i>-->\n            <span tabindex = \"1\" (keyup.enter)=\"onDataFilterIconClick($event)\" class=\"datatable-filter-icon\">\n                <amexio-c-icon key=\"datagrid_filter\" (click)=\"onDataFilterIconClick($event)\"></amexio-c-icon>\n            </span>\n            <span *ngIf=\"showToolTip\" class=\"dropdown\" style=\"width: 250px; right:0\">\n                <ul class=\"dropdown-list\" *ngFor=\"let opt of stringFilterArray; let i = index\">\n                    <ng-container *ngIf=\"opt.type===column.datatype\">\n                        <li #listId id = {{i}} tabindex=\"1\" (keyup.enter)=\"selectedOption(column,opt)\" (keyup.arrowup)=\"onArrowUpList(listId.id, column.datatype)\" (keyup.arrowdown)=\"onArrowdownList(listId.id, column.datatype)\" role=\"option\" class=\"list-items\">\n                            <div (click)=\"selectedOption(column,opt)\">\n                                {{opt.key}}&nbsp;\n                                <i [class]=\"opt.checkedStatus\" aria-hidden=\"true\"></i>\n                            </div>\n                        </li>\n                    </ng-container>\n                </ul>\n            </span>\n        </div>\n    </ng-container>\n\n    <ng-container *ngIf=\"column.datatype==='number'\">\n        <div class=\"inputgroup\">\n            <input tabindex = \"1\" type=\"text\" [(ngModel)]=\"filterValue\" [attr.placeholder]=\"column.text\" (keyup)=\"keyUpSearch(column)\" type=\"number\" class=\"input-control\" aria-label=\"Text input with dropdown button\">\n            <!--<i class=\"fa fa-filter\" aria-hidden=\"true\" (click)=\"showToolTip = !showToolTip\"></i>-->\n            <span tabindex = \"1\"  (keyup.enter)=\"onDataFilterIconClick($event)\" class=\"datatable-filter-icon\">\n                <amexio-c-icon key=\"datagrid_filter\" (click)=\"onDataFilterIconClick($event)\"></amexio-c-icon>\n            </span>\n            <span *ngIf=\"showToolTip\" class=\"dropdown\" style=\"width: 250px; right:0\">\n                <ul class=\"dropdown-list\" *ngFor=\"let opt of numberFilterArray; let i = index\">\n                    <ng-container *ngIf=\"opt.type===column.datatype\">\n                        <li #listId id = {{i}} tabindex=\"1\" (keyup.enter)=\"selectedOption(column,opt)\" (keyup.arrowup)=\"onArrowUpList(listId.id, column.datatype)\" (keyup.arrowdown)=\"onArrowdownList(listId.id, column.datatype)\" role=\"option\" class=\"list-items\">                        <div (click)=\"selectedOption(column,opt)\">\n                                {{opt.key}}&nbsp;\n                                <i [class]=\"opt.checkedStatus\" aria-hidden=\"true\"></i>\n                            </div>\n                        </li>\n                    </ng-container>\n                </ul>\n            </span>\n        </div>\n    </ng-container>\n  ",
                },] },
    ];
    /** @nocollapse */
    DataGridFilterComponent.ctorParameters = function () { return [
        { type: CommonDataService },
        { type: i0.Renderer2 }
    ]; };
    DataGridFilterComponent.propDecorators = {
        column: [{ type: i0.Input }],
        filterObject: [{ type: i0.Output }],
        onFilterClick: [{ type: i0.Output }]
    };
    return DataGridFilterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioDatagridComponent = /** @class */ (function () {
    function AmexioDatagridComponent(element, dataTableService, cd, renderer) {
        this.element = element;
        this.dataTableService = dataTableService;
        this.cd = cd;
        this.renderer = renderer;
        /*
           Events
           name : rowSelect
           datatype : none
           version : none
           default : none
           description : It will gives you row clicked data.
           */
        this.rowSelect = new i0.EventEmitter();
        /*
           Events
           name : selectedRowData
           datatype : none
           version : none
           default : none
           description : It will fire only on selection of checkbox and gives you selected record data.
           */
        this.selectedRowData = new i0.EventEmitter();
        /*
           Events
           name : onHeaderClick
           datatype : none
           version : none
           default : none
           description : It will gives you click event and column info.
           */
        this.onHeaderClick = new i0.EventEmitter();
        /*
           Properties
           name : groupby
           datatype :
           version : 4.0 onwards
           default : none
           description : Set True for Enable group by functionality.
           */
        this.groupby = false;
        this.serverSidePaging = false;
        this.rightClick = new i0.EventEmitter();
        /*
           Events
           name : onPageChange
           datatype : none
           version : none
           default : none
           description : It will gives you current and next page info
           */
        this.onPageChange = new i0.EventEmitter();
        this.columns = [];
        this.viewRows = [];
        this.selectAll = false;
        this.globalFilterOptions = [];
        this.tempContextMenu = [];
        this.mouseLocation = { left: 0, top: 0 };
        this.isExpanded = false;
        this.mask = true;
        this.checkIcon = 'fa fa-check';
        this.plusIcon = 'fa fa-plus';
        this.checkDefaultIcon = 'checkbox default';
        this.checkBoxSelectClass = '';
        this.showEnableColumnFilter = false;
        this.filterComRef = [];
        this.columnCountArray = [];
        this.arrayTabIndex = [];
        this.tabindex = '-1';
        this.columnHiddenIndexArray = [];
        this.prevlistindex = -1;
        this.listindex = -1;
        this.stringFilterArray = [];
        this.numberFilterArray = [];
        this.selectedRows = [];
        this.sortBy = -1;
        this.globalFilterOptions = [{
                key: 'Start With', value: '1', checkedStatus: this.checkIcon, type: 'string',
            }, {
                key: 'Ends With', value: '2', checkedStatus: '', type: 'string',
            }, {
                key: 'Contains', value: '3', checkedStatus: '', type: 'string',
            }];
    }
    Object.defineProperty(AmexioDatagridComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioDatagridComponent.prototype, "columndefintion", {
        get: /**
         * @return {?}
         */
        function () {
            return this._columndefintion;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._columndefintion = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.enablecolumnfiter) {
            this.enablecolumnfilter = this.enablecolumnfiter;
        }
        this.isExpanded = true;
        this.iconclassKey = this.plusIcon;
        if (this.enabledatafilter === true) {
            this.globalfilter = false;
        }
        if (this.selectedrowcolor == null || this.selectedrowcolor === '') {
            this.selectedrowcolor = '#dcecf7';
        }
        if (this.httpmethod && this.httpurl) {
            this.dataTableService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.setData(this.data);
            this.previousData = JSON.parse(JSON.stringify(this.data));
        }
        this.componentLoaded = true;
        this.checkBoxSelectClass = this.setCheckBoxSelectClass();
        this.componentId = 'gridcolumn' + Math.floor(Math.random() * 1000 + 999);
        this.gridId = 'grid' + Math.floor(Math.random() * 1000 + 999);
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.enabledatafilter) {
            this.filterComRef = this.filterRef.toArray();
        }
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (this.previousData != null && JSON.stringify(this.previousData) !== JSON.stringify(this.data)) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setChangeData(this.data);
        }
        if (this.columnPreviewData != null && this.columndefintion != null &&
            JSON.stringify(this.columnPreviewData) !== JSON.stringify(this.columndefintion)) {
            this.columnPreviewData = JSON.parse(JSON.stringify(this.columndefintion));
            this.columns = this.columndefintion;
        }
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        if (this.columndefintion) {
            this.columns = this.columndefintion;
            this.columnPreviewData = JSON.parse(JSON.stringify(this.columndefintion));
        }
        else {
            this.createConfig();
        }
        this.getColumnCount();
        this.checkFirstTabIndex(1);
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.createConfig = /**
     * @return {?}
     */
    function () {
        this.columns = [];
        var /** @type {?} */ columnRefArray = [];
        columnRefArray = this.columnRef.toArray();
        for (var _i = 0, columnRefArray_1 = columnRefArray; _i < columnRefArray_1.length; _i++) {
            var cr = columnRefArray_1[_i];
            var /** @type {?} */ columnConfig = cr;
            var /** @type {?} */ columnData = void 0;
            if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate != null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    headerTemplate: columnConfig.headerTemplate,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    bodyTemplate: columnConfig.bodyTemplate,
                    contextmenu: columnConfig.contextmenu,
                };
            }
            else if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    headerTemplate: columnConfig.headerTemplate,
                    contextmenu: columnConfig.contextmenu,
                };
            }
            else if (columnConfig.bodyTemplate != null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    bodyTemplate: columnConfig.bodyTemplate,
                    contextmenu: columnConfig.contextmenu,
                };
            }
            else if (columnConfig.bodyTemplate == null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    width: columnConfig.width,
                    sort: columnConfig.sort,
                    datatype: columnConfig.datatype,
                    contextmenu: columnConfig.contextmenu,
                };
            }
            if (columnConfig.summarytype) {
                columnData['summarytype'] = columnConfig.summarytype;
            }
            if (columnConfig.summarycaption) {
                columnData['summarycaption'] = columnConfig.summarycaption;
            }
            this.columns.push(columnData);
            this.enableHeaderMethod();
        }
    };
    // Enables header if text to any of the column is given
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.enableHeaderMethod = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.columns.forEach(function (element) {
            if (element.text) {
                _this.enableHeader = true;
            }
        });
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setChangeData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        this.setSelectedFlag(httpResponse);
        if (this.groupby) {
            this.cloneData = JSON.parse(JSON.stringify(this.data));
            var /** @type {?} */ groups = {};
            this.commonMethod(this.cloneData, groups);
        }
        if (this.enabledatafilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (this.globalfilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (!this.groupby) {
            this.renderData();
        }
        this.setPaginatorData();
        this.mask = false;
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        this.viewRows = this.getResponseData(httpResponse);
        this.setSelectedFlag(this.viewRows);
        this.data = this.viewRows;
        if (this.groupby) {
            this.cloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (this.enabledatafilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        if (this.globalfilter) {
            this.filterCloneData = JSON.parse(JSON.stringify(this.data));
        }
        this.renderData();
        if (this.groupby) {
            this.setColumnData();
        }
        this.setPaginatorData();
        this.mask = false;
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setPaginatorData = /**
     * @return {?}
     */
    function () {
        if (this.serverSidePaging && this.totalDataCount && this.viewRows.length > 0) {
            if (!this.pagesize && !this.totalPages) {
                this.pagesize = this.viewRows.length;
                this.totalPages = Math.ceil(this.totalDataCount / this.pagesize);
            }
        }
        else {
            this.totalPages = this.pageNumbers.length;
        }
    };
    /**
     * @param {?} viewRows
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setSelectedFlag = /**
     * @param {?} viewRows
     * @return {?}
     */
    function (viewRows) {
        viewRows.forEach(function (row) {
            if (!row.hasOwnProperty('isSelected')) {
                row['isSelected'] = false;
            }
        });
    };
    /**
     * @param {?} col
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setGroupByColumn = /**
     * @param {?} col
     * @return {?}
     */
    function (col) {
        this.groupbydataindex = col.dataindex;
        this.selectAll = false;
        this.setColumnData();
    };
    // Method required for global filter
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.keyUpSearch = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.filterValue == null || this.filterValue === '') {
            this.removeGlobalFilter();
        }
        var /** @type {?} */ filter = {
            value: this.filterValue,
        };
        this.globalFilterOptions.forEach(function (opt) {
            if (opt.checkedStatus === _this.checkIcon) {
                filter['filter'] = opt.value;
            }
        });
        this.getGlobalFilteredData(filter);
    };
    /**
     * @param {?} opt
     * @return {?}
     */
    AmexioDatagridComponent.prototype.checkStatus = /**
     * @param {?} opt
     * @return {?}
     */
    function (opt) {
        this.globalFilterOptions.forEach(function (item) {
            item.checkedStatus = '';
        });
        opt.checkedStatus = this.checkIcon;
    };
    /**
     * @param {?} opt
     * @return {?}
     */
    AmexioDatagridComponent.prototype.selectedOption = /**
     * @param {?} opt
     * @return {?}
     */
    function (opt) {
        this.checkStatus(opt);
        var /** @type {?} */ filter = {
            value: this.filterValue,
            filter: opt.value,
            type: opt.type,
        };
        if (this.filterValue) {
            this.getGlobalFilteredData(filter);
        }
        this.showToolTip = false;
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.removeGlobalFilter = /**
     * @return {?}
     */
    function () {
        this.filterValue = '';
    };
    /**
     * @param {?} filteredObj
     * @return {?}
     */
    AmexioDatagridComponent.prototype.getGlobalFilteredData = /**
     * @param {?} filteredObj
     * @return {?}
     */
    function (filteredObj) {
        var _this = this;
        var /** @type {?} */ resultData = [];
        if (filteredObj) {
            this.filterCloneData.forEach(function (row) {
                if (_this.checkValueInColumn(row, filteredObj)) {
                    resultData.push(row);
                }
            });
            if (resultData.length > (1 * this.pagesize)) {
                this.pagingRegenration();
                this.renderData();
            }
            else {
                this.viewRows = resultData;
                this.currentPage = 1;
                this.maxPage = 1;
            }
        }
        else {
            this.data = this.filterCloneData;
            this.pagingRegenration();
            this.renderData();
        }
    };
    /**
     * @param {?} row
     * @param {?} filteredObj
     * @return {?}
     */
    AmexioDatagridComponent.prototype.checkValueInColumn = /**
     * @param {?} row
     * @param {?} filteredObj
     * @return {?}
     */
    function (row, filteredObj) {
        var /** @type {?} */ searchStatus = false;
        var /** @type {?} */ statusCollection = [];
        this.columns.forEach(function (opt) {
            var /** @type {?} */ optvalue = '';
            var /** @type {?} */ filtervalue = '';
            if (typeof row[opt.dataindex] === 'string') {
                optvalue = row[opt.dataindex].toLowerCase();
            }
            if (typeof filteredObj.value === 'string') {
                filtervalue = filteredObj.value.toLowerCase();
            }
            if (filteredObj.filter === '1') {
                statusCollection.push(optvalue.startsWith(filtervalue));
            }
            else if (filteredObj.filter === '2') {
                statusCollection.push(optvalue.endsWith(filtervalue));
            }
            else if (filteredObj.filter === '3') {
                statusCollection.push(optvalue.includes(filtervalue));
            }
        });
        if (statusCollection.filter(function (status) { return status === true; }).length > 0) {
            searchStatus = true;
        }
        return searchStatus;
    };
    /**
     * @param {?} filteredObj
     * @param {?} option
     * @param {?} opt
     * @return {?}
     */
    AmexioDatagridComponent.prototype.filterConditionMethod = /**
     * @param {?} filteredObj
     * @param {?} option
     * @param {?} opt
     * @return {?}
     */
    function (filteredObj, option, opt) {
        this.data = [];
        var /** @type {?} */ condition;
        if (filteredObj.filter === '1') {
            condition = option[opt.dataindex].toLowerCase().startsWith(filteredObj.value.toLowerCase());
            this.setstatus(condition);
        }
        if (filteredObj.filter === '2') {
            condition = option[opt.dataindex].toLowerCase().endsWith(filteredObj.value.toLowerCase());
            this.setstatus(condition);
        }
        if (filteredObj.filter === '3') {
            condition = option[opt.dataindex].toLowerCase().includes(filteredObj.value.toLowerCase());
            this.setstatus(condition);
        }
    };
    // Refactored code to avoid duplication: for filter grid
    /**
     * @param {?} condition
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setstatus = /**
     * @param {?} condition
     * @return {?}
     */
    function (condition) {
        if (condition) {
            status = condition;
        }
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setColumnData = /**
     * @return {?}
     */
    function () {
        this.data = this.cloneData;
        var /** @type {?} */ groups = {};
        this.commonMethod(this.data, groups);
    };
    /**
     * @param {?} data
     * @param {?} groups
     * @return {?}
     */
    AmexioDatagridComponent.prototype.commonMethod = /**
     * @param {?} data
     * @param {?} groups
     * @return {?}
     */
    function (data, groups) {
        var _this = this;
        data.forEach(function (option) {
            var /** @type {?} */ groupName = option[_this.groupbydataindex];
            if (!groups[groupName]) {
                groups[groupName] = [];
            }
            groups[groupName].push(option);
        });
        data = [];
        for (var /** @type {?} */ groupName in groups) {
            if (groups.hasOwnProperty(groupName)) {
                data.push({ expanded: false, isSelected: false, group: groupName, groupData: groups[groupName] });
            }
        }
        /*-------Aggregation---------*/
        this.renderData();
        this.cd.detectChanges();
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.renderData = /**
     * @return {?}
     */
    function () {
        // calculate page no for pagination
        if (this.data) {
            this.maxPage = 0;
            this.pageNumbers = [];
            if (this.data.length > (1 * this.pagesize)) {
                this.maxPage = Math.floor((this.data.length / this.pagesize));
                if ((this.data.length % this.pagesize) > 0) {
                    this.maxPage++;
                }
            }
            for (var /** @type {?} */ pageNo = 1; pageNo <= this.maxPage; pageNo++) {
                this.pageNumbers.push(pageNo);
            }
        }
        if (this.pagesize >= 1) {
            this.getPageSize();
        }
        else {
            this.viewRows = this.data;
        }
        this.selectedRowNo = -1;
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.getPageSize = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ rowsTemp = this.data;
        var /** @type {?} */ newRows = [];
        var /** @type {?} */ startIndex = 0;
        var /** @type {?} */ endIndex = this.pagesize;
        if (this.currentPage > 1) {
            startIndex = (this.currentPage - 1) * this.pagesize;
            endIndex = startIndex + this.pagesize;
        }
        while (startIndex <= endIndex - 1) {
            if (rowsTemp[startIndex]) {
                newRows.push(rowsTemp[startIndex]);
            }
            startIndex++;
        }
        this.viewRows = newRows;
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioDatagridComponent.prototype.getResponseData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.selectAllRecord = /**
     * @return {?}
     */
    function () {
        this.selectAll = !this.selectAll;
        if (this.selectAll) {
            for (var _i = 0, _a = this.viewRows; _i < _a.length; _i++) {
                var vr = _a[_i];
                this.selectedRows.push(vr);
            }
        }
        else {
            this.selectedRows = [];
        }
        this.emitSelectedRows();
        if (this.groupby) {
            if (!this.selectAll) {
                this.viewRows.forEach(function (row) {
                    row.isSelected = false;
                    row.groupData.forEach(function (node) {
                        node.isSelected = false;
                    });
                });
            }
            else {
                this.viewRows.forEach(function (row) {
                    row.isSelected = true;
                    row.groupData.forEach(function (node) {
                        node.isSelected = true;
                    });
                });
            }
        }
    };
    /**
     * @param {?} column
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onColumnCheck = /**
     * @param {?} column
     * @return {?}
     */
    function (column) {
        column.hidden = !column.hidden;
        this.getColumnCount();
        this.checkFirstTabIndex(1);
    };
    /**
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onRowClick = /**
     * @param {?} rowData
     * @param {?} rowIndex
     * @return {?}
     */
    function (rowData, rowIndex) {
        this.data.forEach(function (opt) {
            opt.isSelected = false;
            if (opt.hasOwnProperty('groupData')) {
                opt.groupData.forEach(function (optChild) {
                    optChild.isSelected = false;
                });
            }
        });
        rowData.isSelected = !rowData.isSelected;
        rowIndex = 'row' + rowIndex;
        this.rowId = rowIndex;
        this.rowSelect.emit(rowData);
        this.selectedRowNo = rowIndex;
    };
    /**
     * @param {?} pageInfo
     * @return {?}
     */
    AmexioDatagridComponent.prototype.loadPageData = /**
     * @param {?} pageInfo
     * @return {?}
     */
    function (pageInfo) {
        if (this.serverSidePaging) {
            this.onPageChange.emit(pageInfo);
        }
        else {
            this.currentPage = pageInfo.pageNumber;
            this.renderData();
        }
    };
    /**
     * @param {?} filteredObj
     * @return {?}
     */
    AmexioDatagridComponent.prototype.getFilteredData = /**
     * @param {?} filteredObj
     * @return {?}
     */
    function (filteredObj) {
        var _this = this;
        var /** @type {?} */ resultData = [];
        if (filteredObj.length > 0) {
            this.filterCloneData.forEach(function (option) {
                if (_this.filterOpertion(option, filteredObj)) {
                    resultData.push(option);
                }
            });
            if (resultData.length > (1 * this.pagesize)) {
                this.pagingRegenration();
                this.renderData();
            }
            else {
                this.viewRows = resultData;
                this.currentPage = 1;
                this.maxPage = 1;
            }
        }
        else {
            this.data = this.filterCloneData;
            this.pagingRegenration();
            this.renderData();
        }
    };
    /**
     * @param {?} data
     * @param {?} filteredObj
     * @return {?}
     */
    AmexioDatagridComponent.prototype.filterOpertion = /**
     * @param {?} data
     * @param {?} filteredObj
     * @return {?}
     */
    function (data, filteredObj) {
        var _this = this;
        var /** @type {?} */ statusCollection = [];
        var /** @type {?} */ condition = false;
        filteredObj.forEach(function (filterOpt) {
            if (filterOpt.type === 'string') {
                if (filterOpt.value && data[filterOpt.key] && typeof data[filterOpt.key] === 'string') {
                    statusCollection.push(_this.checkStringFilter(filterOpt.filter, data[filterOpt.key].toLowerCase(), filterOpt.value.toLowerCase()));
                }
            }
            else if (filterOpt.type === 'number') {
                statusCollection.push(_this.checkNumberFilter(filterOpt.filter, data[filterOpt.key], filterOpt.value));
            }
        });
        if (statusCollection.filter(function (status) { return status === true; }).length > 0) {
            condition = true;
        }
        return condition;
    };
    /**
     * @param {?} filter
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    AmexioDatagridComponent.prototype.checkNumberFilter = /**
     * @param {?} filter
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (filter, key, value) {
        if (filter === '<') {
            return key > value;
        }
        else if (filter === '>') {
            return key < value;
        }
        else if (filter === '>=') {
            return key <= value;
        }
        else if (filter === '=<') {
            return key >= value;
        }
        else if (filter === '==') {
            return key === value;
        }
        else if (filter === '!=') {
            return key !== value;
        }
        else {
            return key !== value;
        }
    };
    /**
     * @param {?} filter
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    AmexioDatagridComponent.prototype.checkStringFilter = /**
     * @param {?} filter
     * @param {?} key
     * @param {?} value
     * @return {?}
     */
    function (filter, key, value) {
        if (filter === '3') {
            return key.includes(value);
        }
        else if (filter === '1') {
            return key.startsWith(value);
        }
        else if (filter === '2') {
            return key.endsWith(value);
        }
        else {
            return key !== value;
        }
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.pagingRegenration = /**
     * @return {?}
     */
    function () {
        this.maxPage = Math.floor((this.data.length / this.pagesize));
        if ((this.data.length % this.pagesize) > 0) {
            this.maxPage++;
        }
        for (var /** @type {?} */ pageNo = 1; pageNo <= this.maxPage; pageNo++) {
            this.pageNumbers.push(pageNo);
        }
    };
    /**
     * @param {?} rowData
     * @param {?} event
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setSelectedRow = /**
     * @param {?} rowData
     * @param {?} event
     * @return {?}
     */
    function (rowData, event) {
        if (event.classList.value === this.checkDefaultIcon) {
            this.selectedRows.push(rowData);
            event.classList.value = 'checkbox active';
        }
        else {
            var /** @type {?} */ indexOf = this.selectedRows.indexOf(rowData);
            this.selectedRows.splice(indexOf, 0);
            event.classList.value = this.checkDefaultIcon;
        }
        this.emitSelectedRows();
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.emitSelectedRows = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ sRows = [];
        for (var _i = 0, _a = this.selectedRows; _i < _a.length; _i++) {
            var sr = _a[_i];
            if (sr) {
                sRows.push(sr);
            }
        }
        this.selectedRowData.emit(sRows);
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setCheckBoxSelectClass = /**
     * @return {?}
     */
    function () {
        if (this.selectAll) {
            return 'checkbox active';
        }
        else if (!this.selectAll) {
            return this.checkDefaultIcon;
        }
    };
    /**
     * @param {?} sortCol
     * @param {?} clickEvent
     * @return {?}
     */
    AmexioDatagridComponent.prototype.sortOnColHeaderClick = /**
     * @param {?} sortCol
     * @param {?} clickEvent
     * @return {?}
     */
    function (sortCol, clickEvent) {
        this.onHeaderClick.emit({ event: clickEvent, data: sortCol });
        if (sortCol.sort) {
            if (this.sortBy === -1) {
                this.sortBy = 1;
            }
            else if (this.sortBy === 1) {
                this.sortBy = 2;
            }
            else if (this.sortBy === 2) {
                this.sortBy = 1;
            }
            this.setSortColumn(sortCol, this.sortBy);
        }
    };
    /**
     * @param {?} sortCol
     * @param {?} _sortBy
     * @return {?}
     */
    AmexioDatagridComponent.prototype.setSortColumn = /**
     * @param {?} sortCol
     * @param {?} _sortBy
     * @return {?}
     */
    function (sortCol, _sortBy) {
        /*------set column sort false for other column--------*/
        this.columns.forEach(function (opt) {
            opt['isColumnSort'] = false;
        });
        this.sortBy = _sortBy;
        this.sortColumn = sortCol;
        this.sortColumn.sort = true;
        this.sortColumn.isColumnSort = true;
        this.sortData();
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.sortData = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.sortColumn) {
            var /** @type {?} */ sortColDataIndex_1;
            var /** @type {?} */ sortOrder_1 = this.sortBy;
            if (this.sortColumn.dataindex && this.sortColumn.datatype) {
                var /** @type {?} */ dataindex = this.sortColumn.dataindex;
                sortColDataIndex_1 = dataindex;
                if (this.sortColumn.datatype === 'string') {
                    if (this.groupby) {
                        this.sortOrderGrpBy(sortOrder_1);
                    }
                    else {
                        this.data.sort(function (a, b) {
                            var /** @type {?} */ x = a[sortColDataIndex_1].toLowerCase();
                            var /** @type {?} */ y = b[sortColDataIndex_1].toLowerCase();
                            return _this.noGrpBySortOrder(sortOrder_1, x, y);
                        });
                    }
                }
                else if (this.sortColumn.datatype === 'number') {
                    this.sortOrderByNumber(sortOrder_1, sortColDataIndex_1);
                }
                else if (this.sortColumn.datatype === 'boolean') {
                    this.sortOrderByBoolean(sortOrder_1, sortColDataIndex_1);
                }
            }
        }
        this.renderData();
    };
    /**
     * @param {?} sortOrder
     * @param {?} sortColDataIndex
     * @return {?}
     */
    AmexioDatagridComponent.prototype.sortOrderByBoolean = /**
     * @param {?} sortOrder
     * @param {?} sortColDataIndex
     * @return {?}
     */
    function (sortOrder, sortColDataIndex) {
        this.data.sort(function (a, b) {
            var /** @type {?} */ x = a[sortColDataIndex];
            var /** @type {?} */ y = b[sortColDataIndex];
            if (sortOrder === 1) {
                return (x === y) ? 0 : x ? -1 : 1;
            }
        });
        if (sortOrder === 2) {
            this.data.reverse();
        }
    };
    // Sort Order for number field
    /**
     * @param {?} sortOrder
     * @param {?} sortColDataIndex
     * @return {?}
     */
    AmexioDatagridComponent.prototype.sortOrderByNumber = /**
     * @param {?} sortOrder
     * @param {?} sortColDataIndex
     * @return {?}
     */
    function (sortOrder, sortColDataIndex) {
        if (this.groupby) {
            this.data.sort(function (a, b) {
                var /** @type {?} */ x = a.group;
                var /** @type {?} */ y = b.group;
                if (sortOrder === 2) {
                    return y - x;
                }
                else {
                    return x - y;
                }
            });
        }
        else {
            this.data.sort(function (a, b) {
                var /** @type {?} */ x = a[sortColDataIndex];
                var /** @type {?} */ y = b[sortColDataIndex];
                if (sortOrder === 2) {
                    return y - x;
                }
                else {
                    return x - y;
                }
            });
        }
    };
    // Sort order if group by is false
    /**
     * @param {?} sortOrder
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    AmexioDatagridComponent.prototype.noGrpBySortOrder = /**
     * @param {?} sortOrder
     * @param {?} x
     * @param {?} y
     * @return {?}
     */
    function (sortOrder, x, y) {
        if (sortOrder === 2) {
            if (x < y) {
                return 1;
            }
            if (x > y) {
                return -1;
            }
        }
        else {
            if (x < y) {
                return -1;
            }
            if (x > y) {
                return 1;
            }
        }
        return 0;
    };
    // Sort Order if group by is true
    /**
     * @param {?} sortOrder
     * @return {?}
     */
    AmexioDatagridComponent.prototype.sortOrderGrpBy = /**
     * @param {?} sortOrder
     * @return {?}
     */
    function (sortOrder) {
        this.data.sort(function (a, b) {
            var /** @type {?} */ x = a.group.toLowerCase();
            var /** @type {?} */ y = b.group.toLowerCase();
            if (sortOrder === 2) {
                if (x < y) {
                    return 1;
                }
                if (x > y) {
                    return -1;
                }
            }
            else {
                if (x < y) {
                    return -1;
                }
                if (x > y) {
                    return 1;
                }
            }
            return 0;
        });
    };
    /* grouby column methods*/
    /**
     * @param {?} btn
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onTabClick = /**
     * @param {?} btn
     * @return {?}
     */
    function (btn) {
        btn.classList.toggle('active-accordion');
        var /** @type {?} */ panel = btn.nextElementSibling;
        if (this.iconclassKey === this.plusIcon) {
            this.iconclassKey = 'fa fa-minus';
        }
        else if (this.iconclassKey === 'fa fa-minus') {
            this.iconclassKey = this.plusIcon;
        }
        if (panel.style.maxHeight) {
            panel.style.maxHeight = null;
        }
        else {
            panel.style.maxHeight = panel.scrollHeight + 'px';
        }
    };
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    AmexioDatagridComponent.prototype.toogle = /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    function (row, index) {
        row.expanded = !row.expanded;
        if (row.expanded) {
            if (row.hasOwnProperty('groupData')) {
                this.addRows(row, index);
            }
        }
        else {
            if (row.hasOwnProperty('groupData')) {
                this.removeRows(row);
            }
        }
    };
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    AmexioDatagridComponent.prototype.addRows = /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    function (row, index) {
        var _this = this;
        row.level = Math.floor(Math.random() * 900) + 100;
        row.groupData.forEach(function (node, index1) {
            node.level = row.level;
            _this.viewRows.splice(index + (index1 + 1), 0, node);
        });
    };
    /**
     * @param {?} row
     * @return {?}
     */
    AmexioDatagridComponent.prototype.removeRows = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        var _this = this;
        var /** @type {?} */ count = 0;
        this.viewRows.forEach(function (node) {
            if (!node.hasOwnProperty('group') && node.level === row.level) {
                count++;
            }
        });
        this.viewRows.forEach(function (node, index) {
            if (!node.hasOwnProperty('group') && node.level === row.level) {
                _this.viewRows.splice(index, count);
            }
        });
    };
    /**
     * @param {?} row
     * @return {?}
     */
    AmexioDatagridComponent.prototype.isGroupChecking = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        if (row.hasOwnProperty('group')) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} row
     * @return {?}
     */
    AmexioDatagridComponent.prototype.selectParent = /**
     * @param {?} row
     * @return {?}
     */
    function (row) {
        var _this = this;
        if (this.groupby) {
            row.isSelected = !row.isSelected;
            row.groupData.forEach(function (node) {
                node.isSelected = !node.isSelected;
            });
            this.selectedRows = [];
            this.viewRows.forEach(function (rows) {
                if (rows.isSelected) {
                    _this.selectedRows.push(rows);
                }
            });
            this.emitSelectedRows();
        }
    };
    /**
     * @param {?} event
     * @param {?} row
     * @param {?} col
     * @param {?} ref
     * @return {?}
     */
    AmexioDatagridComponent.prototype.loadContextMenu = /**
     * @param {?} event
     * @param {?} row
     * @param {?} col
     * @param {?} ref
     * @return {?}
     */
    function (event, row, col, ref) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.tempContextMenu = [];
            this.tempSelectedFlag(this.viewRows);
            this.mouseLocation.left = event.clientX;
            this.mouseLocation.top = event.clientY;
            row.isSelected = true;
            if (col.contextmenu && col.contextmenu.length > 0) {
                this.flag = true;
                this.tempContextMenu = col.contextmenu;
                this.addListner();
            }
            else if (this.contextmenu && this.contextmenu.length > 0) {
                this.tempContextMenu = this.contextmenu;
                this.flag = true;
                this.addListner();
            }
            this.posixUp = this.getListPosition(ref);
            event.preventDefault();
            event.stopPropagation();
            this.rightClickRowData = row;
        }
    };
    /**
     * @param {?} Data
     * @return {?}
     */
    AmexioDatagridComponent.prototype.rightClickDataEmit = /**
     * @param {?} Data
     * @return {?}
     */
    function (Data) {
        this.rightClick.emit(Data);
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioDatagridComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} viewRows
     * @return {?}
     */
    AmexioDatagridComponent.prototype.tempSelectedFlag = /**
     * @param {?} viewRows
     * @return {?}
     */
    function (viewRows) {
        viewRows.forEach(function (row) {
            if (row.isSelected) {
                row.isSelected = false;
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.addListner = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.globalClickListenFunc = this.renderer.listen('document', 'click', function (e) {
            _this.flag = false;
            _this.showToolTip = false;
            _this.showEnableColumnFilter = false;
            if (!_this.flag || !_this.showToolTip || !_this.showEnableColumnFilter) {
                _this.removeListner();
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.removeListner = /**
     * @return {?}
     */
    function () {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeListner();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onFilterIconClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopImmediatePropagation();
        this.addListner();
        this.showEnableColumnFilter = false;
        this.showToolTip = !this.showToolTip;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onEnableColumnClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.stopImmediatePropagation();
        this.addListner();
        this.showToolTip = false;
        this.showEnableColumnFilter = !this.showEnableColumnFilter;
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.getFilterClick = /**
     * @return {?}
     */
    function () {
        this.filterComRef.forEach(function (com) {
            com.showToolTip = false;
        });
    };
    // TAB NAVIGATION
    // LEFT ARROW
    /**
     * @param {?} ref
     * @return {?}
     */
    AmexioDatagridComponent.prototype.arrowLeft = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        var /** @type {?} */ unitId = parseInt(intId, 10) % 10;
        var /** @type {?} */ firstId = intId.slice(0, -1);
        this.findPreviousColumn(unitId, firstId);
    };
    // RIGHT ARROW
    /**
     * @param {?} ref
     * @return {?}
     */
    AmexioDatagridComponent.prototype.arrowRight = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        var /** @type {?} */ unitId = parseInt(intId, 10) % 10;
        var /** @type {?} */ firstId = intId.slice(0, -1);
        this.findNextColumn(unitId, firstId);
    };
    // UP ARROW
    /**
     * @param {?} ref
     * @return {?}
     */
    AmexioDatagridComponent.prototype.arrowUp = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        var /** @type {?} */ unitId = intId.slice(0, -1);
        if (unitId > 1 && document.getElementById(this.title + '-' + (parseInt(intId, 10) - 10).toString())) {
            document.getElementById(this.title + '-' + (parseInt(intId, 10) - 10).toString()).focus();
        }
    };
    // DOWN ARROW
    /**
     * @param {?} ref
     * @return {?}
     */
    AmexioDatagridComponent.prototype.arrowDown = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        var /** @type {?} */ firstId = parseInt(intId.slice(0, -1), 10);
        if ((this.pagesize && firstId < this.pagesize && firstId < this.viewRows.length || (firstId <= this.viewRows.length - 1))
            && document.getElementById(this.title + '-' + (parseInt(intId, 10) + 10).toString())) {
            document.getElementById(this.title + '-' + (parseInt(intId, 10) + 10).toString()).focus();
        }
    };
    // END
    /**
     * @param {?} ref
     * @return {?}
     */
    AmexioDatagridComponent.prototype.keyEnd = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        var /** @type {?} */ unitId = parseInt(intId, 10) % 10;
        var /** @type {?} */ firstId = intId.slice(0, -1);
        var /** @type {?} */ newLastId = this.columns.length;
        this.findHomeColumn(unitId, firstId, newLastId);
    };
    // END: TO FIND LAST COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} newLastId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.findLastColumn = /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} newLastId
     * @return {?}
     */
    function (unitId, firstId, newLastId) {
        if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(newLastId)) {
            this.findHomeColumn(unitId, firstId, newLastId - 1);
        }
        else {
            var /** @type {?} */ generatedId = firstId + '' + newLastId;
            document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    };
    // HOME
    /**
     * @param {?} ref
     * @return {?}
     */
    AmexioDatagridComponent.prototype.keyHome = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ intId = (ref.id).substring(ref.id.search('-') + 1, (ref.id).length);
        var /** @type {?} */ unitId = parseInt(intId, 10) % 10;
        this.findHomeColumn(unitId, intId.slice(0, -1), 1);
    };
    // HOME: TO FIND FIRST COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} newFirstId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.findHomeColumn = /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} newFirstId
     * @return {?}
     */
    function (unitId, firstId, newFirstId) {
        if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(newFirstId)) {
            this.findHomeColumn(unitId, firstId, newFirstId + 1);
        }
        else {
            var /** @type {?} */ generatedId = firstId + '' + newFirstId;
            document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    };
    // CONTROL HOME
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.keyControlHome = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ unitId = 1;
        var /** @type {?} */ firstId = 1;
        this.findControlHomeColumn(unitId, firstId);
    };
    // CONTROL HOME COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.findControlHomeColumn = /**
     * @param {?} unitId
     * @param {?} firstId
     * @return {?}
     */
    function (unitId, firstId) {
        if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(unitId)) {
            this.findControlHomeColumn(unitId + 1, firstId);
        }
        else {
            var /** @type {?} */ generatedId = firstId + '' + unitId;
            document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    };
    // CONTROL END
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.keyControlEnd = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ unitId = this.columns.length;
        if (this.pagesize && this.viewRows.length >= this.pagesize) {
            var /** @type {?} */ firstId = this.pagesize;
            this.findControlEndColumn(unitId, firstId);
        }
        else {
            var /** @type {?} */ firstId = this.viewRows.length;
            this.findControlEndColumn(unitId, firstId);
        }
    };
    // CONTROL END COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.findControlEndColumn = /**
     * @param {?} unitId
     * @param {?} firstId
     * @return {?}
     */
    function (unitId, firstId) {
        if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(unitId)) {
            this.findControlHomeColumn(unitId - 1, firstId);
        }
        else {
            var /** @type {?} */ generatedId = firstId + '' + unitId;
            document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    };
    // TO GET COLUMN COUNT EXCLUDING HIDDEN COLUMNS
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.getColumnCount = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.columns) {
            this.columnHiddenIndexArray = [];
            this.columns.forEach(function (element, index) {
                if (!element.hidden) {
                    _this.columnCountArray.push(element);
                }
                else {
                    _this.columnHiddenIndexArray.push(index + 1);
                }
            });
        }
    };
    // TO FIND NEXT COLUMN: RIGHT ARROW
    /**
     * @param {?} index
     * @param {?} firstId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.findNextColumn = /**
     * @param {?} index
     * @param {?} firstId
     * @return {?}
     */
    function (index, firstId) {
        if (index < this.columns.length) {
            if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(index + 1)) {
                index = index + 1;
                this.findNextColumn(index, firstId);
            }
            else {
                var /** @type {?} */ generatedId = firstId + '' + (index + 1);
                document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
            }
        }
    };
    // TO FIND PREVIOUS COLUMN: LEFT ARROW
    /**
     * @param {?} index
     * @param {?} firstId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.findPreviousColumn = /**
     * @param {?} index
     * @param {?} firstId
     * @return {?}
     */
    function (index, firstId) {
        if (index > 1) {
            if (this.columnHiddenIndexArray.length >= 1 && this.columnHiddenIndexArray.includes(index - 1)) {
                index = index - 1;
                this.findPreviousColumn(index, firstId);
            }
            else {
                var /** @type {?} */ generatedId = firstId + '' + (index - 1);
                document.getElementById(this.title + '-' + (parseInt(generatedId, 10)).toString()).focus();
            }
        }
    };
    // DEFAULT FIRST TAB
    /**
     * @param {?} index
     * @return {?}
     */
    AmexioDatagridComponent.prototype.checkFirstTabIndex = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        if (this.columnHiddenIndexArray.length >= 1) {
            if (this.columnHiddenIndexArray.includes(index)) {
                this.firstIndex = index + 1;
                this.checkFirstTabIndex(this.firstIndex);
            }
        }
        else {
            this.firstIndex = 1;
        }
    };
    // DOWN COLUMN: DOWN ARROW
    /**
     * @param {?} listId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onArrowdownList = /**
     * @param {?} listId
     * @return {?}
     */
    function (listId) {
        var /** @type {?} */ unitId = parseInt(listId, 10);
        var /** @type {?} */ nextId = unitId + 1;
        if (nextId < this.columns.length) {
            document.getElementById(nextId.toString()).focus();
        }
        else {
            listId = '-1';
            this.onArrowdownList(listId);
        }
    };
    // UP COLUMN: UP ARROW
    /**
     * @param {?} listId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onArrowUpList = /**
     * @param {?} listId
     * @return {?}
     */
    function (listId) {
        var /** @type {?} */ unitId = parseInt(listId, 10);
        var /** @type {?} */ previousId = unitId - 1;
        if (previousId >= 0) {
            document.getElementById(previousId.toString()).focus();
        }
        else {
            var /** @type {?} */ nextId = this.columns.length;
            listId = nextId.toString();
            this.onArrowUpList(listId);
        }
    };
    /**
     * @param {?} listId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onArrowUpGlobalList = /**
     * @param {?} listId
     * @return {?}
     */
    function (listId) {
        var /** @type {?} */ unitId = parseInt(listId, 10);
        var /** @type {?} */ previousId = unitId - 1;
        if (previousId >= 0) {
            document.getElementById(previousId.toString()).focus();
        }
        else {
            var /** @type {?} */ nextId = this.globalFilterOptions.length;
            listId = nextId.toString();
            this.onArrowUpGlobalList(listId);
        }
    };
    /**
     * @param {?} listId
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onArrowdownGlobalList = /**
     * @param {?} listId
     * @return {?}
     */
    function (listId) {
        var /** @type {?} */ unitId = parseInt(listId, 10);
        var /** @type {?} */ nextId = unitId + 1;
        if (nextId < this.globalFilterOptions.length) {
            document.getElementById(nextId.toString()).focus();
        }
        else {
            listId = '-1';
            this.onArrowdownGlobalList(listId);
        }
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onPageDownClick = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.pageId.activePage < this.pagesize) {
            this.pageId.onPageClick(this.pageId.activePage + 1, this.pageId.activePage);
            var /** @type {?} */ pageInfo = { pageNumber: this.pageId.activePage, current: this.pageId.activePage, next: this.pageId.activePage + 1 };
            this.loadPageData(pageInfo);
            this.checkFirstTabIndex(1);
            setTimeout(function () {
                _this.keyControlHome();
            }, 100);
        }
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.onPageUpClick = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.pageId.activePage > 1) {
            this.pageId.onPageClick(this.pageId.activePage - 1, this.pageId.activePage - 2);
            var /** @type {?} */ pageInfo = { pageNumber: this.pageId.activePage - 1, current: this.pageId.activePage, next: this.pageId.activePage + 1 };
            this.loadPageData(pageInfo);
            setTimeout(function () {
                _this.keyControlEnd();
            }, 100);
        }
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.showGroupCol = /**
     * @return {?}
     */
    function () {
        this.showGroupByColumn = !this.showGroupByColumn;
    };
    /**
     * @return {?}
     */
    AmexioDatagridComponent.prototype.findContolEndGrpBy = /**
     * @return {?}
     */
    function () {
        if (this.viewRows && this.viewRows.length > 0) {
            var /** @type {?} */ firstLevelGrid_1 = [];
            var /** @type {?} */ unitId = this.columns.length;
            var /** @type {?} */ firstId = this.viewRows.length;
            this.viewRows.forEach(function (element, index) {
                if (element.hasOwnProperty('expanded')) {
                    firstLevelGrid_1.push(element);
                }
            });
            if (!firstLevelGrid_1[firstLevelGrid_1.length - 1].expanded) {
                this.findControlEndColumn(1, firstId);
            }
            else {
                this.findControlEndColumn(unitId, firstId);
            }
        }
    };
    AmexioDatagridComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-datagrid',
                    template: "\n    <div class=\"datagrid\">\n      <div class=\"datatabletitle\">\n        <span *ngIf=\"title\" id=\"{{gridId}}\"> {{title}} </span>\n        <span class=\"dataheaderFilter\" class=\"float-right\" style=\"padding-bottom:1.1%\">\n          <ng-content select=\"amexio-datagrid-header\"></ng-content>\n          <span tabindex='1' *ngIf=\"enablecolumnfilter ? true:false\" (keyup.enter)=\"onEnableColumnClick($event)\" class=\"float-right enablecolumnfilter\"\n            (click)=\"onEnableColumnClick($event)\" style=\" cursor: pointer;\">\n            &nbsp;\n            <span *ngIf=\"!show\">&#9776;</span>\n            <span *ngIf=\"show\">&#9747;</span>\n          </span>\n        </span>\n        <span *ngIf=\"groupby ? true : false\" class=\"float-right-datagridlist\" tabindex=\"1\" (keyup.enter)=\"showGroupCol()\"\n          (click)=\"showGroupByColumn = !showGroupByColumn; showToolTip = false\" style=\" cursor: pointer;\">\n          <!--<span class=\"fa fa-th-list\"></span>-->\n          <amexio-c-icon key=\"datagrid_list\"></amexio-c-icon>\n        </span>\n      </div>\n      <!--Filter with Checkbox datagrid start-->\n\n      <ng-container *ngIf=\"enabledatafilter ? true : false\">\n        <div class=\"datatable datatable-row\">\n          <ng-container *ngIf=\"enablecheckbox\">\n            <div class=\"datatable-col col-group datatable-checkbox-width\">\n              <div class=\"inputgroup\">\n                <div class=\"input-box\">\n                  <div *ngIf=\"!selectAll\" (click)=\"selectAllRecord()\" class=\"checkbox default\"></div>\n                  <div *ngIf=\"selectAll\" (click)=\"selectAllRecord()\" class=\"checkbox active\">&#10004;</div>\n                </div>\n              </div>\n            </div>\n          </ng-container>\n\n          <!--Filter datagrid start-->\n\n          <ng-container *ngIf=\"enabledatafilter ? true : false\">\n            <ng-container *ngFor=\"let cols of columns\">\n              <ng-container *ngIf=\"!cols.hidden\">\n                <div class=\"datatable-col col-group\" [style.width.%]=\"cols.width\">\n                  <data-grid-filter (onFilterClick)=\"getFilterClick($event)\" [column]=\"cols\" (filterObject)=\"getFilteredData($event)\">\n                  </data-grid-filter>\n                </div>\n              </ng-container>\n            </ng-container>\n          </ng-container>\n\n        </div>\n      </ng-container>\n\n      <!--Filter datagrid start-->\n      <ng-container *ngIf=\"globalfilter ? true : false\">\n        <div class=\"datatable datatable-row\">\n          <ng-container class=\"datatable datatable-column\">\n            <div class=\"inputgroup\" style=\"padding-left: 1%; padding-right: 1%\">\n              <input type=\"text\" tabindex=\"1\" [(ngModel)]=\"filterValue\" (keyup)=\"keyUpSearch($event)\" type=\"text\" class=\"input-control\"\n                aria-label=\"Text input with dropdown button\">\n              <span tabindex=\"1\" (keyup.enter)=\"onFilterIconClick($event)\" class=\"datatable-filter-icon\">\n                <amexio-c-icon key=\"datagrid_filter\" (click)=\"onFilterIconClick($event)\"></amexio-c-icon>\n              </span>\n              <span *ngIf=\"showToolTip\" class=\"dropdown\" style=\"width: 250px; right: 0\">\n                <ul class=\"dropdown-list\" *ngFor=\"let opt of globalFilterOptions;  let i = index\">\n                  <li #listId id={{i}} (keyup.enter)=\"selectedOption(opt)\" (keyup.arrowup)=\"onArrowUpGlobalList(listId.id)\"\n                    (keyup.arrowdown)=\"onArrowdownGlobalList(listId.id)\" role=\"option\" tabindex=\"1\" class=\"list-items\">\n                    <div (click)=\"selectedOption(opt)\">\n                      {{opt.key}}&nbsp;\n                      <i [class]=\"opt.checkedStatus\" aria-hidden=\"true\"></i>\n                    </div>\n                  </li>\n                </ul>\n              </span>\n            </div>\n          </ng-container>\n        </div>\n      </ng-container>\n\n      <ng-container *ngIf=\"enablecolumnfilter ? true : false\">\n        <span *ngIf=\"showEnableColumnFilter\" class=\"dropdown dropdown-right\" [ngStyle]=\"{'top': globalfilter || enabledatafilter ? '10%':''}\"\n          style=\"width: 250px;\">\n          <ul role=\"listbox\" class=\"dropdown-list\">\n            <li #listId id={{i}} (keyup.arrowup)=\"onArrowUpList(listId.id)\" (keyup.arrowdown)=\"onArrowdownList(listId.id)\"\n              role=\"option\" tabindex=\"1\" class=\"list-items\" *ngFor=\"let cols of columns;let i = index;\">\n              <div [attr.aria-checked]=\"!cols.hidden\">\n                <input tabindex=\"1\" role=\"checkbox\" id=\"{{componentId}}\" type=\"checkbox\" [attr.checked]=\"!cols.hidden ? true: null\"\n                  (click)=\"onColumnCheck(cols)\" (keyup.enter)=\"onColumnCheck(cols)\" />\n                <label>{{cols.text}}</label>\n              </div>\n            </li>\n          </ul>\n        </span>\n      </ng-container>\n\n      <ng-container *ngIf=\"groupby ? true : false\">\n        <span *ngIf=\"showGroupByColumn\" class=\"dropdown dropdown-right\" style=\"width: 250px;\">\n          <ul class=\"dropdown-list\">\n            <li #listId id={{i}} (keyup.arrowup)=\"onArrowUpList(listId.id)\" (keyup.arrowdown)=\"onArrowdownList(listId.id)\"\n              role=\"option\" tabindex=\"1\" class=\"list-items\" *ngFor=\"let cols of columns;let i = index;\" (click)=\"showGroupByColumn = !showGroupByColumn\">\n              <div (click)=\"setGroupByColumn(cols)\">\n                <label>{{cols.text}}</label>\n              </div>\n            </li>\n          </ul>\n        </span>\n      </ng-container>\n    </div>\n\n    <!--Checkbox datagrid with datatypes condition start-->\n    <ng-container *ngIf=\"enableHeader\">\n      <div class=\"datatable\" role=\"grid\" attr.aria-labelledby=\"{{gridId}}\">\n        <div class=\"datatable-header\">\n          <ng-container *ngIf=\"enablecheckbox\">\n            <div class=\"datatable-col datatable-checkbox-width checkbox-col\">\n              <div class=\"inputgroup\">\n                <div class=\"input-box\">\n                  <div *ngIf=\"!selectAll\" (click)=\"selectAllRecord()\" class=\"checkbox default\"></div>\n                  <div *ngIf=\"selectAll\" (click)=\"selectAllRecord()\" class=\"checkbox active\">&#10004;</div>\n                </div>\n              </div>\n            </div>\n          </ng-container>\n          <!--datagrid start unhidden-->\n          <ng-container *ngFor=\"let cols of columns\">\n            <ng-container *ngIf=\"!cols.hidden\">\n              <ng-container *ngIf=\"(cols.datatype=='string' || cols.datatype == 'boolean')\">\n                <!-- -------------------- -->\n                <div class=\"datatable-col\" tabindex=\"1\" [style.width.%]=\"cols.width\" (click)=\"sortOnColHeaderClick(cols, $event)\"\n                  (keyup.enter)=\"sortOnColHeaderClick(cols, $event)\">\n\n                  <ng-container *ngIf=\"cols.headerTemplate\">\n                    <ng-template [ngTemplateOutlet]=\"cols.headerTemplate\" [ngTemplateOutletContext]=\"{column:cols ,index: i}\"></ng-template>\n                  </ng-container>\n                  <ng-container *ngIf=\"!cols.headerTemplate\">\n                    {{cols.text}} &nbsp;\n\n                  </ng-container>\n                  <ng-container *ngIf=\"this.sortBy==1   && cols.isColumnSort\">\n                    <amexio-c-icon key=\"datagrid_arrowup\"></amexio-c-icon>\n                    <!--&nbsp; <i class=\"fa fa-arrow-up\"></i>-->\n                  </ng-container>\n                  <ng-container *ngIf=\"this.sortBy==2  && cols.isColumnSort\">\n                    <!--&nbsp;<i class=\"fa fa-arrow-down\"></i>-->\n                    <amexio-c-icon key=\"datagrid_arrowdown\"></amexio-c-icon>\n                  </ng-container>\n                </div>\n              </ng-container>\n              <ng-container *ngIf=\"cols.datatype=='number'\">\n                <div class=\"datatable-col\" tabindex=\"1\" [style.width.%]=\"cols.width\" (keyup.enter)=\"sortOnColHeaderClick(cols, $event)\"\n                  (click)=\"sortOnColHeaderClick(cols, $event)\">\n                  <ng-container *ngIf=\"cols.headerTemplate\">\n                    <ng-template [ngTemplateOutlet]=\"cols.headerTemplate\" [ngTemplateOutletContext]=\"{column:cols ,index: i}\"></ng-template>\n                  </ng-container>\n                  <ng-container *ngIf=\"!cols.headerTemplate\">\n                    <span class=\"float-right\">\n                      {{cols.text}} &nbsp;\n                      <ng-container *ngIf=\"this.sortBy==1 && cols.isColumnSort\">\n                        <amexio-c-icon key=\"datagrid_arrowup\"></amexio-c-icon>\n                        <!--&nbsp; <i class=\"fa fa-arrow-up\"></i>-->\n                      </ng-container>\n                      <ng-container *ngIf=\"this.sortBy==2 && cols.isColumnSort\">\n                        <!--&nbsp;<i class=\"fa fa-arrow-down\"></i>-->\n                        <amexio-c-icon key=\"datagrid_arrowdown\"></amexio-c-icon>\n                      </ng-container>\n                    </span>\n                  </ng-container>\n                </div>\n              </ng-container>\n            </ng-container>\n          </ng-container>\n        </div>\n      </div>\n    </ng-container>\n\n    <!--Group BY datagrid start-->\n    <ng-container *ngIf=\"!groupby\">\n      <div class=\"datatable-height\" [style.height.px]=\"height\">\n        <div class=\"datatable\" role=\"grid\">\n          <div style=\"height: 300px;\" *ngIf=\"mask\">\n            <div class=\"spinner\"></div>\n          </div>\n          <ng-container *ngIf=\"!mask\">\n            <div #id class=\"datatable-row\" *ngFor=\"let row of viewRows;let i=index\" id=\"{{'row'+i}}\" [ngClass]=\"{'datatable-row-active':row.isSelected}\"\n              (click)=\"onRowClick(row, i)\">\n\n              <ng-container *ngIf=\"enablecheckbox\">\n                <div class=\"datatable-col datatable-checkbox-width checkbox-col\">\n                  <div class=\"inputgroup\">\n                    <div class=\"input-box\">\n                      <div (click)=\"setSelectedRow(row, check)\" [class]=\"checkBoxSelectClass\" #check>\n                        {{((checkBoxSelectClass == 'checkbox active') && (check.classList.value == 'checkbox active')) ||\n                        ((checkBoxSelectClass ==\n                        'checkbox default') && (check.classList.value == 'checkbox active')) ? '&#10004;' : ''}}\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </ng-container>\n\n              <ng-container *ngFor=\"let cols of columns;let colIndex = index\">\n                <ng-container *ngIf=\"!cols.hidden\">\n                  <ng-container *ngIf=\"cols.datatype=='number'\">\n                    <div #ref id=\"{{title}}-{{i+1}}{{colIndex+1}}\" class=\"datatable-col\" [attr.tabindex]=\"(((i+1== 1) && (colIndex + 1 == firstIndex))? 1: tabindex)\"\n                      [style.width.%]=\"cols.width\" scope=\"row\" [attr.data-label]=\"cols.text\" (keyup.arrowright)=\"arrowRight(ref)\"\n                      (keyup.arrowleft)=\"arrowLeft(ref)\" (keyup.arrowdown)=\"arrowDown(ref)\" (keyup.arrowup)=\"arrowUp(ref)\"\n                      (keyup.end)=\"keyEnd(ref)\" (keyup.home)=\"keyHome(ref)\" (keyup.control.end)=\"keyControlEnd(ref)\"\n                      (keyup.control.home)=\"keyControlHome(ref)\" (keyup.pagedown)=\"onPageDownClick()\" (keyup.pageup)=\"onPageUpClick()\"\n                      (keyup.enter)=\"onRowClick(row, i)\" [style.width.%]=\"cols.width\" scope=\"row\" [attr.data-label]=\"cols.text\">\n                      <span class=\"float-right\">\n                        <ng-container *ngIf=\"row[cols.dataindex]!= '';else elseBlock\">\n                          <div (contextmenu)=\"loadContextMenu($event,row, cols, id)\">\n                            <amexio-display-field [data]=\"row\" [data-index]=\"cols.dataindex\"></amexio-display-field>\n                          </div>\n                        </ng-container>\n                        <ng-template #elseBlock>\n                          &nbsp;\n                        </ng-template>\n                      </span>\n                    </div>\n                  </ng-container>\n                  <ng-container *ngIf=\"!cols?.bodyTemplate && (cols.datatype == 'string' || cols.datatype == 'boolean')\">\n                    <div #ref id=\"{{title}}-{{i+1}}{{colIndex+1}}\" class=\"datatable-col\" [attr.tabindex]=\"(((i+1== 1) && (colIndex + 1 == firstIndex))? 1: tabindex)\"\n                      [style.width.%]=\"cols.width\" scope=\"row\" [attr.data-label]=\"cols.text\" (keyup.arrowright)=\"arrowRight(ref)\"\n                      (keyup.arrowleft)=\"arrowLeft(ref)\" (keyup.enter)=\"onRowClick(row, i)\" (keyup.arrowdown)=\"arrowDown(ref)\"\n                      (keyup.arrowup)=\"arrowUp(ref)\" (keyup.end)=\"keyEnd(ref)\" (keyup.home)=\"keyHome(ref)\"\n                      (keyup.control.end)=\"keyControlEnd()\" (keyup.control.home)=\"keyControlHome(ref)\" (keyup.pageup)=\"onPageUpClick()\"\n                      (keyup.pagedown)=\"onPageDownClick(ref)\">\n                      <!-- <ng-container *ngIf=\"(cols.datatype == 'boolean' ? true : row[cols.dataindex]!= null ? true : false);else elseBlock\"> -->\n                        <div (contextmenu)=\"loadContextMenu($event,row, cols, id)\">\n                          <amexio-display-field [data]=\"row\" [data-index]=\"cols.dataindex\"></amexio-display-field>\n                        </div>\n                      <!-- </ng-container> -->\n                      <ng-template #elseBlock>\n                        &nbsp;\n                      </ng-template>\n                    </div>\n                  </ng-container>\n                  <ng-container *ngIf=\"cols.bodyTemplate\">\n                    <div #ref id=\"{{title}}-{{i+1}}{{colIndex+1}}\" class=\"datatable-col\" [attr.tabindex]=\"(((i+1== 1) && (colIndex + 1 == firstIndex))? 1: tabindex)\"\n                      [style.width.%]=\"cols.width\" scope=\"row\" [attr.data-label]=\"cols.text\" (keyup.arrowright)=\"arrowRight(ref)\"\n                      (keyup.arrowleft)=\"arrowLeft(ref)\" (keyup.arrowdown)=\"arrowDown(ref)\" (keyup.arrowup)=\"arrowUp(ref)\"\n                      (keyup.end)=\"keyEnd(ref)\" (keyup.home)=\"keyHome(ref)\" (keyup.control.end)=\"keyControlEnd()\"\n                      (keyup.control.home)=\"keyControlHome(ref)\" (keyup.pagedown)=\"onPageDownClick(ref)\" (keyup.pageup)=\"onPageUpClick()\"\n                      class=\"datatable-col\" [style.width.%]=\"cols.width\" scope=\"row\" [attr.data-label]=\"cols.text\">\n                      <ng-template [ngTemplateOutlet]=\"cols.bodyTemplate\" [ngTemplateOutletContext]=\"{ $implicit: { text : row[cols.dataindex] }, row: row }\"></ng-template>\n                    </div>\n                  </ng-container>\n                </ng-container>\n\n              </ng-container>\n            </div>\n          </ng-container>\n\n        </div>\n      </div>\n\n    </ng-container>\n\n    <!--Group BY datagrid end-->\n\n    <!--Group BY and Filter Data datagrid start-->\n    <ng-container *ngIf=\"groupby && !enabledatafilter\">\n      <div class=\"datatable-height\" [style.height.px]=\"height\">\n        <div class=\"datatable\" role=\"grid\" style=\"table-layout: inherit !important;\">\n          <div style=\"height: 300px;\" *ngIf=\"mask\">\n            <div class=\"spinner\"></div>\n          </div>\n          <ng-container *ngIf=\"!mask\">\n            <div class=\"datatable-row\" *ngFor=\"let row of viewRows;let i=index\" id=\"{{'row'+i}}\" [ngClass]=\"{'datatable-row-active':row.isSelected}\"\n              (click)=\"toogle(row, i)\">\n              <ng-container *ngIf=\"enablecheckbox\">\n                <div class=\"datatable-col datatable-checkbox-width checkbox-col\">\n                  <div class=\"inputgroup\">\n                    <div class=\"input-box\">\n                      <div (click)=\"selectParent(row)\" [class]=\"row.isSelected ?'checkbox active':'checkbox default'\">\n                        {{row.isSelected ? '&#10004;' : ''}}\n                      </div>\n                    </div>\n                  </div>\n                </div>\n              </ng-container>\n              <ng-container *ngFor=\"let cols of columns;let colIndex = index\">\n                <ng-container *ngIf=\"isGroupChecking(row)\">\n\n                  <ng-container *ngIf=\"colIndex == 0\">\n                    <div #grpref class=\"datatable-col col-group\" class=\"datatable-col col-group\" id=\"{{title}}-{{i+1}}{{colIndex+1}}\"\n                      tabindex=\"1\" (keyup.arrowdown)=\"arrowDown(grpref)\" (keyup.arrowup)=\"arrowUp(grpref)\"\n                      (keyup.control.end)=\"findContolEndGrpBy()\" (keyup.control.home)=\"keyControlHome()\" (keyup.enter)=\"toogle(row, i)\">\n                      <!--<i *ngIf=\"!row.expanded\" class=\"fa fa-caret-right\" aria-hidden=\"true\" (click)=\"toogle(row,i)\"></i>-->\n                      <ng-container *ngIf=\"!row.expanded\">\n                        <amexio-c-icon key=\"datagrid_expand\"></amexio-c-icon>\n                      </ng-container>\n                      <ng-container *ngIf=\"row.expanded\">\n                        <amexio-c-icon key=\"datagrid_collapse\"></amexio-c-icon>\n                      </ng-container>\n                      {{row.group}}\n                    </div>\n                  </ng-container>\n\n                  <ng-container *ngIf=\"colIndex != 0\">\n                    <div class=\"datatable-col col-hidden\">\n                    </div>\n                  </ng-container>\n                </ng-container>\n                <ng-container *ngIf=\"!isGroupChecking(row)\">\n                  <ng-container *ngIf=\"cols.datatype=='string' || cols.datatype == 'boolean'\">\n                    <div #grpref id=\"{{title}}-{{i+1}}{{colIndex+1}}\" (keyup.arrowdown)=\"arrowDown(grpref)\" (keyup.arrowup)=\"arrowUp(grpref)\"\n                      (keyup.arrowright)=\"arrowRight(grpref)\" (keyup.arrowleft)=\"arrowLeft(grpref)\" (keyup.end)=\"keyEnd(grpref)\"\n                      (keyup.home)=\"keyHome(grpref)\" (keyup.control.end)=\"findContolEndGrpBy()\" (keyup.control.home)=\"keyControlHome()\"\n                      class=\"datatable-col\" tabindex=\"1\" [style.width.%]=\"cols.width\" [attr.data-label]=\"cols.text\">\n                      <ng-container *ngIf=\"colIndex == 0\">\n                        <span style=\"padding-left: 20px\">\n                          <amexio-display-field [data]=\"row\" [data-index]=\"cols.dataindex\"></amexio-display-field>\n                        </span>\n                      </ng-container>\n                      <ng-container *ngIf=\"colIndex != 0\">\n                        <amexio-display-field [data]=\"row\" [data-index]=\"cols.dataindex\"></amexio-display-field>\n                      </ng-container>\n                    </div>\n                  </ng-container>\n                  <ng-container *ngIf=\"cols.datatype=='number'\">\n\n                    <div #grpref id=\"{{title}}-{{i+1}}{{colIndex+1}}\" (keyup.arrowdown)=\"arrowDown(grpref)\" (keyup.arrowup)=\"arrowUp(grpref)\"\n                      (keyup.arrowright)=\"arrowRight(grpref)\" (keyup.arrowleft)=\"arrowLeft(grpref)\" (keyup.end)=\"keyEnd(grpref)\"\n                      (keyup.home)=\"keyHome(grpref)\" (keyup.control.end)=\"findContolEndGrpBy()\" (keyup.control.home)=\"keyControlHome()\"\n                      class=\"datatable-col\" tabindex=\"1\" [style.width.%]=\"cols.width\" [attr.data-label]=\"cols.text\">\n\n                      <ng-container *ngIf=\"colIndex == 0\">\n                        <span style=\"padding-left: 20px\">\n                          <ng-container *ngIf=\"row[cols.dataindex]!= '' ;else elseBlock\">\n                            <amexio-display-field [data]=\"row\" [data-index]=\"cols.dataindex\"></amexio-display-field>\n                          </ng-container>\n                          <ng-template #elseBlock>\n                            &nbsp;\n                          </ng-template>\n\n                        </span>\n                      </ng-container>\n                      <ng-container *ngIf=\"colIndex != 0\">\n                        <span class=\"float-right\">\n                          <ng-container *ngIf=\"row[cols.dataindex]!= '' ;else elseBlock\">\n                            <amexio-display-field [data]=\"row\" [data-index]=\"cols.dataindex\"></amexio-display-field>\n                          </ng-container>\n                          <ng-template #elseBlock>\n                            &nbsp;\n                          </ng-template>\n                        </span>\n                      </ng-container>\n\n                    </div>\n\n                  </ng-container>\n\n                </ng-container>\n              </ng-container>\n            </div>\n          </ng-container>\n\n        </div>\n      </div>\n    </ng-container>\n    <!--Group BY and Filter Data datagrid end-->\n\n    <!-- Context Menu  -->\n    <!-- <span [ngStyle]=\"contextStyle\">\n        <ul *ngIf=\"flag\" class=\"context-menu-list\" [ngClass]=\"{'dropdown-up' : posixUp}\">\n            <li (click)=\"onContextNodeClick(itemConfig)\" class=\"context-menu-list-items\" [ngStyle]=\"{'cursor': itemConfig.disabled ? 'not-allowed':'pointer'}\"\n                [ngClass]=\"{'context-menu-separator':itemConfig.seperator}\" *ngFor=\"let itemConfig of tempContextMenu\">\n                <i [ngStyle]=\"{'padding-left': itemConfig.icon ? '5px':'22px'}\" [ngClass]=\"itemConfig.icon\"></i>\n                <span style=\"white-space: nowrap;display: inline ; padding-left:10px\">\n                    {{itemConfig.text}}\n                </span>\n            </li>\n        </ul>\n    </span> -->\n\n    <ng-container *ngIf=\"flag\">\n      <base-contextmenu [base-context-menu]=\"contextmenu\" [mouse-location-top]=\"mouseLocation.top\" [mouse-location-left]=\"mouseLocation.left\"\n        [is-FlagShow]=\"flag\" [right-click-data]=\"rightClickRowData\" (onRightClick)=\"rightClickDataEmit($event)\"\n        [position-up]=\"posixUp\">\n      </base-contextmenu>\n    </ng-container>\n\n    <!-- Footer of the grid -->\n    <div class=\"footer\">\n      <ng-container *ngIf=\"(pagesize && (data && data.length > pagesize)) || (serverSidePaging && totalPages)\">\n        <amexio-paginator #pageId [server-side-paging]=\"serverSidePaging\" [pages]=\"totalPages\" [rows]=\"pagesize\"\n          (onPageChange)=\"loadPageData($event)\"></amexio-paginator>\n      </ng-container>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioDatagridComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: CommonDataService },
        { type: i0.ChangeDetectorRef },
        { type: i0.Renderer2 }
    ]; };
    AmexioDatagridComponent.propDecorators = {
        title: [{ type: i0.Input }],
        pagesize: [{ type: i0.Input, args: ['page-size',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        enablecheckbox: [{ type: i0.Input, args: ['enable-checkbox',] }],
        data: [{ type: i0.Input, args: ['data',] }],
        rowSelect: [{ type: i0.Output }],
        selectedRowData: [{ type: i0.Output }],
        onHeaderClick: [{ type: i0.Output }],
        height: [{ type: i0.Input }],
        groupby: [{ type: i0.Input }],
        groupbydataindex: [{ type: i0.Input, args: ['groupby-data-index',] }],
        enabledatafilter: [{ type: i0.Input, args: ['enable-data-filter',] }],
        cclass: [{ type: i0.Input, args: ['c-class',] }],
        tableHeadercclass: [{ type: i0.Input }],
        tableTitlecclass: [{ type: i0.Input }],
        tableDatacclass: [{ type: i0.Input }],
        selectedrowcolor: [{ type: i0.Input, args: ['selected-row-color',] }],
        totalDataCount: [{ type: i0.Input, args: ['total-data-count',] }],
        serverSidePaging: [{ type: i0.Input, args: ['server-side-paging',] }],
        columndefintion: [{ type: i0.Input, args: ['column-defintion',] }],
        enablecolumnfiter: [{ type: i0.Input, args: ['enable-column-fiter',] }],
        enablecolumnfilter: [{ type: i0.Input, args: ['enable-column-filter',] }],
        globalfilter: [{ type: i0.Input, args: ['global-filter',] }],
        contextmenu: [{ type: i0.Input, args: ['context-menu',] }],
        rightClick: [{ type: i0.Output }],
        onPageChange: [{ type: i0.Output }],
        filterRef: [{ type: i0.ViewChildren, args: [DataGridFilterComponent,] }],
        columnRef: [{ type: i0.ContentChildren, args: [AmexioGridColumnComponent,] }],
        pageId: [{ type: i0.ViewChild, args: ['pageId',] }]
    };
    return AmexioDatagridComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*/
var AmexioDataGridHeaderComponent = /** @class */ (function () {
    function AmexioDataGridHeaderComponent() {
    }
    /**
     * @return {?}
     */
    AmexioDataGridHeaderComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioDataGridHeaderComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-datagrid-header', template: "\n    <ng-content></ng-content>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioDataGridHeaderComponent.ctorParameters = function () { return []; };
    AmexioDataGridHeaderComponent.propDecorators = {
        padding: [{ type: i0.Input }]
    };
    return AmexioDataGridHeaderComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var GoogleMapScriptService = /** @class */ (function () {
    function GoogleMapScriptService() {
    }
    /**
     * @param {?} id
     * @return {?}
     */
    GoogleMapScriptService.prototype.loadScript = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        var /** @type {?} */ script = document.createElement('script');
        script.innerHTML = '';
        script.src = 'https://maps.google.com/maps/api/js?key=' + id;
        script.async = true;
        script.defer = true;
        return script;
    };
    // THIS METHOD IS USED FOR CHEKING SCIRPT IS PRESENT IN BODY OT NOT
    /**
     * @param {?} script
     * @return {?}
     */
    GoogleMapScriptService.prototype.isScriptAlreadyPresent = /**
     * @param {?} script
     * @return {?}
     */
    function (script) {
        var /** @type {?} */ scripts = document.getElementsByTagName('script');
        var /** @type {?} */ isScriptLoaded;
        // tslint:disable-next-line:prefer-for-of
        for (var /** @type {?} */ i = 0; i < scripts.length; i++) {
            var /** @type {?} */ scriptData = scripts[i];
            if (scriptData.src === script) {
                isScriptLoaded = true;
            }
        }
        return isScriptLoaded;
    };
    GoogleMapScriptService.decorators = [
        { type: i0.Injectable },
    ];
    return GoogleMapScriptService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var GOOGLEMAP_CONSTANT = {
    GOOGLE_MAP_URL: 'https://maps.google.com/maps/api/js?key=',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioGoogleMapComponent = /** @class */ (function () {
    function AmexioGoogleMapComponent(el, differs, _loadGoogleMapService) {
        this.el = el;
        this._loadGoogleMapService = _loadGoogleMapService;
        this.height = '250px';
        this.minheight = '250px';
        this.width = '100%';
        this.initiallat = 51.507351;
        this.initiallng = -0.127758;
        this.initialzoomlevel = 2;
        this.stockColor = '#FF0000';
        this.fillColor = '#f5f5f5';
        this.fillOpacity = 0.45;
        this.strokeOpacity = 0.6;
        this.onMarkerClick = new i0.EventEmitter();
        this.onReady = new i0.EventEmitter();
        this.differ = differs.find([]).create(null);
    }
    Object.defineProperty(AmexioGoogleMapComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v) {
                this._data = v;
                this.initalize();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioGoogleMapComponent.prototype, "coordinates", {
        get: /**
         * @return {?}
         */
        function () {
            return this._coordinates;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v) {
                this._coordinates = v;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioGoogleMapComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.componentId = +Math.floor(Math.random() * 90000) + 10000 + 'google';
        if (this.googlemapkey) {
            var /** @type {?} */ fullScriptTag = GOOGLEMAP_CONSTANT.GOOGLE_MAP_URL + this.googlemapkey;
            var /** @type {?} */ isScriptPresent = this._loadGoogleMapService.isScriptAlreadyPresent(fullScriptTag);
            var /** @type {?} */ options = {
                center: { lat: this.initiallat, lng: this.initiallng },
                zoom: this.initialzoomlevel,
            };
            if (!isScriptPresent) {
                var /** @type {?} */ script = this._loadGoogleMapService.loadScript(this.googlemapkey);
                this.loadScriptWithMap(script, options);
            }
            else {
                this.loadMap(options);
            }
        }
    };
    /**
     * @param {?} script
     * @param {?} options
     * @return {?}
     */
    AmexioGoogleMapComponent.prototype.loadScriptWithMap = /**
     * @param {?} script
     * @param {?} options
     * @return {?}
     */
    function (script, options) {
        var _this = this;
        if (script != null) {
            var /** @type {?} */ body = /** @type {?} */ (document.body);
            script.onload = function () {
                _this.loadMap(options);
            };
            body.appendChild(script);
        }
        else {
            this.loadMap(options);
        }
    };
    /**
     * @param {?} options
     * @return {?}
     */
    AmexioGoogleMapComponent.prototype.loadMap = /**
     * @param {?} options
     * @return {?}
     */
    function (options) {
        this.map = new google.maps.Map(this.el.nativeElement.children[0], options);
        this.onReady.emit({
            map: this.map,
        });
        if (!this.map && this.el.nativeElement.offsetParent) {
            this.infoWindow = new google.maps.InfoWindow();
        }
        this.initalize();
    };
    // INITALIZATION OF DATA AND SEND DATA TO MAP
    /**
     * @return {?}
     */
    AmexioGoogleMapComponent.prototype.initalize = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ flightPlanCoordinates = this.getCoordinates();
        if (flightPlanCoordinates && flightPlanCoordinates.length > 0) {
            var /** @type {?} */ flightPath = new google.maps.Polygon({
                paths: flightPlanCoordinates,
                strokeColor: this.stockColor,
                strokeOpacity: this.strokeOpacity,
                strokeWeight: 2,
                fillColor: this.fillColor,
                fillOpacity: this.fillOpacity,
            });
            flightPath.setMap(this.map);
        }
        if (this.data && this.map) {
            this.localoverlays = [];
            for (var _i = 0, _a = this.data; _i < _a.length; _i++) {
                var overlay = _a[_i];
                this.localoverlays.push(new google.maps.Marker({
                    position: { lat: overlay.lat, lng: overlay.lng },
                    icon: overlay.icon,
                    title: overlay.title,
                    data: overlay.data,
                }));
            }
            for (var _b = 0, _c = this.localoverlays; _b < _c.length; _b++) {
                var overlay = _c[_b];
                overlay.setMap(this.map);
                this.bindOverlayEvents(overlay);
            }
        }
        var /** @type {?} */ changes = this.differ.diff(this.localoverlays);
        if (changes && this.map) {
            changes.forEachRemovedItem(function (record) {
                google.maps.event.clearInstanceListeners(record.item);
                record.item.setMap(null);
            });
        }
    };
    /**
     * @param {?} overlay
     * @return {?}
     */
    AmexioGoogleMapComponent.prototype.bindOverlayEvents = /**
     * @param {?} overlay
     * @return {?}
     */
    function (overlay) {
        var _this = this;
        overlay.addListener('click', function (event) {
            _this.onMarkerClick.emit(overlay.data);
            if (overlay && overlay.title) {
                _this.infoWindow.setContent('<div>' + overlay.title + '</div>');
                _this.infoWindow.open(_this.map, overlay);
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioGoogleMapComponent.prototype.getMap = /**
     * @return {?}
     */
    function () {
        return this.map;
    };
    // TO GET COORDINATES
    /**
     * @return {?}
     */
    AmexioGoogleMapComponent.prototype.getCoordinates = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ flightPlanCoordinates = [];
        if (this._coordinates && this._coordinates.length > 0) {
            for (var _i = 0, _a = this._coordinates; _i < _a.length; _i++) {
                var co = _a[_i];
                var /** @type {?} */ str = co.split(' ', 2);
                if (str && str.length === 2) {
                    flightPlanCoordinates.push({
                        lat: parseFloat(str[0]),
                        lng: parseFloat(str[1]),
                    });
                }
                else {
                    console.log('Wrong Lat-Long format ' + co);
                }
            }
        }
        return flightPlanCoordinates;
    };
    AmexioGoogleMapComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-google-map',
                    template: "\n    <div [style.width]=\"width\" [style.height]=\"height\" [style.min-height]=\"minheight\"></div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioGoogleMapComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: i0.IterableDiffers },
        { type: GoogleMapScriptService }
    ]; };
    AmexioGoogleMapComponent.propDecorators = {
        googlemapkey: [{ type: i0.Input, args: ['google-map-key',] }],
        style: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        minheight: [{ type: i0.Input, args: ['min-height',] }],
        width: [{ type: i0.Input }],
        initiallat: [{ type: i0.Input, args: ['initial-lat',] }],
        initiallng: [{ type: i0.Input, args: ['initial-lng',] }],
        initialzoomlevel: [{ type: i0.Input, args: ['initial-zoom-level',] }],
        stockColor: [{ type: i0.Input, args: ['stroke-color',] }],
        fillColor: [{ type: i0.Input, args: ['fill-color',] }],
        fillOpacity: [{ type: i0.Input, args: ['fill-opacity',] }],
        strokeOpacity: [{ type: i0.Input, args: ['stroke-opacity',] }],
        onMarkerClick: [{ type: i0.Output }],
        onReady: [{ type: i0.Output }],
        data: [{ type: i0.Input, args: ['data',] }],
        coordinates: [{ type: i0.Input, args: ['co-ordinates',] }]
    };
    return AmexioGoogleMapComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioItemSelectorComponent = /** @class */ (function () {
    function AmexioItemSelectorComponent(itemSelectorService) {
        this.itemSelectorService = itemSelectorService;
        this.mask = true;
        /*
           Properties
           name : enable-drop
           datatype : boolean
           version : 5.0.0 onwards
           default : false
           description : any node can be dropped in the selector structure
           */
        this.enabledrop = false;
        /*
           Properties
           name : across-itemselector
           datatype : boolean
           version : 5.0.0 onwards
           default : false
           description : Dragging and dropping is possible across list.
           */
        this.acrossitemselector = false;
        /*
           Events
           name : availableRecords
           datatype : none
           version : none
           default : none
           description :  Get available values objects.
           */
        this.availableRecords = new i0.EventEmitter();
        /*
           Events
           name : selectedRecords
           datatype : none
           version : none
           default : none
           description :  Get selected value Object.
           */
        this.selectedRecords = new i0.EventEmitter();
        this.onDrag = new i0.EventEmitter();
        this.dragover = new i0.EventEmitter();
        this.selectedData = [];
        this.leftactive = true;
        this.rightactive = true;
    }
    Object.defineProperty(AmexioItemSelectorComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.httpmethod && this.httpurl) {
            this.itemSelectorService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.response = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.response);
            });
        }
        else if (this.data) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    };
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (JSON.stringify(this.previousValue) !== JSON.stringify(this.data)) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
            responsedata.forEach(function (option, index) {
                if (!option['isSelected']) {
                    option['isSelected'] = false;
                }
            });
        }
        else {
            responsedata = httpResponse;
        }
        this.availableData = responsedata;
        this.generateIndex(this.availableData);
        this.mask = false;
    };
    /**
     * @param {?} getAvailableData
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.generateIndex = /**
     * @param {?} getAvailableData
     * @return {?}
     */
    function (getAvailableData) {
        if (getAvailableData) {
            getAvailableData.forEach(function (element, index) {
                element['id'] = 'itemselector' + Math.floor(Math.random() * 10000 + 99999);
            });
        }
    };
    /**
     * @param {?} data
     * @param {?} index
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.itemClick = /**
     * @param {?} data
     * @param {?} index
     * @param {?} left
     * @param {?} right
     * @return {?}
     */
    function (data, index, left, right) {
        this.leftactive = left;
        this.rightactive = right;
        this.switchingObject = data;
        this.objectIndex = index;
        for (var _i = 0, _a = this.availableData; _i < _a.length; _i++) {
            var ir = _a[_i];
            if ((ir)[this.valuefield] === data[this.valuefield]) {
                ir['isSelected'] = true;
            }
            else {
                ir['isSelected'] = false;
            }
        }
        if (right) {
            for (var _b = 0, _c = this.selectedData; _b < _c.length; _b++) {
                var ir = _c[_b];
                if ((ir)[this.valuefield] === data[this.valuefield]) {
                    ir['selectedClick'] = true;
                }
                else {
                    ir['selectedClick'] = false;
                }
            }
        }
    };
    /**
     * @param {?} dragData
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.dataFormLeftToRightMove = /**
     * @param {?} dragData
     * @return {?}
     */
    function (dragData) {
        this.itemClick(dragData.data, dragData.index, true, false);
        var /** @type {?} */ currentNode;
        if (this.availableData && this.availableData.length !== 1) {
            this.availableData.forEach(function (element, index) {
                if (element.id && dragData.data.id) {
                    if (element.id === dragData.data.id) {
                        currentNode = index - 1;
                    }
                    if (index === 0) {
                        currentNode = index + 1;
                    }
                }
            });
            var /** @type {?} */ focusId = (this.availableData[currentNode]);
            document.getElementById(focusId['id']).focus();
        }
        this.rightSwitch();
    };
    /**
     * @param {?} focus
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.enterFocus = /**
     * @param {?} focus
     * @return {?}
     */
    function (focus) {
        this.itemClick(focus.data, focus.index, false, true);
    };
    /**
     * @param {?} dragData
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.shiftFocusMethod = /**
     * @param {?} dragData
     * @return {?}
     */
    function (dragData) {
        var /** @type {?} */ currentIndex;
        if (this.selectedData && this.selectedData.length > 0) {
            this.selectedData.forEach(function (element, index) {
                if (element.id === dragData.data.id) {
                    currentIndex = index - 1;
                }
                if (index === 0) {
                    currentIndex = index + 1;
                }
            });
        }
        var /** @type {?} */ focusId = (this.selectedData[currentIndex]);
        document.getElementById(focusId['id']).focus();
    };
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.downArrowPress = /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    function (event, index) {
        if (this.availableData[index] === 0) {
            this.focusDetectionOnAvailableData(event, index);
        }
        else {
            var /** @type {?} */ nextitem = this.availableData[index + 1];
            document.getElementById(nextitem['id']).focus();
        }
    };
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.upArrowPress = /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    function (event, index) {
        if (this.availableData[index] === 0) {
            this.focusDetectionOnAvailableData(event, index);
        }
        else {
            var /** @type {?} */ nextitem = this.availableData[index - 1];
            document.getElementById(nextitem['id']).focus();
        }
    };
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.downSwitchOnTab = /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    function (event, index) {
        if (this.selectedData[index] === 0) {
            this.focusDetectionOnSelected(event, index);
        }
        else {
            var /** @type {?} */ nextitem = this.selectedData[index + 1];
            document.getElementById(nextitem['id']).focus();
        }
    };
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.upSwitchOnTab = /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    function (event, index) {
        if (this.selectedData[index] === 0) {
            this.focusDetectionOnSelected(event, index);
        }
        else {
            var /** @type {?} */ nextitem = this.selectedData[index - 1];
            document.getElementById(nextitem['id']).focus();
        }
    };
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.focusDetectionOnAvailableData = /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    function (event, index) {
        var /** @type {?} */ nextitem = this.availableData[0];
        document.getElementById(nextitem['id']).focus();
    };
    /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.focusDetectionOnSelected = /**
     * @param {?} event
     * @param {?} index
     * @return {?}
     */
    function (event, index) {
        var /** @type {?} */ nextitem = this.selectedData[0];
        document.getElementById(nextitem['id']).focus();
    };
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.rightSwitch = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.selectedData.forEach(function (element) {
            _this.dragDropValidation(element);
        });
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.selectedData.push(this.switchingObject);
            this.selectedData[0]['selectedClick'] = true;
            this.switchingObject['isSelected'] = true;
            this.availableData.forEach(function (option, index) {
                if (option['isSelected']) {
                    _this.availableData.splice(index, 1);
                    option['selectedClick'] = false;
                }
            });
            this.switchingObject = null;
            this.dataEmitter();
        }
    };
    /**
     * @param {?} element
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.dragDropValidation = /**
     * @param {?} element
     * @return {?}
     */
    function (element) {
        if (this.switchingObject === element) {
            this.switchingObject.isSelected = false;
        }
    };
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.leftSwitch = /**
     * @return {?}
     */
    function () {
        this.setLeftSwitch();
    };
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.setLeftSwitch = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ flag = false;
        this.availableData.forEach(function (element) {
            _this.dragDropValidation(element);
        });
        if (!flag && this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.availableData.push(this.switchingObject);
            this.switchingObject['isSelected'] = false;
            this.selectedData.forEach(function (option, index) {
                if (!option['isSelected']) {
                    _this.selectedData.splice(index, 1);
                }
            });
            this.switchingObject = null;
            this.dataEmitter();
        }
    };
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.upSwitch = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.selectedData.forEach(function (opt, i) {
                _this.getIndexObject(opt, i);
            });
            if (this.objectIndex !== 0) {
                var /** @type {?} */ index = this.selectedData[this.objectIndex];
                this.selectedData[this.objectIndex] = this.selectedData[this.objectIndex - 1];
                this.selectedData[this.objectIndex - 1] = index;
                this.dataEmitter();
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.downSwitch = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected') && this.switchingObject['isSelected']) {
            this.selectedData.forEach(function (opt, i) {
                _this.getIndexObject(opt, i);
            });
            if (this.selectedData.length - 1 !== this.objectIndex) {
                var /** @type {?} */ index = this.selectedData[this.objectIndex];
                this.selectedData[this.objectIndex] = this.selectedData[this.objectIndex + 1];
                this.selectedData[this.objectIndex + 1] = index;
                this.dataEmitter();
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.moveTop = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ tempArray = [];
        if (this.switchingObject != null && this.switchingObject['isSelected']) {
            this.selectedData.forEach(function (opt, i) {
                _this.getIndexObject(opt, i);
            });
            if (this.selectedData.length > 1) {
                tempArray[0] = this.selectedData[this.objectIndex];
                this.selectedData.splice(this.objectIndex, 1);
                this.selectedData.forEach(function (option) {
                    tempArray.push(option);
                });
                this.selectedData = tempArray;
                this.dataEmitter();
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.moveBottom = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.switchingObject != null && this.switchingObject.hasOwnProperty('isSelected')) {
            this.selectedData.forEach(function (opt, i) {
                _this.getIndexObject(opt, i);
            });
            if (this.switchingObject['isSelected'] && this.selectedData.length > 1) {
                this.selectedData.splice(this.objectIndex, 1);
                this.selectedData[this.selectedData.length] = this.switchingObject;
            }
        }
        this.dataEmitter();
    };
    /**
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.dataEmitter = /**
     * @return {?}
     */
    function () {
        this.availableRecords.emit(this.availableData);
        this.selectedRecords.emit(this.selectedData);
    };
    /**
     * @param {?} opt
     * @param {?} i
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.getIndexObject = /**
     * @param {?} opt
     * @param {?} i
     * @return {?}
     */
    function (opt, i) {
        if (opt[this.valuefield] === this.switchingObject[this.valuefield]) {
            this.objectIndex = i;
        }
    };
    // Method to drag parent with node
    /**
     * @param {?} dragData
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.onDragStartLeft = /**
     * @param {?} dragData
     * @return {?}
     */
    function (dragData) {
        if (!this.acrossitemselector) {
            this.itemClick(dragData.data, dragData.index, true, false);
        }
        else {
            dragData.event.dataTransfer.setData('itemnodedata', JSON.stringify(dragData.data));
            this.onDrag.emit(dragData);
        }
    };
    /**
     * @param {?} dragData
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.onDragStartRight = /**
     * @param {?} dragData
     * @return {?}
     */
    function (dragData) {
        if (!this.acrossitemselector) {
            this.itemClick(dragData.data, dragData.index, false, true);
        }
        else {
            dragData.event.dataTransfer.setData('itemnodedata', JSON.stringify(dragData.data));
            this.onDrag.emit(dragData);
        }
    };
    /**
     * @param {?} dragOverData
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.allowDrop = /**
     * @param {?} dragOverData
     * @return {?}
     */
    function (dragOverData) {
        dragOverData.event.preventDefault();
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.dropRight = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.enabledrop) {
            this.rightSwitch();
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioItemSelectorComponent.prototype.dropLeft = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.enabledrop) {
            this.leftSwitch();
        }
    };
    AmexioItemSelectorComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-item-selector', template: "\n    <amexio-row>\n        <amexio-column [size]=\"'45pt'\">\n            <amexio-card [header]=\"true\">\n                <amexio-header>Available</amexio-header>\n                <amexio-body>\n                    <div style=\"height: 220px;\" *ngIf=\"mask\">\n                        <div class=\"spinner\"></div>\n                    </div>\n                    <div tabindex=\"1\" role=\"listbox\" [style.height.px]=\"height\" (dragover)=\"allowDrop({event:$event,data:data})\" (drop)=\"dropLeft($event)\"\n                        *ngIf=\"!mask\" style=\"overflow: auto;outline: none;\">\n                        <div id=\"{{data.id}}\" tabindex=\"1\" role=\"option\"\n                         (keyup.enter)=\"dataFormLeftToRightMove({event:$event,data:data,index:i})\"\n                         (keyup.arrowdown)=\"downArrowPress($event,i)\" \n                        (keyup.arrowup)=\"upArrowPress($event,i)\"\n                            class=\"itemselector-list\" [ngClass]=\"data['isSelected'] ? 'itemselector-list-active':''\" *ngFor=\"let data of availableData; let i = index\"\n                            (click)=\"itemClick(data,i, true,false)\" [attr.draggable]=\"enabledrag\" (dragstart)=\"onDragStartLeft({event:$event,data:data,index:i})\">\n                            {{data[displayfield]}}\n                        </div>\n                    </div>\n                </amexio-body>\n            </amexio-card>\n        </amexio-column>\n\n\n        <amexio-column [size]=\"'10pt'\">\n\n            <div class=\"item-selector-action-panel\">\n\n                <amexio-card [header]=\"true\">\n                    <amexio-header>&nbsp;</amexio-header>\n                    <amexio-body>\n\n                        <div class=\"actionbar\">\n                            <div [style.height.px]=\"height\" class=\"actionbarinner\">\n                                <div tabindex=\"1\" (keyup.enter)=\"moveTop()\" [ngClass]=\"{'actiondisable':!rightactive}\"\n                                    (click)=\"moveTop()\" class=\"action movetop \">\n                                    <amexio-c-icon key=\"itemselector_caretup\"></amexio-c-icon>\n                                </div>\n                                <div tabindex=\"1\" (keyup.enter)=\"upSwitch()\" [ngClass]=\"{'actiondisable':!rightactive}\"\n                                    (click)=\"upSwitch()\" class=\"action moveup\">\n                                    <amexio-c-icon key=\"itemselector_arrowup\"></amexio-c-icon>\n                                </div>\n                                <div tabindex=\"1\" (keyup.enter)=\"leftSwitch()\" [ngClass]=\"{'actiondisable':!rightactive}\"\n                                    (click)=\"leftSwitch()\" class=\"action moveleft\">\n                                    <amexio-c-icon key=\"itemselector_arrowleft\"></amexio-c-icon>\n                                </div>\n                                <div tabindex=\"1\" (keyup.enter)=\"rightSwitch()\" [ngClass]=\"{'actiondisable':!leftactive}\"\n                                    (click)=\"rightSwitch()\" class=\"action moveright\">\n                                    <amexio-c-icon key=\"itemselector_arrowright\"></amexio-c-icon>\n                                </div>\n                                <div tabindex=\"1\" (keyup.enter)=\"downSwitch()\" [ngClass]=\"{'actiondisable':!rightactive}\"\n                                    (click)=\"downSwitch()\" class=\"action movedown\">\n                                    <amexio-c-icon key=\"itemselector_arrowdown\"></amexio-c-icon>\n                                </div>\n                                <div tabindex=\"1\" (keyup.enter)=\"moveBottom()\" [ngClass]=\"{'actiondisable':!rightactive}\"\n                                    (click)=\"moveBottom()\" class=\"action movebottom\">\n                                    <amexio-c-icon key=\"itemselector_caretdown\"></amexio-c-icon>\n                                </div>\n                            </div>\n                        </div>\n                    </amexio-body>\n                </amexio-card>\n            </div>\n\n        </amexio-column>\n\n        <amexio-column [size]=\"'45pt'\">\n            <amexio-card [header]=\"true\">\n                <amexio-header>Selected</amexio-header>\n                <amexio-body>\n                    <div role=\"listbox\" [style.height.px]=\"height\" style=\"overflow: auto\" (dragover)=\"allowDrop({event:$event,data:data})\"\n                        (drop)=\"dropRight($event)\">\n                        <div [attr.tabindex]=\"data['selectedClick'] ? 2 : -1\" role=\"option\" contenteditable=\"false\"\n                            (keyup.enter)=\"enterFocus({event:$event,data:data,index:i})\" id=\"{{data.id}}\" [attr.draggable]=\"enabledrag\"\n                            (keyup.arrowdown)=\"downSwitchOnTab($event,i)\" (keyup.arrowup)=\"upSwitchOnTab( $event,i)\" class=\"itemselector-list\"\n                            *ngFor=\"let data of selectedData; let i = index\" (click)=\"itemClick(data,i, false,true)\"\n                            [ngClass]=\"data['selectedClick'] ? 'itemselector-list-active':''\" (dragstart)=\"onDragStartRight({event:$event,data:data,index:i})\">\n                            <label>\n                                {{data[displayfield]}}\n\n                            </label>\n                        </div>\n                    </div>\n                </amexio-body>\n            </amexio-card>\n        </amexio-column>\n    </amexio-row>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioItemSelectorComponent.ctorParameters = function () { return [
        { type: CommonDataService }
    ]; };
    AmexioItemSelectorComponent.propDecorators = {
        data: [{ type: i0.Input, args: ['data',] }],
        height: [{ type: i0.Input }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        valuefield: [{ type: i0.Input, args: ['value-field',] }],
        enabledrag: [{ type: i0.Input, args: ['enable-drag',] }],
        enabledrop: [{ type: i0.Input, args: ['enable-drop',] }],
        acrossitemselector: [{ type: i0.Input, args: ['across-itemselector',] }],
        availableRecords: [{ type: i0.Output }],
        selectedRecords: [{ type: i0.Output }],
        onDrag: [{ type: i0.Output }],
        dragover: [{ type: i0.Output }],
        dragData: [{ type: i0.Input }],
        parentRef: [{ type: i0.Input }]
    };
    return AmexioItemSelectorComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 11/22/17.
 */
var AmexioListBoxComponent = /** @class */ (function () {
    function AmexioListBoxComponent(dataService, renderer) {
        this.dataService = dataService;
        this.renderer = renderer;
        /*
        Properties
        name : enable-header
        datatype : boolean
        version : 4.2.4 onwards
        default : true
        description : User can disabled header of listbox to false..
        */
        this.enableHeader = true;
        /*
        Events
        name : selectedRows
        datatype : none
        version : none
        default : none
        description : It will fire only on selection of checkbox and gives you selected record data.
        */
        this.selectedRows = new i0.EventEmitter();
        /*
        Events
        name : onRowClick
        datatype : none
        version : none
        default : none
        description : It will gives you row clicked data.
        */
        this.onRowClick = new i0.EventEmitter();
        /*
          Events
          name : rightClick
          datatype : none
          version : 5.0.1
          default : none
          description : It will gives you row clicked data.
          */
        this.rightClick = new i0.EventEmitter();
        this.filterText = '';
        this.selectAll = false;
        this.maskloader = true;
        this.ishoverselected = true;
        this.mouseLocation = { left: 0, top: 0 };
        this.activedescendant = 'aria-activedescendant';
        this.flag = false;
        this.prevlistindex = -1;
        this.listindex = -1;
        this.filter = false;
        this.enablecheckbox = false;
        this.selectedData = [];
        this.searchplaceholder = 'Search';
        this.flag = true;
    }
    Object.defineProperty(AmexioListBoxComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.response = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.response);
            });
        }
        else if (this.data) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
        this.componentId = 'listbox' + Math.floor(Math.random() * 1000 + 999);
        this.listenListboxOutClick();
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.listenListboxOutClick = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.documentClickListener = this.renderer
            .listen('document', 'click', function (event) {
            if (_this.viewData.length > 0) {
                _this.viewData.forEach(function (element, index) {
                    if (_this.prevlistindex !== -1 && _this.viewData[_this.prevlistindex].hasOwnProperty('ishoverselected')
                        && _this.viewData[_this.prevlistindex]['ishoverselected'] === true) {
                        _this.viewData[_this.prevlistindex]['ishoverselected'] = false;
                        _this.prevlistindex = -1;
                        _this.listindex = -1;
                    }
                });
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.onArrowdown = /**
     * @return {?}
     */
    function () {
        if (this.prevlistindex > -1) {
            this.viewData[this.prevlistindex]['ishoverselected'] = false;
        }
        this.listindex++;
        this.prevlistindex = this.listindex;
        if (this.listindex >= this.viewData.length) {
            this.listindex = 0;
            this.prevlistindex = 0;
        }
        this.viewData[this.listindex]['ishoverselected'] = true;
        if (this.viewData[this.listindex]['ishoverselected']) {
            var /** @type {?} */ divid = document.getElementById(this.componentId);
            divid.setAttribute(this.activedescendant, this.viewData[this.listindex].index);
        }
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.onArrowUp = /**
     * @return {?}
     */
    function () {
        if (this.prevlistindex > -1) {
            this.viewData[this.prevlistindex]['ishoverselected'] = false;
        }
        this.prevlistindex--;
        if (this.prevlistindex === -1) {
            this.prevlistindex = this.viewData.length - 1;
            this.listindex = -1;
        }
        this.viewData[this.prevlistindex]['ishoverselected'] = true;
        if (this.viewData[this.prevlistindex]['ishoverselected']) {
            var /** @type {?} */ divid = document.getElementById(this.componentId);
            divid.setAttribute(this.activedescendant, this.viewData[this.prevlistindex].index);
        }
        if (this.prevlistindex === 0) {
            this.listindex = 0;
        }
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.onEnterPress = /**
     * @return {?}
     */
    function () {
        this.viewData.forEach(function (element, index) {
            if (element.ishoverselected === true) {
                if (element.isSelected === true) {
                    element.isSelected = false;
                }
                else {
                    element.isSelected = true;
                }
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (JSON.stringify(this.previousData) !== JSON.stringify(this.data)) {
            this.previousData = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioListBoxComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.viewData = responsedata;
        this.setSelectedFlag(this.viewData);
        this.orgData = JSON.parse(JSON.stringify(this.viewData));
    };
    /**
     * @param {?} viewRows
     * @return {?}
     */
    AmexioListBoxComponent.prototype.setSelectedFlag = /**
     * @param {?} viewRows
     * @return {?}
     */
    function (viewRows) {
        viewRows.forEach(function (row, index) {
            if (!row.hasOwnProperty('isSelected')) {
                row['isSelected'] = false;
            }
            row['index'] = 'listbox' + Math.floor(Math.random() * 1000 + 999) + index;
        });
        this.maskloader = false;
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.filterData = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ tData = JSON.parse(JSON.stringify(this.orgData));
        var /** @type {?} */ nodes = this.searchTree(tData, this.filterText);
        this.viewData = nodes;
    };
    /**
     * @param {?} data
     * @param {?} matchingTitle
     * @return {?}
     */
    AmexioListBoxComponent.prototype.searchTree = /**
     * @param {?} data
     * @param {?} matchingTitle
     * @return {?}
     */
    function (data, matchingTitle) {
        var /** @type {?} */ disp = this.displayfield;
        return data.filter(function f(node) {
            if (node[disp] && node[disp].toLowerCase().startsWith(matchingTitle.toLowerCase())) {
                return true;
            }
            if (node.children) {
                return (node.children = node.children.filter(f)).length;
            }
        });
        // return res;
    };
    /**
     * @param {?} rowData
     * @return {?}
     */
    AmexioListBoxComponent.prototype.selectedCheckBox = /**
     * @param {?} rowData
     * @return {?}
     */
    function (rowData) {
        var _this = this;
        rowData.isSelected = !rowData.isSelected;
        this.selectedData = [];
        this.viewData.forEach(function (node) {
            if (node.isSelected) {
                _this.selectedData.push(node);
            }
        });
        this.selectedRows.emit(this.selectedData);
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.selectAllRecord = /**
     * @return {?}
     */
    function () {
        this.selectedData = [];
        this.selectAll = !this.selectAll;
        if (this.selectAll) {
            this.viewData.forEach(function (node) {
                node.isSelected = true;
            });
            this.selectedData = this.viewData;
        }
        else {
            this.viewData.forEach(function (node) {
                node.isSelected = false;
            });
        }
        this.selectedRows.emit(this.selectedData);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioListBoxComponent.prototype.onClick = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.onRowClick.emit(data);
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} event
     * @param {?} row
     * @param {?} id
     * @return {?}
     */
    AmexioListBoxComponent.prototype.loadContextMenu = /**
     * @param {?} event
     * @param {?} row
     * @param {?} id
     * @return {?}
     */
    function (event, row, id) {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.tempSelectedFlag(this.viewData);
            this.mouseLocation.left = event.clientX;
            this.mouseLocation.top = event.clientY;
            row.isSelected = true;
            this.getContextMenu();
            this.posixUp = this.getListPosition(id);
            event.preventDefault();
            event.stopPropagation();
            this.rightClickRowData = row;
        }
    };
    // getcontextmenu
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.getContextMenu = /**
     * @return {?}
     */
    function () {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.contextMenuFlag = true;
            this.addListner();
        }
    };
    /**
     * @param {?} rows
     * @return {?}
     */
    AmexioListBoxComponent.prototype.tempSelectedFlag = /**
     * @param {?} rows
     * @return {?}
     */
    function (rows) {
        rows.forEach(function (row) {
            if (row.isSelected) {
                row.isSelected = false;
            }
        });
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioListBoxComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ height = 240;
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} Data
     * @return {?}
     */
    AmexioListBoxComponent.prototype.rightClickDataEmit = /**
     * @param {?} Data
     * @return {?}
     */
    function (Data) {
        this.rightClick.emit(Data);
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.addListner = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.globalClickListenFunc = this.renderer.listen('document', 'click', function (e) {
            _this.contextMenuFlag = false;
            if (!_this.contextMenuFlag) {
                _this.removeListner();
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.removeListner = /**
     * @return {?}
     */
    function () {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    };
    /**
     * @return {?}
     */
    AmexioListBoxComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeListner();
    };
    AmexioListBoxComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-listbox', template: "\n    <div class=\"listbox\" [style.border]=\"border\">\n      <div *ngIf=\"enableHeader\" class=\"header\" style=\"display: flex; justify-content: space-between\">\n        <div style=\"display: flex;justify-content: flex-start;\">\n          <div role=\"checkbox\" tabindex=\"0\" *ngIf=\"enablecheckbox\" (keyup.enter)=\"selectAllRecord()\" class=\"input-box\">\n            <div *ngIf=\"!selectAll\" (click)=\"selectAllRecord()\" class=\"checkbox default\"></div>\n            <div *ngIf=\"selectAll\" (click)=\"selectAllRecord()\" class=\"checkbox active\">&#10004;</div>\n          </div>\n          <div tabindex=\"0\" attr.aria-label=\"{{header}} list\" class=\"title\">&nbsp;&nbsp;{{header}}</div>\n        </div>\n\n        <div *ngIf=\"(filter == true)\">\n          <input type=\"text\" [(ngModel)]=\"filterText\" [placeholder]=\"searchplaceholder\" (keyup)=\"filterData()\" class=\"search \" />\n        </div>\n      </div>\n      <div class=\"listbox-height\" tabindex=\"0\" (keyup.arrowdown)=\"onArrowdown()\" (keyup.arrowup)=\"onArrowUp()\"\n        (keyup.enter)=\"onEnterPress()\" [style.height.px]=\"height\">\n        <ul id=\"{{componentId}}\" tabindex=\"0\" role=\"listbox\" class=\"list\" [ngClass]=\"{'loading-mask' : maskloader}\">\n          <li #id role=\"option\" [attr.aria-selected]=\"row.isSelected\"\n           class=\"list-items\" *ngFor=\"let row of viewData let rowno = index \"\n            [ngClass]=\"{'tree-node-label-selected':row.isSelected ,\n            'list-box-items':row.ishoverselected,\n            'tree-node-label-not-selected':row.isSelected=='false'}\"\n            id=\"{{row.index}}\">\n            <div (click)=\"onClick(row)\" (contextmenu)=\"loadContextMenu($event,row, id)\">\n              <ng-container *ngIf=\"enablecheckbox\">\n                <div class=\"inputgroup\" style=\"float: left; height: 100%;\">\n                  <div class=\"input-box\">\n                    <div role=\"checkbox\" [attr.checked]=\"row.isSelected\" (click)=\"selectedCheckBox(row)\" [class]=\"row.isSelected ?'checkbox active':'checkbox default'\">\n                      {{row.isSelected ? '&#10004;' : ''}}\n                    </div>\n                  </div>\n                </div>&nbsp;\n              </ng-container>\n              <ng-container *ngIf=\"!bodyTemplate\"> {{row[displayfield]}}</ng-container>\n              <ng-template *ngIf=\"bodyTemplate\" [ngTemplateOutlet]=\"bodyTemplate\" [ngTemplateOutletContext]=\"{ row: row }\"></ng-template>\n            </div>\n          </li>\n        </ul>\n      </div>\n    </div>\n    <ng-container *ngIf=\"contextMenuFlag\">\n      <base-contextmenu [base-context-menu]=\"contextmenu\" [mouse-location-top]=\"mouseLocation.top\" [mouse-location-left]=\"mouseLocation.left\"\n        [is-FlagShow]=\"contextMenuFlag\" [right-click-data]=\"rightClickRowData\" (onRightClick)=\"rightClickDataEmit($event)\"\n        [position-up]=\"posixUp\">\n      </base-contextmenu>\n    </ng-container>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioListBoxComponent.ctorParameters = function () { return [
        { type: CommonDataService },
        { type: i0.Renderer2 }
    ]; };
    AmexioListBoxComponent.propDecorators = {
        enablecheckbox: [{ type: i0.Input, args: ['enable-checkbox',] }],
        header: [{ type: i0.Input }],
        enableHeader: [{ type: i0.Input, args: ['enable-header',] }],
        searchplaceholder: [{ type: i0.Input, args: ['search-placeholder',] }],
        filter: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        height: [{ type: i0.Input }],
        selectedRows: [{ type: i0.Output }],
        onRowClick: [{ type: i0.Output }],
        border: [{ type: i0.Input }],
        contextmenu: [{ type: i0.Input, args: ['context-menu',] }],
        rightClick: [{ type: i0.Output }],
        bodyTemplate: [{ type: i0.ContentChild, args: ['amexioBodyTmpl',] }]
    };
    return AmexioListBoxComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by dattaram on 13/2/19.
 */
var PageInfo = /** @class */ (function () {
    function PageInfo(pN, eI, rows) {
        this.pageNumber = pN;
        this.endIndex = eI;
        this.startIndex = (this.endIndex - rows + 1);
    }
    return PageInfo;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 11/23/17.
 */
var AmexioPaginatorComponent = /** @class */ (function () {
    function AmexioPaginatorComponent() {
        this.serverSidePaging = false;
        /*
           Properties
           name : rows
           datatype : any
           version : 4.0 onwards
           default : none
           description : number of records on one page
           */
        this.rows = 10;
        /*
           Events
           name : onRowChange
           datatype : none
           version : none
           default : none
           description : if you click on '<<' will get 1st record and if you click on '>>' will get last record.
           */
        this.onRowChange = new i0.EventEmitter();
        /*
           Events
           name : onPageChange
           datatype : none
           version : none
           default : none
           description : It will gives you current page number
           */
        this.onPageChange = new i0.EventEmitter();
        this.fullPageSet = [];
        this.activePages = [];
        this.pageIndex = [];
        this.cloneRow = null;
    }
    /**
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.size == null || this.size === '') {
            this.size = 'medium';
        }
        this.initializePages();
        this.componentId = this.createCompId('paginator', this.pages);
    };
    /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.createCompId = /**
     * @param {?} inputType
     * @param {?} name
     * @return {?}
     */
    function (inputType, name) {
        return inputType + '_' + name + '_' + Math.floor(Math.random() * 1000 + 999);
    };
    /**
     * @param {?} change
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.ngOnChanges = /**
     * @param {?} change
     * @return {?}
     */
    function (change) {
        if (change["pages"] && !change["pages"].isFirstChange()) {
            this.initializePages();
        }
        if (change["rows"] && !change["rows"].isFirstChange()) {
            this.initializePages();
        }
    };
    /**
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.initializePages = /**
     * @return {?}
     */
    function () {
        this.resetData();
        if (this.rows > 10 && this.serverSidePaging) {
            this.isCustomLogic = true;
            this.cloneRow = this.rows;
            this.rows = 10;
        }
        if (this.rows && this.rows != null) {
            if (this.rows > this.pages) {
                this.rows = this.pages;
            }
            for (var /** @type {?} */ i = 0; i < this.pages; i++) {
                this.fullPageSet.push(i + 1);
            }
            for (var /** @type {?} */ i = 0; i < this.rows; i++) {
                this.activePages.push(i + 1);
            }
            this.calculateRows();
            this.setRows(this.rows);
        }
        else {
            for (var /** @type {?} */ i = 0; i < this.pages; i++) {
                this.fullPageSet.push(i + 1);
                this.activePages.push(i + 1);
            }
        }
        this.activePageIndex = 0;
        this.currentRowIndex = 0;
        this.activePage = this.activePageIndex + 1;
    };
    /**
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.onFirstClick = /**
     * @return {?}
     */
    function () {
        this.setAndEmitPageState(this.activePage, 1);
        this.activePageIndex = 0;
        this.changeRows(this.pageIndex[0], 0, null);
    };
    /**
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.onLastClick = /**
     * @return {?}
     */
    function () {
        this.changeRows(this.pageIndex[this.pageIndex.length - 1], this.pageIndex.length - 1, null);
        this.activePageIndex = this.activePages.length - 1;
        this.activePage = this.activePages[this.activePages.length - 1];
        this.setAndEmitPageState(this.activePage, this.pageIndex[this.pageIndex.length - 1]);
    };
    /**
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.onPrevious = /**
     * @return {?}
     */
    function () {
        if (this.activePageIndex !== 0) {
            // within row bounds
            this.setNextOrPreviewsPage(this.activePageIndex -= 1);
        }
        else {
            // load prev rows
            var /** @type {?} */ sIndx = void 0;
            if (this.fullPageSet.indexOf(this.activePage) === 1) {
                sIndx = this.fullPageSet.indexOf(this.activePage);
            }
            else {
                sIndx = this.fullPageSet.indexOf(this.activePage) - 1;
            }
            if (sIndx > 0) {
                this.changeRows(this.pageIndex[this.currentRowIndex - 1], this.currentRowIndex - 1, null);
                this.setNextOrPreviewsPage(this.activePages.length - 2);
            }
        }
    };
    /**
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.onNext = /**
     * @return {?}
     */
    function () {
        if (this.activePageIndex !== this.activePages.length - 1) {
            // within row bounds
            this.setNextOrPreviewsPage(this.activePageIndex += 1);
        }
        else {
            // load next rows
            var /** @type {?} */ sIndx = this.fullPageSet.indexOf(this.activePage) + 1;
            if (sIndx <= this.fullPageSet.length - 1) {
                this.changeRows(this.pageIndex[this.currentRowIndex + 1], this.currentRowIndex + 1, null);
                this.setNextOrPreviewsPage(1);
            }
        }
    };
    /**
     * @param {?} index
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.setNextOrPreviewsPage = /**
     * @param {?} index
     * @return {?}
     */
    function (index) {
        this.activePageIndex = index;
        this.activePage = this.activePages[index];
        this.setAndEmitPageState(index, this.activePage);
    };
    /* If page size is less then row*/
    /**
     * @param {?} rowNumber
     * @param {?} inDx
     * @param {?} event
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.changeRows = /**
     * @param {?} rowNumber
     * @param {?} inDx
     * @param {?} event
     * @return {?}
     */
    function (rowNumber, inDx, event) {
        if (rowNumber != null) {
            this.activePages = [];
            if (this.pages <= rowNumber) {
                this.currentRow = this.pages;
                for (var /** @type {?} */ i = this.currentRow - this.rows + 1; i <= this.currentRow; i++) {
                    if (i !== 0) {
                        this.activePages.push(i);
                    }
                }
            }
            else {
                this.getCurrentRow(rowNumber);
            }
            this.onPageChangeMethod(inDx);
            if (event) {
                this.show = !this.show;
            }
        }
    };
    /**
     * @param {?} rowNumber
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.getCurrentRow = /**
     * @param {?} rowNumber
     * @return {?}
     */
    function (rowNumber) {
        this.currentRow = rowNumber;
        for (var /** @type {?} */ i = this.currentRow - this.rows; i <= this.currentRow; i++) {
            if (i !== 0) {
                this.activePages.push(i);
            }
        }
    };
    /**
     * @param {?} inDx
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.onPageChangeMethod = /**
     * @param {?} inDx
     * @return {?}
     */
    function (inDx) {
        this.currentRowIndex = inDx;
        this.onRowChange.emit(this.currentRow);
        this.activePageIndex = 0;
        this.activePage = this.activePages[0];
    };
    /**
     * @param {?} page
     * @param {?} index
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.onPageClick = /**
     * @param {?} page
     * @param {?} index
     * @return {?}
     */
    function (page, index) {
        this.setAndEmitPageState(this.activePageIndex + 1, page);
        this.activePageIndex = index;
        this.activePage = page;
    };
    /**
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.calculateRows = /**
     * @return {?}
     */
    function () {
        this.currentRow = this.rows;
        var /** @type {?} */ loopI = Math.ceil(this.pages / this.rows);
        for (var /** @type {?} */ i = 1; i <= loopI; i++) {
            if ((this.rows * i) > this.pages) {
                this.pageIndex.push(this.pages);
            }
            else {
                this.pageIndex.push(this.rows * i);
            }
        }
    };
    /**
     * @param {?} rowNumber
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.setRows = /**
     * @param {?} rowNumber
     * @return {?}
     */
    function (rowNumber) {
        this.activePages = [];
        if (rowNumber > this.pages) {
            this.currentRow = this.pages;
        }
        else {
            this.currentRow = rowNumber;
        }
        for (var /** @type {?} */ i = 0; i < this.currentRow; i++) {
            this.activePages.push(i + 1);
        }
    };
    /**
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.showColumnOptions = /**
     * @return {?}
     */
    function () {
        this.show = !this.show;
    };
    /**
     * @param {?} currentPageIndex
     * @param {?} futurePageIndex
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.setAndEmitPageState = /**
     * @param {?} currentPageIndex
     * @param {?} futurePageIndex
     * @return {?}
     */
    function (currentPageIndex, futurePageIndex) {
        if (this.isCustomLogic) {
            this.currentState = new PageInfo(currentPageIndex, (this.cloneRow * currentPageIndex), this.cloneRow);
            this.futureState = new PageInfo(futurePageIndex, (this.cloneRow * futurePageIndex), this.cloneRow);
        }
        else {
            this.currentState = new PageInfo(currentPageIndex, (this.rows * currentPageIndex), this.rows);
            this.futureState = new PageInfo(futurePageIndex, (this.rows * futurePageIndex), this.rows);
        }
        this.onPageChange.emit(this.createOnPageEmitObject(this.futureState.pageNumber));
    };
    // CREATE ON PAGE EMIT OBJECT
    /**
     * @param {?} activePage
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.createOnPageEmitObject = /**
     * @param {?} activePage
     * @return {?}
     */
    function (activePage) {
        return {
            pageNumber: activePage,
            current: this.currentState,
            next: this.futureState,
        };
    };
    /**
     * @return {?}
     */
    AmexioPaginatorComponent.prototype.resetData = /**
     * @return {?}
     */
    function () {
        this.fullPageSet.length = 0;
        this.activePages.length = 0;
        this.pageIndex.length = 0;
    };
    AmexioPaginatorComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-paginator', template: "\n    <div role=\"navigation\" attr.aria-labelledby=\"componentId\" aria-label=\"pagination\" class=\"paginator\">\n      <span class=\"paginator-pages\">\n        <a role=\"radiogroup\" id=\"{{componentId}}\" aria-label=\"previous page\" tabindex=\"1\" class=\"paginator-page\" (click)=\"onPrevious()\">&lt;</a>\n        <a role=\"radiogroup\" id=\"{{componentId}}\" aria-label=\"previous set page\" tabindex=\"1\" class=\"paginator-page\" (click)=\"onFirstClick()\">&lt;&lt;</a>\n      </span>\n      <span id=\"{{componentId}}\" tabindex=\"1\" attr.aria-label=\"Page{{i+1}}\" role=\"link\" (keyup.enter)=\"onPageClick(page,i)\" class=\"paginator-pages\" *ngFor=\"let page of activePages;let i = index\">\n        <a class=\"paginator-page\" [ngClass]=\"{'active' : activePageIndex == i  }\"  (click)=\"onPageClick(page,i)\">{{page}}</a>\n      </span>\n      <span role=\"presentation\" class=\"paginator-pages\">\n        <a role=\"radiogroup\" id=\"{{componentId}}\" aria-label=\"next set page\" tabindex=\"1\" class=\"paginator-page\" (click)=\"onLastClick()\">&gt;&gt;</a>\n        <a role=\"radiogroup\" id=\"{{componentId}}\" aria-label=\"next page\" tabindex=\"1\" class=\"paginator-page\" (click)=\"onNext()\">&gt;</a>\n      </span>\n      <ng-container *ngIf=\"!serverSidePaging\">\n        <ng-container *ngIf=\"pages > rows\">\n        <span class=\"paginator-pages\">\n          <a class=\"paginator-page\" (click)=\"showColumnOptions()\" style=\" cursor: pointer;\">{{currentRow}} &nbsp; &#9660;</a>\n          <span *ngIf=\"show\" class=\"dropdown\" style=\"width: 50px;\">\n            <ul class=\"dropdown-list\">\n              <li class=\"list-items\" *ngFor=\"let row of pageIndex;let i = index\" (click)=\"changeRows(row,i, $event)\">\n                <div>{{row}}</div>\n              </li>\n            </ul>\n          </span>\n        </span>\n        </ng-container>\n      </ng-container>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioPaginatorComponent.ctorParameters = function () { return []; };
    AmexioPaginatorComponent.propDecorators = {
        serverSidePaging: [{ type: i0.Input, args: ['server-side-paging',] }],
        pages: [{ type: i0.Input }],
        rows: [{ type: i0.Input }],
        size: [{ type: i0.Input }],
        onRowChange: [{ type: i0.Output }],
        onPageChange: [{ type: i0.Output }]
    };
    return AmexioPaginatorComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioProgressMultiBarComponent = /** @class */ (function () {
    function AmexioProgressMultiBarComponent() {
    }
    /**
     * @return {?}
     */
    AmexioProgressMultiBarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    AmexioProgressMultiBarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-multi-bar', template: "\n\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioProgressMultiBarComponent.ctorParameters = function () { return []; };
    return AmexioProgressMultiBarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 27/12/17.
 */
var AmexioProgressBarComponent = /** @class */ (function () {
    function AmexioProgressBarComponent() {
        /*
          Properties
          name : show
          datatype : boolean
          version : 4.0 onwards
          default : true
          description :  Shows / Hides the progress bar.
          */
        this.showProgress = true;
        this.progressclass = '';
        this.strippedCss = 'stripped ';
    }
    /**
     * @return {?}
     */
    AmexioProgressBarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.height) {
            this.height = this.height + 'px';
        }
        else {
            this.height = '20px';
        }
        if (this.stripped) {
            this.progressclass = this.progressclass + this.strippedCss;
        }
        if (this.type && !this.amexiocolor) {
            this.progressclass = this.progressclass + this.type.toLocaleLowerCase();
        }
        else if (this.amexiocolor && !this.type) {
            this.progressclass = this.progressclass + this.amexiocolor.toLocaleLowerCase();
        }
    };
    AmexioProgressBarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-progress-bar',
                    template: "\n    <div *ngIf=\"showProgress\" class=\"progress\" [ngStyle]=\"{'height':height}\">\n\n      <span [ngClass]=\"progressclass\" *ngIf=\"infinite\" style=\"width: 100%;\" tabindex=\"1\" role=\"progressbar\" aria-readonly=\"true\"\n        attr.aria-label=\"'inprogress {{label}}'\">\n        {{label != null ? label : 'Loading...'}}\n      </span>\n      <span tabindex=\"1\" attr.aria-label=\"'progressbar {{tooltip}}'\" role=\"progressbar\" attr.aria-valuenow=\"{{currentvalue}}\"\n        aria-valuemin=\"0\" aria-valuemax=\"100\" [ngClass]=\"progressclass\" *ngIf=\"!infinite\" [ngStyle]=\"{'width.%' : currentvalue}\">\n      </span>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioProgressBarComponent.ctorParameters = function () { return []; };
    AmexioProgressBarComponent.propDecorators = {
        showProgress: [{ type: i0.Input, args: ['show',] }],
        infinite: [{ type: i0.Input }],
        type: [{ type: i0.Input }],
        amexiocolor: [{ type: i0.Input, args: ['amexio-color',] }],
        currentvalue: [{ type: i0.Input, args: ['current-value',] }],
        label: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        stripped: [{ type: i0.Input }],
        multi: [{ type: i0.Input }],
        tooltip: [{ type: i0.Input, args: ['tooltip',] }]
    };
    return AmexioProgressBarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PropertyGridComponent = /** @class */ (function () {
    function PropertyGridComponent() {
        this.hasBorder = false;
        this.hasColon = false;
        this.enableKeyBold = false;
        this.enableValueClick = false;
        this.onValueClick = new i0.EventEmitter();
    }
    /**
     * @param {?} event
     * @return {?}
     */
    PropertyGridComponent.prototype.onClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.link && event.link.length > 0) {
            this.onValueClick.emit(event);
        }
    };
    PropertyGridComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-property-grid',
                    template: "\n      <ng-container *ngIf=\"data && data.length > 0\">\n        <table [ngClass]=\"{'borderStyle': hasBorder}\" style=\"width: 100%\">\n          <tr *ngFor=\"let item of data\">\n            <td class=\"field-name-align\" [ngClass]=\"{'borderStyle': hasBorder}\">\n              <span *ngIf=\"item.fieldIcon\" style=\"padding-right: 5px\">\n                <amexio-c-icon class=\"fa + {{item.fieldIcon}}\"></amexio-c-icon>\n              </span>\n              <span *ngIf=\"!item.onlyIcon\"\n                [ngStyle]=\"{'font-weight': enableKeyBold ? 'bold': 'normal'}\">{{item.fieldName}}</span>\n              <span *ngIf=\"hasColon\"> :</span>\n            </td>\n            <td class=\"field-name-align\"\n              [ngClass]=\"{'borderStyle': hasBorder, 'isclickenabled':(item.link && item.link.length>0)}\"\n              (click)=\"onClick(item)\">\n              {{item.fieldValue}}\n            </td>\n          </tr>\n        </table>\n      </ng-container>\n    ",
                    styles: ["\n      .isclickenabled{cursor:pointer;color:#0366d6;text-decoration:underline}\n    "],
                },] },
    ];
    /** @nocollapse */
    PropertyGridComponent.ctorParameters = function () { return []; };
    PropertyGridComponent.propDecorators = {
        data: [{ type: i0.Input, args: ['key-value-data',] }],
        hasBorder: [{ type: i0.Input, args: ['has-border',] }],
        hasColon: [{ type: i0.Input, args: ['has-colon',] }],
        enableKeyBold: [{ type: i0.Input, args: ['enable-key-bold',] }],
        enableValueClick: [{ type: i0.Input, args: ['enable-value-click',] }],
        onValueClick: [{ type: i0.Output, args: ['onValueClick',] }]
    };
    return PropertyGridComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 11/12/17.
 */
var AmexioFilterTreeComponent = /** @class */ (function () {
    function AmexioFilterTreeComponent(_http, cdf, treeViewFilterService) {
        this._http = _http;
        this.cdf = cdf;
        this.treeViewFilterService = treeViewFilterService;
        /*
        Properties
        name : enable-checkbox
        datatype : false
        version : 4.0 onwards
        default : false
        description : Enables checkbox for each row, this allows user for multi selection.
        */
        this.enablecheckbox = false;
        /*
        Events
        name : nodeClick
        datatype : none
        version : none
        default : none
        description : It will gives you clicked node data.
        */
        this.nodeClick = new i0.EventEmitter();
        /*
        Events
        name : onTreeNodeChecked
        datatype : none
        version : none
        default : none
        description : It will gives whole tree data with checked flag status.
        */
        this.onTreeNodeChecked = new i0.EventEmitter();
        this.isDataFound = true;
        this.onClickSearch = false;
        this.mask = true;
        this.filterIndex = 3;
        this.triggerchar = 1;
        this.childarraykey = 'children';
        this.filterOptionData = [{
                key: 'Is Equal To', value: 1, type: 'string', checkedStatus: '',
            }, {
                key: 'Is Not Equal To', value: 2, type: 'string', checkedStatus: '',
            }, {
                key: 'Start With', value: 3, type: 'string', checkedStatus: 'fa fa-check',
            }, {
                key: 'Ends With', value: 4, type: 'string', checkedStatus: '',
            }, {
                key: 'Contains', value: 5, type: 'string', checkedStatus: '',
            }];
        this.generatefilterOptionDataIndex(this.filterOptionData);
    }
    Object.defineProperty(AmexioFilterTreeComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.parentTmp != null) {
            this.templates = { treeNodeTemplate: this.parentTmp };
        }
        else if (this.templates != null) {
            this.parentTmp = this.templates.treeNodeTemplate;
        }
    };
    /**
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        if (this.parentTmp != null) {
            this.templates = { treeNodeTemplate: this.parentTmp };
        }
        else if (this.templates != null) {
            this.parentTmp = this.templates.treeNodeTemplate;
        }
        if (this.httpmethod && this.httpurl) {
            this.callService();
        }
        else if (this.data) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
        this.componentLoaded = true;
    };
    /**
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (JSON.stringify(this.previousValue) !== JSON.stringify(this.data)) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    };
    /**
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.filterData = /**
     * @return {?}
     */
    function () {
        this.showToolTip = false;
        if (this.filterText && this.filterText.length >= this.triggerchar) {
            var /** @type {?} */ tData = JSON.parse(JSON.stringify(this.orgTreeData));
            var /** @type {?} */ treeNodes = this.searchTree(tData, this.filterText);
            this.treeData = treeNodes;
            if (this.treeData && this.treeData.length === 0) {
                this.isDataFound = false;
            }
            else {
                this.isDataFound = true;
            }
        }
        else if (this.onClickSearch) {
            var /** @type {?} */ tData = JSON.parse(JSON.stringify(this.orgTreeData));
            var /** @type {?} */ treeNodes = this.searchTree(tData, this.filterText);
            this.treeData = treeNodes;
            this.onClickSearch = false;
            if (this.treeData && this.treeData.length === 0) {
                this.isDataFound = true;
            }
            else {
                this.isDataFound = false;
            }
        }
        else {
            this.isDataFound = true;
            this.treeData = this.orgTreeData;
        }
        if (this.treeData) {
            this.generatefilterIndex(this.treeData, 1, Math.floor(Math.random() * 1000 + 999 + 1));
        }
    };
    /**
     * @param {?} data
     * @param {?} matchingTitle
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.searchTree = /**
     * @param {?} data
     * @param {?} matchingTitle
     * @return {?}
     */
    function (data, matchingTitle) {
        var /** @type {?} */ fi = this.filterIndex;
        if (matchingTitle) {
            return this.filterActualData(data, fi, matchingTitle);
        }
    };
    /**
     * @param {?} data
     * @param {?} fi
     * @param {?} matchingTitle
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.filterActualData = /**
     * @param {?} data
     * @param {?} fi
     * @param {?} matchingTitle
     * @return {?}
     */
    function (data, fi, matchingTitle) {
        return data.filter(function f(node) {
            if ((fi === 5 && node.text.toLowerCase().includes(matchingTitle.toLowerCase())) ||
                (fi === 3 && node.text.toLowerCase().startsWith(matchingTitle.toLowerCase())) ||
                (fi === 1 && node.text.toLowerCase() === matchingTitle.toLowerCase()) ||
                (fi === 2 && node.text.toLowerCase() !== matchingTitle.toLowerCase()) ||
                (fi === 4 && node.text.toLowerCase().endsWith(matchingTitle.toLowerCase()))) {
                return true;
            }
            if (node.children) {
                return (node.children = node.children.filter(f)).length;
            }
        });
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.filterOption = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.onClickSearch = true;
        this.filterIndex = data.value;
        this.filterOptionData.forEach(function (opt) {
            if (opt.value !== data.value) {
                opt.checkedStatus = '';
            }
            else {
                opt.checkedStatus = 'fa fa-check';
            }
        });
        this.filterData();
        this.showToolTip = false;
    };
    /**
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.renderServiceData = /**
     * @return {?}
     */
    function () {
        this.setData(this.data);
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ tdata = this.getData(httpResponse);
        if (tdata) {
            this.orgTreeData = JSON.parse(JSON.stringify(tdata));
            this.treeData = tdata;
            this.generatefilterIndex(this.treeData, 1, Math.floor(Math.random() * 1000 + 999 + 1));
        }
        this.mask = false;
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.getData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    };
    /**
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.callService = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.treeViewFilterService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
            _this.data = response;
        }, function () {
            _this.renderServiceData();
        });
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.onRowSelect = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.nodeClick.emit(data);
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.onCheckSelect = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.onTreeNodeChecked.emit(data);
    };
    /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.generatefilterIndex = /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    function (data, parentId, rannumber) {
        var _this = this;
        data.forEach(function (element, index) {
            element['index'] = '' + rannumber + '-' + parentId + (index + 1);
            if (element[_this.childarraykey]) {
                _this.generatefilterIndex(element[_this.childarraykey], element.index.split('-')[1], rannumber);
            }
        });
    };
    /**
     * @param {?} filteroptions
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.generatefilterOptionDataIndex = /**
     * @param {?} filteroptions
     * @return {?}
     */
    function (filteroptions) {
        filteroptions.forEach(function (element, index) {
            element['index'] = Math.floor(Math.random() * 1000 + 999 + 1) + '-' + index;
        });
    };
    /**
     * @param {?} data
     * @param {?} opt
     * @param {?} rowindex
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.onArrowFilterUp = /**
     * @param {?} data
     * @param {?} opt
     * @param {?} rowindex
     * @return {?}
     */
    function (data, opt, rowindex) {
        if (rowindex > 0) {
            var /** @type {?} */ nextindex = rowindex - 1;
            var /** @type {?} */ focusdata = data[nextindex];
            if (document.getElementById(focusdata.index)) {
                document.getElementById(focusdata.index).focus();
            }
        }
    };
    /**
     * @param {?} data
     * @param {?} opt
     * @param {?} rowindex
     * @return {?}
     */
    AmexioFilterTreeComponent.prototype.onArrowFilterDown = /**
     * @param {?} data
     * @param {?} opt
     * @param {?} rowindex
     * @return {?}
     */
    function (data, opt, rowindex) {
        if (rowindex < data.length - 1) {
            var /** @type {?} */ nextindex = rowindex + 1;
            var /** @type {?} */ focusdata = data[nextindex];
            if (document.getElementById(focusdata.index)) {
                document.getElementById(focusdata.index).focus();
            }
        }
    };
    AmexioFilterTreeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-tree-filter-view', template: "\n    <div>\n      <div>\n        <div class=\"inputgroup\">\n          <input  tabindex=\"1\" type=\"text\" class=\"input-control text-input-width\" aria-label=\"Filter Tree Search\" [(ngModel)]=\"filterText\"\n                 placeholder=\"Search\" (keyup)=\"filterData()\">\n          <!--<i class=\"fa fa-filter\" aria-hidden=\"true\" (click)=\"showToolTip = !showToolTip\"></i>-->\n          <span tabindex=\"1\" (keyup.enter)=\"showToolTip = !showToolTip\" attr.aria-expanded=\"showToolTip\" class=\"datatable-filter-icon\">\n          <amexio-c-icon key=\"tree_filter\" (click)=\"showToolTip = !showToolTip\"></amexio-c-icon>\n          </span>\n          <!--  <div class=\"input-group-btn\">-->\n          <!-- <button type=\"button\"\n          class=\"btn\" data-toggle=\"dropdown\"\n          (click)=\"showToolTip = !showToolTip\"\n          aria-haspopup=\"true\" aria-expanded=\"false\">\n           </button>-->\n          <span *ngIf=\"showToolTip\" class=\"dropdown\">\n              <ul class=\"dropdown-list\">\n                <li tabindex=\"1\" id={{opt.index}} role=\"option\" class=\"list-items\"\n                *ngFor=\"let opt of filterOptionData let rowindex = index\"\n                 (click)=\"filterOption(opt)\"\n                  (keyup.enter)=\"filterOption(opt)\"\n                   (keyup.arrowup)=\"onArrowFilterUp(filterOptionData,opt,rowindex)\"\n                   (keyup.arrowdown)=\"onArrowFilterDown(filterOptionData,opt,rowindex)\">\n                 {{opt.key}}&nbsp;\n                 <!--<i [class]=\"opt.checkedStatus\" aria-hidden=\"true\"></i>-->\n                  <amexio-c-icon key=\"opt.checkedStatus\"></amexio-c-icon>\n                </li>\n              </ul>\n            </span>\n          <!-- </div>-->\n        </div>\n        <ng-container *ngIf=\"isDataFound\">\n          <amexio-treeview\n            [data]=\"treeData\"\n            [filter-tree-flag]=\"true\"\n            [enable-checkbox]=\"enablecheckbox\"\n            (onTreeNodeChecked)=\"onCheckSelect($event)\"\n            (nodeClick)=\"onRowSelect($event)\" [templates]=\"templates\">\n          </amexio-treeview>\n        </ng-container>\n        <ng-container *ngIf=\"!isDataFound\">\n          <p>No Data Found.</p>\n        </ng-container>\n\n      </div>\n    </div>\n\n\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioFilterTreeComponent.ctorParameters = function () { return [
        { type: HttpClient },
        { type: i0.ChangeDetectorRef },
        { type: CommonDataService }
    ]; };
    AmexioFilterTreeComponent.propDecorators = {
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        data: [{ type: i0.Input, args: ['data',] }],
        enablecheckbox: [{ type: i0.Input, args: ['enable-checkbox',] }],
        nodeClick: [{ type: i0.Output }],
        onTreeNodeChecked: [{ type: i0.Output }],
        triggerchar: [{ type: i0.Input, args: ['trigger-char',] }],
        childarraykey: [{ type: i0.Input, args: ['child-array-key',] }],
        parentTmp: [{ type: i0.ContentChild, args: ['amexioTreeTemplate',] }]
    };
    return AmexioFilterTreeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
var HorizontalTreeViewNodeComponent = /** @class */ (function () {
    function HorizontalTreeViewNodeComponent() {
        /*
        Events
        name : onNodeClick
        datatype : none
        version : none
        default : none
        description : It will gives you clicked node data.
        */
        this.onNodeClick = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @param {?} node
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.onClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        node.expand = !node.expand;
        this.onNodeClick.emit(node);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.onInnerClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.onNodeClick.emit(node);
    };
    /**
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.onArrowUp = /**
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    function (data, node, index) {
        var /** @type {?} */ newindex = index - 1;
        if (newindex >= 0) {
            var /** @type {?} */ previousindex = data[newindex];
            this.setFocus(previousindex);
            this.focusToInnerLastItem(previousindex);
        }
        else {
            var /** @type {?} */ id = node.id;
            var /** @type {?} */ spiltID = this.splitID(id);
            var /** @type {?} */ randomnumber = spiltID[0];
            var /** @type {?} */ currentid = spiltID[1];
            var /** @type {?} */ newid = parseInt(currentid.slice(0, -1), 10);
            var /** @type {?} */ id2 = newid;
            var /** @type {?} */ focusid1 = randomnumber + '-' + id2;
            if (document.getElementById(focusid1)) {
                document.getElementById(focusid1).focus();
            }
        }
    };
    /**
     * @param {?} focuselement
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.setFocus = /**
     * @param {?} focuselement
     * @return {?}
     */
    function (focuselement) {
        if (document.getElementById(focuselement.id)) {
            document.getElementById(focuselement.id).focus();
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.focusToInnerLastItem = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        if (node.hasOwnProperty('expand') && node.expand && node['children']) {
            node['children'].forEach(function (innernode) {
                _this.focusToInnerLastItem(innernode);
            });
        }
        else {
            this.setFocus(node);
        }
    };
    /**
     * @param {?} id
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.splitID = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return id.split('-');
    };
    /**
     * @param {?} event
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.onArrowDown = /**
     * @param {?} event
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    function (event, data, node, index) {
        var /** @type {?} */ incrementindex = index + 1;
        var /** @type {?} */ itemid = data[incrementindex];
        if (node.expand === true && node['children']) {
            var /** @type {?} */ data1 = node['children'][0];
            this.setFocus(data1);
        }
        else {
            if (incrementindex < data.length) {
                this.setFocus(itemid);
            }
            else {
                this.focusTONextParent(node);
            }
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.focusTONextParent = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var /** @type {?} */ sliceId = this.splitID(node.id);
        var /** @type {?} */ randomnumber = sliceId[0];
        var /** @type {?} */ currentid = sliceId[1];
        var /** @type {?} */ newid = parseInt(currentid.slice(0, -1), 10);
        var /** @type {?} */ currentitem = newid + 1;
        var /** @type {?} */ focusid1 = randomnumber + '-' + currentitem;
        if (document.getElementById(focusid1)) {
            document.getElementById(focusid1).focus();
        }
        else {
            var /** @type {?} */ nextnewid = parseInt(currentitem.toString().slice(0, -1), 10);
            var /** @type {?} */ id3 = nextnewid + 1;
            var /** @type {?} */ focusid2 = randomnumber + '-' + id3;
            if (document.getElementById(focusid2)) {
                document.getElementById(focusid2).focus();
            }
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    HorizontalTreeViewNodeComponent.prototype.onEnterClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.onClick(node);
        if (node.hasOwnProperty('expand') && node.expand && node['children']) {
            var /** @type {?} */ sliceId = this.splitID(node.id);
            var /** @type {?} */ randomnumber = sliceId[0];
            var /** @type {?} */ currentid = sliceId[1];
            var /** @type {?} */ nextId = currentid + 1;
            var /** @type {?} */ focusid = randomnumber + '-' + nextId;
            if (document.getElementById(focusid)) {
                document.getElementById(focusid).focus();
            }
        }
    };
    HorizontalTreeViewNodeComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-horizontal-treeviewnode', template: "\n  <div #id class=\"horizontaltreeview-node\">\n  <div class=\"horizontaltreeview-node-entry\" [ngClass]=\"{'sole':data.length==1}\" *ngFor=\"let node of data; let i = index\">\n    <span id={{node.id}} tabindex=\"1\" [attr.aria-expanded]=\"node.expand\"\n    class=\"horizontaltreeview-node-label\" (click)=\"onClick(node)\" (keyup.enter)=\"onEnterClick(node)\"\n    (keyup.arrowup)=\"onArrowUp(data,node,i)\"\n    (keyup.arrowdown)=\"onArrowDown($event,data,node,i)\">\n      {{node.text}}\n      <span  *ngIf=\"node.children && (node.children.length>0)\" class=\"float-right\" (click)=\"onClick(node)\" (keyup.enter)=\"onClick(node)\">\n        <amexio-c-icon *ngIf=\"node.expand\" key=\"horizontal-tree-collapse\"></amexio-c-icon>\n        <amexio-c-icon *ngIf=\"!node.expand\" key=\"horizontal-tree-expanded\"></amexio-c-icon>\n      </span>\n    </span>\n    <amexio-horizontal-treeviewnode *ngIf=\"node.expand && node.children && (node.children.length>0)\"\n                                    [data]=\"node.children\"\n                                    (onNodeClick)=\"onInnerClick($event)\"></amexio-horizontal-treeviewnode>\n  </div>\n</div>\n  ",
                },] },
    ];
    /** @nocollapse */
    HorizontalTreeViewNodeComponent.ctorParameters = function () { return []; };
    HorizontalTreeViewNodeComponent.propDecorators = {
        data: [{ type: i0.Input }],
        onNodeClick: [{ type: i0.Output }]
    };
    return HorizontalTreeViewNodeComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 12/1/17.
 */
var HorizontalTreeViewComponent = /** @class */ (function () {
    function HorizontalTreeViewComponent(dataService) {
        this.dataService = dataService;
        /*
        Events
        name : nodeClick
        datatype : none
        version : none
        default : none
        description : It will gives you clicked node data.
        */
        this.nodeClick = new i0.EventEmitter();
        this.mask = true;
    }
    /**
     * @return {?}
     */
    HorizontalTreeViewComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    HorizontalTreeViewComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        // Check if key is added?
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.mask = false;
        this.generateIndex(this.data, 1, Math.floor(Math.random() * 1000 + 999 + 1));
    };
    /**
     * @param {?} node
     * @return {?}
     */
    HorizontalTreeViewComponent.prototype.nodeclick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.nodeClick.emit(node);
    };
    /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    HorizontalTreeViewComponent.prototype.generateIndex = /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    function (data, parentId, rannumber) {
        var _this = this;
        data.forEach(function (element, index) {
            element['id'] = '' + rannumber + '-' + parentId + (index + 1);
            if (element['children']) {
                _this.generateIndex(element['children'], element.id.split('-')[1], rannumber);
            }
        });
    };
    HorizontalTreeViewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-horizontal-treeview', template: "\n\n    <div class=\"horizontaltreeview\">\n      <span tabindex=\"1\" class=\"horizontaltreeview-node-label\">{{label}}</span>\n      <div style=\"height: 300px;\" *ngIf=\"mask\">\n        <div class=\"spinner\"></div>\n      </div>\n      <amexio-horizontal-treeviewnode *ngIf=\"!mask\" [data]=\"data\" (onNodeClick)=\"nodeclick($event)\"></amexio-horizontal-treeviewnode>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    HorizontalTreeViewComponent.ctorParameters = function () { return [
        { type: CommonDataService }
    ]; };
    HorizontalTreeViewComponent.propDecorators = {
        label: [{ type: i0.Input }],
        data: [{ type: i0.Input }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        nodeClick: [{ type: i0.Output }]
    };
    return HorizontalTreeViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by ketangote on 11/23/17.
 */
var AmexioTreeViewComponent = /** @class */ (function () {
    function AmexioTreeViewComponent(element, dataService, cdf, renderer) {
        this.element = element;
        this.dataService = dataService;
        this.cdf = cdf;
        this.renderer = renderer;
        /*
            Events
            name : nodeClick
            datatype : none
            version : none
            default : none
            description : It will gives you clicked node data.
            */
        this.nodeClick = new i0.EventEmitter();
        /*
           Properties
           name : enable-checkbox
           datatype : false
           version : 4.0 onwards
           default : none
           description : Enables checkbox for each row, this allows user for multi selection.
           */
        this.enablecheckbox = false;
        /*
            Properties
            name : enable-drop
            datatype : boolean
            version : 5.0.0 onwards
            default : false
            description : any node can be dropped in the tree structure
            */
        this.enabledrop = false;
        /*
           Properties
           name : across-tree
           datatype : boolean
           version : 5.0.0 onwards
           default : false
           description : Dragging and dropping is possible across tree.
           */
        this.acrosstree = false;
        this.filtertreeflag = false;
        /*
            Events
            name : onTreeNodeChecked
            datatype : any
            version : 4.0 onwards
            default : none
            description : It will gives whole tree data with checked flag status.
            */
        this.onTreeNodeChecked = new i0.EventEmitter();
        this.onDrag = new i0.EventEmitter();
        this.onDrop = new i0.EventEmitter();
        this.dragover = new i0.EventEmitter();
        this.nodeRightClick = new i0.EventEmitter();
        this.rightClick = new i0.EventEmitter();
        this.mouseLocation = { left: 0, top: 0 };
        this.globalTreeData = [];
        this.isNode = true;
        this.acrosstree = false;
        this.displaykey = 'text';
        this.childarraykey = 'children';
    }
    Object.defineProperty(AmexioTreeViewComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.httpmethod && this.httpurl) {
            this.dataService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.setData(this.data);
        }
    };
    /**
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            if (_this.parentTmp != null) {
                _this.templates = { treeNodeTemplate: _this.parentTmp };
            }
            else if (_this.templates != null) {
                _this.parentTmp = _this.templates.treeNodeTemplate;
            }
        });
        this.cdf.detectChanges();
        this.componentLoaded = true;
    };
    /**
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (JSON.stringify(this.previousValue) !== JSON.stringify(this.data) && this.previousValue != null && this.data != null) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.expandAll = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.expandAllCall(this.parentRef);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.expandAllCall = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        node.forEach(function (childCheck) {
            if (!childCheck.expand) {
                childCheck.expand = true;
            }
            if (childCheck.hasOwnProperty(_this.childarraykey)) {
                _this.expandAllCall(childCheck[_this.childarraykey]);
            }
        });
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.collapseAll = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        this.collapseAllCall(this.parentRef);
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.collapseAllCall = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        node.forEach(function (childCheck) {
            if (childCheck.expand) {
                childCheck.expand = false;
            }
            if (childCheck.hasOwnProperty(_this.childarraykey)) {
                _this.collapseAllCall(childCheck[_this.childarraykey]);
            }
        });
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.onClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        node.expand = !node.expand;
    };
    /**
     * @param {?} event
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.onArrowDown = /**
     * @param {?} event
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    function (event, data, node, index) {
        var /** @type {?} */ incrementindex = index + 1;
        var /** @type {?} */ itemid = data[incrementindex];
        if (node.expand === true && node[this.childarraykey]) {
            var /** @type {?} */ data1 = node[this.childarraykey][0];
            this.setFocus(data1);
        }
        else {
            if (incrementindex < data.length) {
                this.setFocus(itemid);
            }
            else {
                this.focusTONextParent(node);
            }
        }
    };
    /**
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.onArrowUp = /**
     * @param {?} data
     * @param {?} node
     * @param {?} index
     * @return {?}
     */
    function (data, node, index) {
        var /** @type {?} */ newindex = index - 1;
        if (newindex >= 0) {
            var /** @type {?} */ previousindex = data[newindex];
            this.setFocus(previousindex);
            this.focusToInnerLastItem(previousindex);
        }
        else {
            var /** @type {?} */ id = node.elementId;
            var /** @type {?} */ spiltID = this.splitID(id);
            var /** @type {?} */ randomnumber = spiltID[0];
            var /** @type {?} */ currentid = spiltID[1];
            var /** @type {?} */ newid = parseInt(currentid.slice(0, -1), 10);
            var /** @type {?} */ id2 = newid;
            var /** @type {?} */ focusid1 = randomnumber + '-' + id2;
            if (document.getElementById(focusid1)) {
                document.getElementById(focusid1).focus();
            }
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.focusToInnerLastItem = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        if (node.hasOwnProperty('expand') && node.expand && node[this.childarraykey]) {
            node[this.childarraykey].forEach(function (innernode) {
                _this.focusToInnerLastItem(innernode);
            });
        }
        else {
            this.setFocus(node);
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.focusTONextParent = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var /** @type {?} */ sliceId = this.splitID(node.elementId);
        var /** @type {?} */ randomnumber = sliceId[0];
        var /** @type {?} */ currentid = sliceId[1];
        var /** @type {?} */ newid = parseInt(currentid.slice(0, -1), 10);
        var /** @type {?} */ currentitem = newid + 1;
        var /** @type {?} */ focusid1 = randomnumber + '-' + currentitem;
        if (document.getElementById(focusid1)) {
            document.getElementById(focusid1).focus();
        }
        else {
            var /** @type {?} */ nextnewid = parseInt(currentitem.toString().slice(0, -1), 10);
            var /** @type {?} */ id3 = nextnewid + 1;
            var /** @type {?} */ focusid2 = randomnumber + '-' + id3;
            if (document.getElementById(focusid2)) {
                document.getElementById(focusid2).focus();
            }
        }
    };
    /**
     * @param {?} id
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.splitID = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return id.split('-');
    };
    /**
     * @param {?} focuselement
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.setFocus = /**
     * @param {?} focuselement
     * @return {?}
     */
    function (focuselement) {
        if (document.getElementById(focuselement.elementId)) {
            document.getElementById(focuselement.elementId).focus();
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.onNodeClick = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var /** @type {?} */ cloneNode = JSON.parse(JSON.stringify(node));
        this.cloneMethod(cloneNode);
        this.nodeClick.emit(cloneNode);
        this.activateNode(this.data, node);
    };
    /**
     * @param {?} cloneNode
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.cloneMethod = /**
     * @param {?} cloneNode
     * @return {?}
     */
    function (cloneNode) {
        var _this = this;
        delete cloneNode['elementId'];
        if (cloneNode.children) {
            cloneNode.children.forEach(function (element) {
                _this.cloneMethod(element);
            });
        }
    };
    /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.generateIndex = /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    function (data, parentId, rannumber) {
        var _this = this;
        data.forEach(function (element, index) {
            element['elementId'] = '' + rannumber + '-' + parentId + (index + 1);
            if (element[_this.childarraykey]) {
                _this.generateIndex(element[_this.childarraykey], element.elementId.split('-')[1], rannumber);
            }
        });
    };
    /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.activateNode = /**
     * @param {?} data
     * @param {?} node
     * @return {?}
     */
    function (data, node) {
        for (var _i = 0, data_1 = data; _i < data_1.length; _i++) {
            var i = data_1[_i];
            if (node === data[i] && !i[this.childarraykey]) {
                i['active'] = true;
            }
            else {
                i['active'] = false;
            }
            if (i[this.childarraykey]) {
                this.activateNode(i[this.childarraykey], node);
            }
        }
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        // Check if key is added?
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        this.data = responsedata;
        this.parentRef = this.data;
        if (this.globalTreeData.length === 0 && !this.filtertreeflag) {
            this.globalTreeData = this.data;
            this.generateIndex(this.globalTreeData, 1, Math.floor(Math.random() * 1000 + 999 + 1));
        }
        this.setSelectedFlag();
        this.activateNode(this.data, null);
    };
    // To add isSelected flag explicitily in tree Data
    /**
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.setSelectedFlag = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.parentRef && this.parentRef.length > 0) {
            this.parentRef.forEach(function (node) {
                if (node) {
                    if (node.hasOwnProperty('isSelected')) {
                        node.isSelected = false;
                    }
                    else {
                        node['isSelected'] = false;
                    }
                    if (node.hasOwnProperty(_this.childarraykey) && node[_this.childarraykey] && node[_this.childarraykey].length > 0) {
                        _this.setSelectedFlagInChild(node);
                    }
                }
            });
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.setSelectedFlagInChild = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        var _this = this;
        if (node[this.childarraykey] && node[this.childarraykey].length > 0) {
            node[this.childarraykey].forEach(function (childcom) {
                if (childcom.hasOwnProperty('isSelected')) {
                    childcom.isSelected = false;
                }
                else {
                    childcom['isSelected'] = false;
                }
                if (childcom.hasOwnProperty(_this.childarraykey)
                    && childcom[_this.childarraykey] && childcom[_this.childarraykey].length > 0) {
                    _this.setSelectedFlagInChild(childcom);
                }
            });
        }
    };
    /**
     * @param {?} checkedData
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.emitCheckedData = /**
     * @param {?} checkedData
     * @return {?}
     */
    function (checkedData) {
        var _this = this;
        checkedData.checked = !checkedData.checked;
        if (checkedData.checked) {
            if (checkedData.hasOwnProperty(this.childarraykey)) {
                checkedData[this.childarraykey].forEach(function (option) {
                    option.checked = true;
                    if (option.hasOwnProperty(_this.childarraykey)) {
                        _this.setCheckedStatusFromParent(option);
                    }
                });
            }
            this.emitData(checkedData);
        }
        else {
            if (checkedData.hasOwnProperty(this.childarraykey)) {
                checkedData[this.childarraykey].forEach(function (option) {
                    option.checked = false;
                    if (option.hasOwnProperty(_this.childarraykey)) {
                        _this.searchObject(option);
                    }
                });
            }
            this.emitData(checkedData);
        }
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.emitData = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        var /** @type {?} */ obj = {};
        for (var _i = 0, _a = Object.entries(data); _i < _a.length; _i++) {
            var _b = _a[_i], key = _b[0], value = _b[1];
            if (key !== 'id') {
                obj[key] = value;
            }
        }
        this.onTreeNodeChecked.emit(obj);
    };
    /**
     * @param {?} object
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.searchObject = /**
     * @param {?} object
     * @return {?}
     */
    function (object) {
        var _this = this;
        object[this.childarraykey].forEach(function (childOption) {
            childOption.checked = false;
            if (childOption.hasOwnProperty(_this.childarraykey)) {
                _this.searchObject(childOption);
            }
        });
    };
    /**
     * @param {?} object
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.setCheckedStatusFromParent = /**
     * @param {?} object
     * @return {?}
     */
    function (object) {
        var _this = this;
        object[this.childarraykey].forEach(function (childOption) {
            childOption.checked = true;
            if (childOption.hasOwnProperty(_this.childarraykey)) {
                _this.setCheckedStatusFromParent(childOption);
            }
        });
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.onTreeNodeCheck = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.onTreeNodeChecked.emit(data);
    };
    // Method to drag parent with node
    /**
     * @param {?} dragData
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.onDragStart = /**
     * @param {?} dragData
     * @return {?}
     */
    function (dragData) {
        dragData.event.dataTransfer.setData('treenodedata', JSON.stringify(dragData.data));
        dragData.event.dataTransfer.effectAllowed = 'copy';
        this.dragData = dragData;
        this.onDrag.emit(dragData);
    };
    /**
     * @param {?} dragOverData
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.allowDrop = /**
     * @param {?} dragOverData
     * @return {?}
     */
    function (dragOverData) {
        dragOverData.event.preventDefault();
        if (!this.enabledrop) {
            dragOverData.event.dataTransfer.dropEffect = 'none';
        }
        this.noDragMethod(this.dragData, dragOverData.data, dragOverData.event);
        this.dragover.emit(dragOverData);
    };
    /**
     * @param {?} dragData
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.noDragMethod = /**
     * @param {?} dragData
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    function (dragData, node, event) {
        if (!this.acrosstree) {
            if (dragData.data === node || node.leaf === true) {
                event.dataTransfer.dropEffect = 'none';
            }
            else {
                event.target.style.border = '3px dotted green';
            }
        }
        else {
            if (node.leaf === true) {
                event.dataTransfer.dropEffect = 'none';
            }
            else {
                event.target.style.border = '3px dotted green';
            }
        }
        if (dragData.data.hasOwnProperty(this.childarraykey)) {
            this.getDropNode(dragData, node, event);
        }
    };
    /**
     * @param {?} dragData
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.getDropNode = /**
     * @param {?} dragData
     * @param {?} node
     * @param {?} event
     * @return {?}
     */
    function (dragData, node, event) {
        var _this = this;
        if (JSON.stringify(dragData.data) === JSON.stringify(node)) {
            event.dataTransfer.dropEffect = 'none';
        }
        else if (dragData.data[this.childarraykey] && dragData.data[this.childarraykey].length > 0) {
            dragData.data[this.childarraykey].forEach(function (child) {
                if (JSON.stringify(child) === JSON.stringify(node) || node.leaf === true) {
                    event.dataTransfer.dropEffect = 'none';
                }
                else if (child.hasOwnProperty(_this.childarraykey)) {
                    _this.getDropNode({ data: child, event1: event }, node, event);
                }
            });
        }
    };
    /**
     * @param {?} dropData
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.drop = /**
     * @param {?} dropData
     * @return {?}
     */
    function (dropData) {
        if (this.enabledrop) {
            dropData.event.target.style.border = '';
            dropData.event.preventDefault();
            if (this.acrosstree === false) {
                this.setDropAcrosstree(dropData);
                if (this.isNode === true) {
                    this.setDropNodeTree(dropData);
                }
            }
            else {
                if (dropData.data.hasOwnProperty(this.childarraykey)) {
                    this.removeNode(dropData);
                    dropData.data[this.childarraykey].push(JSON.parse(dropData.event.dataTransfer.getData('treenodedata')));
                    this.onDrop.emit(dropData);
                }
            }
        }
    };
    // drop method split into 2 other method setDropAcrosstree, setDropNodeTree
    // first method of drop
    /**
     * @param {?} dropData
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.setDropAcrosstree = /**
     * @param {?} dropData
     * @return {?}
     */
    function (dropData) {
        if (this.dragData.data === dropData.data) {
            this.isNode = false;
        }
        else if (this.dragData.data.hasOwnProperty(this.childarraykey)) {
            this.checkNode(this.dragData, dropData);
        }
    };
    // second method pf drop
    /**
     * @param {?} dropData
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.setDropNodeTree = /**
     * @param {?} dropData
     * @return {?}
     */
    function (dropData) {
        if (dropData.data.hasOwnProperty(this.childarraykey)) {
            this.removeNode(dropData);
            dropData.data[this.childarraykey].push(JSON.parse(dropData.event.dataTransfer.getData('treenodedata')));
            this.onDrop.emit(dropData);
        }
    };
    /**
     * @param {?} dragData
     * @param {?} dropData
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.checkNode = /**
     * @param {?} dragData
     * @param {?} dropData
     * @return {?}
     */
    function (dragData, dropData) {
        var _this = this;
        this.dragData.data[this.childarraykey].forEach(function (child) {
            if (JSON.stringify(child) === JSON.stringify(dropData.data)) {
                _this.isNode = false;
            }
            else if (child.hasOwnProperty(_this.childarraykey)) {
                _this.checkNode(child, dropData);
            }
        });
    };
    /**
     * @param {?} data
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.removeNode = /**
     * @param {?} data
     * @return {?}
     */
    function (data) {
        this.removeDragNode(this.parentRef, JSON.parse(data.event.dataTransfer.getData('treenodedata')));
    };
    /**
     * @param {?} treeData
     * @param {?} dragNode
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.removeDragNode = /**
     * @param {?} treeData
     * @param {?} dragNode
     * @return {?}
     */
    function (treeData, dragNode) {
        var _this = this;
        treeData.forEach(function (childNode, index) {
            if (JSON.stringify(childNode) === JSON.stringify(dragNode)) {
                treeData.splice(index, 1);
            }
            else if (childNode.hasOwnProperty(_this.childarraykey)) {
                _this.removeDragNode(childNode[_this.childarraykey], dragNode);
            }
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.dragleave = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        event.target.style.border = '';
    };
    /**
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.getContextMenu = /**
     * @return {?}
     */
    function () {
        if (this.contextmenu && this.contextmenu.length > 0) {
            this.flag = true;
            this.addListner();
        }
    };
    /**
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.resetFlag = /**
     * @return {?}
     */
    function () {
        if (this.flag) {
            this.flag = false;
            this.setSelectedFlag();
        }
    };
    /**
     * @param {?} rightClickData
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.loadContextMenu = /**
     * @param {?} rightClickData
     * @return {?}
     */
    function (rightClickData) {
        this.setSelectedFlag();
        this.mouseLocation.left = rightClickData.event.clientX;
        this.mouseLocation.top = rightClickData.event.clientY;
        rightClickData.data['isSelected'] = true;
        this.getContextMenu();
        this.posixUp = this.getListPosition(rightClickData.ref);
        if (this.contextmenu && this.contextmenu.length > 0) {
            rightClickData.event.preventDefault();
            rightClickData.event.stopPropagation();
        }
        this.rightClickNodeData = rightClickData.data;
        this.nodeRightClick.emit(rightClickData);
    };
    /**
     * @param {?} elementRef
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.getListPosition = /**
     * @param {?} elementRef
     * @return {?}
     */
    function (elementRef) {
        var /** @type {?} */ height = 240; // must be same in dropdown.scss
        if ((window.screen.height - elementRef.getBoundingClientRect().bottom) < height) {
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * @param {?} Data
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.rightClickDataEmit = /**
     * @param {?} Data
     * @return {?}
     */
    function (Data) {
        this.rightClick.emit(Data);
    };
    /**
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.addListner = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.globalClickListenFunc = this.renderer.listen('document', 'click', function (e) {
            _this.resetFlag();
            if (!_this.flag) {
                _this.removeListner();
            }
        });
    };
    /**
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.removeListner = /**
     * @return {?}
     */
    function () {
        if (this.globalClickListenFunc) {
            this.globalClickListenFunc();
        }
    };
    /**
     * @return {?}
     */
    AmexioTreeViewComponent.prototype.ngOnDestroy = /**
     * @return {?}
     */
    function () {
        this.removeListner();
    };
    AmexioTreeViewComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-treeview', template: "\n      <div *ngIf=\"data == null\" style=\"height: 300px;width: 300px;\">\n        <div class=\"spinner\"></div>\n      </div>\n\n      <div class=\"treenode\" *ngFor=\"let node of data let rowindex = index\">\n        <div #id class=\"treenode-content\" (click)=\"onClick(node)\" (keyup.enter)=\"onClick(node)\">\n          <div style=\"white-space:nowrap\">\n            <div  aria-label=\"Dropdown button clickable\" class=\"tree-node-label\" *ngIf=\"node[childarraykey] && (node[childarraykey].length>0)\">\n              <em class=\"fa\" [ngClass]=\"{'fa-angle-down':node.expand,'fa-angle-right':!node.expand}\"></em>\n            </div> &nbsp;\n            <div tabindex=\"1\" id={{node.elementId}} role=\"treeitem\" (keyup.arrowup)=\"onArrowUp(data,node,rowindex)\"\n              (keyup.arrowdown)=\"onArrowDown($event,data,node,rowindex)\" class=\"tree-node-label tree-node-label-hover\"\n              [attr.aria-expanded]=\"node.expand\" [ngClass]=\"{'tree-node-label-selected':node.isSelected ,'tree-node-label-not-selected':node.isSelected=='false'}\"\n              [attr.draggable]=\"enabledrag\" (dragleave)=\"dragleave($event)\" (drop)=\"drop({event:$event,data:node})\"\n              (dragover)=\"allowDrop({event:$event,data:node})\" (dragstart)=\"onDragStart({event:$event,data:node})\"\n              (contextmenu)=\"loadContextMenu({event:$event,data:node,ref:id})\">\n              <div class=\"tree-node-label\" *ngIf=\"enablecheckbox\">\n                <input type=\"checkbox\" [checked]=\"'checked'?node.checked:null\" (click)=\"emitCheckedData(node)\" />\n              </div>\n              <div class=\"tree-node-label\" (click)=\"onNodeClick(node)\">\n                <div class=\"tree-node-label\" *ngIf=\"templates == null\">\n                  <div class=\"tree-node-label\" *ngIf=\"node.icon\" [ngClass]=\"node.icon\" aria-hidden=\"true\" style=\"padding-right: 5px;\">\n                  </div>\n                  <div class=\"tree-node-label\">\n                    {{node[displaykey]}}\n                    <ng-container *ngIf=\"badge && node.badge\">\n                      <span class=\"tree-badge\">{{node.badge}}</span>\n                    </ng-container>\n                  </div>\n                </div>\n                <div class=\"tree-node-label\" *ngIf=\"templates != null\">\n                  <ng-template [ngTemplateOutlet]=\"templates.treeNodeTemplate\" [ngTemplateOutletContext]=\"{ $implicit: { text: node.text } , icon: node.icon,node : node }\">\n                  </ng-template>\n                </div>\n              </div>\n\n            </div>\n          </div>\n        </div>\n        <div class=\"treenode-children\" style=\"display: block;\" *ngIf=\"node.expand && node[childarraykey] && (node[childarraykey].length>0)\">\n          <amexio-treeview [child-array-key]=\"childarraykey\" [display-key]=\"displaykey\" [enable-drag]=\"enabledrag\"\n            [enable-drop]=\"enabledrop\" [data]=\"node[childarraykey]\"  [dragData]=\"dragData\" [parentRef]=\"parentRef\" (onDrag)=onDragStart($event)\n            (onDrop)=drop($event) (nodeClick)=\"onNodeClick($event)\" (dragleave)=\"($event)\" (nodeRightClick)=\"loadContextMenu($event)\"\n            [across-tree]=\"acrosstree\" [templates]=\"templates\"\n             [global-tree-data]=\"globalTreeData\"\n             [filter-tree-flag]=\"filtertreeflag\"\n             [enable-checkbox]=\"enablecheckbox\" [badge]=\"badge\"\n            (onTreeNodeChecked)=\"this.onTreeNodeCheck($event)\">\n          </amexio-treeview>\n        </div>\n      </div>\n      <ng-container *ngIf=\"flag\">\n        <base-contextmenu [base-context-menu]=\"contextmenu\" [mouse-location-top]=\"mouseLocation.top\" [mouse-location-left]=\"mouseLocation.left\"\n          [is-FlagShow]=\"flag\" [right-click-data]=\"rightClickNodeData\" (onRightClick)=\"rightClickDataEmit($event)\"\n          [position-up]=\"posixUp\">\n        </base-contextmenu>\n      </ng-container>\n    ",
                },] },
    ];
    /** @nocollapse */
    AmexioTreeViewComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: CommonDataService },
        { type: i0.ChangeDetectorRef },
        { type: i0.Renderer2 }
    ]; };
    AmexioTreeViewComponent.propDecorators = {
        data: [{ type: i0.Input, args: ['data',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        displaykey: [{ type: i0.Input, args: ['display-key',] }],
        childarraykey: [{ type: i0.Input, args: ['child-array-key',] }],
        nodeClick: [{ type: i0.Output }],
        enablecheckbox: [{ type: i0.Input, args: ['enable-checkbox',] }],
        templates: [{ type: i0.Input }],
        enabledrag: [{ type: i0.Input, args: ['enable-drag',] }],
        enabledrop: [{ type: i0.Input, args: ['enable-drop',] }],
        acrosstree: [{ type: i0.Input, args: ['across-tree',] }],
        badge: [{ type: i0.Input, args: ['badge',] }],
        contextmenu: [{ type: i0.Input, args: ['context-menu',] }],
        parentRef: [{ type: i0.Input }],
        filtertreeflag: [{ type: i0.Input, args: ['filter-tree-flag',] }],
        parentTmp: [{ type: i0.ContentChild, args: ['amexioTreeTemplate',] }],
        onTreeNodeChecked: [{ type: i0.Output }],
        onDrag: [{ type: i0.Output }],
        onDrop: [{ type: i0.Output }],
        dragover: [{ type: i0.Output }],
        dragData: [{ type: i0.Input }],
        nodeRightClick: [{ type: i0.Output }],
        rightClick: [{ type: i0.Output }],
        globalTreeData: [{ type: i0.Input, args: ['global-tree-data',] }]
    };
    return AmexioTreeViewComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TreeDataTableComponent = /** @class */ (function () {
    function TreeDataTableComponent(treeDataTableService) {
        this.treeDataTableService = treeDataTableService;
        /*
           Events
           name : selectedRecord
           datatype : none
           version : none
           default : none
           description : Get selected value Object.
           */
        this.selectedRecord = new i0.EventEmitter();
        this.rowSelect = new i0.EventEmitter();
        this.columns = [];
        this.mask = true;
    }
    Object.defineProperty(TreeDataTableComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} value
         * @return {?}
         */
        function (value) {
            this._data = value;
            if (this.componentLoaded) {
                this.updateComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TreeDataTableComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.httpmethod && this.httpurl) {
            this.treeDataTableService.fetchData(this.httpurl, this.httpmethod).subscribe(function (response) {
                _this.responseData = response;
            }, function (error) {
            }, function () {
                _this.setData(_this.responseData);
            });
        }
        else if (this.data) {
            this.previousValue = JSON.parse(JSON.stringify(this.data));
            this.setData(this.data);
        }
    };
    /**
     * @return {?}
     */
    TreeDataTableComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.onResize();
        this.componentLoaded = true;
    };
    /**
     * @return {?}
     */
    TreeDataTableComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.createConfig();
    };
    /**
     * @return {?}
     */
    TreeDataTableComponent.prototype.createConfig = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ columnRefArray = this.columnRef.toArray();
        for (var _i = 0, columnRefArray_1 = columnRefArray; _i < columnRefArray_1.length; _i++) {
            var cr = columnRefArray_1[_i];
            var /** @type {?} */ columnConfig = cr;
            var /** @type {?} */ columnData = void 0;
            if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate != null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    headerTemplate: columnConfig.headerTemplate,
                    width: columnConfig.width,
                    bodyTemplate: columnConfig.bodyTemplate,
                };
            }
            else if (columnConfig.headerTemplate != null && columnConfig.bodyTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    headerTemplate: columnConfig.headerTemplate,
                };
            }
            else if (columnConfig.bodyTemplate != null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    datatype: columnConfig.datatype,
                    width: columnConfig.width,
                    bodyTemplate: columnConfig.bodyTemplate,
                };
            }
            else if (columnConfig.bodyTemplate == null && columnConfig.headerTemplate == null) {
                columnData = {
                    text: columnConfig.text,
                    dataindex: columnConfig.dataindex,
                    hidden: columnConfig.hidden,
                    width: columnConfig.width,
                    datatype: columnConfig.datatype,
                };
            }
            this.columns.push(columnData);
        }
    };
    /**
     * @return {?}
     */
    TreeDataTableComponent.prototype.updateComponent = /**
     * @return {?}
     */
    function () {
        if (this.data) {
            this.viewRows = this.getResponseData(this.data);
        }
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    TreeDataTableComponent.prototype.setData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var _this = this;
        if (httpResponse) {
            var /** @type {?} */ treedata = this.getResponseData(httpResponse);
            this.viewRows = treedata;
            this.viewRows.forEach(function (row, index) {
                _this.viewRows[index].level = 1;
                _this.viewRows[index].expanded = false;
            });
            this.mask = false;
        }
        else {
            this.viewRows = [];
        }
        this.generateIndex(this.viewRows, 1, Math.floor(Math.random() * 1000 + 999 + 1));
    };
    /**
     * @param {?} httpResponse
     * @return {?}
     */
    TreeDataTableComponent.prototype.getResponseData = /**
     * @param {?} httpResponse
     * @return {?}
     */
    function (httpResponse) {
        var /** @type {?} */ responsedata = httpResponse;
        if (this.datareader != null) {
            var /** @type {?} */ dr = this.datareader.split('.');
            for (var _i = 0, dr_1 = dr; _i < dr_1.length; _i++) {
                var ir = dr_1[_i];
                responsedata = responsedata[ir];
            }
        }
        else {
            responsedata = httpResponse;
        }
        return responsedata;
    };
    /**
     * @return {?}
     */
    TreeDataTableComponent.prototype.removeAll = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.viewRows.forEach(function (node) {
            node.expanded = false;
            _this.removeRows(node);
        });
    };
    /**
     * @return {?}
     */
    TreeDataTableComponent.prototype.expandAll = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.viewRows.forEach(function (node, index) {
            node.expanded = true;
            _this.addRows(node, index);
        });
    };
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    TreeDataTableComponent.prototype.toogle = /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    function (row, index) {
        row.expanded = !row.expanded;
        if (row.expanded) {
            this.addRows(row, index);
        }
        else {
            this.removeRows(row);
        }
    };
    /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    TreeDataTableComponent.prototype.addRows = /**
     * @param {?} row
     * @param {?} index
     * @return {?}
     */
    function (row, index) {
        if (row.children) {
            for (var /** @type {?} */ i = 0; i < row.children.length; i++) {
                var /** @type {?} */ node = row.children[i];
                if (!row.level) {
                    row.level = 1;
                }
                if (node.children) {
                    node.expanded = false;
                }
                node.level = (row.level + 1);
                this.viewRows.splice(index + (i + 1), 0, node);
            }
        }
    };
    /**
     * @param {?} node
     * @return {?}
     */
    TreeDataTableComponent.prototype.removeRows = /**
     * @param {?} node
     * @return {?}
     */
    function (node) {
        if (node.children) {
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var nc = _a[_i];
                if (this.viewRows) {
                    this.setRemovedRows(nc);
                }
            }
        }
    };
    /**
     * @param {?} nc
     * @return {?}
     */
    TreeDataTableComponent.prototype.setRemovedRows = /**
     * @param {?} nc
     * @return {?}
     */
    function (nc) {
        for (var _i = 0, _a = this.viewRows; _i < _a.length; _i++) {
            var vr = _a[_i];
            if (vr === nc) {
                if (nc.children) {
                    this.removeRows(nc);
                }
                this.viewRows.splice(this.viewRows.indexOf(nc), 1);
            }
        }
    };
    /**
     * @param {?} rowData
     * @param {?} event
     * @return {?}
     */
    TreeDataTableComponent.prototype.setSelectedRow = /**
     * @param {?} rowData
     * @param {?} event
     * @return {?}
     */
    function (rowData, event) {
        this.selectedRecord.emit(rowData);
        this.rowSelect.emit(rowData);
    };
    /**
     * @return {?}
     */
    TreeDataTableComponent.prototype.onResize = /**
     * @return {?}
     */
    function () {
        if (this.height) {
            var /** @type {?} */ h = (window.innerHeight / 100) * this.height;
            if (this.gridHeader && this.gridHeader.nativeElement && this.gridHeader.nativeElement.offsetHeight) {
                h = h - this.gridHeader.nativeElement.offsetHeight;
            }
            if (this.height === 100) {
                h = h - 40;
            }
            this.height = h;
        }
    };
    // Tab Navigation
    /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    TreeDataTableComponent.prototype.generateIndex = /**
     * @param {?} data
     * @param {?} parentId
     * @param {?} rannumber
     * @return {?}
     */
    function (data, parentId, rannumber) {
        var _this = this;
        data.forEach(function (element, index) {
            element['id'] = '' + rannumber + '-';
            if (element['children']) {
                _this.generateIndex(element['children'], element.id.split('-')[1], rannumber);
            }
        });
    };
    /**
     * @param {?} id
     * @return {?}
     */
    TreeDataTableComponent.prototype.splitID = /**
     * @param {?} id
     * @return {?}
     */
    function (id) {
        return id.split('-');
    };
    /**
     * @param {?} ref
     * @return {?}
     */
    TreeDataTableComponent.prototype.arrowUp = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ id = ref.id;
        var /** @type {?} */ spiltID = this.splitID(id);
        var /** @type {?} */ randomNo = spiltID[0];
        var /** @type {?} */ currentId = spiltID[1];
        var /** @type {?} */ unitId = currentId.slice(0, -1);
        if (unitId > 1 && document.getElementById(randomNo + '-' + (parseInt(currentId, 10) - 10).toString())) {
            document.getElementById(randomNo + '-' + (parseInt(currentId, 10) - 10).toString()).focus();
        }
    };
    /**
     * @param {?} ref
     * @return {?}
     */
    TreeDataTableComponent.prototype.arrowDown = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ id = ref.id;
        var /** @type {?} */ spiltID = this.splitID(id);
        var /** @type {?} */ randomNo = spiltID[0];
        var /** @type {?} */ currentId = spiltID[1];
        var /** @type {?} */ firstId = parseInt(currentId.slice(0, -1), 10);
        if ((firstId < this.viewRows.length || (firstId <= this.viewRows.length - 1))
            && document.getElementById(randomNo + '-' + (parseInt(currentId, 10) + 10).toString())) {
            document.getElementById(randomNo + '-' + (parseInt(currentId, 10) + 10).toString()).focus();
        }
    };
    /**
     * @param {?} ref
     * @return {?}
     */
    TreeDataTableComponent.prototype.arrowRight = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ id = ref.id;
        var /** @type {?} */ spiltID = this.splitID(id);
        var /** @type {?} */ randomNo = spiltID[0];
        var /** @type {?} */ currentId = spiltID[1];
        var /** @type {?} */ unitId = parseInt(currentId, 10) % 10;
        var /** @type {?} */ firstId = currentId.slice(0, -1);
        this.findNextColumn(unitId, firstId, randomNo);
    };
    /**
     * @param {?} index
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    TreeDataTableComponent.prototype.findNextColumn = /**
     * @param {?} index
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    function (index, firstId, randomNo) {
        if (index < this.columns.length) {
            if (this.columns.length >= 1 && this.columns.includes(index + 1)) {
                index = index + 1;
                this.findNextColumn(index, firstId, randomNo);
            }
            else {
                var /** @type {?} */ generatedId = firstId + '' + (index + 1);
                document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
            }
        }
    };
    /**
     * @param {?} ref
     * @return {?}
     */
    TreeDataTableComponent.prototype.arrowLeft = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ id = ref.id;
        var /** @type {?} */ spiltID = this.splitID(id);
        var /** @type {?} */ randomNo = spiltID[0];
        var /** @type {?} */ currentId = spiltID[1];
        var /** @type {?} */ unitId = parseInt(currentId, 10) % 10;
        var /** @type {?} */ firstId = currentId.slice(0, -1);
        this.findPreviousColumn(unitId, firstId, randomNo);
    };
    /**
     * @param {?} index
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    TreeDataTableComponent.prototype.findPreviousColumn = /**
     * @param {?} index
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    function (index, firstId, randomNo) {
        if (index > 1) {
            if (this.columns.length >= 1 && this.columns.includes(index - 1)) {
                index = index - 1;
                this.findPreviousColumn(index, firstId, randomNo);
            }
            else {
                var /** @type {?} */ generatedId = firstId + '' + (index - 1);
                document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
            }
        }
    };
    // HOME
    /**
     * @param {?} ref
     * @return {?}
     */
    TreeDataTableComponent.prototype.keyHome = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ id = ref.id;
        var /** @type {?} */ spiltID = this.splitID(id);
        var /** @type {?} */ randomNo = spiltID[0];
        var /** @type {?} */ currentId = spiltID[1];
        var /** @type {?} */ unitId = parseInt(currentId, 10) % 10;
        this.findHomeColumn(unitId, currentId.slice(0, -1), 1, randomNo);
    };
    // HOME: TO FIND FIRST COLUMN
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} newFirstId
     * @param {?} randomNo
     * @return {?}
     */
    TreeDataTableComponent.prototype.findHomeColumn = /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} newFirstId
     * @param {?} randomNo
     * @return {?}
     */
    function (unitId, firstId, newFirstId, randomNo) {
        if (this.columns.length >= 1 && this.columns.includes(newFirstId)) {
            this.findHomeColumn(unitId, firstId, newFirstId + 1, randomNo);
        }
        else {
            var /** @type {?} */ generatedId = firstId + '' + newFirstId;
            document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    };
    // END
    /**
     * @param {?} ref
     * @return {?}
     */
    TreeDataTableComponent.prototype.keyEnd = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ id = ref.id;
        var /** @type {?} */ spiltID = this.splitID(id);
        var /** @type {?} */ randomNo = spiltID[0];
        var /** @type {?} */ currentId = spiltID[1];
        var /** @type {?} */ unitId = parseInt(currentId, 10) % 10;
        var /** @type {?} */ firstId = currentId.slice(0, -1);
        var /** @type {?} */ newLastId = this.columns.length;
        this.findHomeColumn(unitId, firstId, newLastId, randomNo);
    };
    /**
     * @param {?} ref
     * @return {?}
     */
    TreeDataTableComponent.prototype.keyControlHome = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ id = ref.id;
        var /** @type {?} */ spiltID = this.splitID(id);
        var /** @type {?} */ randomNo = spiltID[0];
        this.findControlHomeColumn(1, 1, randomNo);
    };
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    TreeDataTableComponent.prototype.findControlHomeColumn = /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    function (unitId, firstId, randomNo) {
        if (this.columns.length >= 1 && this.columns.includes(unitId)) {
            this.findControlHomeColumn(unitId + 1, firstId, randomNo);
        }
        else {
            var /** @type {?} */ generatedId = firstId + '' + unitId;
            document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    };
    /**
     * @param {?} ref
     * @return {?}
     */
    TreeDataTableComponent.prototype.keyControlEnd = /**
     * @param {?} ref
     * @return {?}
     */
    function (ref) {
        var /** @type {?} */ id = ref.id;
        var /** @type {?} */ spiltID = this.splitID(id);
        var /** @type {?} */ randomNo = spiltID[0];
        var /** @type {?} */ unitId = this.columns.length;
        var /** @type {?} */ firstId = this.viewRows.length;
        this.findControlEndColumn(unitId, firstId, randomNo);
    };
    /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    TreeDataTableComponent.prototype.findControlEndColumn = /**
     * @param {?} unitId
     * @param {?} firstId
     * @param {?} randomNo
     * @return {?}
     */
    function (unitId, firstId, randomNo) {
        if (this.columns.length >= 1 && this.columns.includes(unitId)) {
            this.findControlHomeColumn(unitId - 1, firstId, randomNo);
        }
        else {
            var /** @type {?} */ generatedId = firstId + '' + unitId;
            document.getElementById(randomNo + '-' + (parseInt(generatedId, 10)).toString()).focus();
        }
    };
    TreeDataTableComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-tree-data-table',
                    template: "\n    <div (window:resize)=\"onResize()\">\n        <div #header class=\"datatable\">\n            <div class=\"datatable-header\">\n                <ng-container *ngFor=\"let cols of columns;let i = index\">\n                    <ng-container *ngIf=\"cols.datatype=='string'\">\n                        <div class=\"datatable-col\" tabindex = \"1\" [ngClass]=\"{'header' : i == 0}\" [style.width.%]=\"cols.width\">\n                            <ng-container *ngIf=\"cols.headerTemplate\">\n                                <ng-template [ngTemplateOutlet]=\"cols.headerTemplate\" [ngTemplateOutletContext]=\"{column:cols ,index: i}\"></ng-template>\n                            </ng-container>\n                            <ng-container *ngIf=\"!cols.headerTemplate\">\n                                {{cols.text}}\n                            </ng-container>\n                        </div>\n                    </ng-container>\n                    <ng-container *ngIf=\"cols.datatype=='number'\">\n                        <ng-container *ngIf=\"cols.headerTemplate\">\n                            <ng-template [ngTemplateOutlet]=\"cols.headerTemplate\" [ngTemplateOutletContext]=\"{column:cols ,index: i}\"></ng-template>\n                        </ng-container>\n                        <ng-container *ngIf=\"!cols.headerTemplate\">\n                            <span class=\"float-right\">\n                                <div class=\"datatable-col\" tabindex = \"1\" [style.width.%]=\"cols.width\" [ngClass]=\"{'header' : i == 0}\"> {{cols.text}}</div>\n                            </span>\n                        </ng-container>\n\n                    </ng-container>\n                </ng-container>\n            </div>\n        </div>\n\n        <div class=\"datatable-height\" [style.height.px]=\"height\">\n            <div class=\"datatable\">\n                <div style=\"height: 300px;\" *ngIf=\"mask\">\n                    <div class=\"spinner\"></div>\n                </div>\n                <ng-container *ngIf=\"!mask\">\n                    <div class=\"datatable-row\" (click)=\"toogle(row,i)\" *ngFor=\"let row of viewRows;let i=index\"  (click)=\"setSelectedRow(row, $event)\">\n                        <ng-container *ngFor=\"let cols of columns;let colIndex = index\">\n                            <ng-container *ngIf=\"cols.datatype=='string' && !cols?.bodyTemplate\">\n                                <div #ref id=\"{{row.id}}{{i+1}}{{colIndex+1}}\" [attr.tabindex] = \"(((i+1== 1) && (colIndex + 1 == 1))? 1: -1)\" (keyup.enter)=\"toogle(row,i)\" (keyup.enter)=\"setSelectedRow(row, $event)\" \n                                class=\"datatable-col\" (keyup.arrowright)=\"arrowRight(ref)\" (keyup.arrowleft)=\"arrowLeft(ref)\" (keyup.arrowup)=\"arrowUp(ref)\" (keyup.arrowdown)=\"arrowDown(ref)\" \n                                (keyup.end)=\"keyEnd(ref)\" (keyup.home)=\"keyHome(ref)\" (keyup.control.end)=\"keyControlEnd(ref)\" (keyup.control.home)=\"keyControlHome(ref)\"\n                                [attr.data-label]=\"cols.text\" [style.width.%]=\"cols.width\">\n                                    <ng-container *ngIf=\"colIndex == 0\">\n                                        <span [style.padding-left.px]=\"(!row.level || row.level <= 1? 10 : (10+(10*row.level)) )\">\n                                            <ng-container *ngIf=\"!row.expanded && row.children\">\n                                                <amexio-c-icon class=\"iconPaddingStyle\" key=\"tree_collapse\"></amexio-c-icon>\n                                            </ng-container>\n                                            <ng-container *ngIf=\"row.expanded && row.children\">\n                                                <amexio-c-icon class=\"iconPaddingStyle\" key=\"tree_expand\"></amexio-c-icon>\n                                            </ng-container>\n                                            <ng-container *ngIf=\"row[cols.dataindex]!= null && row[cols.dataindex]!= '' ;else elseBlock\">\n                                                {{row[cols.dataindex]}} \n                                            </ng-container>\n                                            <ng-template #elseBlock>\n                                                &nbsp;\n                                            </ng-template>\n                                        </span>\n                                    </ng-container>\n\n                                    <ng-container *ngIf=\"colIndex > 0\">\n                                        <ng-container *ngIf=\"row[cols.dataindex]!= null && row[cols.dataindex]!= '' ;else elseBlock\">\n                                            {{row[cols.dataindex]}}\n                                        </ng-container>\n                                        <ng-template #elseBlock>\n                                            &nbsp;\n                                        </ng-template>\n                                    </ng-container>\n                                </div>\n                            </ng-container>\n                            <ng-container *ngIf=\"cols.datatype=='number' && !cols?.bodyTemplate\">\n                                <div #ref class=\"datatable-col\" id=\"{{row.id}}{{i+1}}{{colIndex+1}}\" \n                                (keyup.end)=\"keyEnd(ref)\" (keyup.home)=\"keyHome(ref)\" (keyup.control.end)=\"keyControlEnd(ref)\" (keyup.control.home)=\"keyControlHome(ref)\"\n                                (keyup.arrowright)=\"arrowRight(ref)\" (keyup.arrowleft)=\"arrowLeft(ref)\" (keyup.arrowup)=\"arrowUp(ref)\" (keyup.arrowdown)=\"arrowDown(ref)\"\n                                 [attr.tabindex] = \"(((i+1== 1) && (colIndex + 1 == 1))? 1: -1)\" (keyup.enter)=\"toogle(row,i)\" (keyup.enter)=\"setSelectedRow(row, $event)\" [attr.data-label]=\"cols.text\" [style.width.%]=\"cols.width\">\n                                    <ng-container *ngIf=\"colIndex == 0\">\n                                        <span  [style.padding-left.px]=\"(!row.level || row.level <= 1? 10 : (10+(10*row.level)) )\">\n                                            <ng-container *ngIf=\"!row.expanded && row.children\">\n                                                <amexio-c-icon class=\"iconPaddingStyle\" key=\"tree_collapse\"></amexio-c-icon>\n                                            </ng-container>\n                                            <ng-container *ngIf=\"row.expanded && row.children\">\n                                                <amexio-c-icon class=\"iconPaddingStyle\" key=\"tree_expand\"></amexio-c-icon>\n                                            </ng-container>\n                                            <span class=\"float-right\">\n                                                <ng-container *ngIf=\"row[cols.dataindex]!= null;else elseBlock\">\n                                                    {{row[cols.dataindex]}}\n                                                </ng-container>\n                                                <ng-template #elseBlock>\n                                                    &nbsp;\n                                                </ng-template>\n                                            </span>\n                                        </span>\n                                    </ng-container>\n\n                                    <ng-container *ngIf=\"colIndex > 0\">\n                                        <span class=\"float-right\">\n                                            <ng-container *ngIf=\"row[cols.dataindex]!= null;else elseBlock\">\n                                                {{row[cols.dataindex]}}\n                                            </ng-container>\n                                            <ng-template #elseBlock>\n                                                &nbsp;\n                                            </ng-template>\n                                        </span>\n                                    </ng-container>\n                                </div>\n\n                            </ng-container>\n\n                            <ng-container *ngIf=\"cols.bodyTemplate\">\n\n                                <div #ref class=\"datatable-col\"  id=\"{{row.id}}{{i+1}}{{colIndex+1}}\" \n                                (keyup.end)=\"keyEnd(ref)\" (keyup.home)=\"keyHome(ref)\" (keyup.control.end)=\"keyControlEnd(ref)\" (keyup.control.home)=\"keyControlHome(ref)\"\n                                (keyup.arrowright)=\"arrowRight(ref)\" (keyup.arrowleft)=\"arrowLeft(ref)\" (keyup.arrowup)=\"arrowUp(ref)\" (keyup.arrowdown)=\"arrowDown(ref)\"\n                                [attr.tabindex] = \"(((i+1== 1) && (colIndex + 1 == 1))? 1: -1)\" (keyup.enter)=\"toogle(row,i)\" (keyup.enter)=\"setSelectedRow(row, $event)\"\n                                 [attr.data-label]=\"cols.text\" [style.width.%]=\"cols.width\">\n                                    <ng-container *ngIf=\"colIndex == 0\">\n                                        <span  [style.padding-left.px]=\"(!row.level || row.level <= 1? 10 : (10+(10*row.level)) )\">\n                                            <ng-container *ngIf=\"!row.expanded && row.children\">\n                                                <amexio-c-icon class=\"iconPaddingStyle\" key=\"tree_collapse\"></amexio-c-icon>\n                                            </ng-container>\n                                            <ng-container *ngIf=\"row.expanded && row.children\">\n                                                <amexio-c-icon class=\"iconPaddingStyle\" key=\"tree_expand\"></amexio-c-icon>\n                                            </ng-container>\n                                            <ng-template [ngTemplateOutlet]=\"cols.bodyTemplate\" [ngTemplateOutletContext]=\"{ $implicit: { text : row[cols.dataindex] }, row: row }\"></ng-template>\n                                        </span>\n                                    </ng-container>\n\n                                    <ng-container *ngIf=\"colIndex > 0\">\n                                        <ng-template [ngTemplateOutlet]=\"cols.bodyTemplate\" [ngTemplateOutletContext]=\"{ $implicit: { text : row[cols.dataindex] }, row: row }\"></ng-template>\n                                    </ng-container>\n\n                                </div>\n                            </ng-container>\n\n                        </ng-container>\n\n                    </div>\n                </ng-container>\n\n            </div>\n        </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    TreeDataTableComponent.ctorParameters = function () { return [
        { type: CommonDataService }
    ]; };
    TreeDataTableComponent.propDecorators = {
        data: [{ type: i0.Input, args: ['data',] }],
        datareader: [{ type: i0.Input, args: ['data-reader',] }],
        httpmethod: [{ type: i0.Input, args: ['http-method',] }],
        httpurl: [{ type: i0.Input, args: ['http-url',] }],
        displayfield: [{ type: i0.Input, args: ['display-field',] }],
        valuefield: [{ type: i0.Input, args: ['value-field',] }],
        selectedRecord: [{ type: i0.Output }],
        height: [{ type: i0.Input }],
        gridHeader: [{ type: i0.ViewChild, args: ['header', { read: i0.ElementRef },] }],
        rowSelect: [{ type: i0.Output }],
        columnRef: [{ type: i0.ContentChildren, args: [AmexioGridColumnComponent,] }]
    };
    return TreeDataTableComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DATA_COMPONENTS = [
    AmexioTreeViewComponent,
    AmexioListBoxComponent,
    AmexioDatagridComponent,
    AmexioDataGridHeaderComponent,
    AmexioGoogleMapComponent,
    DataGridFilterComponent,
    AmexioPaginatorComponent,
    AmexioGridColumnComponent,
    PropertyGridComponent,
    AmexioProgressMultiBarComponent,
    AmexioProgressBarComponent,
    HorizontalTreeViewNodeComponent,
    HorizontalTreeViewComponent,
    AmexioFilterTreeComponent,
    TreeDataTableComponent,
    AmexioItemSelectorComponent,
];
var AmexioDataModule = /** @class */ (function () {
    function AmexioDataModule() {
    }
    /**
     * @return {?}
     */
    AmexioDataModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioDataModule,
            providers: [CommonDataService, GoogleMapScriptService],
        };
    };
    AmexioDataModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        AmexioPaneModule,
                        AmexioLayoutModule,
                        HttpClientModule,
                        AmexioBaseContextMenuModule,
                        AmexioCommonModule.forRoot(),
                    ],
                    exports: DATA_COMPONENTS,
                    declarations: DATA_COMPONENTS,
                    providers: [CommonDataService, GoogleMapScriptService],
                },] },
    ];
    return AmexioDataModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/** @enum {string} */
var Icon = {
    fontawesome: 'fa',
    material: 'mat',
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioGridModel = /** @class */ (function () {
    function AmexioGridModel() {
        this.name = '';
        this.desktop = [];
        this.mobile = [];
        this.tab = [];
        this.layoutType = '';
        this.count = 0;
    }
    return AmexioGridModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var GridConfig = /** @class */ (function () {
    function GridConfig(layoutName, layoutType) {
        this.amexiogridmodel = new AmexioGridModel();
        this.amexiogridmodel.layoutType = layoutType;
        this.amexiogridmodel.name = layoutName;
        return this;
    }
    /**
     * @param {?} layout
     * @return {?}
     */
    GridConfig.prototype.addlayout = /**
     * @param {?} layout
     * @return {?}
     */
    function (layout) {
        this.count = layout.length;
        if (this.amexiogridmodel.layoutType === '') {
            this.amexiogridmodel.layoutType = GridConstants.Desktop;
        }
        this.amexiogridmodel[this.amexiogridmodel.layoutType].push(layout);
        return this;
    };
    /**
     * @return {?}
     */
    GridConfig.prototype.getLayout = /**
     * @return {?}
     */
    function () {
        return this.amexiogridmodel;
    };
    return GridConfig;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var GoogleMapOverlays = /** @class */ (function () {
    function GoogleMapOverlays(_lat, _lng, _title, _showtitle, _icon, _data) {
        this.lat = _lat;
        this.lng = _lng;
        this.title = _title;
        this.showtitle = _showtitle;
        this.icon = _icon;
        this.data = (_data) ? _data : {};
    }
    return GoogleMapOverlays;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AvailableSlotsModel = /** @class */ (function () {
    function AvailableSlotsModel(datetime, data) {
        this.datetime = datetime;
        this.data = data;
    }
    return AvailableSlotsModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DayModel = /** @class */ (function () {
    function DayModel(date, twentyfourformat, availableSlots) {
        this.date = date;
        this.twentyfourformat = twentyfourformat;
        this.availableSlots = availableSlots;
    }
    /**
     * @param {?} timeslots
     * @return {?}
     */
    DayModel.prototype.setTimeSlots = /**
     * @param {?} timeslots
     * @return {?}
     */
    function (timeslots) {
        this.timeslots = timeslots;
        this.markTimeSlots();
    };
    /**
     * @return {?}
     */
    DayModel.prototype.markTimeSlots = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.availableSlots) {
            this.availableSlots.forEach(function (slot) {
                if (slot.datetime.getDate() === _this.date.getDate()
                    && slot.datetime.getMonth() === _this.date.getMonth()
                    && slot.datetime.getFullYear() === _this.date.getFullYear()) {
                    slot.data.forEach(function (time) {
                        _this.checkTimeSlots(time);
                    });
                }
            });
        }
    };
    /**
     * @param {?} time
     * @return {?}
     */
    DayModel.prototype.checkTimeSlots = /**
     * @param {?} time
     * @return {?}
     */
    function (time) {
        this.timeslots.forEach(function (timeModel) {
            if (time === timeModel.timeId) {
                timeModel.available = true;
                return true;
            }
        });
        return false;
    };
    return DayModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TimeModel = /** @class */ (function () {
    function TimeModel(_id, _time) {
        this.available = false;
        this.selected = false;
        this.selectedStyleClass = '';
        this.availableStyleClass = '';
        this.timeId = _id;
        this.time = _time;
    }
    return TimeModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TimeUtil = /** @class */ (function () {
    function TimeUtil() {
    }
    /**
     * @param {?} twentfourhourformatdata
     * @return {?}
     */
    TimeUtil.prototype.timeData = /**
     * @param {?} twentfourhourformatdata
     * @return {?}
     */
    function (twentfourhourformatdata) {
        if (twentfourhourformatdata) {
            return this.twentfourhourformatdata();
        }
        else {
            return this.ampmdata();
        }
    };
    /**
     * @return {?}
     */
    TimeUtil.prototype.twentfourhourformatdata = /**
     * @return {?}
     */
    function () {
        return this.data(':00');
    };
    /**
     * @return {?}
     */
    TimeUtil.prototype.ampmdata = /**
     * @return {?}
     */
    function () {
        return this.data(' am');
    };
    /**
     * @param {?} appender
     * @return {?}
     */
    TimeUtil.prototype.data = /**
     * @param {?} appender
     * @return {?}
     */
    function (appender) {
        var /** @type {?} */ timemodels = [];
        for (var /** @type {?} */ i = 0; i < 10; i++) {
            timemodels.push(new TimeModel(i, '0' + i + appender));
        }
        for (var /** @type {?} */ i = 10; i < 25; i++) {
            timemodels.push(new TimeModel(i, i + appender));
        }
        return timemodels;
    };
    /**
     * @return {?}
     */
    TimeUtil.prototype.workingslot1 = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ timemodels = [];
        timemodels.push(new TimeModel(10, '10 am'));
        timemodels.push(new TimeModel(11, '11 am'));
        timemodels.push(new TimeModel(12, '12 pm'));
        timemodels.push(new TimeModel(13, '01 pm'));
        timemodels.push(new TimeModel(14, '02 pm'));
        timemodels.push(new TimeModel(15, '03 pm'));
        timemodels.push(new TimeModel(16, '04 pm'));
        timemodels.push(new TimeModel(17, '05 pm'));
        timemodels.push(new TimeModel(18, '06 pm'));
        return timemodels;
    };
    return TimeUtil;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PropertyGridModel = /** @class */ (function () {
    function PropertyGridModel(_fieldName, _fieldValue, _fieldIcon, _onlyIcon, _link, _data) {
        this.fieldName = _fieldName;
        this.fieldValue = _fieldValue;
        this.fieldIcon = _fieldIcon;
        this.onlyIcon = _onlyIcon;
        this.link = _link;
        this.data = _data;
    }
    return PropertyGridModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioWidgetModule = /** @class */ (function () {
    function AmexioWidgetModule() {
    }
    /**
     * @return {?}
     */
    AmexioWidgetModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioWidgetModule,
            providers: [CommonDataService, DeviceQueryService, IconLoaderService],
        };
    };
    AmexioWidgetModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        AmexioFormsModule,
                        AmexioNavModule,
                        AmexioDataModule,
                        AmexioLayoutModule,
                        AmexioMediaModule,
                        AmexioPaneModule,
                        HttpClientModule,
                        AmexioCreativeModule,
                        AmexioBaseContextMenuModule,
                    ],
                    entryComponents: [AmexioTabPillComponent],
                    exports: [
                        AmexioFormsModule,
                        AmexioNavModule,
                        AmexioDataModule,
                        AmexioLayoutModule,
                        AmexioMediaModule,
                        AmexioPaneModule,
                        AmexioBaseContextMenuModule,
                        AmexioCreativeModule,
                        AmexioRuntimeModule,
                    ],
                    declarations: [],
                    providers: [CommonDataService, DeviceQueryService, IconLoaderService],
                },] },
    ];
    return AmexioWidgetModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var DashBoardTitleComponent = /** @class */ (function () {
    function DashBoardTitleComponent() {
    }
    /**
     * @return {?}
     */
    DashBoardTitleComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () { };
    DashBoardTitleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-dashboard-title', template: " ",
                },] },
    ];
    /** @nocollapse */
    DashBoardTitleComponent.ctorParameters = function () { return []; };
    DashBoardTitleComponent.propDecorators = {
        title: [{ type: i0.Input }],
        position: [{ type: i0.Input }],
        color: [{ type: i0.Input }],
        fontname: [{ type: i0.Input, args: ['font-name',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        bold: [{ type: i0.Input }],
        italic: [{ type: i0.Input }]
    };
    return DashBoardTitleComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
var DataPointCenterComponent = /** @class */ (function () {
    function DataPointCenterComponent() {
    }
    /**
     * @return {?}
     */
    DataPointCenterComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    DataPointCenterComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-center', template: "\n\n    <div [ngClass]=\"cclass\" [attr.align]=\"contentalign\" [style.background-color]=\"backgroundcolor\"\n         [style.color]=\"fontcolor\" [style.width]=\"width\" [style.height]=\"height\">\n      <ng-content></ng-content>\n    </div>",
                },] },
    ];
    /** @nocollapse */
    DataPointCenterComponent.ctorParameters = function () { return []; };
    DataPointCenterComponent.propDecorators = {
        contentalign: [{ type: i0.Input, args: ['content-align',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        fontcolor: [{ type: i0.Input, args: ['font-color',] }],
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        cclass: [{ type: i0.Input, args: ['c-class',] }]
    };
    return DataPointCenterComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 8/16/17.
*/
var DataPointsComponent = /** @class */ (function () {
    function DataPointsComponent() {
        this.colspan = 1;
    }
    /**
     * @return {?}
     */
    DataPointsComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.amexiocolor !== '') {
            this.dpClass = this.amexiocolor;
        }
        if (this.west) {
            this.colspan++;
        }
        if (this.east) {
            this.colspan++;
        }
    };
    DataPointsComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-datapoints', template: "\n\n  <div class=\"datapoints\" [ngClass]=\"dpClass\">\n      <table width=\"100%\" [style.background-color]=\"backgroundcolor\" [style.color]=\"fontcolor\">\n        <tr *ngIf=\"north\">\n          <td [attr.colspan]=\"colspan\">\n            <ng-content select=\"amexio-north\"></ng-content>\n          </td>\n        </tr>\n        <tr>\n          <td *ngIf=\"west\">\n            <ng-content select=\"amexio-west\"></ng-content>\n          </td>\n          <td *ngIf=\"center\">\n            <ng-content select=\"amexio-center\"></ng-content>\n          </td>\n          <td *ngIf=\"east\">\n            <ng-content select=\"amexio-east\"></ng-content>\n          </td>\n        </tr>\n        <tr *ngIf=\"south\">\n          <td [attr.colspan]=\"colspan\">\n            <ng-content select=\"amexio-south\"></ng-content>\n          </td>\n        </tr>\n      </table>\n    </div>\n\n\n  ", styles: ["\n    .amexio-datapoints {\n\n    }\n  "],
                },] },
    ];
    /** @nocollapse */
    DataPointsComponent.ctorParameters = function () { return []; };
    DataPointsComponent.propDecorators = {
        north: [{ type: i0.Input }],
        south: [{ type: i0.Input }],
        west: [{ type: i0.Input }],
        center: [{ type: i0.Input }],
        east: [{ type: i0.Input }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        fontcolor: [{ type: i0.Input, args: ['font-color',] }],
        amexiocolor: [{ type: i0.Input, args: ['amexio-color',] }]
    };
    return DataPointsComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
var DataPointEastComponent = /** @class */ (function () {
    function DataPointEastComponent() {
    }
    /**
     * @return {?}
     */
    DataPointEastComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.cclass == null) {
            this.cclass = 'datapoint-east';
        }
    };
    DataPointEastComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-east', template: "\n\n    <div [ngClass]=\"cclass\" class=\"datapoint-east\" [attr.align]=\"contentalign\" [style.background-color]=\"backgroundcolor\"\n         [style.color]=\"fontcolor\" [style.width]=\"width\" [style.height]=\"height\">\n      <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    DataPointEastComponent.ctorParameters = function () { return []; };
    DataPointEastComponent.propDecorators = {
        contentalign: [{ type: i0.Input, args: ['content-align',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        fontcolor: [{ type: i0.Input, args: ['font-color',] }],
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        cclass: [{ type: i0.Input, args: ['c-class',] }]
    };
    return DataPointEastComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
var DataPointNorthComponent = /** @class */ (function () {
    function DataPointNorthComponent() {
    }
    /**
     * @return {?}
     */
    DataPointNorthComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.cclass == null) {
            this.cclass = 'datapoints-north';
        }
    };
    DataPointNorthComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-north', template: "\n\n    <div [ngClass]=\"cclass\" [attr.align]=\"contentalign\" [style.background-color]=\"backgroundcolor\"\n         [style.color]=\"fontcolor\" [style.width]=\"width\" [style.height]=\"height\">\n      <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    DataPointNorthComponent.ctorParameters = function () { return []; };
    DataPointNorthComponent.propDecorators = {
        contentalign: [{ type: i0.Input, args: ['content-align',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        fontcolor: [{ type: i0.Input, args: ['font-color',] }],
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        cclass: [{ type: i0.Input, args: ['c-class',] }]
    };
    return DataPointNorthComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
var DataPointSouthComponent = /** @class */ (function () {
    function DataPointSouthComponent() {
    }
    /**
     * @return {?}
     */
    DataPointSouthComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.cclass == null) {
            this.cclass = 'datapoint-south';
        }
    };
    DataPointSouthComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-south', template: "\n\n    <div [ngClass]=\"cclass\" [attr.align]=\"contentalign\" [style.background-color]=\"backgroundcolor\"\n         [style.color]=\"fontcolor\" [style.width]=\"width\" [style.height]=\"height\">\n      <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    DataPointSouthComponent.ctorParameters = function () { return []; };
    DataPointSouthComponent.propDecorators = {
        contentalign: [{ type: i0.Input, args: ['content-align',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        fontcolor: [{ type: i0.Input, args: ['font-color',] }],
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        cclass: [{ type: i0.Input, args: ['c-class',] }]
    };
    return DataPointSouthComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by ketangote on 7/25/17.
*/
var DataPointWestComponent = /** @class */ (function () {
    function DataPointWestComponent() {
    }
    /**
     * @return {?}
     */
    DataPointWestComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.cclass == null) {
            this.cclass = 'datapoint-west';
        }
    };
    DataPointWestComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-west', template: "\n\n    <div [ngClass]=\"cclass\" [attr.align]=\"contentalign\" [style.background-color]=\"backgroundcolor\"\n         [style.color]=\"fontcolor\" [style.width]=\"width\" [style.height]=\"height\">\n      <ng-content></ng-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    DataPointWestComponent.ctorParameters = function () { return []; };
    DataPointWestComponent.propDecorators = {
        contentalign: [{ type: i0.Input, args: ['content-align',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        fontcolor: [{ type: i0.Input, args: ['font-color',] }],
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        cclass: [{ type: i0.Input, args: ['c-class',] }]
    };
    return DataPointWestComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Pratik on 07/08/17.
*/
var DashboardLoaderService = /** @class */ (function () {
    function DashboardLoaderService() {
        this.chartPackage = {
            AreaChart: 'corechart',
            Bar: 'bar',
            BarChart: 'corechart',
            ColumnChart: 'corechart',
            PieChart: 'corechart',
            Gantt: 'gantt',
            Gauge: 'gauge',
            GeoChart: 'geochart',
            Histogram: 'corechart',
            Line: 'line',
            LineChart: 'corechart',
            Map: 'map',
            Timeline: 'timeline',
            BubbleChart: 'corechart',
            CandlestickChart: 'corechart',
            ComboChart: 'corechart',
            TreeMap: 'treemap',
        };
        this.googleScriptLoadingNotifier = new i0.EventEmitter();
        this.isScriptLoading = false;
    }
    /**
     * @param {?} chartName
     * @return {?}
     */
    DashboardLoaderService.prototype.loadCharts = /**
     * @param {?} chartName
     * @return {?}
     */
    function (chartName) {
        var _this = this;
        return new rxjs_1(function (observer) {
            _this.loadScript().subscribe(function (val) { return console.log(); }, function (error) { return console.error(error); }, function () {
                _this.loadRequiredChart(observer, chartName);
            });
        });
    };
    /**
     * @return {?}
     */
    DashboardLoaderService.prototype.loadScript = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new rxjs_1(function (observer) {
            if (!_this.isScriptLoading) {
                // check if previously its loaded
                if (typeof google !== 'undefined' && google.charts) {
                    // check if chart package has been loaded using chartPackagename ?
                    // check if chart package has been loaded using chartPackagename ?
                    _this.loadBaseChart(observer);
                }
                else {
                    _this.isScriptLoading = true;
                    var /** @type {?} */ script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://www.gstatic.com/charts/loader.js';
                    script.async = true;
                    script.defer = true;
                    script.onload = function () {
                        _this.isScriptLoading = false;
                        _this.googleScriptLoadingNotifier.emit(true);
                        _this.loadBaseChart(observer);
                    };
                    script.onerror = function () {
                        observer.error('Could Not Load google Script');
                    };
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
            }
            else {
                _this.googleScriptLoadingNotifier.subscribe(function (loaded) {
                    if (loaded) {
                        _this.loadBaseChart(observer);
                    }
                });
            }
        });
    };
    /**
     * Load Base Chart
     * @param observer
     */
    /**
     * Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    DashboardLoaderService.prototype.loadBaseChart = /**
     * Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    function (observer) {
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback(function () {
            observer.complete();
        });
    };
    /**
     * Load the required charts
     * @param chartName
     */
    /**
     * Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    DashboardLoaderService.prototype.loadRequiredChart = /**
     * Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    function (observer, chartName) {
        if (google.visualization.hasOwnProperty(chartName)) {
            observer.complete();
        }
        else {
            google.charts.load('current', { packages: [this.chartPackage[chartName]] });
            google.charts.setOnLoadCallback(function () {
                observer.complete();
            });
        }
    };
    DashboardLoaderService.decorators = [
        { type: i0.Injectable },
    ];
    /** @nocollapse */
    DashboardLoaderService.ctorParameters = function () { return []; };
    return DashboardLoaderService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Created by Sagar.
*/
var GaugeChartComponent = /** @class */ (function () {
    function GaugeChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(GaugeChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
        Properties
        name : data
        datatype : any
        version : 4.0 onwards
        default : none
        description : Local data for gauge chart
        */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    GaugeChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.gaugeData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                width: this.width,
                height: this.height,
                redFrom: this.redcolorfrom,
                redTo: this.redcolorto,
                yellowFrom: this.yellowcolorfrom,
                yellowTo: this.yellowcolorto,
                scalevalue: this.scalevalue,
            };
            if (this.gaugeData) {
                this.chart = new google.visualization.Gauge(this.gaugedashboard.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.gaugeData, this.options);
            }
        }
    };
    /**
     * @return {?}
     */
    GaugeChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartTitleArray = this.chartTitleComp.toArray();
        // take first component
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
    };
    /**
     * @return {?}
     */
    GaugeChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('Gauge').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    GaugeChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    GaugeChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-dashboard-gauge', template: "\n    <div *ngIf=\"showChart\" #gaugedashboard\n         [style.width]=\"width\"\n         [style.height]=\"height\" (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    GaugeChartComponent.ctorParameters = function () { return [
        { type: DashboardLoaderService }
    ]; };
    GaugeChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        redcolorfrom: [{ type: i0.Input, args: ['red-color-from',] }],
        redcolorto: [{ type: i0.Input, args: ['red-color-to',] }],
        yellowcolorfrom: [{ type: i0.Input, args: ['yellow-color-from',] }],
        yellowcolorto: [{ type: i0.Input, args: ['yellow-color-to',] }],
        scalevalue: [{ type: i0.Input, args: ['scale-value',] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [DashBoardTitleComponent,] }],
        gaugedashboard: [{ type: i0.ViewChild, args: ['gaugedashboard',] }]
    };
    return GaugeChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var DASHBOARD = [
    DashBoardTitleComponent,
    DataPointCenterComponent,
    DataPointsComponent,
    DataPointEastComponent,
    DataPointNorthComponent,
    DataPointSouthComponent,
    DataPointWestComponent,
    GaugeChartComponent,
];
var AmexioDashBoardModule = /** @class */ (function () {
    function AmexioDashBoardModule() {
    }
    /**
     * @return {?}
     */
    AmexioDashBoardModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioDashBoardModule,
            providers: [CommonDataService, DashboardLoaderService],
        };
    };
    AmexioDashBoardModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        HttpClientModule,
                        AmexioCommonModule,
                    ],
                    exports: DASHBOARD,
                    declarations: DASHBOARD,
                    providers: [CommonDataService, DashboardLoaderService],
                },] },
    ];
    return AmexioDashBoardModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var ChartAreaComponent = /** @class */ (function () {
    function ChartAreaComponent() {
    }
    /**
     * @return {?}
     */
    ChartAreaComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    ChartAreaComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-area-properties', template: "",
                },] },
    ];
    /** @nocollapse */
    ChartAreaComponent.ctorParameters = function () { return []; };
    ChartAreaComponent.propDecorators = {
        chartbackgroundcolor: [{ type: i0.Input, args: ['chart-background-color',] }],
        leftposition: [{ type: i0.Input, args: ['left-position',] }],
        topposition: [{ type: i0.Input, args: ['top-position',] }],
        chartwidth: [{ type: i0.Input, args: ['chart-width',] }],
        chartheight: [{ type: i0.Input, args: ['chart-height',] }]
    };
    return ChartAreaComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var ChartLegendComponent = /** @class */ (function () {
    function ChartLegendComponent() {
        /*
        Properties
        name : bold
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : Set true for Legend text in bold
        */
        this.bold = false;
    }
    /**
     * @return {?}
     */
    ChartLegendComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    ChartLegendComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-legend', template: " ",
                },] },
    ];
    /** @nocollapse */
    ChartLegendComponent.ctorParameters = function () { return []; };
    ChartLegendComponent.propDecorators = {
        position: [{ type: i0.Input }],
        alignment: [{ type: i0.Input }],
        color: [{ type: i0.Input }],
        fontname: [{ type: i0.Input, args: ['font-name',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        bold: [{ type: i0.Input }],
        maxlines: [{ type: i0.Input, args: ['max-lines',] }]
    };
    return ChartLegendComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var ChartTitleComponent = /** @class */ (function () {
    function ChartTitleComponent() {
    }
    /**
     * @return {?}
     */
    ChartTitleComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    ChartTitleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-title', template: " ",
                },] },
    ];
    /** @nocollapse */
    ChartTitleComponent.ctorParameters = function () { return []; };
    ChartTitleComponent.propDecorators = {
        title: [{ type: i0.Input }],
        position: [{ type: i0.Input }],
        color: [{ type: i0.Input }],
        fontname: [{ type: i0.Input, args: ['font-name',] }],
        fontsize: [{ type: i0.Input, args: ['font-size',] }],
        bold: [{ type: i0.Input }],
        italic: [{ type: i0.Input }]
    };
    return ChartTitleComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ChartLoaderService = /** @class */ (function () {
    function ChartLoaderService() {
        this.chartPackage = {
            AreaChart: 'corechart',
            Bar: 'bar',
            BarChart: 'corechart',
            ColumnChart: 'corechart',
            PieChart: 'corechart',
            Gantt: 'gantt',
            Gauge: 'gauge',
            GeoChart: 'geochart',
            Histogram: 'corechart',
            Line: 'line',
            LineChart: 'corechart',
            Map: 'map',
            Timeline: 'timeline',
            BubbleChart: 'corechart',
            CandlestickChart: 'corechart',
            ComboChart: 'corechart',
            TreeMap: 'treemap',
        };
        this.googleScriptLoadingNotifier = new i0.EventEmitter();
        this.isScriptLoading = false;
    }
    /**
     * @param {?} chartName
     * @return {?}
     */
    ChartLoaderService.prototype.loadCharts = /**
     * @param {?} chartName
     * @return {?}
     */
    function (chartName) {
        var _this = this;
        return new rxjs_1(function (observer) {
            _this.loadScript().subscribe(function (val) { return console.log(); }, function (error) { return console.error(error); }, function () {
                _this.loadRequiredChart(observer, chartName);
            });
        });
    };
    /**
     * @return {?}
     */
    ChartLoaderService.prototype.loadScript = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new rxjs_1(function (observer) {
            if (!_this.isScriptLoading) {
                // check if previously its loaded
                if (typeof google !== 'undefined' && google.charts) {
                    // check if chart package has been loaded using chartPackagename ?
                    // check if chart package has been loaded using chartPackagename ?
                    _this.loadBaseChart(observer);
                }
                else {
                    _this.isScriptLoading = true;
                    var /** @type {?} */ script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://www.gstatic.com/charts/loader.js';
                    script.async = true;
                    script.defer = true;
                    script.onload = function () {
                        _this.isScriptLoading = false;
                        _this.googleScriptLoadingNotifier.emit(true);
                        _this.loadBaseChart(observer);
                    };
                    script.onerror = function () {
                        observer.error('Could Not Load google Script');
                    };
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
            }
            else {
                _this.googleScriptLoadingNotifier.subscribe(function (loaded) {
                    if (loaded) {
                        _this.loadBaseChart(observer);
                    }
                });
            }
        });
    };
    /**
     * Load Base Chart
     * @param observer
     */
    /**
     * Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    ChartLoaderService.prototype.loadBaseChart = /**
     * Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    function (observer) {
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback(function () {
            observer.complete();
        });
    };
    /**
     * Load the required charts
     * @param chartName
     */
    /**
     * Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    ChartLoaderService.prototype.loadRequiredChart = /**
     * Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    function (observer, chartName) {
        if (google.visualization.hasOwnProperty(chartName)) {
            observer.complete();
        }
        else {
            google.charts.load('current', { packages: [this.chartPackage[chartName]] });
            google.charts.setOnLoadCallback(function () {
                observer.complete();
            });
        }
    };
    ChartLoaderService.decorators = [
        { type: i0.Injectable },
    ];
    /** @nocollapse */
    ChartLoaderService.ctorParameters = function () { return []; };
    return ChartLoaderService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
*     http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
* Author: Sagar
*/
var AreaChartComponent = /** @class */ (function () {
    function AreaChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(AreaChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
      Properties
      name : data
      datatype : any
      version : 4.0 onwards
      default :
      description : Local data for AreaChart
      */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AreaChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.areaData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.createTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.createChartLegend() : 'none',
                chartArea: this.chartAreaComponent ? this.createChartArea() : null,
            };
            if (this.areaData) {
                this.chart = new google.visualization.AreaChart(this.areachart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.areaData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    };
    /**
     * @return {?}
     */
    AreaChartComponent.prototype.createTitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    AreaChartComponent.prototype.createChartLegend = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    AreaChartComponent.prototype.createChartArea = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    AreaChartComponent.prototype.click = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    AreaChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    };
    /**
     * @return {?}
     */
    AreaChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('AreaChart').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AreaChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    AreaChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-area', template: "\n    <div *ngIf=\"showChart\" #areachart\n         [style.width]=\"width\"\n         [style.height]=\"height\" (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    AreaChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    AreaChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        areachart: [{ type: i0.ViewChild, args: ['areachart',] }]
    };
    return AreaChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var BarChartComponent = /** @class */ (function () {
    function BarChartComponent(loader) {
        this.loader = loader;
        // showing stack chart
        /*
        Properties
        name : stacked
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : If set to true, stacks the elements for all series at each domain value.default value is false
        */
        this.stacked = false;
        this.width = '100%';
    }
    Object.defineProperty(BarChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
      Properties
      name : data
      datatype : any
      version : 4.0 onwards
      default :
      description : Local data for AreaChart
      */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this.showChart = true;
                this._data = data;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BarChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            // bind the data
            this.barData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                isStacked: this.stacked,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.createChartLegend() : 'none',
                chartArea: this.chartAreaComponent ? this.createChartBar() : null,
                hAxis: {
                    title: this.xaxistitle, minvalue: 0,
                },
                vAxis: {
                    title: this.yaxistitle,
                },
            };
            if (this.barData) {
                this.chart = new google.visualization.BarChart(this.barchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.barData, this.options);
            }
        }
    };
    /**
     * @return {?}
     */
    BarChartComponent.prototype.chartTitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    BarChartComponent.prototype.createChartLegend = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    BarChartComponent.prototype.createChartBar = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @return {?}
     */
    BarChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    };
    /**
     * @return {?}
     */
    BarChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('BarChart').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    BarChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    BarChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-bar', template: "\n    <div *ngIf=\"showChart\" #barchart\n         [style.width]=\"width\"\n         [style.height]=\"height\" (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    BarChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    BarChartComponent.propDecorators = {
        data: [{ type: i0.Input, args: ['data',] }],
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        stacked: [{ type: i0.Input }],
        xaxistitle: [{ type: i0.Input, args: ['x-axis-title',] }],
        yaxistitle: [{ type: i0.Input, args: ['y-axis-title',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        barchart: [{ type: i0.ViewChild, args: ['barchart',] }]
    };
    return BarChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var HorizontalAxisComponent = /** @class */ (function () {
    function HorizontalAxisComponent() {
    }
    /**
     * @return {?}
     */
    HorizontalAxisComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    HorizontalAxisComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-horizontal-axis', template: " ",
                },] },
    ];
    /** @nocollapse */
    HorizontalAxisComponent.ctorParameters = function () { return []; };
    HorizontalAxisComponent.propDecorators = {
        title: [{ type: i0.Input }],
        titlecolor: [{ type: i0.Input, args: ['title-color',] }]
    };
    return HorizontalAxisComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var VerticalAxisComponent = /** @class */ (function () {
    function VerticalAxisComponent() {
    }
    /**
     * @return {?}
     */
    VerticalAxisComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    VerticalAxisComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-vertical-axis', template: " ",
                },] },
    ];
    /** @nocollapse */
    VerticalAxisComponent.ctorParameters = function () { return []; };
    VerticalAxisComponent.propDecorators = {
        title: [{ type: i0.Input }],
        titlecolor: [{ type: i0.Input, args: ['title-color',] }]
    };
    return VerticalAxisComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var BubbleChartComponent = /** @class */ (function () {
    function BubbleChartComponent(loader) {
        this.loader = loader;
        /*
        Properties
        name : axis-color
        datatype : any
        version : 4.0 onwards
        default : none
        description : An object that specifies a mapping between color column values and
        colors or a gradient scale.example:['#FF0000', '#00FF00'] or ['yellow', 'red']
        */
        this.axiscolor = [];
        this.width = '100%';
    }
    Object.defineProperty(BubbleChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
      Properties
      name : data
      datatype : any
      version : 4.0 onwards
      default : none
      description : Local data for AreaChart
      */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    BubbleChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.bubbleData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.createTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.createChartLegend() : 'none',
                chartArea: this.chartAreaComponent ? this.createChartBackground() : null,
                vAxis: this.verticalComponent ? this.createChartVertical() : null,
                hAxis: this.horizontalComponent ? this.createchartHorizontal() : null,
                bubble: { textStyle: { fontsize: 11 } },
                axiscolor: { colors: this.axiscolor },
            };
            if (this.bubbleData) {
                this.chart = new google.visualization.BubbleChart(this.bubblechart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.bubbleData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    };
    /**
     * @return {?}
     */
    BubbleChartComponent.prototype.createTitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    BubbleChartComponent.prototype.createChartLegend = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    BubbleChartComponent.prototype.createChartBackground = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @return {?}
     */
    BubbleChartComponent.prototype.createChartVertical = /**
     * @return {?}
     */
    function () {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    };
    /**
     * @return {?}
     */
    BubbleChartComponent.prototype.createchartHorizontal = /**
     * @return {?}
     */
    function () {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    BubbleChartComponent.prototype.click = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    BubbleChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    };
    /**
     * @return {?}
     */
    BubbleChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('BubbleChart').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    BubbleChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    BubbleChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-bubble',
                    template: "\n      <div *ngIf=\"showChart\" #bubblechart\n           [style.width]=\"width\"\n           [style.height]=\"height\" (window:resize)=\"onResize($event)\">\n        <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n        </div>\n      </div>\n  ",
                    styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n  .lmask.fixed {\n    position: fixed;\n  }\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    BubbleChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    BubbleChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        axiscolor: [{ type: i0.Input, args: ['axis-color',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        horizontalComp: [{ type: i0.ContentChildren, args: [HorizontalAxisComponent,] }],
        verticalComp: [{ type: i0.ContentChildren, args: [VerticalAxisComponent,] }],
        bubblechart: [{ type: i0.ViewChild, args: ['bubblechart',] }]
    };
    return BubbleChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var CandlestickChartComponent = /** @class */ (function () {
    function CandlestickChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(CandlestickChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
      Properties
      name : data
      datatype : any
      version : 4.0 onwards
      default : none
      description : Local data for AreaChart
      */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CandlestickChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.candlestickData = google.visualization.arrayToDataTable(this._data, true);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTileTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: 'none',
                chartArea: this.chartAreaComponent ? this.chartLegendStyle() : null,
                vAxis: this.verticalComponent ? this.chartVerticalStyle() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalStyle() : null,
            };
            if (this.candlestickData) {
                this.chart = new google.visualization.CandlestickChart(this.candlestick.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.candlestickData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    };
    /**
     * @return {?}
     */
    CandlestickChartComponent.prototype.chartTileTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    CandlestickChartComponent.prototype.chartLegendStyle = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @return {?}
     */
    CandlestickChartComponent.prototype.chartVerticalStyle = /**
     * @return {?}
     */
    function () {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    };
    /**
     * @return {?}
     */
    CandlestickChartComponent.prototype.chartHorizontalStyle = /**
     * @return {?}
     */
    function () {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    CandlestickChartComponent.prototype.click = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    CandlestickChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        // take first component
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    };
    /**
     * @return {?}
     */
    CandlestickChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('CandlestickChart').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CandlestickChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    CandlestickChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-candlestick', template: "\n    <div *ngIf=\"showChart\" #candlestick\n         [style.width]=\"width\"\n         [style.height]=\"height\" (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    CandlestickChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    CandlestickChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        horizontalComp: [{ type: i0.ContentChildren, args: [HorizontalAxisComponent,] }],
        verticalComp: [{ type: i0.ContentChildren, args: [VerticalAxisComponent,] }],
        candlestick: [{ type: i0.ViewChild, args: ['candlestick',] }]
    };
    return CandlestickChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var CandlestickWaterfallChartComponent = /** @class */ (function () {
    function CandlestickWaterfallChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(CandlestickWaterfallChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
      Properties
      name : data
      datatype : any
      version : 4.0 onwards
      default : none
      description : Local data for AreaChart
      */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.candlestickData = google.visualization.arrayToDataTable(this._data, true);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: 'none',
                chartArea: this.chartAreaComponent ? this.chartLegendStyle() : null,
                vAxis: this.verticalComponent ? this.chartVerticalComponent() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalComponent() : null,
                bar: { groupWidth: this.barwidth ? this.barwidth : null },
                // Remove space between bars.
                candlestick: this.chartColorStyle(),
            };
            if (this.candlestickData) {
                this.chart = new google.visualization.CandlestickChart(this.candlestickwaterfall.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.candlestickData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    };
    /**
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.chartTitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.chartLegendStyle = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.chartVerticalComponent = /**
     * @return {?}
     */
    function () {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    };
    /**
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.chartHorizontalComponent = /**
     * @return {?}
     */
    function () {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    };
    /**
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.chartColorStyle = /**
     * @return {?}
     */
    function () {
        return {
            fallingColor: this.fallingcolor ? { strokeWidth: 0, fill: this.fallingcolor ? this.fallingcolor : null } : null,
            // red
            risingColor: this.risingcolor ? { strokeWidth: 0, fill: this.risingcolor ? this.risingcolor : null } : null,
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.click = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        // take first component
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    };
    /**
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('CandlestickChart').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    CandlestickWaterfallChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    CandlestickWaterfallChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-candlestick-waterfall', template: "\n    <div *ngIf=\"showChart\" #candlestickwaterfall\n         [style.width]=\"width\"\n         [style.height]=\"height\" (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    CandlestickWaterfallChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    CandlestickWaterfallChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        barwidth: [{ type: i0.Input, args: ['bar-width',] }],
        fallingcolor: [{ type: i0.Input, args: ['falling-color',] }],
        risingcolor: [{ type: i0.Input, args: ['rising-color',] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        horizontalComp: [{ type: i0.ContentChildren, args: [HorizontalAxisComponent,] }],
        verticalComp: [{ type: i0.ContentChildren, args: [VerticalAxisComponent,] }],
        candlestickwaterfall: [{ type: i0.ViewChild, args: ['candlestickwaterfall',] }]
    };
    return CandlestickWaterfallChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var ColumnChartComponent = /** @class */ (function () {
    function ColumnChartComponent(loader) {
        this.loader = loader;
        // showing stack chart
        /*
        Properties
        name : stacked
        datatype : boolean
        version : 4.0 onwards
        default : false
        description : If set to true, stacks the elements for all series at each domain value.default value is false
        */
        this.stacked = false;
        this.width = '100%';
    }
    Object.defineProperty(ColumnChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
       Properties
       name : data
       datatype : any
       version : 4.0 onwards
       default : none
       description : For the use of local data
       */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ColumnChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.columnData = this.createTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                isStacked: this.stacked,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackGroundColor() : null,
            };
            if (this.columnData) {
                this.chart = new google.visualization.ColumnChart(this.columnchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.columnData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    };
    /**
     * @return {?}
     */
    ColumnChartComponent.prototype.chartTitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    ColumnChartComponent.prototype.chartLegendStyle = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    ColumnChartComponent.prototype.chartBackGroundColor = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ColumnChartComponent.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ColumnChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    };
    // This method create data table structure of array and return in required chart data
    /**
     * @param {?} array
     * @return {?}
     */
    ColumnChartComponent.prototype.createTable = /**
     * @param {?} array
     * @return {?}
     */
    function (array) {
        // create Duplicate Array for data arrangement
        var /** @type {?} */ dupArray = array.slice();
        var /** @type {?} */ data = new google.visualization.DataTable();
        var /** @type {?} */ labelObject = dupArray[0];
        // remove first object of array
        dupArray.shift();
        labelObject.forEach(function (datatypeObject) {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        });
        var /** @type {?} */ finalArray = [];
        dupArray.forEach(function (rowObject) {
            finalArray.push(rowObject);
        });
        data.addRows(finalArray);
        return data;
    };
    /**
     * @return {?}
     */
    ColumnChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('ColumnChart').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ColumnChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    ColumnChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-column', template: "\n    <div  *ngIf=\"showChart\" #columnchart\n         [style.width]=\"width\"\n         [style.height]=\"height\"\n         (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    ColumnChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    ColumnChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        stacked: [{ type: i0.Input }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        columnchart: [{ type: i0.ViewChild, args: ['columnchart',] }]
    };
    return ColumnChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var ComboChartComponent = /** @class */ (function () {
    function ComboChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(ComboChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
        Properties
        name : data
        datatype : any
        version : 4.0 onwards
        default : none
        description : For the use of local data
        */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ComboChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.comboData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackground() : null,
                vAxis: this.verticalComponent ? this.chartVerticalStyle() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalStyle() : null,
                seriesType: 'bars',
                series: { 4: { type: 'line' } },
            };
            if (this.comboData) {
                this.chart = new google.visualization.ComboChart(this.combochart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.comboData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ComboChartComponent.prototype.click = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    /**
     * @return {?}
     */
    ComboChartComponent.prototype.chartTitleStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    ComboChartComponent.prototype.chartLegendStyle = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    ComboChartComponent.prototype.chartBackground = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @return {?}
     */
    ComboChartComponent.prototype.chartVerticalStyle = /**
     * @return {?}
     */
    function () {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    };
    /**
     * @return {?}
     */
    ComboChartComponent.prototype.chartHorizontalStyle = /**
     * @return {?}
     */
    function () {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ComboChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    };
    /**
     * @return {?}
     */
    ComboChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('ComboChart').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ComboChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    ComboChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-combo', template: "\n    <div *ngIf=\"showChart\" #combochart\n         [style.width]=\"width\"\n         [style.height]=\"height\" (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    ComboChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    ComboChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        horizontalComp: [{ type: i0.ContentChildren, args: [HorizontalAxisComponent,] }],
        verticalComp: [{ type: i0.ContentChildren, args: [VerticalAxisComponent,] }],
        combochart: [{ type: i0.ViewChild, args: ['combochart',] }]
    };
    return ComboChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var DonutChartComponent = /** @class */ (function () {
    function DonutChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(DonutChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
        Properties
        name : data
        datatype : any
        version : 4.0 onwards
        default : none
        description : For the use of local data
        */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    DonutChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.donutData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chariTitleTextStyle() : null,
                pieHole: 0.4,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundColor() : null,
            };
            if (this.donutData) {
                this.chart = new google.visualization.PieChart(this.donutchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.donutData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    };
    /**
     * @return {?}
     */
    DonutChartComponent.prototype.chariTitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    DonutChartComponent.prototype.chartLegendStyle = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    DonutChartComponent.prototype.chartBackgroundColor = /**
     * @return {?}
     */
    function () {
        return { backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    DonutChartComponent.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    DonutChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    };
    /**
     * @return {?}
     */
    DonutChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('PieChart').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    DonutChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    DonutChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-donut', template: "\n    <div *ngIf=\"showChart\" #donutchart\n         [style.width]=\"width\"\n         [style.height]=\"height\"\n         (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    DonutChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    DonutChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        donutchart: [{ type: i0.ViewChild, args: ['donutchart',] }]
    };
    return DonutChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2017-2018 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the 'License');
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var GanttChartComponent = /** @class */ (function () {
    function GanttChartComponent(loader) {
        this.loader = loader;
        /*
        Properties
        name : critical-path-enabled
        datatype : boolean
        version : 4.3 onwards
        default : false
        description : If you set the criticalPathEnabled option to true, it show critical path line
        */
        this.criticalPathEnabled = false;
        this.width = '100%';
    }
    Object.defineProperty(GanttChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
        Properties
        name : data
        datatype : any
        version : 4.3 onwards
        default : none
        description : For the use of local data
        */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    GanttChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.data && this.showChart) {
            this.hasLoaded = true;
            this.options = { gantt: { criticalPathEnabled: this.criticalPathEnabled,
                    criticalPathStyle: { stroke: '#e64a19',
                        strokeWidth: 5 } },
                innerGridTrack: { fill: this.innerGridTrackColor ? this.innerGridTrackColor : '' },
                innerGridDarkTrack: { fill: this.innerGridDarkTrack ? this.innerGridDarkTrack : '' },
            };
            if (google && google.visualization) {
                this.chart = new google.visualization.Gantt(this.ganttchart.nativeElement);
                this.chart.draw(this.createTable(this._data), this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
            else {
                this.hasLoaded = false;
            }
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    GanttChartComponent.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    /**
     * @param {?} array
     * @return {?}
     */
    GanttChartComponent.prototype.createTable = /**
     * @param {?} array
     * @return {?}
     */
    function (array) {
        var /** @type {?} */ copyOfArray = array.slice();
        var /** @type {?} */ data = new google.visualization.DataTable();
        var /** @type {?} */ labelObject = copyOfArray[0];
        copyOfArray.shift();
        labelObject.forEach(function (datatypeObject) {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        });
        var /** @type {?} */ newArray = [];
        copyOfArray.forEach(function (rowObject) {
            newArray.push(rowObject);
        });
        data.addRows(newArray);
        return data;
    };
    /**
     * @return {?}
     */
    GanttChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('Gantt').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    GanttChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-gantt', template: "\n    <div *ngIf='showChart' #gantt\n         [style.width]='width'\n    >\n      <div *ngIf='!hasLoaded' class='lmask'>\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    GanttChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    GanttChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        criticalPathEnabled: [{ type: i0.Input, args: ['critical-path-enabled',] }],
        innerGridTrackColor: [{ type: i0.Input, args: ['inner-grid-track-color',] }],
        innerGridDarkTrack: [{ type: i0.Input, args: ['inner-grid-dark-track-color',] }],
        ganttchart: [{ type: i0.ViewChild, args: ['gantt',] }]
    };
    return GanttChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var HistogramChartComponent = /** @class */ (function () {
    function HistogramChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(HistogramChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
        Properties
        name : data
        datatype : any
        version : 4.0 onwards
        default : none
        description : For the use of local data
        */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    HistogramChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.histogramData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.charttitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackground() : null,
            };
            if (this.histogramData) {
                this.chart = new google.visualization.Histogram(this.histogramchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.histogramData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    HistogramChartComponent.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    /**
     * @return {?}
     */
    HistogramChartComponent.prototype.charttitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    HistogramChartComponent.prototype.chartegendStyle = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    HistogramChartComponent.prototype.chartBackground = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    HistogramChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    };
    /**
     * @return {?}
     */
    HistogramChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('Histogram').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    HistogramChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-histogram',
                    template: "\n      <div *ngIf=\"showChart\" #histogramchart\n           [style.width]=\"width\"\n           [style.height]=\"height\"\n      >\n        <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n        </div>\n      </div>\n  ",
                    styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n  .lmask.fixed {\n    position: fixed;\n  }\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    HistogramChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    HistogramChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        histogramchart: [{ type: i0.ViewChild, args: ['histogramchart',] }]
    };
    return HistogramChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var LineChartComponent = /** @class */ (function () {
    function LineChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(LineChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
        Properties
        name : data
        datatype : any
        version : 4.0 onwards
        default : none
        description : For the use of local data
        */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    LineChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.lineData = this.createTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundStyle() : null,
            };
            if (this.lineData) {
                this.chart = new google.visualization.LineChart(this.linechart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.lineData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    };
    /**
     * @return {?}
     */
    LineChartComponent.prototype.chartTitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    LineChartComponent.prototype.chartLegendStyle = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    LineChartComponent.prototype.chartBackgroundStyle = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    LineChartComponent.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    LineChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    };
    // This method create data table structure of array and return in required chart data
    /**
     * @param {?} array
     * @return {?}
     */
    LineChartComponent.prototype.createTable = /**
     * @param {?} array
     * @return {?}
     */
    function (array) {
        // create Duplicate Array for data arrangement
        var /** @type {?} */ dupArray = array.slice();
        var /** @type {?} */ data = new google.visualization.DataTable();
        var /** @type {?} */ labelObject = dupArray[0];
        // remove first object of array
        dupArray.shift();
        labelObject.forEach(function (datatypeObject) {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        });
        var /** @type {?} */ finalArray = [];
        dupArray.forEach(function (rowObject) {
            finalArray.push(rowObject);
        });
        data.addRows(finalArray);
        return data;
    };
    /**
     * @return {?}
     */
    LineChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('LineChart').subscribe(function (value) { return console.log(); }, function (error) { return console.error(error); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    LineChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    LineChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-line', template: "\n    <div *ngIf=\"showChart\" #linechart\n         [style.width]=\"width\"\n         [style.height]=\"height\"\n         (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    LineChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    LineChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        linechart: [{ type: i0.ViewChild, args: ['linechart',] }]
    };
    return LineChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var PieChartComponent = /** @class */ (function () {
    function PieChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(PieChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
      Properties
      name : data
      datatype : any
      version : 4.0 onwards
      default : none
      description : sets the pie hole size
      */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    PieChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.pieData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.charttitleTextStyle() : null,
                is3D: this.is3d,
                pieHole: this.piehole,
                startangle: this.startangle,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLengendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundStyle() : null,
            };
            if (this.pieData) {
                this.chart = new google.visualization.PieChart(this.piechart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.pieData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.onClick);
            }
        }
    };
    /**
     * @return {?}
     */
    PieChartComponent.prototype.charttitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    PieChartComponent.prototype.chartLengendStyle = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null,
            textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    PieChartComponent.prototype.chartBackgroundStyle = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    PieChartComponent.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    PieChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    };
    /**
     * @return {?}
     */
    PieChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('PieChart').subscribe(function (value) { return console.log(); }, function (error) { return console.error(error); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    PieChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    PieChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-pie', template: "\n\n        <div *ngIf=\"showChart\" #piechart\n             [style.width]=\"width\"\n             [style.height]=\"height\"\n             (window:resize)=\"onResize($event)\">\n          <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n          </div>\n        </div>\n  ",
                    styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n  .lmask.fixed {\n    position: fixed;\n  }\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    PieChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    PieChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        is3d: [{ type: i0.Input }],
        piehole: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        startangle: [{ type: i0.Input, args: ['start-angle',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        piechart: [{ type: i0.ViewChild, args: ['piechart',] }]
    };
    return PieChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var ScatterChartComponent = /** @class */ (function () {
    function ScatterChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(ScatterChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
        Properties
        name : data
        datatype : any
        version : 4.0 onwards
        default : none
        description : For the use of local data
        */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    ScatterChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.scatterData = google.visualization.arrayToDataTable(this._data);
            this.options = {
                title: this.chartTitleComponent ? this.chartTitleComponent.title : null,
                titleTextStyle: this.chartTitleComponent ? this.chartTitleTextStyle() : null,
                backgroundcolor: this.backgroundcolor,
                legend: this.chartLengendComponent ? this.chartLegendStyle() : 'none',
                chartArea: this.chartAreaComponent ? this.chartBackgroundColor() : null,
                vAxis: this.verticalComponent ? this.chartVerticalStyle() : null,
                hAxis: this.horizontalComponent ? this.chartHorizontalStyle() : null,
            };
            if (this.scatterData) {
                this.chart = new google.visualization.ScatterChart(this.scatterchart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.scatterData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    };
    /**
     * @return {?}
     */
    ScatterChartComponent.prototype.chartTitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.chartTitleComponent.color ? this.chartTitleComponent.color : null,
            fontName: this.chartTitleComponent.fontname ? this.chartTitleComponent.fontname : null,
            fontsize: this.chartTitleComponent.fontsize ? this.chartTitleComponent.fontsize : null,
            bold: this.chartTitleComponent.bold ? this.chartTitleComponent.bold : null,
            italic: this.chartTitleComponent.italic ? this.chartTitleComponent.italic : null,
        };
    };
    /**
     * @return {?}
     */
    ScatterChartComponent.prototype.chartLegendStyle = /**
     * @return {?}
     */
    function () {
        return {
            position: this.chartLengendComponent.position ? this.chartLengendComponent.position : null,
            // this work only in chart position is top
            maxLines: this.chartLengendComponent.maxlines ? this.chartLengendComponent.maxlines : null, textStyle: {
                color: this.chartLengendComponent.color ? this.chartLengendComponent.color : null,
                fontsize: this.chartLengendComponent.fontsize ? this.chartLengendComponent.fontsize : null,
                fontName: this.chartLengendComponent.fontname ? this.chartLengendComponent.fontname : null,
                bold: this.chartLengendComponent.bold ? this.chartLengendComponent.bold : null,
                alignment: this.chartLengendComponent.alignment ? this.chartLengendComponent.alignment : null,
            },
        };
    };
    /**
     * @return {?}
     */
    ScatterChartComponent.prototype.chartBackgroundColor = /**
     * @return {?}
     */
    function () {
        return {
            backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
            left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
            top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
            height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
            width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
        };
    };
    /**
     * @return {?}
     */
    ScatterChartComponent.prototype.chartVerticalStyle = /**
     * @return {?}
     */
    function () {
        return {
            title: this.verticalComponent.title ? this.verticalComponent.title : null,
            titleTextStyle: { color: this.verticalComponent.titlecolor ? this.verticalComponent.titlecolor : null },
        };
    };
    /**
     * @return {?}
     */
    ScatterChartComponent.prototype.chartHorizontalStyle = /**
     * @return {?}
     */
    function () {
        return {
            title: this.horizontalComponent.title ? this.horizontalComponent.title : null,
            titleTextStyle: { color: this.horizontalComponent.titlecolor ? this.horizontalComponent.titlecolor : null },
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    ScatterChartComponent.prototype.click = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    ScatterChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        this.horizontalArray = this.horizontalComp.toArray();
        this.verticalArray = this.verticalComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
        if (this.horizontalArray.length === 1) {
            this.horizontalComponent = this.horizontalArray.pop();
        }
        if (this.verticalArray.length === 1) {
            this.verticalComponent = this.verticalArray.pop();
        }
    };
    /**
     * @return {?}
     */
    ScatterChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('ScatterChart').subscribe(function (value) { return console.log(); }, function (error) { return console.error(error); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ScatterChartComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    ScatterChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-scatter', template: "\n    <div *ngIf=\"showChart\" #scatterchart\n         [style.width]=\"width\"\n         [style.height]=\"height\" (window:resize)=\"onResize($event)\">\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    ScatterChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    ScatterChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        horizontalComp: [{ type: i0.ContentChildren, args: [HorizontalAxisComponent,] }],
        verticalComp: [{ type: i0.ContentChildren, args: [VerticalAxisComponent,] }],
        scatterchart: [{ type: i0.ViewChild, args: ['scatterchart',] }]
    };
    return ScatterChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Sagar Jadhav
 *
 */
var TimeLineChartComponent = /** @class */ (function () {
    function TimeLineChartComponent(loader) {
        this.loader = loader;
        this.width = '100%';
    }
    Object.defineProperty(TimeLineChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
        Properties
        name : data
        datatype : any
        version : 4.0 onwards
        default : none
        description : For the use of local data
        */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TimeLineChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.data && this.showChart) {
            this.chart = new google.visualization.Timeline(this.timelinechart.nativeElement);
            this.hasLoaded = true;
            this.chart.draw(this.createTable(this._data));
            google.visualization.events.addListener(this.chart, 'click', this.onClick);
        }
    };
    /**
     * @param {?} e
     * @return {?}
     */
    TimeLineChartComponent.prototype.onClick = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    // after content init for inner directive is run
    /**
     * @return {?}
     */
    TimeLineChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartLegendArray = this.chartLegendComp.toArray();
        this.chartTitleArray = this.chartTitleComp.toArray();
        this.chartAreaArray = this.chartAreaComp.toArray();
        // take first component
        if (this.chartLegendArray.length === 1) {
            this.chartLengendComponent = this.chartLegendArray.pop();
        }
        if (this.chartTitleArray.length === 1) {
            this.chartTitleComponent = this.chartTitleArray.pop();
        }
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    };
    // This method create data table structure of array and return in required chart data
    /**
     * @param {?} array
     * @return {?}
     */
    TimeLineChartComponent.prototype.createTable = /**
     * @param {?} array
     * @return {?}
     */
    function (array) {
        // create Duplicate Array for data arrangement
        var /** @type {?} */ dupArray = array.slice();
        var /** @type {?} */ data = new google.visualization.DataTable();
        var /** @type {?} */ labelObject = dupArray[0];
        // remove first object of array
        dupArray.shift();
        labelObject.forEach(function (datatypeObject) {
            data.addColumn(datatypeObject.datatype, datatypeObject.label);
        });
        var /** @type {?} */ finalArray = [];
        dupArray.forEach(function (rowObject) {
            finalArray.push(rowObject);
        });
        data.addRows(finalArray);
        return data;
    };
    /**
     * @return {?}
     */
    TimeLineChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('Timeline').subscribe(function (value) { return console.log(); }, function (error) { return console.error(error); }, function () {
            _this.drawChart();
        });
    };
    TimeLineChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-chart-timeline', template: "\n    <div *ngIf=\"showChart\" #timelinechart\n         [style.width]=\"width\"\n    >\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    TimeLineChartComponent.ctorParameters = function () { return [
        { type: ChartLoaderService }
    ]; };
    TimeLineChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        chartLegendComp: [{ type: i0.ContentChildren, args: [ChartLegendComponent,] }],
        chartTitleComp: [{ type: i0.ContentChildren, args: [ChartTitleComponent,] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [ChartAreaComponent,] }],
        timelinechart: [{ type: i0.ViewChild, args: ['timelinechart',] }]
    };
    return TimeLineChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CHART_COMPONENTS = [
    AreaChartComponent, BarChartComponent, ChartAreaComponent,
    ChartLegendComponent, ChartTitleComponent, ColumnChartComponent,
    DonutChartComponent, GanttChartComponent, HistogramChartComponent, LineChartComponent,
    PieChartComponent, TimeLineChartComponent, ComboChartComponent,
    VerticalAxisComponent,
    HorizontalAxisComponent,
    BubbleChartComponent,
    ScatterChartComponent, CandlestickChartComponent, CandlestickWaterfallChartComponent,
];
var AmexioChartsModule = /** @class */ (function () {
    function AmexioChartsModule() {
    }
    /**
     * @return {?}
     */
    AmexioChartsModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioChartsModule,
            providers: [CommonDataService, ChartLoaderService],
        };
    };
    AmexioChartsModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        HttpClientModule,
                        AmexioCommonModule,
                    ],
                    exports: CHART_COMPONENTS,
                    declarations: CHART_COMPONENTS,
                    providers: [CommonDataService, ChartLoaderService],
                },] },
    ];
    return AmexioChartsModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/*
* Copyright [2019] [Metamagic]
*
* Licensed under the Apache License, Version 2.0 (the "License");
* you may not use this file except in compliance with the License.
* You may obtain a copy of the License at
*
* http://www.apache.org/licenses/LICENSE-2.0
*
* Unless required by applicable law or agreed to in writing, software
* distributed under the License is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
* See the License for the specific language governing permissions and
* limitations under the License.
*
*  Created by pratik on 17/8/17.
*/
var MapLoaderService = /** @class */ (function () {
    function MapLoaderService() {
        this.chartPackage = {
            AreaChart: 'corechart',
            Bar: 'bar',
            BarChart: 'corechart',
            ColumnChart: 'corechart',
            PieChart: 'corechart',
            Gantt: 'gantt',
            Gauge: 'gauge',
            GeoChart: 'geochart',
            Histogram: 'corechart',
            Line: 'line',
            LineChart: 'corechart',
            Map: 'map',
            Timeline: 'timeline',
            BubbleChart: 'corechart',
            CandlestickChart: 'corechart',
            ComboChart: 'corechart',
            TreeMap: 'treemap',
        };
        this.googleScriptLoadingNotifier = new i0.EventEmitter();
        this.isScriptLoading = false;
    }
    /**
     * @param {?} chartName
     * @return {?}
     */
    MapLoaderService.prototype.loadCharts = /**
     * @param {?} chartName
     * @return {?}
     */
    function (chartName) {
        var _this = this;
        return new rxjs_1(function (observer) {
            _this.loadScript().subscribe(function (val) { return console.log(); }, function (error) { return console.error(error); }, function () {
                _this.loadRequiredChart(observer, chartName);
            });
        });
    };
    /**
     * @return {?}
     */
    MapLoaderService.prototype.loadScript = /**
     * @return {?}
     */
    function () {
        var _this = this;
        return new rxjs_1(function (observer) {
            if (!_this.isScriptLoading) {
                // check if previously its loaded
                if (typeof google !== 'undefined' && google.charts) {
                    // check if chart package has been loaded using chartPackagename ?
                    // check if chart package has been loaded using chartPackagename ?
                    _this.loadBaseChart(observer);
                }
                else {
                    _this.isScriptLoading = true;
                    var /** @type {?} */ script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.src = 'https://www.gstatic.com/charts/loader.js';
                    script.async = true;
                    script.defer = true;
                    script.onload = function () {
                        _this.isScriptLoading = false;
                        _this.googleScriptLoadingNotifier.emit(true);
                        _this.loadBaseChart(observer);
                    };
                    script.onerror = function () {
                        observer.error('Could Not Load google Script');
                    };
                    document.getElementsByTagName('head')[0].appendChild(script);
                }
            }
            else {
                _this.googleScriptLoadingNotifier.subscribe(function (loaded) {
                    if (loaded) {
                        _this.loadBaseChart(observer);
                    }
                });
            }
        });
    };
    /**
     *  Load Base Chart
     * @param observer
     */
    /**
     *  Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    MapLoaderService.prototype.loadBaseChart = /**
     *  Load Base Chart
     * @param {?} observer
     * @return {?}
     */
    function (observer) {
        google.charts.load('current', { packages: ['corechart'] });
        google.charts.setOnLoadCallback(function () {
            observer.complete();
        });
    };
    /**
     *  Load the required charts
     * @param chartName
     */
    /**
     *  Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    MapLoaderService.prototype.loadRequiredChart = /**
     *  Load the required charts
     * @param {?} observer
     * @param {?} chartName
     * @return {?}
     */
    function (observer, chartName) {
        if (google.visualization.hasOwnProperty(chartName)) {
            observer.complete();
        }
        else {
            google.charts.load('current', { packages: [this.chartPackage[chartName]] });
            google.charts.setOnLoadCallback(function () {
                observer.complete();
            });
        }
    };
    MapLoaderService.decorators = [
        { type: i0.Injectable },
    ];
    /** @nocollapse */
    MapLoaderService.ctorParameters = function () { return []; };
    return MapLoaderService;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MapPropertiesComponent = /** @class */ (function () {
    function MapPropertiesComponent() {
    }
    /**
     * @return {?}
     */
    MapPropertiesComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    MapPropertiesComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-map-properties', template: "",
                },] },
    ];
    /** @nocollapse */
    MapPropertiesComponent.ctorParameters = function () { return []; };
    MapPropertiesComponent.propDecorators = {
        chartbackgroundcolor: [{ type: i0.Input, args: ['chart-background-color',] }],
        leftposition: [{ type: i0.Input, args: ['left-position',] }],
        topposition: [{ type: i0.Input, args: ['top-position',] }],
        chartwidth: [{ type: i0.Input, args: ['chart-width',] }],
        chartheight: [{ type: i0.Input, args: ['chart-height',] }]
    };
    return MapPropertiesComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var GeoChartComponent = /** @class */ (function () {
    function GeoChartComponent(loader) {
        this.loader = loader;
        /*
          not in use
        */
        this.countryname = false;
        this.width = '100%';
    }
    Object.defineProperty(GeoChartComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    GeoChartComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        if (this.showChart) {
            this.geomapData = google.visualization.arrayToDataTable(this._data);
            this.showChartExist();
            if (this.geomapData) {
                this.chart = new google.visualization.GeoChart(this.geochart.nativeElement);
                this.hasLoaded = true;
                this.chart.draw(this.geomapData, this.options);
                google.visualization.events.addListener(this.chart, 'click', this.click);
            }
        }
    };
    /**
     * @return {?}
     */
    GeoChartComponent.prototype.showChartExist = /**
     * @return {?}
     */
    function () {
        this.options = {
            displayMode: this.countryname ? 'text' : null,
            region: this.regioncode ? this.regioncode : null,
            backgroundcolor: this.backgroundcolor ? this.backgroundcolor : null,
            unusedregioncolor: this.unusedregioncolor ? this.unusedregioncolor : null,
            chartArea: this.chartAreaComponent ? {
                backgroundcolor: this.chartAreaComponent.chartbackgroundcolor ? this.chartAreaComponent.chartbackgroundcolor : null,
                left: this.chartAreaComponent.leftposition ? this.chartAreaComponent.leftposition : null,
                top: this.chartAreaComponent.topposition ? this.chartAreaComponent.topposition : null,
                height: this.chartAreaComponent.chartheight ? this.chartAreaComponent.chartheight : null,
                width: this.chartAreaComponent.chartwidth ? this.chartAreaComponent.chartwidth : null,
            } : null,
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    GeoChartComponent.prototype.click = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    /**
     * @return {?}
     */
    GeoChartComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.chartAreaArray = this.chartAreaComp.toArray();
        if (this.chartAreaArray.length === 1) {
            this.chartAreaComponent = this.chartAreaArray.pop();
        }
    };
    /**
     * @return {?}
     */
    GeoChartComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('GeoChart').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    GeoChartComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-map-geo-chart', template: "\n    <div *ngIf=\"showChart\" #geochart\n         [style.width]=\"width\"\n         [style.height]=\"height\"\n    >\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n"],
                },] },
    ];
    /** @nocollapse */
    GeoChartComponent.ctorParameters = function () { return [
        { type: MapLoaderService }
    ]; };
    GeoChartComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        countryname: [{ type: i0.Input, args: ['country-name',] }],
        regioncode: [{ type: i0.Input, args: ['region-code',] }],
        backgroundcolor: [{ type: i0.Input, args: ['background-color',] }],
        unusedregioncolor: [{ type: i0.Input, args: ['unused-region-color',] }],
        chartAreaComp: [{ type: i0.ContentChildren, args: [MapPropertiesComponent,] }],
        geochart: [{ type: i0.ViewChild, args: ['geochart',] }]
    };
    return GeoChartComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MapTitleComponent = /** @class */ (function () {
    function MapTitleComponent() {
    }
    /**
     * @return {?}
     */
    MapTitleComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    MapTitleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-map-title', template: " ",
                },] },
    ];
    /** @nocollapse */
    MapTitleComponent.ctorParameters = function () { return []; };
    MapTitleComponent.propDecorators = {
        title: [{ type: i0.Input }],
        position: [{ type: i0.Input }],
        color: [{ type: i0.Input }],
        fontname: [{ type: i0.Input, args: ['font-name',] }],
        bold: [{ type: i0.Input }],
        italic: [{ type: i0.Input }]
    };
    return MapTitleComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var TreeMapComponent = /** @class */ (function () {
    function TreeMapComponent(loader) {
        this.loader = loader;
        this.onClick = new i0.EventEmitter();
        this.width = '100%';
    }
    Object.defineProperty(TreeMapComponent.prototype, "data", {
        get: /**
         * @return {?}
         */
        function () {
            return this._data;
        },
        /*
        Properties
        name : data
        datatype : any
        version : 4.0 onwards
        default : none
        description : Local data for TreeMap.
        */
        set: /**
         * @param {?} data
         * @return {?}
         */
        function (data) {
            if (data) {
                this._data = data;
                this.showChart = true;
            }
            else {
                this.showChart = false;
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    TreeMapComponent.prototype.drawChart = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ chart;
        var /** @type {?} */ localData = this._data;
        if (this.showChart) {
            this.treemapData = google.visualization.arrayToDataTable(this._data);
            this.initializeOptions();
            if (this.treemapData) {
                chart = new google.visualization.TreeMap(this.treemapmap.nativeElement);
                this.hasLoaded = true;
                chart.draw(this.treemapData, this.options);
                google.visualization.events.addListener(chart, 'select', function (eve, event) {
                    localData.forEach(function (element, index) {
                        if ((chart.getSelection())[0].row + 1 === index) {
                            _this.onClick.emit(element);
                        }
                    });
                });
            }
        }
    };
    /**
     * @return {?}
     */
    TreeMapComponent.prototype.initializeOptions = /**
     * @return {?}
     */
    function () {
        this.options = {
            title: this.mapTitleComponent ? this.mapTitleComponent.title : null,
            titleTextStyle: this.mapTitleComponent ? this.mapTitleTextStyle() : null,
            mincolor: this.mincolor ? this.mincolor : null, midcolor: this.midcolor ? this.midcolor : null,
            maxcolor: this.maxcolor ? this.maxcolor : null, headerHeight: 15, fontcolor: 'black',
            showscale: this.showscale ? this.showscale : false,
            maxpostdepth: this.maxpostdepth ? this.maxpostdepth : 1,
        };
    };
    /**
     * @return {?}
     */
    TreeMapComponent.prototype.mapTitleTextStyle = /**
     * @return {?}
     */
    function () {
        return {
            color: this.mapTitleComponent.color ? this.mapTitleComponent.color : null,
            fontName: this.mapTitleComponent.fontname ? this.mapTitleComponent.fontname : null,
            bold: this.mapTitleComponent.bold ? this.mapTitleComponent.bold : null,
            italic: this.mapTitleComponent.italic ? this.mapTitleComponent.italic : null,
        };
    };
    /**
     * @param {?} e
     * @return {?}
     */
    TreeMapComponent.prototype.click = /**
     * @param {?} e
     * @return {?}
     */
    function (e) {
    };
    /**
     * @return {?}
     */
    TreeMapComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        this.mapTitleArray = this.maptleComp.toArray();
        if (this.mapTitleArray.length === 1) {
            this.mapTitleComponent = this.mapTitleArray.pop();
        }
    };
    /**
     * @return {?}
     */
    TreeMapComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        this.hasLoaded = false;
        this.loader.loadCharts('TreeMap').subscribe(function (value) { return console.log(); }, function (errror) { return console.error(errror); }, function () {
            _this.drawChart();
        });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    TreeMapComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.drawChart();
    };
    TreeMapComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-map-treemap', template: "\n    <div *ngIf=\"showChart\" #treemapmap\n         [style.width]=\"width\"\n         [style.height]=\"height\" (window:resize)=\"onResize($event)\"\n    >\n      <div *ngIf=\"!hasLoaded\" class=\"lmask\">\n      </div>\n    </div>\n  ", styles: [".lmask {\n    position: absolute;\n    height: 100%;\n    width: 100%;\n    background-color: #000;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    top: 0;\n    z-index: 9999;\n    opacity: 0.4;\n  }\n\n  .lmask.fixed {\n    position: fixed;\n  }\n\n  .lmask:before {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-right: 5px solid transparent;\n    border-left: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 35px #2187e7;\n    width: 50px;\n    height: 50px;\n    -moz-animation: spinPulse 1s infinite ease-in-out;\n    -webkit-animation: spinPulse 1s infinite linear;\n    margin: -25px 0 0 -25px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  .lmask:after {\n    content: '';\n    background-color: transparent;\n    border: 5px solid rgba(0, 183, 229, 0.9);\n    opacity: .9;\n    border-left: 5px solid transparent;\n    border-right: 5px solid transparent;\n    border-radius: 50px;\n    box-shadow: 0 0 15px #2187e7;\n    width: 30px;\n    height: 30px;\n    -moz-animation: spinoffPulse 1s infinite linear;\n    -webkit-animation: spinoffPulse 1s infinite linear;\n    margin: -15px 0 0 -15px;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n  }\n\n  @-moz-keyframes spinPulse {\n    0% {\n      -moz-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -moz-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -moz-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-moz-keyframes spinoffPulse {\n    0% {\n      -moz-transform: rotate(0deg);\n    }\n    100% {\n      -moz-transform: rotate(360deg);\n    }\n  }\n\n  @-webkit-keyframes spinPulse {\n    0% {\n      -webkit-transform: rotate(160deg);\n      opacity: 0;\n      box-shadow: 0 0 1px #2187e7;\n    }\n    50% {\n      -webkit-transform: rotate(145deg);\n      opacity: 1;\n    }\n    100% {\n      -webkit-transform: rotate(-320deg);\n      opacity: 0;\n    }\n  }\n\n  @-webkit-keyframes spinoffPulse {\n    0% {\n      -webkit-transform: rotate(0deg);\n    }\n    100% {\n      -webkit-transform: rotate(360deg);\n    }\n  }\n\n  "],
                },] },
    ];
    /** @nocollapse */
    TreeMapComponent.ctorParameters = function () { return [
        { type: MapLoaderService }
    ]; };
    TreeMapComponent.propDecorators = {
        width: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        data: [{ type: i0.Input, args: ['data',] }],
        mincolor: [{ type: i0.Input, args: ['min-color',] }],
        midcolor: [{ type: i0.Input, args: ['mid-color',] }],
        maxcolor: [{ type: i0.Input, args: ['max-color',] }],
        showscale: [{ type: i0.Input, args: ['show-scale',] }],
        maxpostdepth: [{ type: i0.Input, args: ['max-post-depth',] }],
        onClick: [{ type: i0.Output }],
        maptleComp: [{ type: i0.ContentChildren, args: [MapTitleComponent,] }],
        treemapmap: [{ type: i0.ViewChild, args: ['treemapmap',] }]
    };
    return TreeMapComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var MAP_COMPONENTS = [
    MapPropertiesComponent,
    GeoChartComponent,
    TreeMapComponent,
    MapTitleComponent,
];
var AmexioMapModule = /** @class */ (function () {
    function AmexioMapModule() {
    }
    /**
     * @return {?}
     */
    AmexioMapModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioMapModule,
            providers: [CommonDataService, MapLoaderService],
        };
    };
    AmexioMapModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        HttpClientModule,
                        AmexioCommonModule,
                    ],
                    exports: MAP_COMPONENTS,
                    declarations: MAP_COMPONENTS,
                    providers: [CommonDataService, MapLoaderService],
                },] },
    ];
    return AmexioMapModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 18/1/18.
 */
/*
 * Copyright 2016-2017 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Author - Pratik Kelwalkar
 *
 */
var MultiMediaCarouselComponent = /** @class */ (function () {
    function MultiMediaCarouselComponent() {
        /*
        Properties
        name : has-details
        datatype :  boolean
        version : 4.0 onwards
        default : none
        description : Provide a embedded view for more information on the media
        
        */
        this.hasDetail = true;
        /*
        Events
        name : onVideoLoad
        datatype : none
        version : none
        default : none
        description :
        */
        this.onVideoLoad = new i0.EventEmitter();
        this.right = false;
        this.left = false;
        this.elementId = 'multi-media-ee-carousel-' + Math.floor(Math.random() * 90000) + 10000;
    }
    /**
     * @return {?}
     */
    MultiMediaCarouselComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.carouselStyle == null) {
            this.carouselStyle = 'horizontal';
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    MultiMediaCarouselComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes['data'] != null) {
            this.data = changes['data'].currentValue;
        }
    };
    /**
     * @return {?}
     */
    MultiMediaCarouselComponent.prototype.leftClick = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ ts = document.getElementById(this.elementId);
        ts.scrollLeft -= 350;
        if (ts.scrollLeft === 0) {
            document.getElementById(this.elementId + 'leftarrow').style.visibility = 'hidden';
        }
        document.getElementById(this.elementId + 'rightarrow').style.visibility = 'visible';
    };
    /**
     * @return {?}
     */
    MultiMediaCarouselComponent.prototype.rightClick = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ ts = document.getElementById(this.elementId);
        ts.scrollLeft += 350;
        if ((ts.scrollWidth - ts.offsetWidth - ts.scrollLeft) <= 0) {
            document.getElementById(this.elementId + 'rightarrow').style.visibility = 'hidden';
        }
        document.getElementById(this.elementId + 'leftarrow').style.visibility = 'visible';
    };
    /**
     * @return {?}
     */
    MultiMediaCarouselComponent.prototype.closeDetailPage = /**
     * @return {?}
     */
    function () {
        this.data.forEach(function (item) {
            item.selected = null;
        });
        this.displayDetail = false;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    MultiMediaCarouselComponent.prototype.openDetailsSection = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.videoUrl = item.video;
        this.currentDetailsImagePath = item.details_img;
        this.currentDetailsTitle = item.title;
        this.currentDetailsDesc = item.desc;
        this.currentContent = item.content;
        this.seasonNo = item.seasonNo;
        this.matchPercentage = item.matchPercentage;
        this.ageLimit = item.ageLimit;
        this.releaseYear = item.releaseYear;
        this.data.forEach(function (item1) {
            item1.selected = null;
        });
        item.selected = 'selected';
        this.displayDetail = true;
    };
    /**
     * @param {?} item
     * @return {?}
     */
    MultiMediaCarouselComponent.prototype.loadVideo = /**
     * @param {?} item
     * @return {?}
     */
    function (item) {
        this.onVideoLoad.emit(item.video);
    };
    /**
     * @param {?} video
     * @return {?}
     */
    MultiMediaCarouselComponent.prototype.playVideo = /**
     * @param {?} video
     * @return {?}
     */
    function (video) {
        this.onVideoLoad.emit(video);
    };
    MultiMediaCarouselComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-media-ee-carousel',
                    template: "\n    <div class=\"section-header\" style=\"z-index: 1;\">{{title}}</div>\n    <div class=\"contain row\">\n\n      <div class=\"left-arrow\" [attr.id]=\"elementId+'leftarrow'\" style=\"cursor: pointer\"> <div [ngClass]=\"{'controls' : carouselStyle=='horizontal','controls-v' : carouselStyle=='vertical'}\" (click)=\"leftClick();\"><em class=\"fa fa-chevron-left fa-2x\" aria-hidden=\"true\"></em></div> </div>\n\n      <div class=\"row1\" [attr.id]=\"elementId\">\n        <div class=\"row__inner\">\n          <ng-container *ngIf=\"data\">\n            <div class=\"tile\" *ngFor=\"let item of data;let i = index\">\n              <div class=\"tile__media\" (click)=\"loadVideo(item)\">\n                <img alt=\"title\" class=\"tile__img\" [attr.src]=\"item.img\" />\n              </div>\n              <div class=\"{{item.selected}}\">\n                <em [ngStyle]=\"{'visibility':item.selected ? 'visible':'hidden'}\" class=\"fa fa-caret-down\" aria-hidden=\"false\"></em>\n              </div>\n              <div [ngClass]=\"{'tile__details' : carouselStyle=='horizontal','tile__details_v' : carouselStyle=='vertical'}\">\n                <div class=\"textonly\">\n\n                  <div class=\"playpanel\">\n                    <div style=\"cursor: pointer\" (click)=\"loadVideo(item)\" class=\"playbutton\"><em class=\"fa fa-play\" aria-hidden=\"true\"></em></div>\n                  </div>\n\n                  <span class=\"carousel-title\" *ngIf=\"item.title\">{{item.title}}</span><br>\n                  <span class=\"match\">{{item.matchPercentage}} Match</span> {{item.releaseYear}} <span class=\"age mini\">{{item.ageLimit}}</span> {{item.seasonNo}}<br>\n                  <div class=\"subtitle\">{{item.desc}}</div>\n\n                </div>\n                <div class=\"actionpanel\"   *ngIf=\"item.content\">\n                  <div style=\"cursor: pointer;\" (click)=\"openDetailsSection(item)\"><em class=\"fa fa-chevron-down fa-2x\" aria-hidden=\"true\"></em></div>\n                </div>\n\n\n              </div>\n            </div>\n          </ng-container>\n        </div>\n      </div>\n\n      <ng-container *ngIf=\"carouselStyle=='horizontal'\">\n        <div class=\"right-arrow\" [attr.id]=\"elementId+'rightarrow'\" style=\"cursor: pointer\"> <div [ngClass]=\"{'controls' : carouselStyle=='horizontal','controls-v' : carouselStyle=='vertical'}\" (click)=\"rightClick();\"><em class=\"fa fa-chevron-right fa-2x\" aria-hidden=\"true\"></em></div></div>\n      </ng-container>\n\n      <ng-container *ngIf=\"carouselStyle=='vertical'\">\n        <div class=\"right-arrow-tall\" [attr.id]=\"elementId+'rightarrow'\" style=\"cursor: pointer\"> <div [ngClass]=\"{'controls' : carouselStyle=='horizontal','controls-v' : carouselStyle=='vertical'}\" (click)=\"rightClick();\"><em class=\"fa fa-chevron-right fa-2x\" aria-hidden=\"true\"></em></div></div>\n      </ng-container>\n\n    </div>\n\n    <div [attr.id]=\"elementId+'carousel-detail-content'\" class=\"collapse\" *ngIf=\"hasDetail && displayDetail\">\n      <amexio-ee-content [bg-image-url]=\"currentDetailsImagePath\"\n                         [title]=\"currentDetailsTitle\" [description]=\"currentDetailsDesc\"\n                         [contents]=\"currentContent\" [link]=\"videoUrl\"\n                         (onWatchClick)=\"playVideo(videoUrl)\" (onCloseClick)=\"closeDetailPage()\"\n                         [rate]=\"rate\" [watch]=\"true\" [my-list]=\"true\"\n                         [close]=\"true\" [season-no]=\"seasonNo\" [release-year]=\"releaseYear\" [age-limit]=\"ageLimit\" [match-percentage]=\"matchPercentage\"\n      ></amexio-ee-content>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    MultiMediaCarouselComponent.ctorParameters = function () { return []; };
    MultiMediaCarouselComponent.propDecorators = {
        data: [{ type: i0.Input }],
        carouselStyle: [{ type: i0.Input, args: ['carousel-type',] }],
        hasDetail: [{ type: i0.Input, args: ['has-details',] }],
        title: [{ type: i0.Input }],
        onVideoLoad: [{ type: i0.Output }]
    };
    return MultiMediaCarouselComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ContentComponent = /** @class */ (function () {
    function ContentComponent() {
        /*
        Properties
        name : watch
        datatype :  any
        version : 4.0 onwards
        default : false
        description : Enable watch button.*/
        this.enableWatch = false;
        /*
        Properties
        name : my-list
        datatype : none
        version : 4.0 onwards
        default : false
        description : Enable MyList button.
        */
        this.enableMyList = false;
        /*
        Events
        name :  onWatchClick
        datatype :  none
        version : none
        default : none
        description : Get watch button click.
        */
        this.onWatchClick = new i0.EventEmitter();
        /*
        Properties
        name : onAddListClick
        datatype :  none
        version : none
        default : none
        description : Get add list button click.
        
        */
        this.onAddListClick = new i0.EventEmitter();
        /*
        Properties
        name : onLikeClick
        datatype :  none
        version : none
        default : none
        description : Get like click.
        
        */
        this.onLikeClick = new i0.EventEmitter();
        /*
        Properties
        name : onUnlikeLikeClick
        datatype :  none
        version : none
        default : none
        description : Get unlike click.
        
        */
        this.onUnlikeLikeClick = new i0.EventEmitter();
        /*
        Properties
        name : onCloseClick
        datatype :  any
        version :none
        default : none
        description : Get close content click.
        
        */
        this.onCloseClick = new i0.EventEmitter();
        this.closeEnable = false;
        this.smallScreen = false;
    }
    /**
     * @return {?}
     */
    ContentComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (window.innerWidth < 768) {
            this.smallScreen = true;
            this.size = 'small';
        }
        else {
            this.smallScreen = false;
            this.size = 'default';
        }
    };
    /**
     * @param {?} changes
     * @return {?}
     */
    ContentComponent.prototype.ngOnChanges = /**
     * @param {?} changes
     * @return {?}
     */
    function (changes) {
        if (changes["videoLink"] && !changes["videoLink"].isFirstChange()) {
            this.videoLink = changes["videoLink"].currentValue;
        }
    };
    /**
     * @return {?}
     */
    ContentComponent.prototype.playVideo = /**
     * @return {?}
     */
    function () {
        this.onWatchClick.emit(this.videoLink);
    };
    /**
     * @return {?}
     */
    ContentComponent.prototype.addToList = /**
     * @return {?}
     */
    function () {
        this.overviewData = {
            'title': this.title, 'description': this.description, 'Video Link': this.videoLink, 'rate': this.rate,
        };
        this.onAddListClick.emit(this.overviewData);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    ContentComponent.prototype.onResize = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (event.target.innerWidth < 995) {
            this.size = 'small';
            this.smallScreen = true;
        }
        else {
            this.size = 'default';
            this.smallScreen = false;
        }
    };
    /**
     * @return {?}
     */
    ContentComponent.prototype.getClassName = /**
     * @return {?}
     */
    function () {
        if (this.smallScreen) {
            return 'button-small';
        }
        else {
            return 'button';
        }
    };
    /**
     * @return {?}
     */
    ContentComponent.prototype.unlikeClick = /**
     * @return {?}
     */
    function () {
        this.overviewData = {
            title: this.title, rate: this.rate,
        };
        this.onUnlikeLikeClick.emit(this.overviewData);
    };
    /**
     * @return {?}
     */
    ContentComponent.prototype.likeClick = /**
     * @return {?}
     */
    function () {
        this.overviewData = {
            title: this.title, rate: this.rate,
        };
        this.onLikeClick.emit(this.overviewData);
    };
    /**
     * @return {?}
     */
    ContentComponent.prototype.closeDetailPage = /**
     * @return {?}
     */
    function () {
        this.onCloseClick.emit(this.title);
    };
    ContentComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-ee-content', template: "\n    <div class=\"main-content\" [ngStyle]=\"{'background-image':'url('+bgImgUrl+')'}\" (window:resize)=\"onResize($event)\">\n       <span *ngIf=\"closeEnable\" class=\"close-button\">\n        <i class=\"fa fa-times fa-lg\" (click)=\"closeDetailPage()\" aria-hidden=\"true\"></i>\n      </span>\n      <div class=\"content-area\" >\n        <span class=\"content-title\">{{title}}</span><br>\n        <span><span class=\"match\" *ngIf=\"matchPercentage\">{{matchPercentage}} Match</span> {{releaseYear}} <span\n          class=\"age\" *ngIf=\"ageLimit\">{{ageLimit}}</span> {{seasonNo}}</span><br>\n        <p style=\"word-wrap: break-word;\">{{description}}<br>\n\n        <ng-container *ngIf=\"contents\">\n              <span>\n                <li *ngFor=\"let data of contents\"><strong\n                  style=\"color: #999;\">{{data.key}}: </strong> <strong>  {{data.value}}</strong></li><br>\n          </span>\n        </ng-container>\n        <ul class=\"inline-list\">\n          <li *ngIf=\"enableWatch\">\n            <span class=\"content-button\" (click)=\"playVideo()\">\n            <i class=\"fa fa-play\"></i> &nbsp;&nbsp; Play</span>\n            <!-- <amexio-ee-btn [cClass]=\"'buttoncustom'\"\n            [label]=\"'Play'\" [type]=\"'danger'\" [icon]=\"'fa fa-play'\"\n            [tooltipMessage]=\"'play'\" [size]=\"size\" (onClick)=\"playVideo()\">\n            </amexio-ee-btn> -->\n          </li>\n          <li *ngIf=\"enableMyList\">\n            <span class=\"content-button\" (click)=\"addToList()\">\n            <i class=\"fa fa-plus\"></i>&nbsp;&nbsp; MY LIST</span>\n            <!-- <amexio-ee-btn [cClass]=\"'secondarybutton'\" [label]=\"'MY LIST'\"\n            [icon]=\"'fa fa-plus'\" [type]=\"'secondary'\" [tooltipMessage]=\"'My List'\"\n            [size]=\"size\" (onClick)=\"addToList()\"></amexio-ee-btn> -->\n          </li>\n          <li>\n            <a style=\"color: white!important;\" [ngClass]=\"getClassName()\" (click)=\"likeClick()\"><i class=\"fa fa-thumbs-o-up fa-lg\"\n                                                                   aria-hidden=\"true\"></i>\n            </a>\n          </li>\n          <li><a style=\"color: white!important;\" [ngClass]=\"getClassName()\" (click)=\"unlikeClick()\"><i class=\"fa fa-thumbs-o-down fa-lg \"\n                                                                       aria-hidden=\"true\"></i></a></li>\n\n        </ul>\n        <ng-container *ngIf=\"rate && max\">\n          <amexio-rating-input [(ngModel)]=\"rate\"\n                               [max]=\"max\" name=\"rate\"\n                               [read-only]=\"isReadonly\">\n          </amexio-rating-input>\n        </ng-container>\n      </div>\n    </div>",
                },] },
    ];
    /** @nocollapse */
    ContentComponent.ctorParameters = function () { return []; };
    ContentComponent.propDecorators = {
        bgImgUrl: [{ type: i0.Input, args: ['bg-image-url',] }],
        title: [{ type: i0.Input }],
        description: [{ type: i0.Input }],
        contents: [{ type: i0.Input }],
        videoLink: [{ type: i0.Input, args: ['link',] }],
        rate: [{ type: i0.Input }],
        max: [{ type: i0.Input }],
        isReadonly: [{ type: i0.Input }],
        enableWatch: [{ type: i0.Input, args: ['watch',] }],
        enableMyList: [{ type: i0.Input, args: ['my-list',] }],
        ageLimit: [{ type: i0.Input, args: ['age-limit',] }],
        releaseYear: [{ type: i0.Input, args: ['release-year',] }],
        seasonNo: [{ type: i0.Input, args: ['season-no',] }],
        matchPercentage: [{ type: i0.Input, args: ['match-percentage',] }],
        closeEnable: [{ type: i0.Input, args: ['close',] }],
        onWatchClick: [{ type: i0.Output }],
        onAddListClick: [{ type: i0.Output }],
        onLikeClick: [{ type: i0.Output }],
        onUnlikeLikeClick: [{ type: i0.Output }],
        onCloseClick: [{ type: i0.Output }]
    };
    return ContentComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioWeekDayAvailiblityComponent = /** @class */ (function () {
    function AmexioWeekDayAvailiblityComponent() {
        this.ariadateavailable = [];
        this.noOfDaysArray = [];
        this.selectedDays = [];
        this.data1 = [];
        this.month = ['January', 'Feburary', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        this.day = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'];
        this.height = 'auto';
        this.noOfDays = 7;
        this.multiSelect = false;
        this.availableSlotsBgColor = '';
        this.availableSlotsColor = '';
        this.selectedSlotColor = '';
        this.selectedSlotBgColor = '';
        this.onSingleSelect = new i0.EventEmitter();
        this.onMultiSelect = new i0.EventEmitter();
    }
    Object.defineProperty(AmexioWeekDayAvailiblityComponent.prototype, "date", {
        get: /**
         * @return {?}
         */
        function () {
            return this.currentDate;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v != null && v) {
                this.currentDate = new Date(v.getTime());
                this.initComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmexioWeekDayAvailiblityComponent.prototype, "availableslots", {
        get: /**
         * @return {?}
         */
        function () {
            return this.datesavailable;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v != null && v) {
                this.datesavailable = v;
                this.initComponent();
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @param {?} event1
     * @param {?} dayModel1
     * @param {?} time1
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.onTimeClick = /**
     * @param {?} event1
     * @param {?} dayModel1
     * @param {?} time1
     * @return {?}
     */
    function (event1, dayModel1, time1) {
        if (time1 && time1.available && this.multiSelect) {
            this.onMultiSelection(dayModel1, time1);
        }
        else if (time1 && time1.available && !this.multiSelect) {
            this.viewData.forEach(function (object) {
                object.timeslots.forEach(function (element) {
                    if (element === time1) {
                        element.selected = true;
                    }
                    else {
                        element.selected = false;
                    }
                });
            });
            this.onSingleSelect.emit({ date: dayModel1.date, time: time1.time, timeId: time1.timeId });
        }
    };
    /**
     * @param {?} data1
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.onArrowDown = /**
     * @param {?} data1
     * @return {?}
     */
    function (data1) {
        this.actualtime = '';
        var /** @type {?} */ tempid = data1.ariaId;
        var /** @type {?} */ slicedid = tempid.slice(6);
        slicedid++;
        var /** @type {?} */ newid = this.randomid + '-' + slicedid;
        document.getElementById(newid).focus();
    };
    /**
     * @param {?} data1
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.readtime = /**
     * @param {?} data1
     * @return {?}
     */
    function (data1) {
        var /** @type {?} */ t = parseInt(data1.time, 10);
        var /** @type {?} */ t1 = t % 12;
        if (t1 <= 12) {
            if (t1 === 0) {
                this.actualtime = 12 + ' ' + 'am';
            }
            else {
                this.actualtime = t1 + ' ' + 'am';
            }
        }
        else {
            this.actualtime = t1 + ' ' + 'pm';
        }
    };
    /**
     * @param {?} data1
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.onArrowUp = /**
     * @param {?} data1
     * @return {?}
     */
    function (data1) {
        var /** @type {?} */ tempid = data1.ariaId;
        var /** @type {?} */ slicedid = tempid.slice(6);
        slicedid--;
        var /** @type {?} */ newid = this.randomid + '-' + slicedid;
        document.getElementById(newid).focus();
    };
    /**
     * @param {?} data1
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.onArrowRight = /**
     * @param {?} data1
     * @return {?}
     */
    function (data1) {
        this.onArrowDown(data1);
    };
    /**
     * @param {?} data1
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.onArrowLeft = /**
     * @param {?} data1
     * @return {?}
     */
    function (data1) {
        this.onArrowUp(data1);
    };
    /**
     * @param {?} dayModel1
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.getFullMonthName = /**
     * @param {?} dayModel1
     * @return {?}
     */
    function (dayModel1) {
        var /** @type {?} */ months = ['January', 'Febuary', 'March', 'April', 'May',
            'June', 'July', 'August', 'September', 'October', 'November', 'December'];
        var /** @type {?} */ datemonth = dayModel1.date.getMonth();
        var /** @type {?} */ monthString = '';
        months.forEach(function (element, index) {
            if (datemonth === index) {
                monthString = element;
            }
        });
        return monthString;
    };
    /**
     * @param {?} dayModel1
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.getFullDayName = /**
     * @param {?} dayModel1
     * @return {?}
     */
    function (dayModel1) {
        var /** @type {?} */ weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
            'Thursday', 'Friday', 'Saturday'];
        var /** @type {?} */ day = dayModel1.date.getDay();
        var /** @type {?} */ dayname = '';
        weekdays.forEach(function (element, index) {
            if (day === index) {
                dayname = element;
            }
        });
        return dayname;
    };
    /**
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.gettime = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.initComponent = /**
     * @return {?}
     */
    function () {
        var _this = this;
        if (this.currentDate) {
            this.viewData = [];
            this.randomid = Math.floor(Math.random() * 90000) + 10000;
            var /** @type {?} */ clonedDate = new Date(this.currentDate.getTime());
            var /** @type {?} */ startDate = clonedDate;
            var /** @type {?} */ d1 = new DayModel(new Date(startDate.getTime()), true, this.availableslots);
            d1.setTimeSlots(this.setStyle(new TimeUtil().timeData(true)));
            d1['fulldate'] = this.getFullDayName(d1) + ' ' + d1.date.getDate() + ' ' + this.getFullMonthName(d1)
                + ' ' + d1.date.getFullYear() + ' ' + d1.date.getUTCHours();
            this.viewData.push(d1);
            this.noOfDaysArray = [];
            for (var /** @type {?} */ i = 0; i < this.noOfDays; i++) {
                this.noOfDaysArray.push(i);
            }
            for (var /** @type {?} */ i = 1; i < this.noOfDays; i++) {
                var /** @type {?} */ wdate = this.createWeekDays(startDate, i);
                var /** @type {?} */ d2 = new DayModel(new Date(wdate.getTime()), true, this.availableslots);
                d2.setTimeSlots(this.setStyle(new TimeUtil().timeData(true)));
                d2['fulldate'] = this.getFullDayName(d2) + ' ' + d2.date.getDate()
                    + ' ' + this.getFullMonthName(d2) + ' ' + d2.date.getFullYear() + ' ' + d2.date.getUTCHours();
                this.viewData.push(d2);
                startDate = wdate;
            }
            var /** @type {?} */ inc_1 = 0;
            this.viewData.forEach(function (element) {
                if (element.availableSlots) {
                    element.timeslots.forEach(function (data) {
                        if (data.available) {
                            data['ariaId'] = _this.randomid + '-' + inc_1;
                            inc_1++;
                        }
                    });
                }
            });
        }
    };
    /**
     * @param {?} date
     * @param {?} count
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.createWeekDays = /**
     * @param {?} date
     * @param {?} count
     * @return {?}
     */
    function (date, count) {
        date.setHours(date.getHours() + 24);
        return date;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.getMonday = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (date) {
            var /** @type {?} */ day = date.getDay() || 7;
            if (day !== 1) {
                date.setHours(-24 * (day - 1));
            }
        }
        return date;
    };
    /**
     * @param {?} dayModel1
     * @param {?} time1
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.onMultiSelection = /**
     * @param {?} dayModel1
     * @param {?} time1
     * @return {?}
     */
    function (dayModel1, time1) {
        var _this = this;
        dayModel1.timeslots.forEach(function (obj) {
            if (obj === time1) {
                var /** @type {?} */ selectedAppointDate_1 = {
                    date: dayModel1.date,
                    time: obj.time,
                    timeId: obj.timeId,
                };
                obj.selected = true;
                if (_this.selectedDays.length > 0) {
                    _this.selectedDays.forEach(function (item, index) {
                        if (item.date === selectedAppointDate_1.date) {
                            _this.selectedDays.splice(index, 1);
                        }
                    });
                    _this.selectedDays.push(selectedAppointDate_1);
                }
                else {
                    _this.selectedDays.push(selectedAppointDate_1);
                }
            }
            else {
                obj.selected = false;
            }
        });
        this.onSingleSelect.emit({ date: dayModel1.date, time: time1.time, timeId: time1.timeId });
        this.onMultiSelect.emit(this.selectedDays);
    };
    /**
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.getAvailableStyle = /**
     * @return {?}
     */
    function () {
        return {
            'background-color': this.availableSlotsBgColor,
            'color': this.availableSlotsColor,
        };
    };
    /**
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.getSelectedStyle = /**
     * @return {?}
     */
    function () {
        return {
            'background-color': this.selectedSlotBgColor,
            'color': this.selectedSlotColor,
        };
    };
    /**
     * @param {?} timeModelData
     * @return {?}
     */
    AmexioWeekDayAvailiblityComponent.prototype.setStyle = /**
     * @param {?} timeModelData
     * @return {?}
     */
    function (timeModelData) {
        var _this = this;
        timeModelData.forEach(function (time) {
            time.selectedStyleClass = _this.getSelectedStyle();
            time.availableStyleClass = _this.getAvailableStyle();
        });
        return timeModelData;
    };
    AmexioWeekDayAvailiblityComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-ee-appointment',
                    template: "\n      <div class=\"weekdaycomponent\">\n          <div class=\"datetimepicker1\" style=\"width: 100%;\">\n              <ul *ngIf=\"viewData && (viewData.length == noOfDays)\" class=\"weekdays\" style=\"padding: 5px 0!important\">\n                  <li *ngFor=\"let day of noOfDaysArray\" style=\"width: 14.28%;\">\n                      <label>{{viewData[day].date| date:'E'}} </label><br />\n                      <label style=\"font-size: 10px;\">{{viewData[day].date| date:'dd/MM/yy'}}</label>\n                  </li>\n              </ul>\n              <ul *ngIf=\"viewData && (viewData.length == noOfDays)\" class=\"weekdays\" [style.height]=\"height\" style=\"overflow: auto;padding: 5px 0!important\">\n                  <li *ngFor=\"let day of noOfDaysArray\" style=\"width: 14.28%;\">\n                      <ng-container *ngIf=\"viewData[day] && viewData[day].timeslots &&  viewData[day].timeslots.length>0\">\n                          <ng-container *ngFor=\"let time of  viewData[day].timeslots\">\n                              <div (focus)=\"readtime(time,viewData[day])\" id={{time.ariaId}} [tabindex]=\"time.available ? 0 : -1\"\n                                  attr.aria-label=\"{{viewData[day].fulldate | date : 'EEEE, MMMM d, y'}} {{actualtime}}\"\n                                  *ngIf=\"(time.timeId >= startTime && time.timeId <= endTime)\" style=\"padding:5px;\" [ngStyle]=\"time.selected ? time.selectedStyleClass: (time.available ? time.availableStyleClass : '')\"\n                                  [ngClass]=\"{'availableweekday': time.available,'notavailableweekday': !time.available,'selectedDay':time.selected}\"\n                                  (click)=\"onTimeClick($event,viewData[day],time)\" (keyup.arrowdown)=\"onArrowDown(time)\"\n                                  (keyup.arrowup)=\"onArrowUp(time)\" (keyup.arrowright)=\"onArrowRight(time)\" (keyup.arrowleft)=\"onArrowLeft(time)\" (keyup.enter)=\"onTimeClick($event,viewData[day],time)\">\n                                  {{time.time}}\n                              </div>\n                          </ng-container>\n                      </ng-container>\n                  </li>\n              </ul>\n          </div>\n      </div>\n    ",
                },] },
    ];
    /** @nocollapse */
    AmexioWeekDayAvailiblityComponent.ctorParameters = function () { return []; };
    AmexioWeekDayAvailiblityComponent.propDecorators = {
        height: [{ type: i0.Input, args: ['height',] }],
        startTime: [{ type: i0.Input, args: ['start-time',] }],
        endTime: [{ type: i0.Input, args: ['end-time',] }],
        noOfDays: [{ type: i0.Input, args: ['no-of-days',] }],
        multiSelect: [{ type: i0.Input, args: ['multi-select',] }],
        availableSlotsBgColor: [{ type: i0.Input, args: ['available-slots-bg-color',] }],
        availableSlotsColor: [{ type: i0.Input, args: ['available-slots-color',] }],
        selectedSlotColor: [{ type: i0.Input, args: ['selected-slot-color',] }],
        selectedSlotBgColor: [{ type: i0.Input, args: ['selected-slot-bg-color',] }],
        date: [{ type: i0.Input, args: ['date',] }],
        availableslots: [{ type: i0.Input, args: ['available-slots',] }],
        onSingleSelect: [{ type: i0.Output }],
        onMultiSelect: [{ type: i0.Output }]
    };
    return AmexioWeekDayAvailiblityComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Created by pratik on 18/1/18.
 */
var AmexioYoutubePlayerComponent = /** @class */ (function () {
    function AmexioYoutubePlayerComponent(sanitizer) {
        this.sanitizer = sanitizer;
        /*
        Events
        name :onCloseVideoPlayer
        datatype : none
        version : none
        default : none
        description : it is fired on video player close event
        
        */
        this.onCloseVideoPlayer = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    AmexioYoutubePlayerComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        if (this.height == null) {
            this.height = 450;
        }
        if (this.width == null) {
            this.width = 98;
            this.closePadding = 97;
        }
        else {
            this.closePadding = this.width - 1;
        }
        if (this.url != null) {
            this.sanitizedUrl = this.sanitizer.bypassSecurityTrustResourceUrl(this.url);
        }
    };
    /**
     * @return {?}
     */
    AmexioYoutubePlayerComponent.prototype.routeBackToApp = /**
     * @return {?}
     */
    function () {
        this.onCloseVideoPlayer.emit(this.url);
    };
    AmexioYoutubePlayerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-ee-youtube-player', template: "\n    <div>\n      <span class=\"close-button\" [ngStyle]=\"{'padding-left':closePadding+'%'}\">\n        <i class=\"fa fa-times fa-lg\" (click)=\"routeBackToApp()\" aria-hidden=\"true\"></i>\n      </span>\n      <div class=\"text-center\">\n        <iframe [height]=\"height+'px'\" [width]=\"width+'%'\"\n                [src]=\"sanitizedUrl\" frameborder=\"0\"\n                allowfullscreen>\n        </iframe>\n      </div>\n    </div>\n  ",
                },] },
    ];
    /** @nocollapse */
    AmexioYoutubePlayerComponent.ctorParameters = function () { return [
        { type: platformBrowser.DomSanitizer }
    ]; };
    AmexioYoutubePlayerComponent.propDecorators = {
        url: [{ type: i0.Input }],
        height: [{ type: i0.Input }],
        width: [{ type: i0.Input }],
        onCloseVideoPlayer: [{ type: i0.Output }]
    };
    return AmexioYoutubePlayerComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CALENDAR = {
    ALL_DAY_TEXT: 'all-day',
    YEAR: 'year',
    MONTH: 'month',
    WEEK: 'week',
    DAY: 'day',
    FULL: 'full',
    SHORT: 'short',
    MIN: 'min',
    DAY_NAME: {
        full: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'],
        short: ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'],
        min: ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'],
    },
    MONTH_NAME: {
        full: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October',
            'November', 'December'],
        short: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],
        min: ['Ja', 'Fe', 'Ma', 'Ap', 'Ma', 'Jun', 'Jul', 'Au', 'Se', 'Oc', 'No', 'De'],
    },
    DAY_TIME_SERIES_WITH_30: [{ hr: 0, min: 0 }, { hr: 0, min: 30 }, { hr: 1, min: 0 }, { hr: 1, min: 30 },
        { hr: 2, min: 0 }, { hr: 2, min: 30 }, { hr: 3, min: 0 }, { hr: 3, min: 30 }, { hr: 4, min: 0 },
        { hr: 4, min: 30 }, { hr: 5, min: 0 }, { hr: 5, min: 30 }, { hr: 6, min: 0 }, { hr: 6, min: 30 },
        { hr: 7, min: 0 }, { hr: 7, min: 30 }, { hr: 8, min: 0 }, { hr: 8, min: 30 }, { hr: 9, min: 0 },
        { hr: 9, min: 30 }, { hr: 10, min: 0 }, { hr: 10, min: 30 }, { hr: 11, min: 0 }, { hr: 11, min: 30 },
        { hr: 12, min: 0 }, { hr: 12, min: 30 }, { hr: 13, min: 0 }, { hr: 13, min: 30 }, { hr: 14, min: 0 },
        { hr: 14, min: 30 }, { hr: 15, min: 0 }, { hr: 15, min: 30 }, { hr: 16, min: 0 }, { hr: 16, min: 30 },
        { hr: 17, min: 0 }, { hr: 17, min: 30 }, { hr: 18, min: 0 }, { hr: 18, min: 30 }, { hr: 19, min: 0 },
        { hr: 19, min: 30 }, { hr: 20, min: 0 }, { hr: 20, min: 30 }, { hr: 21, min: 0 }, { hr: 21, min: 30 },
        { hr: 22, min: 0 }, { hr: 22, min: 30 }, { hr: 23, min: 0 }, { hr: 23, min: 30 }, { hr: 24, min: 0 }],
    DAY_TIME_SERIES: [{ hr: 0, min: 0 }, { hr: 1, min: 0 }, { hr: 2, min: 0 }, { hr: 3, min: 0 },
        { hr: 4, min: 0 }, { hr: 5, min: 0 }, { hr: 6, min: 0 }, { hr: 7, min: 0 }, { hr: 8, min: 0 },
        { hr: 9, min: 0 }, { hr: 10, min: 0 }, { hr: 11, min: 0 }, { hr: 12, min: 0 }, { hr: 13, min: 0 },
        { hr: 14, min: 0 }, { hr: 15, min: 0 }, { hr: 16, min: 0 }, { hr: 17, min: 0 }, { hr: 18, min: 0 },
        { hr: 19, min: 0 }, { hr: 20, min: 0 }, { hr: 21, min: 0 }, { hr: 22, min: 0 }, { hr: 23, min: 0 },
        { hr: 24, min: 0 }],
};

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var CalendarEventModel = /** @class */ (function () {
    function CalendarEventModel(isEvent, details, title, hasTimeSlot, eventDateTime, events) {
        this.isEvent = isEvent;
        this.details = details;
        this.title = title;
        this.hasTimeSlot = hasTimeSlot;
        this.eventDateTime = eventDateTime;
        this.events = events;
    }
    return CalendarEventModel;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioDateUtils = /** @class */ (function () {
    function AmexioDateUtils() {
    }
    /**
     * @param {?} d1
     * @param {?} d2
     * @return {?}
     */
    AmexioDateUtils.prototype.isDateEqual = /**
     * @param {?} d1
     * @param {?} d2
     * @return {?}
     */
    function (d1, d2) {
        var /** @type {?} */ date1 = new Date(d1.getTime());
        var /** @type {?} */ date2 = new Date(d2.getTime());
        if (date1.getTime() === date2.getTime()) {
            return true;
        }
        else if ((date1.getUTCFullYear() === date2.getUTCFullYear()) && (date1.getMonth() === date2.getMonth())
            && (date1.getDate() === date2.getDate())) {
            return true;
        }
        return false;
    };
    /**
     * @param {?} d1
     * @param {?} d2
     * @return {?}
     */
    AmexioDateUtils.prototype.isDateGreaterThenEqualTO = /**
     * @param {?} d1
     * @param {?} d2
     * @return {?}
     */
    function (d1, d2) {
        var /** @type {?} */ date1 = new Date(d1.getTime());
        var /** @type {?} */ date2 = new Date(d2.getTime());
        if (date1.getTime() >= date2.getTime()) {
            return true;
        }
        return false;
    };
    /**
     * @param {?} selectedPeriod
     * @param {?} currrentDate
     * @return {?}
     */
    AmexioDateUtils.prototype.createDaysForMonths = /**
     * @param {?} selectedPeriod
     * @param {?} currrentDate
     * @return {?}
     */
    function (selectedPeriod, currrentDate) {
        var /** @type {?} */ calendaryData = [];
        var /** @type {?} */ date = new Date(selectedPeriod.getFullYear(), selectedPeriod.getMonth(), 1, 0, 0, 0, 0); // Starting at the 1st of the month
        var /** @type {?} */ extras = (date.getDay() + 6) % 7; // How many days of the last month do we need to include?
        date.setDate(date.getDate() - extras); // Skip back to the previous monday
        while (calendaryData.length < 6) {
            var /** @type {?} */ rowDays = [];
            for (var /** @type {?} */ i = 0; i < 7; i++) {
                var /** @type {?} */ day = {
                    date: null, selected: false, isActivePeriod: null, isDisabled: false,
                    isActive: false, isEvent: false, eventDetails: null,
                };
                day['id'] = Math.floor(Math.random() * 90000) + 10000 + '_monthid';
                day.date = new Date(date.getTime());
                day.isActivePeriod = (date.getMonth() === selectedPeriod.getMonth());
                day.isActive = this.isDateEqual(day.date, new Date());
                rowDays.push(day);
                date.setDate(date.getDate() + 1);
            }
            calendaryData.push(rowDays);
        }
        return calendaryData;
    };
    /**
     * @param {?} selectedPeriod
     * @param {?} currrentDate
     * @return {?}
     */
    AmexioDateUtils.prototype.createDaysForWeek = /**
     * @param {?} selectedPeriod
     * @param {?} currrentDate
     * @return {?}
     */
    function (selectedPeriod, currrentDate) {
        var /** @type {?} */ calendaryData = [];
        var /** @type {?} */ date = this.getMonday(selectedPeriod);
        for (var /** @type {?} */ i = 0; i < 7; i++) {
            var /** @type {?} */ day = {
                date: null, selected: false, isActivePeriod: null, isDisabled: false, isActive: false, isEvent: false, eventDetails: null,
            };
            day.date = new Date(date.getTime());
            day.isActivePeriod = (date.getMonth() === selectedPeriod.getMonth());
            day.isActive = this.isDateEqual(day.date, currrentDate);
            calendaryData.push(day.date);
            date.setDate(date.getDate() + 1);
        }
        return calendaryData;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    AmexioDateUtils.prototype.getMonday = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (date) {
            var /** @type {?} */ day = date.getDay() || 7;
            if (day !== 1) {
                date.setHours(-24 * (day - 1));
            }
        }
        return date;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    AmexioDateUtils.prototype.getWeekSunday = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        if (date.getDay() === 0) {
            return date;
        }
        else {
            var /** @type {?} */ diff = date.getDate() - date.getDay() + (date.getDay() === 0 ? -6 : 1);
            var /** @type {?} */ monday = new Date(date.setDate(diff));
            return new Date(monday.setDate(monday.getDate() - 1));
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    AmexioDateUtils.prototype.getNextSunday = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        var /** @type {?} */ currentSunday = this.getWeekSunday(date);
        currentSunday.setDate(currentSunday.getDate() + 7);
        return new Date(currentSunday.getTime());
    };
    /**
     * @param {?} date
     * @return {?}
     */
    AmexioDateUtils.prototype.getPrevSunday = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        var /** @type {?} */ currentSunday = this.getWeekSunday(date);
        currentSunday.setDate(currentSunday.getDate() - 7);
        return new Date(currentSunday.getTime());
    };
    /**
     * @param {?} date
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    AmexioDateUtils.prototype.isBetween = /**
     * @param {?} date
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    function (date, startDate, endDate) {
        endDate.setSeconds(0);
        startDate.setSeconds(0);
        date.setSeconds(0);
        startDate.setMilliseconds(0);
        endDate.setMilliseconds(0);
        date.setMilliseconds(0);
        if (date.getTime() > startDate.getTime() && date.getTime() < endDate.getTime()) {
            return true;
        }
        return false;
    };
    /**
     * @param {?} longdate
     * @return {?}
     */
    AmexioDateUtils.prototype.getDateWithSecondsZero = /**
     * @param {?} longdate
     * @return {?}
     */
    function (longdate) {
        var /** @type {?} */ date = new Date(longdate);
        date.setSeconds(0);
        date.setMilliseconds(0);
        return date;
    };
    return AmexioDateUtils;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCalendarComponent = /** @class */ (function () {
    function AmexioCalendarComponent() {
        this.displayHeaders = [];
        this.calendarMonthData = [];
        this.calendarWeekData = [];
        this.prevMonthPressed = false;
        this.nextMonthPressed = false;
        this.dayPressed = false;
        this.weekPressed = false;
        this.monthPressed = false;
        this.yearPressed = false;
        this.onEventClicked = new i0.EventEmitter();
        this.currentState = CALENDAR.MONTH;
        this.headertype = CALENDAR.SHORT;
        this.currrentDate = new Date();
        this.events = [];
        this.adu = new AmexioDateUtils();
        this.weekHeaders = { title: CALENDAR.ALL_DAY_TEXT, daywiseevent: null, time: null };
    }
    Object.defineProperty(AmexioCalendarComponent.prototype, "calendardate", {
        get: /**
         * @return {?}
         */
        function () {
            return this._calenadrDate;
        },
        set: /**
         * @param {?} v
         * @return {?}
         */
        function (v) {
            if (v != null) {
                try {
                    this._calenadrDate = v;
                    this.currrentDate = new Date(v);
                }
                catch (/** @type {?} */ e) {
                    this.currrentDate = new Date();
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @return {?}
     */
    AmexioCalendarComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.initCalendar();
    };
    /**
     * @return {?}
     */
    AmexioCalendarComponent.prototype.initCalendar = /**
     * @return {?}
     */
    function () {
        this.validateEventData();
        this.createData(this.currrentDate);
        this.prevbtnid = Math.floor(Math.random() * 90000) + 10000 + '_previd';
        this.nextbtnid = Math.floor(Math.random() * 90000) + 10000 + '_nextid';
        this.daybtnid = Math.floor(Math.random() * 90000) + 10000 + '_dayid';
        this.weekbtnid = Math.floor(Math.random() * 90000) + 10000 + '_weekid';
        this.monthbtnid = Math.floor(Math.random() * 90000) + 10000 + '_monthid';
        this.yearbtnid = Math.floor(Math.random() * 90000) + 10000 + '_yearid';
    };
    /**
     * @return {?}
     */
    AmexioCalendarComponent.prototype.validateEventData = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ newEvents = [];
        var /** @type {?} */ i = 1;
        this.events.forEach(function (event) {
            if ((event.start + '').indexOf('T') !== -1) {
                event.hasTimeSlot = true;
            }
            if (i > 9) {
                i = 1;
            }
            if (_this.eventColorGrouping) {
                event['eventclass'] = 'calendar-active-' + i;
            }
            if (event.end) {
                var /** @type {?} */ events1 = _this.generatEventData(new Date(event.start), new Date(event.end));
                events1.forEach(function (event1) {
                    var /** @type {?} */ newobj = Object.assign({}, event);
                    newobj.start = event1;
                    newEvents.push(newobj);
                });
            }
            i++;
        });
        newEvents.forEach(function (event) {
            _this.events.push(event);
        });
    };
    /**
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    AmexioCalendarComponent.prototype.generatEventData = /**
     * @param {?} startDate
     * @param {?} endDate
     * @return {?}
     */
    function (startDate, endDate) {
        var /** @type {?} */ event = [];
        var /** @type {?} */ flag = false;
        while (startDate.getTime() <= endDate.getTime()) {
            if (flag) {
                event.push(new Date(startDate.getTime()));
            }
            flag = true;
            startDate.setDate(startDate.getDate() + 1);
        }
        return event;
    };
    /**
     * @param {?} date
     * @return {?}
     */
    AmexioCalendarComponent.prototype.hasEvent = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        var _this = this;
        var /** @type {?} */ eventsData = [];
        var /** @type {?} */ flag = { isEvent: false };
        if (this.events && this.events.length > 0) {
            this.events.forEach(function (event) {
                var /** @type {?} */ eventStartDate = new Date(event.start);
                var /** @type {?} */ isEvent = _this.adu.isDateEqual(date, eventStartDate);
                if (isEvent) {
                    eventsData.push(new CalendarEventModel(isEvent, event, event.title, event.hasTimeSlot, date, null));
                    flag.isEvent = isEvent;
                }
            });
        }
        flag['events'] = eventsData;
        return flag;
    };
    /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    AmexioCalendarComponent.prototype.createData = /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    function (selectedPeriod) {
        if (this.currentState === CALENDAR.MONTH) {
            this.displayHeaders = CALENDAR.DAY_NAME[this.headertype];
            this.calendarMonthData = this.createDaysForCurrentMonths(selectedPeriod, this.currrentDate);
        }
        else if (this.currentState === CALENDAR.WEEK || this.currentState === CALENDAR.DAY) {
            var /** @type {?} */ weekDays = [];
            if (this.currentState === CALENDAR.WEEK) {
                weekDays = this.adu.createDaysForWeek(selectedPeriod, this.currrentDate);
            }
            else {
                weekDays = [];
                weekDays.push(new Date(this.currrentDate.getTime()));
            }
            this.displayHeaders = weekDays;
            this.createDaysForCurrentWeek(selectedPeriod);
        }
        else if (this.currentState === CALENDAR.YEAR) {
            this.displayHeaders = CALENDAR.DAY_NAME[CALENDAR.SHORT];
            this.calendarMonthData = this.createYearData();
        }
    };
    /**
     * @return {?}
     */
    AmexioCalendarComponent.prototype.createYearData = /**
     * @return {?}
     */
    function () {
        var /** @type {?} */ yearData = [];
        var /** @type {?} */ year = this.currrentDate.getUTCFullYear();
        var /** @type {?} */ months = CALENDAR.MONTH_NAME[CALENDAR.FULL];
        for (var /** @type {?} */ i = 0; i < months.length; i++) {
            var /** @type {?} */ monthDate = new Date(year, i, 1);
            var /** @type {?} */ monthData1 = this.createDaysForCurrentMonths(monthDate, new Date());
            yearData.push(Object.assign({}, { month: monthDate, title: months[i], data: monthData1 }));
        }
        return yearData;
    };
    /**
     * @param {?} selectedPeriod
     * @param {?} currrentDate
     * @return {?}
     */
    AmexioCalendarComponent.prototype.createDaysForCurrentMonths = /**
     * @param {?} selectedPeriod
     * @param {?} currrentDate
     * @return {?}
     */
    function (selectedPeriod, currrentDate) {
        var _this = this;
        var /** @type {?} */ calendarMonthData = [];
        var /** @type {?} */ monthData = this.adu.createDaysForMonths(selectedPeriod, currrentDate);
        monthData.forEach(function (week) {
            var /** @type {?} */ rowDays = [];
            week.forEach(function (day) {
                var /** @type {?} */ eventDetails = _this.hasEvent(day.date);
                if (eventDetails && eventDetails.isEvent) {
                    day.eventDetails = eventDetails;
                    day.isEvent = eventDetails.isEvent;
                }
                rowDays.push(day);
            });
            calendarMonthData.push(rowDays);
        });
        return calendarMonthData;
    };
    /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    AmexioCalendarComponent.prototype.createDaysForCurrentWeek = /**
     * @param {?} selectedPeriod
     * @return {?}
     */
    function (selectedPeriod) {
        var _this = this;
        this.calendarWeekData = [];
        var /** @type {?} */ allday = Object.assign({}, this.weekHeaders);
        allday.daywiseevent = [];
        this.displayHeaders.forEach(function (date) {
            var /** @type {?} */ eventDetails1 = _this.hasWeekEvent(date, true);
            var /** @type {?} */ weekobj = Object.assign({}, _this.weekobject);
            weekobj.title = eventDetails1.title;
            weekobj.eventDateTime = date;
            weekobj.isEvent = eventDetails1.isEvent;
            weekobj.eventDetails = eventDetails1;
            allday.daywiseevent.push(weekobj);
        });
        this.calendarWeekData.push(allday);
        CALENDAR.DAY_TIME_SERIES.forEach(function (time) {
            var /** @type {?} */ dateTime = new Date();
            dateTime.setHours(time.hr, time.min);
            var /** @type {?} */ daywiseevent = [];
            var /** @type {?} */ timeDataDayWise = { title: time.hr + ':' + time.min, time: dateTime };
            _this.displayHeaders.forEach(function (day) {
                var /** @type {?} */ dateTime1 = new Date(day.getTime());
                dateTime1.setHours(time.hr, time.min, 0);
                var /** @type {?} */ eventDetails1 = _this.hasWeekEvent(dateTime1, false);
                var /** @type {?} */ weekobj = {
                    title: eventDetails1.title, eventdatetime: dateTime1,
                    isEvent: eventDetails1.isEvent, eventDetails: eventDetails1,
                };
                daywiseevent.push(weekobj);
            });
            timeDataDayWise['daywiseevent'] = daywiseevent;
            _this.calendarWeekData.push(timeDataDayWise);
        });
    };
    /**
     * @param {?} wsd
     * @param {?} wholeday
     * @return {?}
     */
    AmexioCalendarComponent.prototype.hasWeekEvent = /**
     * @param {?} wsd
     * @param {?} wholeday
     * @return {?}
     */
    function (wsd, wholeday) {
        var _this = this;
        var /** @type {?} */ adu = new AmexioDateUtils();
        var /** @type {?} */ weekDateSlotStart = adu.getDateWithSecondsZero(wsd.getTime());
        var /** @type {?} */ weekDateSlotEnd = adu.getDateWithSecondsZero(weekDateSlotStart.getTime());
        weekDateSlotEnd.setHours(weekDateSlotEnd.getHours(), 59);
        var /** @type {?} */ weekEventObject = Object.assign({}, this.weekobject);
        if (this.events && this.events.length > 0) {
            this.events.forEach(function (event) {
                var /** @type {?} */ eventStartDate = adu.getDateWithSecondsZero(new Date(event.start).getTime());
                var /** @type {?} */ isEvent = _this.isEventPresent(event, wholeday, eventStartDate, weekDateSlotEnd, weekDateSlotStart);
                if (event.hasTimeSlot && !wholeday && event.end && isEvent) {
                    var /** @type {?} */ eventEndDate = adu.getDateWithSecondsZero(new Date(event.end).getTime());
                    weekEventObject.diff = (((eventEndDate.getTime() - eventStartDate.getTime())
                        - (86400000 * Math.floor((eventEndDate - eventStartDate) / 86400000))) / 1000) / 60;
                    weekEventObject.diffwithslot = ((eventStartDate.getTime() - weekDateSlotStart.getTime()) / 1000) / 60;
                }
                if (isEvent && !weekEventObject.isEvent) {
                    weekEventObject.hasTimeSlot = event.hasTimeSlot;
                    weekEventObject.eventDateTime = eventStartDate;
                    weekEventObject.isEvent = isEvent;
                    weekEventObject.details = event;
                    weekEventObject.title = event.title;
                }
            });
        }
        return weekEventObject;
    };
    /**
     * @param {?} event
     * @param {?} wholeday
     * @param {?} eventStartDate
     * @param {?} weekDateSlotEnd
     * @param {?} weekDateSlotStart
     * @return {?}
     */
    AmexioCalendarComponent.prototype.isEventPresent = /**
     * @param {?} event
     * @param {?} wholeday
     * @param {?} eventStartDate
     * @param {?} weekDateSlotEnd
     * @param {?} weekDateSlotStart
     * @return {?}
     */
    function (event, wholeday, eventStartDate, weekDateSlotEnd, weekDateSlotStart) {
        var /** @type {?} */ isEvent = false;
        if (event.hasTimeSlot && !wholeday) {
            if (event.end) {
                isEvent = ((weekDateSlotEnd.getTime() > eventStartDate.getTime())
                    && (eventStartDate.getTime() >= weekDateSlotStart.getTime()));
            }
        }
        else if (wholeday && !event.hasTimeSlot) {
            isEvent = new AmexioDateUtils().isDateEqual(eventStartDate, weekDateSlotStart);
        }
        return isEvent;
    };
    /**
     * @param {?} event
     * @param {?} eventDateTime
     * @param {?} isEvent
     * @param {?} diff
     * @param {?} diffwithslot
     * @return {?}
     */
    AmexioCalendarComponent.prototype.getWeekObject = /**
     * @param {?} event
     * @param {?} eventDateTime
     * @param {?} isEvent
     * @param {?} diff
     * @param {?} diffwithslot
     * @return {?}
     */
    function (event, eventDateTime, isEvent, diff, diffwithslot) {
        var /** @type {?} */ flag = Object.assign({}, this.weekobject);
        flag.hasTimeSlot = event.hasTimeSlot;
        flag.eventDateTime = eventDateTime;
        flag.isEvent = isEvent;
        flag.details = event;
        flag.title = event.title;
        flag.diff = diff;
        flag.diffwithslot = diff;
        return flag;
    };
    /**
     * @param {?} state
     * @return {?}
     */
    AmexioCalendarComponent.prototype.setState = /**
     * @param {?} state
     * @return {?}
     */
    function (state) {
        this.dayPressed = false;
        this.weekPressed = false;
        this.yearPressed = false;
        this.monthPressed = false;
        if (state === 'day') {
            this.dayPressed = true;
        }
        else if (state === 'week') {
            this.weekPressed = true;
        }
        else if (state === 'month') {
            this.monthPressed = true;
        }
        else if (state === 'year') {
            this.yearPressed = true;
        }
        this.currentState = state;
        this.currrentDate = new Date();
        this.createData(this.currrentDate);
        this.currrentDate = new Date();
    };
    /**
     * @return {?}
     */
    AmexioCalendarComponent.prototype.previous = /**
     * @return {?}
     */
    function () {
        this.prevMonthPressed = true;
        var /** @type {?} */ newDate = new Date(this.currrentDate.getTime());
        if (this.currentState === CALENDAR.MONTH) {
            newDate.setMonth(newDate.getMonth() - 1);
        }
        else if (this.currentState === CALENDAR.WEEK) {
            newDate = this.adu.getPrevSunday(newDate);
        }
        else if (this.currentState === CALENDAR.DAY) {
            newDate.setDate(newDate.getDate() - 1);
        }
        else if (this.currentState === CALENDAR.YEAR) {
            newDate.setUTCFullYear(newDate.getUTCFullYear() - 1);
        }
        this.currrentDate = new Date(newDate);
        this.createData(this.currrentDate);
    };
    /**
     * @return {?}
     */
    AmexioCalendarComponent.prototype.next = /**
     * @return {?}
     */
    function () {
        this.nextMonthPressed = true;
        var /** @type {?} */ newDate = new Date(this.currrentDate.getTime());
        if (this.currentState === CALENDAR.MONTH) {
            newDate.setMonth(newDate.getMonth() + 1);
        }
        else if (this.currentState === CALENDAR.WEEK) {
            newDate = this.adu.getNextSunday(newDate);
        }
        else if (this.currentState === CALENDAR.DAY) {
            newDate.setDate(newDate.getDate() + 1);
        }
        else if (this.currentState === CALENDAR.YEAR) {
            newDate.setUTCFullYear(newDate.getUTCFullYear() + 1);
        }
        this.currrentDate = new Date(newDate);
        this.createData(this.currrentDate);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCalendarComponent.prototype.onMonthEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onEventClicked.emit(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCalendarComponent.prototype.onDayTimeWiseEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onEventClicked.emit(event);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCalendarComponent.prototype.onYearEvent = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.navigateToDayMode(event.this.date);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCalendarComponent.prototype.onDaytimeHeaderClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        if (this.currentState === CALENDAR.WEEK) {
            this.navigateToDayMode(event);
        }
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCalendarComponent.prototype.onYearHeaderClicked = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.currrentDate = new Date(event.month);
        this.currentState = CALENDAR.MONTH;
        this.createData(this.currrentDate);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    AmexioCalendarComponent.prototype.navigateToDayMode = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        this.currentState = CALENDAR.DAY;
        this.currrentDate = new Date(date);
        this.createData(this.currrentDate);
    };
    AmexioCalendarComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-calendar',
                    template: "\n      <div class=\"calendar-header card-header\">\n          <div style=\"display: inline-flex;\">\n              <div *ngIf=\"(currentState === 'month')\"> {{currrentDate | date : 'MMMM, y'}} </div>\n              <div *ngIf=\"(currentState === 'week')\"> {{displayHeaders[0] | date : 'd MMM'}} - {{displayHeaders[6] | date : 'd MMM'}} {{displayHeaders[6] | date : 'y'}}\n                  </div>\n              <div *ngIf=\"(currentState === 'day')\"> {{currrentDate | date : 'd MMMM, y'}} </div>\n              <div *ngIf=\"(currentState === 'year')\"> {{currrentDate | date : 'y'}} </div>\n\n              <div class=\"calendar-navigation\">\n                  <em id={{prevbtnid}} role=\"button\" [attr.aria-pressed]=\"prevMonthPressed\" (keyup.enter)=\"previous()\" aria-label=\"previous month\"\n                      tabindex=\"1\" style=\"padding-right: 20px;\" class=\"fa fa-chevron-left\" aria-hidden=\"true\" (click)=\"previous()\"></em>\n                  <em id=\"{{nextbtnid}}\" role=\"button\" [attr.aria-pressed]=\"nextMonthPressed\" (keyup.enter)=\"next()\" aria-label=\"next month\"\n                      tabindex=\"1\" style=\"padding-right: 20px;\" class=\"fa fa-chevron-right\" aria-hidden=\"true\" (click)=\"next()\"></em>\n              </div>\n          </div>\n          <div>{{title}}</div>\n          <div>\n              <button id=\"{{daybtnid}}\" role=\"button\" tabindex=\"1\" [attr.aria-pressed]=\"dayPressed\" (keyup.enter)=\"setState('day')\" (click)=\"setState('day')\">Day</button>\n              <button id=\"{{weekbtnid}}\" [attr.aria-pressed]=\"weekPressed\" role=\"button\" aria-label=\"week\" tabindex=\"1\" (keyup.enter)=\"setState('week')\"\n                  (click)=\"setState('week')\">Week</button>\n              <button id=\"{{monthbtnid}}\" [attr.aria-pressed]=\"monthPressed\" role=\"button\" aria-label=\"month\" tabindex=\"1\" (keyup.enter)=\"setState('month')\"\n                  (click)=\"setState('month')\">Month</button>\n              <button id=\"{{yearbtnid}}\" [attr.aria-pressed]=\"yearPressed\" role=\"button\" aria-label=\"year\" tabindex=\"1\" (keyup.enter)=\"setState('year')\"\n                  (click)=\"setState('year')\">Year</button>\n          </div>\n      </div>\n      <amexio-calendar-month *ngIf=\"(currentState === 'month')\" [headers]=\"displayHeaders\" [calendar-data]=\"calendarMonthData\"\n          [calendar-row]=\"calendarRow\" (onEventClicked)=\"onMonthEvent($event)\">\n      </amexio-calendar-month>\n      <amexio-calendar-day-timewise *ngIf=\"(currentState === 'week' || currentState === 'day')\" [headers]=\"displayHeaders\" [calendar-data]=\"calendarWeekData\"\n          (onHeaderClicked)=\"onDaytimeHeaderClick($event)\" (onEventClicked)=\"onDayTimeWiseEvent($event)\"> </amexio-calendar-day-timewise>\n      <amexio-calendar-year *ngIf=\"(currentState === 'year')\" [headers]=\"displayHeaders\" [calendar-data]=\"calendarMonthData\" (onLeftNavigate)=\"previous()\"\n          (onRightNavigate)=\"next()\" (onTopNavigate)=\"previous()\" (onBottomNavigate)=\"next()\" (onHeaderClicked)=\"onYearHeaderClicked($event)\"\n          (onEventClicked)=\"onYearEvent($event)\"> </amexio-calendar-year>\n    ",
                    styles: ["\n      button,em{cursor:pointer}table{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;position:relative;z-index:1}\n    "],
                },] },
    ];
    /** @nocollapse */
    AmexioCalendarComponent.ctorParameters = function () { return []; };
    AmexioCalendarComponent.propDecorators = {
        headertype: [{ type: i0.Input, args: ['header-type',] }],
        events: [{ type: i0.Input, args: ['events',] }],
        title: [{ type: i0.Input, args: ['title',] }],
        calendardate: [{ type: i0.Input, args: ['calendar-date',] }],
        eventColorGrouping: [{ type: i0.Input, args: ['event-color-grouping',] }],
        onEventClicked: [{ type: i0.Output, args: ['onEventClicked',] }]
    };
    return AmexioCalendarComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCalendarDayTimeWiseComponent = /** @class */ (function () {
    function AmexioCalendarDayTimeWiseComponent() {
        this.onEventClicked = new i0.EventEmitter();
        this.onHeaderClicked = new i0.EventEmitter();
    }
    /**
     * @return {?}
     */
    AmexioCalendarDayTimeWiseComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
        this.width = (this.headerRow.nativeElement.offsetWidth - 50) / 7;
        if ((this.width - 50) > 50) {
            this.width = this.width - 50;
        }
    };
    /**
     * @param {?} event1
     * @param {?} eventData
     * @return {?}
     */
    AmexioCalendarDayTimeWiseComponent.prototype.eventClicked = /**
     * @param {?} event1
     * @param {?} eventData
     * @return {?}
     */
    function (event1, eventData) {
        var /** @type {?} */ eventObject = {
            event: event1,
            this: eventData.details,
        };
        this.onEventClicked.emit(eventObject);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCalendarDayTimeWiseComponent.prototype.onHeaderClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onHeaderClicked.emit(event);
    };
    /**
     * @param {?} date
     * @return {?}
     */
    AmexioCalendarDayTimeWiseComponent.prototype.fulldate = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        var /** @type {?} */ days = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'];
        var /** @type {?} */ months = ['january', 'febuary', 'march', 'april', 'may', 'june', 'july', 'august',
            'september', 'october', 'november', 'december'];
        var /** @type {?} */ ariadate = date.getDate();
        months.forEach(function (element, index) {
            if (date.getMonth() === index) {
                ariadate = ariadate + element;
            }
        });
        days.forEach(function (individualday, index) {
            if (date.getDay() === index) {
                ariadate = ariadate + individualday;
            }
        });
        return ariadate;
    };
    AmexioCalendarDayTimeWiseComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-calendar-day-timewise',
                    template: "\n      <table>\n\n          <thead>\n              <tr>\n                  <td [attr.colspan]=\"headers.length\">\n                      <table>\n                          <tr #headerRow>\n                              <td class=\"calendar-header-items calendar-user-active-timeslot\" style=\"width:50px;\"> &nbsp;</td>\n                              <td class=\"calendar-header-items\" style=\"cursor: pointer;\" (click)=\"onHeaderClick(header)\" *ngFor=\"let header of headers\">\n                                  <span tabindex=\"1\" attr.aria-label=\"{{header | date : 'EEEE, MMMM d, y'}}\">\n                                      <span>{{header | date : 'EE'}}</span>\n                                      <br />\n                                      <b style=\"font-size:20px;\">{{header | date : 'd'}}</b>\n                                  </span>\n                              </td>\n                          </tr>\n                      </table>\n                  </td>\n              </tr>\n          </thead>\n\n          <tbody>\n              <tr>\n                  <td class=\"calendar-mainbox\" [attr.colspan]=\"headers.length\">\n                      <div class=\"calendar-scroller\">\n                          <div style=\"width: 100%; position: relative;\">\n                              <div class=\"calendar-bg\">\n                                  <table>\n                                      <tr *ngFor=\"let calendarRow of calendaryData\">\n\n                                          <td class=\"calendar-header-items calendar-week-timeslot\" style=\"width:50px;\">\n                                              <div style=\"min-height: 50px;\" *ngIf=\"(calendarRow.time==null)\">\n                                                  {{calendarRow.title}}\n                                              </div>\n                                              <div class=\"calendar-week-timeslotseries-div\" *ngIf=\"(calendarRow.time && calendarRow.time!=null)\">\n                                                  {{ calendarRow.time | date:'hh:mm a' }}\n                                              </div>\n                                          </td>\n\n                                          <td style=\"padding-bottom: 0px;\" [ngStyle]=\"{'padding-top': (day.isEvent && day.eventDetails && day.eventDetails.diffwithslot) ? day.eventDetails.diffwithslot+'px' : '0px'}\"\n                                              class=\"calendar-box-items\" *ngFor=\"let day of calendarRow.daywiseevent\">\n\n                                              <div (click)=\"eventClicked($event,day)\" [class]=\"'calendar-week-day-timeslot' + '  '+((day.eventDetails.details && day.eventDetails.details.eventclass) ? day.eventDetails.details.eventclass:'') \"\n                                                  [ngClass]=\"{'calendar-week-active-timeslot': day.isEvent}\" [ngStyle]=\"{'height': (day.isEvent && day.eventDetails && day.eventDetails.diff) ? day.eventDetails.diff+'px' : null}\">\n\n                                                  <span [attr.tabindex]=\"(day.isEvent ? 1 : -1)\" (keyup.enter)=\"eventClicked($event,day)\" attr.aria-label=\"{{day.eventdatetime | date : 'EEEE, MMMM d, y'}} {{day.eventDetails.details.title}} {{day.eventDetails.details.start |  date: 'shortTime'}} to {{day.eventDetails.details.end |  date: 'shortTime'}}\"\n                                                      *ngIf=\"day.isEvent\" class=\"calendar-user-active\">\n                                                      {{day.eventDetails.details.title}}\n                                                      <br />\n                                                      <span class=\"calendar-user-active-timeslot\" *ngIf=\"(day.eventDetails.details && day.eventDetails.details.hasTimeSlot)\">\n                                                          {{day.eventDetails.details.start | date: \"shortTime\"}}\n                                                          <ng-container *ngIf=\"(day.eventDetails.details && day.eventDetails.details.end)\">\n                                                              - {{day.eventDetails.details.end | date: \"shortTime\"}}\n                                                          </ng-container>\n                                                      </span>\n                                                  </span>\n\n                                              </div>\n                                          </td>\n\n                                      </tr>\n                                  </table>\n                              </div>\n                          </div>\n                      </div>\n                  </td>\n              </tr>\n          </tbody>\n      </table>\n    ",
                    styles: ["\n      table{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;position:relative;z-index:1}\n    "],
                },] },
    ];
    /** @nocollapse */
    AmexioCalendarDayTimeWiseComponent.ctorParameters = function () { return []; };
    AmexioCalendarDayTimeWiseComponent.propDecorators = {
        headers: [{ type: i0.Input, args: ['headers',] }],
        calendaryData: [{ type: i0.Input, args: ['calendar-data',] }],
        headerRow: [{ type: i0.ViewChild, args: ['headerRow',] }],
        onEventClicked: [{ type: i0.Output, args: ['onEventClicked',] }],
        onHeaderClicked: [{ type: i0.Output, args: ['onHeaderClicked',] }]
    };
    return AmexioCalendarDayTimeWiseComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCalendarMonthComponent = /** @class */ (function () {
    function AmexioCalendarMonthComponent() {
        this.onEventClicked = new i0.EventEmitter();
    }
    /**
     * @param {?} event1
     * @param {?} eventData
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.eventClicked = /**
     * @param {?} event1
     * @param {?} eventData
     * @return {?}
     */
    function (event1, eventData) {
        var /** @type {?} */ eventObject = {
            event: event1,
            this: eventData.details,
        };
        this.onEventClicked.emit(eventObject);
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.nextrightday = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var /** @type {?} */ focusrowindex;
        var /** @type {?} */ focusinnerindex;
        this.calendaryData.forEach(function (calendarrow, rowindex) {
            calendarrow.forEach(function (calendardata, innerindex) {
                if (day.id === calendardata.id) {
                    if ((calendarrow.length - 1) === innerindex) {
                        focusinnerindex = 0;
                        focusrowindex = rowindex + 1;
                    }
                    else {
                        focusinnerindex = innerindex + 1;
                        focusrowindex = rowindex;
                    }
                }
            });
        });
        var /** @type {?} */ itemid = this.calendaryData[focusrowindex][focusinnerindex];
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.nextleftday = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var _this = this;
        this.calendaryData.forEach(function (calendarrow, rowindex) {
            calendarrow.forEach(function (individualday, innerindex) {
                if (day.id === individualday.id) {
                    _this.refactoredleftday(rowindex, innerindex, calendarrow);
                }
            });
        });
        var /** @type {?} */ itemid = this.calendaryData[this.focusrindex][this.focusiindex];
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} rowindex
     * @param {?} innerindex
     * @param {?} calendarrow
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.refactoredleftday = /**
     * @param {?} rowindex
     * @param {?} innerindex
     * @param {?} calendarrow
     * @return {?}
     */
    function (rowindex, innerindex, calendarrow) {
        if (rowindex === 0) {
            if (innerindex > 0) {
                this.focusrindex = rowindex;
                this.focusiindex = innerindex - 1;
            }
            else {
                this.focusrindex = rowindex;
                this.focusiindex = innerindex;
            }
        }
        else {
            if (innerindex === 0) {
                this.focusrindex = rowindex - 1;
                this.focusiindex = calendarrow.length - 1;
            }
            else {
                this.focusrindex = rowindex;
                this.focusiindex = innerindex - 1;
            }
        }
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.nexttopday = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var /** @type {?} */ focusrowindex;
        var /** @type {?} */ focusinnerindex;
        this.calendaryData.forEach(function (calrow, calrowindex) {
            calrow.forEach(function (calday, calinnerindex) {
                if (day.id === calday.id) {
                    if (calrowindex > 0) {
                        focusrowindex = calrowindex - 1;
                        focusinnerindex = calinnerindex;
                    }
                    else {
                        focusrowindex = calrowindex;
                        focusinnerindex = calinnerindex;
                    }
                }
            });
        });
        var /** @type {?} */ itemid = this.calendaryData[focusrowindex][focusinnerindex];
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.nextbottomday = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var /** @type {?} */ focusrowindex;
        var /** @type {?} */ focusinnerindex;
        this.calendaryData.forEach(function (calrow, calindex) {
            calrow.forEach(function (calday, innerindex) {
                if (day.id === calday.id) {
                    if ((calindex < (calrow.length - 1))) {
                        focusrowindex = calindex + 1;
                        focusinnerindex = innerindex;
                    }
                    else {
                        focusrowindex = calindex;
                        focusinnerindex = innerindex;
                    }
                }
            });
        });
        var /** @type {?} */ itemid = this.calendaryData[focusrowindex][focusinnerindex];
        document.getElementById(itemid['id']).focus();
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.ondatefocus = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var _this = this;
        this.ariadatalabel = '';
        if (day.eventDetails && day.eventDetails !== null) {
            day.eventDetails.events.forEach(function (scheduledevent, index) {
                if (index === 0) {
                    _this.ariadatalabel = _this.receiveDateFormat(day.date);
                }
                _this.ariadatalabel = _this.ariadatalabel + scheduledevent.details.title +
                    ' event scheduled ' +
                    _this.formatAMPM(new Date(scheduledevent.details.start)) +
                    ' to ' +
                    _this.formatAMPM(new Date(scheduledevent.details.end));
            });
        }
        else {
            this.ariadatalabel = this.receiveDateFormat(day.date) + ' no events scheduled';
        }
    };
    /**
     * @param {?} date
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.formatAMPM = /**
     * @param {?} date
     * @return {?}
     */
    function (date) {
        var /** @type {?} */ hours = date.getHours();
        var /** @type {?} */ minutes = date.getMinutes();
        var /** @type {?} */ lmins;
        var /** @type {?} */ ampm = hours >= 12 ? 'pm' : 'am';
        hours = hours % 12;
        hours = hours ? hours : 12; // the hour '0' should be '12'
        lmins = minutes < 10 ? '0' + minutes : minutes;
        return (hours + ':' + lmins + ' ' + ampm);
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.receiveDateFormat = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var /** @type {?} */ datestring = '';
        datestring = (day).getDate() + this.getFullMonthName(new Date(day)) +
            this.getFullDayName(new Date(day));
        return datestring;
    };
    /**
     * @param {?} recevieddate
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.getFullMonthName = /**
     * @param {?} recevieddate
     * @return {?}
     */
    function (recevieddate) {
        var /** @type {?} */ months = ['January', 'Febuary', 'March', 'April', 'May', 'June',
            'July', 'August', 'September', 'October', 'November', 'December'];
        var /** @type {?} */ datemonth = recevieddate.getMonth();
        var /** @type {?} */ monthString = '';
        months.forEach(function (element, index) {
            if (datemonth === index) {
                monthString = element;
            }
        });
        return monthString;
    };
    /**
     * @param {?} receiveddate
     * @return {?}
     */
    AmexioCalendarMonthComponent.prototype.getFullDayName = /**
     * @param {?} receiveddate
     * @return {?}
     */
    function (receiveddate) {
        var /** @type {?} */ weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday',
            'Thursday', 'Friday', 'Saturday'];
        var /** @type {?} */ day = receiveddate.getDay();
        var /** @type {?} */ dayname = '';
        weekdays.forEach(function (element, index) {
            if (day === index) {
                dayname = element;
            }
        });
        return dayname;
    };
    AmexioCalendarMonthComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-calendar-month',
                    template: "\n      <table>\n          <thead>\n              <tr>\n                  <td [attr.colspan]=\"headers.length\">\n                      <table>\n                          <tr>\n                              <td class=\"calendar-header-items\" *ngFor=\"let header of headers\">\n                                  <b>{{header}}</b>\n                                  <!-- <b *ngIf=\"(currentState === 'week')\">{{header | date : 'EEEE d'}}</b> -->\n                              </td>\n                          </tr>\n                      </table>\n                  </td>\n              </tr>\n          </thead>\n          <tbody>\n              <tr>\n                  <td class=\"calendar-mainbox\" [attr.colspan]=\"headers.length\">\n                      <div class=\"calendar-scroller\">\n                          <div style=\"width: 100%; position: relative;\">\n                              <div style=\"min-height: 150px; position: relative;\" *ngFor=\"let calendarRow of calendaryData\">\n                                  <div class=\"calendar-bg\">\n                                      <table>\n                                          <tr>\n                                              <!-- here down -->\n                                              <td attr.aria-label=\"{{ariadatalabel}}\" tabindex=\"1\" (focus)=\"ondatefocus(day)\" (keyup.arrowright)=\"nextrightday(day)\" (keyup.arrowleft)=\"nextleftday(day)\"\n                                                  (keyup.arrowdown)=\"nextbottomday(day)\" (keyup.arrowup)=\"nexttopday(day)\" attr.id=\"{{day.id}}\"\n                                                  [ngClass]=\"{'calendar-active-box': day.isActive}\" \n                                                  class=\"calendar-box-items\" *ngFor=\"let day of calendarRow\">\n                                                  <span [ngClass]=\"{'calendar-inactive': !day.isActivePeriod}\">\n                                                      {{ day.date | date:'d' }}\n                                                  </span>\n                                              </td>\n                                          </tr>\n                                      </table>\n                                  </div>\n                                  <div class=\"calendar-user-content\">\n                                      <table>\n                                          <tr>\n                                              <td [ngClass]=\"{'calendar-user-active': (day.eventDetails && day.eventDetails.isEvent)}\" *ngFor=\"let day of calendarRow\">\n                                                  <ng-container *ngIf=\"(day.eventDetails && day.eventDetails.events)\">\n                                                      <ul class=\"calendar-ul\">\n                                                          <li (click)=\"eventClicked($event,dayevent)\" class=\"calendar-li \" [attr.class]=\"'calendar-li '+' '+dayevent.details.eventclass\"\n                                                              *ngFor=\"let dayevent of day.eventDetails.events\">\n                                                              <span tabindex=\"1\" (keyup.enter)=\"eventClicked($event,dayevent)\" attr.aria-label=\"{{day.date | date : 'EEEE, MMMM d, y'}} {{dayevent.details.title}} {{dayevent.details.start |  date: 'shortTime'}} {{dayevent.details.end |  date: 'shortTime'}}\"\n                                                                  class=\"calendar-user-active\" *ngIf=\"dayevent.isEvent\">\n                                                                  {{dayevent.details.title}}\n                                                                  <br/>\n                                                                  <span class=\"calendar-user-active-timeslot\" *ngIf=\"(dayevent.details && dayevent.details.hasTimeSlot)\">\n                                                                      {{dayevent.details.start | date: \"shortTime\"}}\n                                                                      <ng-container *ngIf=\"(dayevent.details && dayevent.details.end)\">\n                                                                          - {{dayevent.details.end | date: \"shortTime\"}}\n                                                                      </ng-container>\n                                                                  </span>\n                                                              </span>\n                                                          </li>\n                                                      </ul>\n                                                  </ng-container>\n                                              </td>\n                                          </tr>\n                                      </table>\n                                  </div>\n                              </div>\n                          </div>\n                      </div>\n                  </td>\n              </tr>\n          </tbody>\n      </table>\n    ",
                    styles: ["\n      table{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;position:relative;z-index:1}\n    "],
                },] },
    ];
    /** @nocollapse */
    AmexioCalendarMonthComponent.ctorParameters = function () { return []; };
    AmexioCalendarMonthComponent.propDecorators = {
        headers: [{ type: i0.Input, args: ['headers',] }],
        calendaryData: [{ type: i0.Input, args: ['calendar-data',] }],
        calendarRow: [{ type: i0.Input, args: ['calendar-row',] }],
        onEventClicked: [{ type: i0.Output, args: ['onEventClicked',] }]
    };
    return AmexioCalendarMonthComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var AmexioCalendarYearComponent = /** @class */ (function () {
    function AmexioCalendarYearComponent() {
        this.isextremeright = false;
        this.isextremeleft = false;
        this.onEventClicked = new i0.EventEmitter();
        this.onHeaderClicked = new i0.EventEmitter();
        this.onleftnavigate = new i0.EventEmitter();
        this.onrightnavigate = new i0.EventEmitter();
        this.ontopnavigate = new i0.EventEmitter();
        this.onbottomnavigate = new i0.EventEmitter();
        this.isdaypressed = false;
    }
    /**
     * @param {?} event1
     * @param {?} eventData
     * @return {?}
     */
    AmexioCalendarYearComponent.prototype.eventClicked = /**
     * @param {?} event1
     * @param {?} eventData
     * @return {?}
     */
    function (event1, eventData) {
        this.isdaypressed = true;
        var /** @type {?} */ eventObject = {
            event: event1,
            this: eventData,
        };
        this.onEventClicked.emit(eventObject);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    AmexioCalendarYearComponent.prototype.monthClicked = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onHeaderClicked.emit(event);
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarYearComponent.prototype.navigateright = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var _this = this;
        this.calendaryData.forEach(function (calendarrow, rowindex) {
            calendarrow.data.forEach(function (calendardata, innerindex) {
                calendardata.forEach(function (calelement, calindex) {
                    if (day.id === calelement.id) {
                        _this.refactorednavigateright(calindex, calendardata, innerindex, calendarrow, rowindex);
                    }
                });
            });
        });
        if (!this.isextremeright) {
            var /** @type {?} */ itemid = this.calendaryData[this.rightfocusrowindex].data[this.rightfocusinnerindex][this.rightfocuscalindex];
            document.getElementById(itemid['id']).focus();
        }
    };
    /**
     * @param {?} calindex
     * @param {?} calendardata
     * @param {?} innerindex
     * @param {?} calendarrow
     * @param {?} rowindex
     * @return {?}
     */
    AmexioCalendarYearComponent.prototype.refactorednavigateright = /**
     * @param {?} calindex
     * @param {?} calendardata
     * @param {?} innerindex
     * @param {?} calendarrow
     * @param {?} rowindex
     * @return {?}
     */
    function (calindex, calendardata, innerindex, calendarrow, rowindex) {
        if (calindex === (calendardata.length - 1) &&
            innerindex === (calendarrow.data.length - 1) &&
            rowindex === (this.calendaryData.length - 1)) {
            this.onrightnavigate.emit();
            this.isextremeright = true;
            this.setExtremeFocus();
        }
        else if (calindex === (calendardata.length - 1)) {
            // chk condn for last row
            if ((calendarrow.data.length - 1) === innerindex) {
                this.rightfocusrowindex = rowindex + 1; // by inc:-> next month
                this.rightfocusinnerindex = 0; // by inc:-> next row in same month
                this.rightfocuscalindex = 0; // by inc:-> next day
            }
            else {
                this.rightfocusrowindex = rowindex; // by inc:-> next month
                this.rightfocusinnerindex = innerindex + 1; // by inc:-> next row in same month
                this.rightfocuscalindex = 0; // by inc:-> next day
            }
        }
        else {
            this.rightfocusrowindex = rowindex; // by inc:-> next month
            this.rightfocusinnerindex = innerindex; // by inc:-> next row in same month
            this.rightfocuscalindex = calindex + 1; // by inc:-> next day
        }
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarYearComponent.prototype.navigateleft = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var _this = this;
        this.calendaryData.forEach(function (calendarrow, rowindex) {
            calendarrow.data.forEach(function (calendardata, innerindex) {
                calendardata.forEach(function (calelement, calindex) {
                    if (day.id === calelement.id) {
                        _this.refactoredleftnavigate(rowindex, innerindex, calindex, calendarrow, calendardata);
                    }
                });
            });
        });
        if (!this.isextremeleft) {
            var /** @type {?} */ itemid = this.calendaryData[this.leftfocusrowindex].data[this.leftfocusinnerindex][this.leftfocuscalindex];
            document.getElementById(itemid['id']).focus();
        }
    };
    /**
     * @param {?} rowindex
     * @param {?} innerindex
     * @param {?} calindex
     * @param {?} calendarrow
     * @param {?} calendardata
     * @return {?}
     */
    AmexioCalendarYearComponent.prototype.refactoredleftnavigate = /**
     * @param {?} rowindex
     * @param {?} innerindex
     * @param {?} calindex
     * @param {?} calendarrow
     * @param {?} calendardata
     * @return {?}
     */
    function (rowindex, innerindex, calindex, calendarrow, calendardata) {
        if (rowindex === 0 && innerindex === 0 && calindex === 0) {
            this.onleftnavigate.emit();
            this.isextremeleft = true;
            this.setExtremeFocus();
        }
        else if (calindex === 0) {
            // chk for first row
            if (innerindex === 0) {
                this.leftfocusrowindex = rowindex - 1;
                this.leftfocusinnerindex = calendarrow.data.length - 1; // row change
                this.leftfocuscalindex = calendardata.length - 1; // last ele of month
            }
            else {
                this.leftfocusrowindex = rowindex;
                this.leftfocusinnerindex = innerindex - 1;
                this.leftfocuscalindex = calendardata.length - 1;
            }
        }
        else {
            this.leftfocusrowindex = rowindex;
            this.leftfocusinnerindex = innerindex;
            this.leftfocuscalindex = calindex - 1;
        }
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarYearComponent.prototype.navigatedown = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var _this = this;
        var /** @type {?} */ focusrowindex;
        var /** @type {?} */ focusinnerindex;
        var /** @type {?} */ focuscalindex;
        var /** @type {?} */ isextremedown = false;
        this.calendaryData.forEach(function (calendarrow, rowindex) {
            calendarrow.data.forEach(function (calendardata, innerindex) {
                calendardata.forEach(function (calelement, calindex) {
                    if (day.id === calelement.id) {
                        if (rowindex === (_this.calendaryData.length - 1) &&
                            innerindex === (calendarrow.data.length - 1)) {
                            _this.onbottomnavigate.emit();
                            isextremedown = true;
                            _this.setExtremeFocus();
                        }
                        else if (innerindex === (calendarrow.data.length - 1)) {
                            focusrowindex = rowindex + 1;
                            focusinnerindex = 0;
                            focuscalindex = 0;
                        }
                        else {
                            focusrowindex = rowindex;
                            focusinnerindex = innerindex + 1;
                            focuscalindex = calindex;
                        }
                    }
                });
            });
        });
        if (!isextremedown) {
            var /** @type {?} */ itemid = this.calendaryData[focusrowindex].data[focusinnerindex][focuscalindex];
            document.getElementById(itemid['id']).focus();
        }
    };
    /**
     * @param {?} day
     * @return {?}
     */
    AmexioCalendarYearComponent.prototype.navigateup = /**
     * @param {?} day
     * @return {?}
     */
    function (day) {
        var _this = this;
        var /** @type {?} */ focusrowindex;
        var /** @type {?} */ focusinnerindex;
        var /** @type {?} */ focuscalindex;
        var /** @type {?} */ isextremetop = false;
        this.calendaryData.forEach(function (calendarrow, rowindex) {
            calendarrow.data.forEach(function (calendardata, innerindex) {
                calendardata.forEach(function (calelement, calindex) {
                    if (day.id === calelement.id) {
                        if (rowindex === 0 && innerindex === 0) {
                            _this.ontopnavigate.emit();
                            isextremetop = true;
                            _this.setExtremeFocus();
                        }
                        else if (innerindex === 0) {
                            focusrowindex = rowindex - 1;
                            focusinnerindex = calendarrow.data.length - 1;
                            focuscalindex = calendardata.length - 1;
                        }
                        else {
                            focusrowindex = rowindex;
                            focusinnerindex = innerindex - 1;
                            focuscalindex = calindex;
                        }
                    }
                });
            });
        });
        if (!isextremetop) {
            var /** @type {?} */ itemid = this.calendaryData[focusrowindex].data[focusinnerindex][focuscalindex];
            document.getElementById(itemid['id']).focus();
        }
    };
    /**
     * @return {?}
     */
    AmexioCalendarYearComponent.prototype.setExtremeFocus = /**
     * @return {?}
     */
    function () {
        var _this = this;
        setTimeout(function () {
            var /** @type {?} */ itemid;
            _this.calendaryData.forEach(function (calendarrow, rowindex) {
                calendarrow.data.forEach(function (calendardata, innerindex) {
                    calendardata.forEach(function (calelement, calindex) {
                        if (rowindex === 0 && innerindex === 0 && calindex === 0) {
                            itemid = _this.calendaryData[0].data[0][0];
                            document.getElementById(itemid['id']).focus();
                        }
                    });
                });
            });
        }, 0);
    };
    AmexioCalendarYearComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-calendar-year',
                    template: "\n      <div class=\"calendar-year\">\n          <div class=\"calendar-year-box\" *ngFor=\"let month of calendaryData\">\n              <div class=\"calendar-year-month\">\n                  <div style=\"cursor: pointer;\" (click)=\"monthClicked(month)\">\n                      <b>{{month.title}}</b>\n                  </div>\n                  <table>\n                      <thead>\n                          <tr>\n                              <td *ngFor=\"let header of headers\" style=\"text-align: center;\">\n                                  {{header}}\n                              </td>\n                          </tr>\n                      </thead>\n                      <tbody>\n                          <tr *ngFor=\"let week of month.data\" class=\"calendar-week-timeslot\">\n                              <td class=\"focuscls\" attr.id=\"{{day.id}}\" tabindex=\"1\" role=\"button\" [attr.aria-pressed]=\"isdaypressed\" (keyup.arrowright)=\"navigateright(day)\"\n                                  (keyup.arrowleft)=\"navigateleft(day)\" (keyup.arrowdown)=\"navigatedown(day)\" (keyup.arrowup)=\"navigateup(day)\"\n                                  attr.aria-label=\"{{day.date | date : 'EEEE, MMMM d, y'}} \" [ngClass]=\"{'calendar-inactive': (!day.isActivePeriod),                                         \n                                              'calendar-year-month-hasevent': (day.isActivePeriod && day.isEvent)}\" (click)=\"eventClicked($event, day)\"\n                                  (keyup.enter)=\"eventClicked($event, day)\" *ngFor=\"let day of week\" style=\"text-align: center;\">\n                                  <div  [ngClass]=\"{'calendar-active-box calendar-year-month-today': (day.isActivePeriod && day.isActive)}\" style=\"height:30px; width: 30px;\"\n                                      style=\"text-align: center; cursor: pointer;\">\n                                      {{day.date | date :'dd'}}\n                                  </div>\n                              </td>\n                          </tr>\n                          <tr></tr>\n                      </tbody>\n                  </table>\n              </div>\n\n          </div>\n      </div>\n    ",
                    styles: ["\n      table{width:100%;height:100%;-webkit-box-sizing:border-box;box-sizing:border-box;table-layout:fixed;border-collapse:collapse;border-spacing:0;position:relative;z-index:1}\n    "],
                },] },
    ];
    /** @nocollapse */
    AmexioCalendarYearComponent.ctorParameters = function () { return []; };
    AmexioCalendarYearComponent.propDecorators = {
        headers: [{ type: i0.Input, args: ['headers',] }],
        calendaryData: [{ type: i0.Input, args: ['calendar-data',] }],
        onEventClicked: [{ type: i0.Output, args: ['onEventClicked',] }],
        onHeaderClicked: [{ type: i0.Output, args: ['onHeaderClicked',] }],
        onleftnavigate: [{ type: i0.Output, args: ['onLeftNavigate',] }],
        onrightnavigate: [{ type: i0.Output, args: ['onRightNavigate',] }],
        ontopnavigate: [{ type: i0.Output, args: ['onTopNavigate',] }],
        onbottomnavigate: [{ type: i0.Output, args: ['onBottomNavigate',] }]
    };
    return AmexioCalendarYearComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var StepWizardItemComponent = /** @class */ (function () {
    function StepWizardItemComponent(formBuilder, iconService) {
        this.formBuilder = formBuilder;
        this.iconService = iconService;
        this.active = false;
        this.footerAlign = 'space-between';
        this.onNextStep = new i0.EventEmitter();
        this.onPreviousStep = new i0.EventEmitter();
        this.index = 0;
        this.showPreviousButton = true;
        this.showNextButton = true;
        this.nextLabel = 'Next';
        this.previousIcon = 'fa fa-chevron-left';
        this.nextIcon = 'fa fa-chevron-right';
        if (this.iconService.iconToUse !== 'fa') {
            this.previousIcon = 'keyboard_arrow_left';
            this.nextIcon = 'keyboard_arrow_right';
        }
    }
    /**
     * @param {?} event
     * @return {?}
     */
    StepWizardItemComponent.prototype.onPreviousClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onPreviousStep.emit({ title: this.title,
            index: this.index, data: this.form.value, emitData: { currentdata: this.form.value, event: event } });
    };
    /**
     * @param {?} event
     * @return {?}
     */
    StepWizardItemComponent.prototype.onNextClick = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        this.onNextStep.emit({ title: this.title, index: this.index, data: this.form.value, emitData: { currentdata: this.form.value, event: event } });
    };
    /**
     * @return {?}
     */
    StepWizardItemComponent.prototype.ngOnInit = /**
     * @return {?}
     */
    function () {
    };
    /**
     * @return {?}
     */
    StepWizardItemComponent.prototype.ngAfterViewInit = /**
     * @return {?}
     */
    function () {
        this.registerFormComponent();
        this.validateForm();
    };
    /**
     * @return {?}
     */
    StepWizardItemComponent.prototype.ngAfterContentChecked = /**
     * @return {?}
     */
    function () {
        this.validateForm();
    };
    /**
     * @return {?}
     */
    StepWizardItemComponent.prototype.validateForm = /**
     * @return {?}
     */
    function () {
        if (this.form && this.form.status === 'INVALID') {
            this.isNextButtonDisable = true;
        }
        else {
            this.isNextButtonDisable = false;
        }
    };
    /**
     * @return {?}
     */
    StepWizardItemComponent.prototype.registerFormComponent = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ ngContentModels = this.models.toArray();
        var /** @type {?} */ innerModelArray = [];
        ngContentModels.forEach(function (model) {
            if (!_this.isFieldPresentInParentAndChildBoth(innerModelArray, model.name)) {
                if (!model.name || model.name === null) {
                    model.name = model.valueAccessor['name'];
                }
                _this.form.control.registerControl(model.name, model.control);
            }
        });
    };
    /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    StepWizardItemComponent.prototype.isFieldPresentInParentAndChildBoth = /**
     * @param {?} innerModelArray
     * @param {?} name
     * @return {?}
     */
    function (innerModelArray, name) {
        var /** @type {?} */ isPresent = false;
        innerModelArray.forEach(function (innerModel) {
            if (name === innerModel.name) {
                isPresent = true;
            }
        });
        return isPresent;
    };
    StepWizardItemComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-step-wizard-item',
                    template: "\n   <form [ngStyle]=\"{'display':active ? 'block':'none'}\" class=\"form-container form-group\">\n       <div class=\"form-body formbody\" tabindex=\"1\">\n           <ng-content></ng-content>\n       </div>\n       <footer #formFooter class=\"form-footer\" [ngStyle]=\"{'justify-content': footerAlign}\">\n           <amexio-button *ngIf=\"showPreviousButton\" [icon]=\"previousIcon\" [label]=\"'Previous'\" [type]=\"'theme-color'\"\n               [tooltip]=\"'Previous'\" (onClick)=\"onPreviousClick($event)\">\n           </amexio-button>\n           <span *ngIf=\"!showPreviousButton\"></span>\n           <amexio-button *ngIf=\"showNextButton\" [disabled]=\"isNextButtonDisable\" [icon]=\"nextIcon\" [label]=\"nextLabel\"\n               [form-bind]=\"'validateForm'\" [type]=\"'theme-color'\" [tooltip]=\"'Next'\" (onClick)=\"onNextClick($event)\">\n           </amexio-button>\n       </footer>\n   </form>\n ",
                },] },
    ];
    /** @nocollapse */
    StepWizardItemComponent.ctorParameters = function () { return [
        { type: forms.FormBuilder },
        { type: IconLoaderService }
    ]; };
    StepWizardItemComponent.propDecorators = {
        title: [{ type: i0.Input, args: ['title',] }],
        icon: [{ type: i0.Input, args: ['icon',] }],
        active: [{ type: i0.Input, args: ['active',] }],
        footerAlign: [{ type: i0.Input, args: ['footer-align',] }],
        onNextStep: [{ type: i0.Output }],
        onPreviousStep: [{ type: i0.Output }],
        form: [{ type: i0.ViewChild, args: [forms.NgForm,] }],
        models: [{ type: i0.ContentChildren, args: [forms.NgModel, { descendants: true },] }]
    };
    return StepWizardItemComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var StepWizardComponent = /** @class */ (function () {
    function StepWizardComponent(matchMediaService) {
        this.matchMediaService = matchMediaService;
        this.showStepNumber = true;
        this.footerAlign = 'space-between';
        this.finalStage = new i0.EventEmitter();
        this.onNextStepClick = new i0.EventEmitter();
        this.onPreviousStepClick = new i0.EventEmitter();
        this.data = {};
        this.isPhone = false;
        if (this.matchMediaService.IsTablet() || this.matchMediaService.IsPhone()) {
            this.isPhone = true;
        }
    }
    /**
     * @return {?}
     */
    StepWizardComponent.prototype.ngAfterContentInit = /**
     * @return {?}
     */
    function () {
        var _this = this;
        var /** @type {?} */ time = new Date().getTime();
        this.stepItemList = this.stepItemQueryList.toArray();
        if (this.stepItemList && this.stepItemList.length > 0) {
            this.stepItemList[0].active = true;
        }
        this.stepItemList.forEach(function (node, index) {
            try {
                _this.stepItemList[index].index = time + index;
                node.onNextStep.subscribe(function (eventdata) {
                    return _this.onNextStep(eventdata);
                });
                node.onPreviousStep.subscribe(function (eventdata) {
                    return _this.onPreviousStep(eventdata);
                });
                _this.stepItemList[index].footerAlign = _this.footerAlign;
            }
            catch (/** @type {?} */ Error) {
            }
        });
        this.stepItemList[0].showPreviousButton = false;
        this.stepItemList[0].activeClass = 'active';
        this.stepItemList[this.stepItemList.length - 1].nextLabel = 'Done';
        this.stepItemList[this.stepItemList.length - 1].nextIcon = '';
        this.title = this.stepItemList[0].title;
    };
    /**
     * @param {?} event
     * @return {?}
     */
    StepWizardComponent.prototype.onNextStep = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        var /** @type {?} */ activeIndex = 0;
        var /** @type {?} */ updatedTitle = event.title.replace(/\s/g, '').toLowerCase();
        this.data[updatedTitle] = event.data;
        this.stepItemList.forEach(function (stepItem, index) {
            if (stepItem.index === event.index) {
                activeIndex = index + 1;
                _this.stepItemList[activeIndex].activeClass = 'active';
                _this.stepItemList[activeIndex].active = true;
                _this.title = _this.stepItemList[activeIndex].title;
            }
        });
        this.stepItemList.forEach(function (stepItem, index) {
            var /** @type {?} */ ind = index + 1;
            if (ind > activeIndex) {
            }
            else {
                _this.stepItemList[ind - 1].activeClass = 'completed';
                _this.stepItemList[ind - 1].active = false;
            }
        });
        if (event && event.emitData && event.emitData.currentdata) {
            // tslint:disable-next-line:max-line-length
            this.onNextStepClick.emit({ title: event.title, currentdata: event.emitData.currentdata, data: this.data, event: event.emitData.event });
        }
        this.finalStage.emit(this.data);
    };
    /**
     * @param {?} event
     * @return {?}
     */
    StepWizardComponent.prototype.onPreviousStep = /**
     * @param {?} event
     * @return {?}
     */
    function (event) {
        var _this = this;
        if (event && event.emitData && event.emitData.currentdata) {
            // tslint:disable-next-line:max-line-length
            this.onPreviousStepClick.emit({ title: event.title, currentdata: event.emitData.currentdata, data: this.data, event: event.emitData.event });
        }
        var /** @type {?} */ activeIndex = 0;
        this.stepItemList.forEach(function (stepItem, index) {
            if (stepItem.index === event.index) {
                activeIndex = index;
            }
        });
        this.stepItemList.forEach(function (stepItem, index) {
            if (activeIndex === index) {
                _this.stepItemList[index - 1].activeClass = 'active';
                _this.stepItemList[index - 1].active = true;
                _this.title = _this.stepItemList[index - 1].title;
            }
            else if (activeIndex > index) {
                _this.stepItemList[index + 1].activeClass = '';
                _this.stepItemList[index].activeClass = 'completed';
                _this.stepItemList[index + 1].active = false;
            }
        });
        this.stepItemList[0].showPreviousButton = false;
    };
    StepWizardComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'amexio-step-wizard',
                    template: "\n    <amexio-card-ce>\n        <amexio-header-ce [background]=\"headerBackground\">\n            {{title}}\n        </amexio-header-ce>\n        <ul class=\"step-wizard step-wizard-horizontal\">\n            <li [attr.tabindex]=\"(item.activeClass === 'active') ? 1: -1\" *ngFor=\"let item of stepItemList; let i = index\"\n                [ngClass]=\"item.activeClass\">\n                <a>\n                    <span class=\"circle \">\n                        <ng-container *ngIf=\"item.icon \">\n                            <amexio-image [icon-class]=\"item.icon \"></amexio-image>\n                        </ng-container>\n                        <ng-container *ngIf=\"!item.icon && showStepNumber \">{{i+1}}</ng-container>\n                    </span>\n                    <ng-container *ngIf=\"item.title \">\n                        <ng-container *ngIf=\"item.icon && showStepNumber \">\n                            {{i+1}}\n                        </ng-container>\n                        <ng-container *ngIf=\"!isPhone\">\n                            <span class=\"stepTitleColor\">\n                                    {{item.title}}\n                            </span>\n                        </ng-container>\n\n                    </ng-container>\n                </a>\n            </li>\n        </ul>\n        <amexio-body-ce>\n            <ng-content select=\"amexio-step-wizard-item\">\n            </ng-content>\n        </amexio-body-ce>\n    </amexio-card-ce>\n  ",
                },] },
    ];
    /** @nocollapse */
    StepWizardComponent.ctorParameters = function () { return [
        { type: DeviceQueryService }
    ]; };
    StepWizardComponent.propDecorators = {
        showStepNumber: [{ type: i0.Input, args: ['show-step-number',] }],
        headerBackground: [{ type: i0.Input, args: ['header-background',] }],
        footerAlign: [{ type: i0.Input, args: ['footer-align',] }],
        finalStage: [{ type: i0.Output }],
        onNextStepClick: [{ type: i0.Output }],
        onPreviousStepClick: [{ type: i0.Output }],
        stepItemQueryList: [{ type: i0.ContentChildren, args: [StepWizardItemComponent,] }]
    };
    return StepWizardComponent;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
var ENTERPRISE_COMPONENTS = [
    MultiMediaCarouselComponent,
    ContentComponent,
    AmexioYoutubePlayerComponent,
    AmexioWeekDayAvailiblityComponent,
    AmexioCalendarComponent,
    AmexioCalendarDayTimeWiseComponent,
    AmexioCalendarMonthComponent,
    AmexioCalendarYearComponent,
    StepWizardComponent,
    StepWizardItemComponent,
];
var AmexioEnterpriseModule = /** @class */ (function () {
    function AmexioEnterpriseModule() {
    }
    /**
     * @return {?}
     */
    AmexioEnterpriseModule.forRoot = /**
     * @return {?}
     */
    function () {
        return {
            ngModule: AmexioEnterpriseModule,
            providers: [CommonDataService, DeviceQueryService],
        };
    };
    AmexioEnterpriseModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.FormsModule,
                        AmexioFormsModule,
                        AmexioPaneModule,
                        AmexioMediaModule,
                        AmexioCreativeModule,
                        AmexioCommonModule,
                        HttpClientModule,
                    ],
                    exports: ENTERPRISE_COMPONENTS,
                    declarations: ENTERPRISE_COMPONENTS,
                    providers: [CommonDataService, DeviceQueryService],
                },] },
    ];
    return AmexioEnterpriseModule;
}());

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * Generated bundle index. Do not edit.
 */

exports.AmexioWidgetModule = AmexioWidgetModule;
exports.CommonDataService = CommonDataService;
exports.DeviceQueryService = DeviceQueryService;
exports.IconLoaderService = IconLoaderService;
exports.Icon = Icon;
exports.AmexioCreditCardModel = AmexioCreditCardModel;
exports.GridConfig = GridConfig;
exports.GridConstants = GridConstants;
exports.GoogleMapOverlays = GoogleMapOverlays;
exports.AvailableSlotsModel = AvailableSlotsModel;
exports.DayModel = DayModel;
exports.TimeModel = TimeModel;
exports.TimeUtil = TimeUtil;
exports.PropertyGridModel = PropertyGridModel;
exports.AmexioFormsModule = AmexioFormsModule;
exports.LoadRecaptchaService = LoadRecaptchaService;
exports.COMPONENT_CLASS_MAP = COMPONENT_CLASS_MAP;
exports.AmexioButtonComponent = AmexioButtonComponent;
exports.AmexioButtonGroupComponent = AmexioButtonGroupComponent;
exports.ScriptLoadService = ScriptLoadService;
exports.AmexioNavModule = AmexioNavModule;
exports.AmexioSideNavComponent = AmexioSideNavComponent;
exports.SideNavNodeComponent = SideNavNodeComponent;
exports.AmexioNavBarComponent = AmexioNavBarComponent;
exports.KEY_CODE_notify = KEY_CODE_notify;
exports.AmexioNotificationComponent = AmexioNotificationComponent;
exports.AmexioLayoutModule = AmexioLayoutModule;
exports.AmexioAccordionHeaderComponent = AmexioAccordionHeaderComponent;
exports.AmexioAccordionTabComponent = AmexioAccordionTabComponent;
exports.AmexioAccordionComponent = AmexioAccordionComponent;
exports.AccordionService = AccordionService;
exports.AmexioBorderLayoutItemComponent = AmexioBorderLayoutItemComponent;
exports.AmexioBorderLayoutComponent = AmexioBorderLayoutComponent;
exports.AmexioBoxComponent = AmexioBoxComponent;
exports.AmexioCardComponent = AmexioCardComponent;
exports.AmexioColumnComponent = AmexioColumnComponent;
exports.AmexioGridComponent = AmexioGridComponent;
exports.AmexioGridItemComponent = AmexioGridItemComponent;
exports.AmexioRowComponent = AmexioRowComponent;
exports.AmexioGridLayoutService = AmexioGridLayoutService;
exports.AmexioDataModule = AmexioDataModule;
exports.GoogleMapScriptService = GoogleMapScriptService;
exports.AmexioListBoxComponent = AmexioListBoxComponent;
exports.AmexioTreeViewComponent = AmexioTreeViewComponent;
exports.AmexioPaginatorComponent = AmexioPaginatorComponent;
exports.TreeDataTableComponent = TreeDataTableComponent;
exports.AmexioGoogleMapComponent = AmexioGoogleMapComponent;
exports.AmexioDashBoardModule = AmexioDashBoardModule;
exports.DashboardLoaderService = DashboardLoaderService;
exports.DashBoardTitleComponent = DashBoardTitleComponent;
exports.DataPointCenterComponent = DataPointCenterComponent;
exports.DataPointsComponent = DataPointsComponent;
exports.DataPointEastComponent = DataPointEastComponent;
exports.DataPointNorthComponent = DataPointNorthComponent;
exports.DataPointSouthComponent = DataPointSouthComponent;
exports.DataPointWestComponent = DataPointWestComponent;
exports.GaugeChartComponent = GaugeChartComponent;
exports.AmexioChartsModule = AmexioChartsModule;
exports.AreaChartComponent = AreaChartComponent;
exports.BarChartComponent = BarChartComponent;
exports.BubbleChartComponent = BubbleChartComponent;
exports.CandlestickChartComponent = CandlestickChartComponent;
exports.CandlestickWaterfallChartComponent = CandlestickWaterfallChartComponent;
exports.ChartAreaComponent = ChartAreaComponent;
exports.ChartLegendComponent = ChartLegendComponent;
exports.ChartTitleComponent = ChartTitleComponent;
exports.ColumnChartComponent = ColumnChartComponent;
exports.ComboChartComponent = ComboChartComponent;
exports.DonutChartComponent = DonutChartComponent;
exports.GanttChartComponent = GanttChartComponent;
exports.HistogramChartComponent = HistogramChartComponent;
exports.HorizontalAxisComponent = HorizontalAxisComponent;
exports.LineChartComponent = LineChartComponent;
exports.PieChartComponent = PieChartComponent;
exports.ScatterChartComponent = ScatterChartComponent;
exports.TimeLineChartComponent = TimeLineChartComponent;
exports.VerticalAxisComponent = VerticalAxisComponent;
exports.ChartLoaderService = ChartLoaderService;
exports.AmexioMapModule = AmexioMapModule;
exports.MapPropertiesComponent = MapPropertiesComponent;
exports.GeoChartComponent = GeoChartComponent;
exports.TreeMapComponent = TreeMapComponent;
exports.MapTitleComponent = MapTitleComponent;
exports.MapLoaderService = MapLoaderService;
exports.AmexioPaneModule = AmexioPaneModule;
exports.AmexioFooterComponent = AmexioFooterComponent;
exports.AmexioBodyComponent = AmexioBodyComponent;
exports.AmexioCarouselComponent = AmexioCarouselComponent;
exports.AmexioTemplateDirective = AmexioTemplateDirective;
exports.AmexioTemplateWrapperDirective = AmexioTemplateWrapperDirective;
exports.AmexiodialoguePaneComponent = AmexiodialoguePaneComponent;
exports.AmexioFieldSetComponent = AmexioFieldSetComponent;
exports.AmexioFormActionComponent = AmexioFormActionComponent;
exports.AmexioFormBodyComponent = AmexioFormBodyComponent;
exports.AmexioFormComponent = AmexioFormComponent;
exports.AmexioFormHeaderComponent = AmexioFormHeaderComponent;
exports.AmexioHeaderComponent = AmexioHeaderComponent;
exports.AmexioPanelHeaderComponent = AmexioPanelHeaderComponent;
exports.AmexioStepsComponent = AmexioStepsComponent;
exports.StepBlockComponent = StepBlockComponent;
exports.AmexioRightVerticalTabComponent = AmexioRightVerticalTabComponent;
exports.AmexioTabActionComponent = AmexioTabActionComponent;
exports.TOP_COMPONENT_CLASS_MAP = TOP_COMPONENT_CLASS_MAP;
exports.BOTTOM_COMPONENT_CLASS_MAP = BOTTOM_COMPONENT_CLASS_MAP;
exports.AmexioTabComponent = AmexioTabComponent;
exports.AmexioTabPillComponent = AmexioTabPillComponent;
exports.AmexioVerticalTabComponent = AmexioVerticalTabComponent;
exports.AmexiotimelineComponent = AmexiotimelineComponent;
exports.AmexiotimelineeventComponent = AmexiotimelineeventComponent;
exports.AmexioWindowPaneComponent = AmexioWindowPaneComponent;
exports.AmexioWindowHeaderComponent = AmexioWindowHeaderComponent;
exports.OverlayContainerComponent = OverlayContainerComponent;
exports.AmexioFormGroupDirective = AmexioFormGroupDirective;
exports.AmexioEnterpriseModule = AmexioEnterpriseModule;
exports.MultiMediaCarouselComponent = MultiMediaCarouselComponent;
exports.ContentComponent = ContentComponent;
exports.AmexioYoutubePlayerComponent = AmexioYoutubePlayerComponent;
exports.AmexioWeekDayAvailiblityComponent = AmexioWeekDayAvailiblityComponent;
exports.AmexioCalendarComponent = AmexioCalendarComponent;
exports.AmexioCalendarDayTimeWiseComponent = AmexioCalendarDayTimeWiseComponent;
exports.AmexioCalendarMonthComponent = AmexioCalendarMonthComponent;
exports.AmexioCalendarYearComponent = AmexioCalendarYearComponent;
exports.AmexioMediaModule = AmexioMediaModule;
exports.AmexioVideoPlayerComponent = AmexioVideoPlayerComponent;
exports.DisplayFieldService = DisplayFieldService;
exports.eb = AmexioRuntimeModule;
exports.ec = AmexioRuntimeComponent;
exports.c = AmexioCommonModule;
exports.b = AmexioContextMenuComponent;
exports.a = AmexioBaseContextMenuModule;
exports.s = BaseInput;
exports.bc = BaseFormValidator;
exports.g = CommonIconComponent;
exports.d = DisplayFieldComponent;
exports.e = DropDownListComponent;
exports.p = EventBaseComponent;
exports.t = AmexioInputHelperComponent;
exports.h = LifeCycleBaseComponent;
exports.r = ListBaseComponent;
exports.bl = ListBaseDatepickerComponent;
exports.l = ValueAccessorBase;
exports.di = AmexioCreativeModule;
exports.dl = AmexioCardCEComponent;
exports.ea = AmexioCarouselCEComponent;
exports.dj = AmexioCardCEActionComponent;
exports.dk = AmexioCardCEBodyComponent;
exports.dm = AmexioCardCEHeaderComponent;
exports.do = AmexioFormCEComponent;
exports.dn = AmexioFormActionCEComponent;
exports.dp = AmexioHomePageCenterPanelComponent;
exports.dt = AmexioHomePageComponent;
exports.dq = AmexioHomePageEastPanelComponent;
exports.dr = AmexioHomePageNorthPanelComponent;
exports.ds = AmexioHomePageWestPanelComponent;
exports.dv = AmexioProgressCEComponent;
exports.dy = ViewportBackgroundComponent;
exports.dz = ViewportContentBodyComponent;
exports.dx = ViewportContentComponent;
exports.dw = ViewportComponent;
exports.du = AmexioWindowCEComponent;
exports.cz = AmexioGridColumnComponent;
exports.cx = AmexioDatagridComponent;
exports.cy = DataGridFilterComponent;
exports.da = AmexioDataGridHeaderComponent;
exports.dh = AmexioItemSelectorComponent;
exports.dc = AmexioProgressMultiBarComponent;
exports.dd = AmexioProgressBarComponent;
exports.db = PropertyGridComponent;
exports.dg = AmexioFilterTreeComponent;
exports.de = HorizontalTreeViewNodeComponent;
exports.df = HorizontalTreeViewComponent;
exports.ed = StepWizardComponent;
exports.ee = StepWizardItemComponent;
exports.bw = AmexioSearchAdvanceComponent;
exports.bv = SearchboxtoolComponent;
exports.ch = AmexioBadgeComponent;
exports.bb = AmexioButtonDropdownComponent;
exports.bd = AmexioButtonDropDownItemComponent;
exports.be = AmexioSpiltButtonDropdownComponent;
exports.bg = CheckboxComponent;
exports.bf = AmexioCheckBoxGroupComponent;
exports.m = AmexioCheckBoxComponent;
exports.ca = AmexioChipComponent;
exports.cb = AmexioChipsComponent;
exports.bz = AmexioCreditcardComponent;
exports.ci = DarkmodeComponent;
exports.bk = AmexioDateTimePickerComponent;
exports.br = AmexioDropDownMenuComponent;
exports.bq = AmexioDropDownitemsComponent;
exports.o = AmexioDropDownComponent;
exports.v = AmexioEmailInputComponent;
exports.bm = AmexioFileUploadComponent;
exports.bo = AmexioFloatingButtonComponent;
exports.bp = AmexioFloatingGroupButtonComponent;
exports.n = AmexioFormValidator;
exports.bn = AmexioLabelComponent;
exports.ck = AmexioMultipleDatePickerComponent;
exports.w = AmexioNumberInputComponent;
exports.x = AmexioPasswordComponent;
exports.u = AmexioRadioGroupComponent;
exports.cj = AmexioRangeSliderComponent;
exports.ba = AmexioRatingComponent;
exports.bx = RecaptchaComponent;
exports.bh = AmexioSliderComponent;
exports.bi = DomHandler;
exports.cf = FacebookAuthComponent;
exports.cc = GoogleAuthComponent;
exports.ce = LinkedInAuthComponent;
exports.cd = SocialBaseComponent;
exports.cg = AmexioSocialComponent;
exports.by = AmexioSpinnerComponent;
exports.bj = AmexioTagsInputComponent;
exports.y = AmexioTextAreaComponent;
exports.k = AmexioTextInputComponent;
exports.z = AmexioToggleComponent;
exports.bs = ToolbarComponent;
exports.bu = ToolBarActionComponent;
exports.bt = ToolbaroneComponent;
exports.q = AmexioTypeAheadComponent;
exports.i = AmexioLayoutComponent;
exports.j = AmexioLayoutItemComponent;
exports.cl = AmexioImageComponent;
exports.cu = AmexioBreadcrumbComponent;
exports.cr = DockbarComponent;
exports.cs = DockedBarToolComponent;
exports.ct = AmexioMenuBarComponent;
exports.cq = AmexioInnerNavMenuComponent;
exports.co = AmexioNavActionComponent;
exports.cm = AmexioNavItemComponent;
exports.cn = AmexioNavMenuComponent;
exports.cp = AmexioNavTextFieldComponent;
exports.cv = AmexioSideNavInnerNodeComponent;
exports.cw = AmexioPanelComponent;
exports.f = FilterPipe;

Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=amexio-ng-extensions.umd.js.map
